# RiverWare_Ruleset 7.5.3 Patch
# Created 18:14 December 12, 2019
# 
RULESET
NAME "MTOM_Rules";
AGENDA_ORDER ASCENDING;
DESCRIPTION "";
PRECISION   8;
VIEW_DOC_INFO
  DOC_INFO_LOC_PART2 "MTOM_Rules_2013-DocTemplate.html";
  DOC_INFO_FORMAT "Auto";
NOTES "";
BEGIN

  POLICY_GROUP   "Calculate Final State Use and Overruns";
  DESCRIPTION    "This policy group contains rules that compute the projected annual water use for the Lower Division States and large junior priority users in each state (i.e. MWD, CAP, and SNWA). It also computes any projected over- or under-runs after all water schedule adjustments have been made. <br><br>The slots containing the state adjusted apportionments do not get changed when shortage or surplus is declared. They also do not get changed for Lower Basin demand variability. So, the difference in the schedules will appear as an overrun or underrun.";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Final SNWP Diversion";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for SNWA after all schedule adjustments. Adjustments may be made to get Nevada to their projected annual apportionment, lower basin demand variability, shortage, or surplus.<br><br>SLOTS SET: ForecastUse.SNWPAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "ForecastUse.SNWPAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" );

    END
    UUID "{0bfe40d2-1379-42c8-a6d3-db88d4d2719e}";;

    RULE                 "Final CAP Diversion";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for CAP after all schedule adjustments. Adjustments may be made to get Arizona to their projected annual apportionment, lower basin demand variability, shortage, or surplus.<br><br>SLOTS SET: Forecast.CAPAnnualFC<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "ForecastUse.CAPAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "CAPDiversion.Total Diversion Requested" );

    END
    UUID "{260969b9-b5a6-4017-8c83-cf6454da6fbe}";;

    RULE                 "Final MWD Diversion";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for MWD after all schedule adjustments. Adjustments may be made to get California to their projected annual apportionment, lower basin demand variability, shortage, or surplus.<br><br>SLOTS SET: ForecastUse.MWDDiversionAnnualFC; ForecastUse.MWDAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "ForecastUse.MWDDiversionAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "MWDDiversion:MWD.Diversion Requested" );

      $ "ForecastUse.MWDAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
 THEN
  "SumSlot"( $ "California_CU_Actual.MWD", @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" ) + "SumFlowsToVolume"( $ "MWDDiversion:MWD.Depletion Requested", @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" )
 ELSE
  FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
   "FlowToVolume"( $ "MWDDiversion:MWD.Depletion Requested" [date], date )
  ENDFOR
 ENDIF;

    END
    UUID "{0feb2abf-ab3a-4ef2-9441-a6c6975c1a78}";;

    RULE                 "Final CA Overrun - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected overrun or underrun for California after all schedule adjustments by calculating the difference between the total annual diversion request and the annual apportionment for the current calendar year.<br><br>SLOTS SET: AnnualWaterUse.CaOverrun";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.CaOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.CaTotalAnnual" [@"24:00:00 December 31, Current Year"] - IF ( "IsMRM"(  ) )
 THEN
  $ "AnnualWaterUse.California_FinalAdjustedApportionment" [@"24:00:00 December 31, Current Year"]
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF;

    END
    UUID "{59a6b371-5c3d-4bda-a304-c88c26e0273c}";;

    RULE                 "Final CA Annual Use - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for California after all schedule adjustments by summing the non-MWD diversion requests and the MWD depletion request for the current calendar year.  This rule also calculates the value of the California Final Adjusted Apportionment.<br><br>SLOTS SET: AnnualWaterUse.CaTotalAnnual; AnnualWaterUse.California_FinalAdjustedApportionment";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND ( @"t" == @"24:00:00 December 31, Current Year" OR @"t" == @"Finish Timestep" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.CaTotalAnnual" [@"24:00:00 December 31, Current Year"] := FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  FOR ( OBJECT diversionSite IN "ListSubbasin"( "California nonMWD WaterUsers" ) ) STAT_SUM
   IF ( diversionSite == % "PaloVerde" )
   THEN
    "FlowToVolume"( diversionSite & "Total Diversion Requested" [date], date )
   ELSE
    "FlowToVolume"( diversionSite & "Diversion Requested" [date], date )
   ENDIF
  ENDFOR + "FlowToVolume"( $ "MWDDiversion:MWD.Depletion Requested" [date], date )
 ENDFOR COMMENTED_BY "This assignment now calculates the Total Diversion by California by Adding all non MWD <br>user Diversion requests to the MWD diversion request less the return flow from MWD. <br>TP 7/13/2015";

      $ "AnnualWaterUse.California_FinalAdjustedApportionment" [@"24:00:00 December 31, Current Year"] := IF ( "IsMRM"(  ) )
 THEN
  IF ( @"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" AND "GetMonth"( @"Start Timestep" ) >= 4.00000000 )
  THEN
   $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
  ELSE
   ( $ "AnnualWaterUse.California_PreliminaryAdjustedApportionment" [@"24:00:00 December 31, Current Year"] - ( NaNToZero ( $ "ICS Credits.AnnualCreationEC_MWD" ["Dec31ofYear"( @"t" )] ) - NaNToZero ( $ "ICS Credits.AnnualSimultaneousCreationDCPICS_MWD" ["Dec31ofYear"( @"t" )] ) ) + ( ( NaNToZero ( $ "ICS Credits.AnnualDeliveryBiNat_CA" ["Dec31ofYear"( @"t" )] ) + NaNToZero ( $ "ICS Credits.AnnualDeliveryEC_MWD" ["Dec31ofYear"( @"t" )] ) + NaNToZero ( $ "ICS Credits.AnnualDeliverySysEff_CA" ["Dec31ofYear"( @"t" )] ) ) + NaNToZero ( $ "ICS Credits.AnnualDeliveryDCP_CA" ["Dec31ofYear"( @"t" )] ) ) ) COMMENTED_BY "removed Tijuana and MWD returns because they are now accounted for in the ICS accounting <br>and Releases Policy group<br>"
  ENDIF
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF;

    END
    UUID "{cb5bece1-347d-415f-b3ce-25fedd882e47}";;

    RULE                 "Final AZ Overrun - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected overrun or underrun for Arizona after all schedule adjustments by calculating the difference between the total diversion request and the annual apportionment for the current calendar year. <br><br>SLOTS SET: AnnualWaterUse.AzOverrun<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.AzOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.AzTotalAnnual" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.Arizona_Apportionment" [@"24:00:00 December 31, Current Year"];

    END
    UUID "{51c1f814-afca-4ce1-ae9a-42e6c1a8a216}";;

    RULE                 "Final AZ Annual Use - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for Arizona after all schedule adjustments by summing the CAP and non-CAP annual diversion requests for the current calendar year. <br><br>SLOTS SET: AnnualWaterUse.AzTotalAnnual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.AzTotalAnnual" [@"24:00:00 December 31, Current Year"] := "SumAnnualCAPDivRequest"(  ) + $ "AnnualWaterUse.AzNoCAPTotalAnnual" [@"24:00:00 December 31, Current Year"];

    END
    UUID "{3181491d-33cb-496a-8c83-de6f7c0e3c69}";;

    RULE                 "Final NV Overrun - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected overrun or underrun for Nevada after all schedule adjustments by calculating the difference between the total diversion requests and the annual apportionment for the current calendar year. <br><br>SLOTS SET: AnnualWaterUse.NVOverrun<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.NVOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.NvTotalAnnual" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"];

    END
    UUID "{572e18ce-04c0-4998-86a9-dc6292768c02}";;

    RULE                 "Final NV Annual Use - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for Nevada after all schedule adjustments by summing the diversion requests of Nevada water users for the current calendar year. <br><br>SLOTS SET: AnnualWaterUse.NvTotalAnnual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.NvTotalAnnual" [@"24:00:00 December 31, Current Year"] := FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  FOR ( OBJECT diversionSite IN "ListSubbasin"( "NevadaWaterUsers" ) ) STAT_SUM
   IF ( diversionSite == % "NvDvsToPkr" )
   THEN
    "FlowToVolume"( diversionSite & "Total Diversion Requested" [date], date )
   ELSE
    "FlowToVolume"( diversionSite & "Diversion Requested" [date], date )
   ENDIF
  ENDFOR
 ENDFOR;

    END
    UUID "{3ce4aca2-e79b-4b7a-b7e7-7d0031d658f2}";;

    RULE                 "Compute Lower Basin Energy";
    DESCRIPTION          "DESCRIPTION: This rule must fire after all schedule adjustments have been made, which is why it is in the highest priority polict group.<br><br>SLOTS SET: Lower Basin Energy.Computed Davis Energy Using Input Eff; Lower Basin Energy.Computed Davis Head using Turbine Release; Lower Basin Energy.Davis KWH per AF; Lower Basin Energy.Computed Parker Energy Using Input Eff; Lower Basin Energy.Computed PD Project Energy Using Peak Base Power Calc; Lower Basin Energy.Computed PD Project Energy Using Input Eff<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Lower Basin Energy.Computed Davis Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] ) * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" );

      $ "Lower Basin Energy.Computed Davis Head using Turbine Release" [] := "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] );

      $ "Lower Basin Energy.Davis KWH per AF" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] ) * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) / "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * 1.00000000 "ft" * 1.00000000 "ft";

      $ "Lower Basin Energy.Computed Parker Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Parker Efficiency" [] * "FlowToVolume"( $ "Havasu.Turbine Release" [], @"t" ) * $ "Havasu.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" );

      $ "Lower Basin Energy.Computed PD Project Energy Using Peak Base Power Calc" [] := $ "Mohave.Energy" [] + $ "Havasu.Energy" [] / 2.00000000;

      $ "Lower Basin Energy.Computed PD Project Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * $ "Mohave.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) + $ "Lower Basin Energy.Input Parker Efficiency" [] * "FlowToVolume"( $ "Havasu.Turbine Release" [], @"t" ) * $ "Havasu.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) / 2.00000000;

    END
    UUID "{075cf9e5-f328-413c-96b9-81a8d5ddb9d8}";;

  END
  UUID "{0e00c279-f30a-4ce4-8855-d1bab141d5de}";;

  POLICY_GROUP   "FloodControl";
  DESCRIPTION    "This policy group contains all the rules required to simulate Lake Mead/Hoover Dam flood control operations. Flood control operations are based on the USACE Water Control Manual for Flood Control: Hoover Dam and Lake Mead Colorado River, December 1982 (Flood Control Manual)";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Compute LC Dam Capacity";
    DESCRIPTION          "DESCRIPTION: This rule sets the power slots for the LC dams based on their power capacity values and power plant capacity fractions<br><br>SLOTS SET: Mead.Power; Mohave.Power; Havasu.Power<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 4.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Mead.Power" [] := $ "EnergyInfo.EffectiveHooverCapacity" [] * $ "Mead.Power Plant Cap Fraction" [];

      $ "Mohave.Power" [] := $ "Lower Basin Energy.Davis_Power_Capacity" [] * $ "Mohave.Power Plant Cap Fraction" [];

      $ "Havasu.Power" [] := $ "Lower Basin Energy.Parker_Power_Capacity" [] * $ "Havasu.Power Plant Cap Fraction" [];

    END
    UUID "{80739e6a-3af3-40a2-ba58-cd1b99e9d8d0}";;

    RULE                 "FC Surplus Schedules Data Volume to Simulation Flow";
    DESCRIPTION          "DESCRIPTION: In the event of Flood Control the Diversion Schedules are set to the Monthly Surplus Schedules for Flood Control. TP 7/28/2015<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Flood Control Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet; OthersBlwImp.AzPumpersBlwImp.Diversion Requested; AzPkrToImp:CibolaValleyIID.Diversion Requested; AzPkrToImp:Parker.Diversion Requested; GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested; CAPDiversion.Total Diversion Requested; MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested; AAC:Coachella.Diversion Requested; AAC:IID.Diversion Requested; CaPkrToImp:CaPumpersAbvImp.Diversion Requested; CaDvsToPkr:Needles.Diversion Requested; MexicanTreatyDelivery:MexicoSched.Diversion Requested; PumpingFromLakeMead:SNWP.Diversion Requested; PumpingFromLakeMead:SNWP.Depletion Requested<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) AND IsNaN $ "Surplus.Flood Control Surplus Flag" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015<br>MC, 20170920: Changed beginning datetime in FOR loop from @&quot;24:00:00 January 31, Current Year&quot; to @&quot;t&quot; per Sep 19 email from Shana T. and Corinne H.<br>A.Pivarnik, 20180921: Disabled statement setting LowerBasinDemandVariability.AbvHooverTriggerSet. Was causing MTOM to fail in August run when trying to set Mead operations. ";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 3.00000000;

            $ "Surplus.Flood Control Surplus Flag" [date] := 1.00000000;

          INACTIVE      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

          INACTIVE      $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "AzPumpersBlwImp" ), date );

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CibolaValleyIID" ), date );

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "City of Parker" ), date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Gila Monster Farms" ), date );

            $ "CAPDiversion.Total Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CAP" ), date );

            $ "MWDDiversion:MWD.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "MWD" ), date );

            $ "MWDDiversion:MWD.Depletion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "MWD" ), date ) - "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Coachella" ), date );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "IID" ), date );

            $ "CaPkrToImp:CaPumpersAbvImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CaPumpersAbvImp" ), date );

            $ "CaDvsToPkr:Needles.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Needles" ), date );

            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Mexico" ), date );

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

            $ "PumpingFromLakeMead:SNWP.Depletion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

      ENDFOREACH;

    END
    UUID "{41783893-2316-4c95-a94e-326bbc88b50f}";;

    RULE                 "Compute Effective Hoover Capacity Regression";
    DESCRIPTION          "DESCRIPTION: This Rule is used to set the EnergyInfo.EffectiveHooverCapacity so that it can go out to 60 weeks.  The regression equation provided is from the LC BoR office and can be adjusted using this rule. <br><br>SLOTS SET: EnergyInfo.EffectiveHooverCapacity; Mead.Power Plant Cap Fraction<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF_STATEMENT (( NOT "IsMRM"(  ) ) COMMENTED_BY "This check determines if a run is a deterministic run or an MRM run and the data comes<br>out of the Ensemble Forecast Sheet. TP 3/28/2013") THEN
            IF_STATEMENT ("IsInput"( $ "EnergyInfo.EffectiveHooverCapacityInput", @"t" )) THEN
          DESCRIPTION          "Use input value";
      $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := $ "EnergyInfo.EffectiveHooverCapacityInput" [@"t"];

      ELSE
          DESCRIPTION          "Calculate based on Mead pool elevation";
      WITH_STATEMENT (NUMERIC elevMead = $ "Mead.Pool Elevation" [@"t"]) DO
            $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := IF ( elevMead >= 1170.00000000 "feet" )
 THEN
  2074.00000000 "MW"
 ELSE
  ( elevMead * ( 5.64540000 "MW" / 1.00000000 "foot" ) - 4530.50000000 "MW" )
 ENDIF;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC elevMead = $ "Mead.Pool Elevation" [@"t"]) DO
            $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := IF ( elevMead >= 1170.00000000 "feet" )
 THEN
  2074.00000000 "MW"
 ELSE
  ( elevMead * ( 5.64540000 "MW" / 1.00000000 "foot" ) - 4530.50000000 "MW" )
 ENDIF;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Set Mead power plant capacity fraction if necessary";
      IF_STATEMENT (NOT "IsInput"( $ "Mead.Power Plant Cap Fraction", @"t" )) THEN
            $ "Mead.Power Plant Cap Fraction" [@"t"] := $ "Mead.Power Plant Cap Fraction" [@"t - 12"];

      END_IF_STATEMENT;

    END
    UUID "{cf065236-de42-46bf-938f-26b4734bd23e}";;

    RULE                 "Mead Space Building";
    DESCRIPTION          "DESCRIPTION: If the storage in Mead is greater than the target storage (based on the minimum system space that must be available), this rule resets the outflow to achieve the target storage during space building months (August 1 - December 31); if the Flood Control Flag is not already set, this rule also sets it based on whether the outflow was reset by the rule<br><br>SLOTS SET: Mead.Outflow; FloodControlOutput.Flood Control Flag<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND NOT IsNaN $ "Mead.Storage" [] AND @"t" > @"24:00:00 July Max DayOfMonth, Current Year" AND IsNaN $ "FloodControlOutput.Flood Control Flag" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>CH, 4/18/18: Added execution constraint: AND IsNaN FloodControlOutput.Flood Control Flag to so that in the case the Flood Control Flag is set in run cycle 3, it is not reset in run cycle 4. Once a flood control flag is set, it should not be reset (even in run cycle 4).";
    BEGIN

      IF_STATEMENT ($ "Mead.Storage" [] > "ComputeTargetStorage"(  )) THEN
            $ "Mead.Outflow" [] := "Max"( "ComputeOutflowAtGivenStorage"( % "Mead", "ComputeTargetStorage"(  ) ), $ "Mead.Outflow" [] );

      END_IF_STATEMENT;

      $ "FloodControlOutput.Flood Control Flag" [] := IF ( IsNaN $ "FloodControlOutput.Flood Control Flag" [] )
 THEN
  IF ( $ "Mead.Storage" [] > "ComputeTargetStorage"(  ) )
  THEN
   1.00000000
  ELSE
   0.00000000
  ENDIF
 ENDIF;

    END
    UUID "{845d936f-f1ea-45e0-a351-84b1ad57cd3f}";;

    RULE                 "Mead Flood Control Release";
    DESCRIPTION          "DESCRIPTION: This rule checks that the release from Mead computed for downstream demands is large enough to satisfy flood control during the runoff season. If not, Mead Outflow is reset to the required flood control release which was previously calculated in the <Set Flood Control Release> rule and stored as FloodControlOutput.FCrelease. The flood control flag is also set to 1, which will cause the system to solve downstream and eventually force more water out of Havasu and Mohave.<br><br>SLOTS SET: Mead.Outflow; FloodControlOutput.Flood Control Flag<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND NOT IsNaN $ "Mead.Outflow" [] AND "GetRunCycleIndex"(  ) >= 3.00000000 AND IsNaN $ "FloodControlOutput.Flood Control Flag" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170518: Rule modified to only use 1 IF statement <br>CH, 4/18/18: Added execution constraint: AND IsNaN FloodControlOutput.Flood Control Flag to so that in the case the Flood Control Flag is set in run cycle 3, it is not reset in run cycle 4. Once a flood control flag is set, it should not be reset (even in run cycle 4).";
    BEGIN

      IF_STATEMENT ($ "Mead.Outflow" [] < $ "FloodControlOutput.FCrelease" []) THEN
            $ "Mead.Outflow" [] := $ "FloodControlOutput.FCrelease" [];

            $ "FloodControlOutput.Flood Control Flag" [] := 1.00000000;

      ELSE
            $ "FloodControlOutput.Flood Control Flag" [] := 0.00000000;

      END_IF_STATEMENT;

    END
    UUID "{04734c58-ee44-4bdb-b2a8-bb807c84a081}";;

    RULE                 "Mead Exclusive Flood Control Space";
    DESCRIPTION          "DESCRIPTION: This rule ensures that Mead does not violate the 1.5 maf space requirement (on MeadFloodControlData.MinSpace slot) at any time of the year. Although this is the highest priority rule, we don't want it to fire until the other flood control procedures have potentially executed. The rule checks the storage in Mead, and if it does not provide the minimum space, the outflow is recalculated so that the minimum space is achieved. If the outflow is recalculated, the FloodControlOutput.Exclusive Space Flag is set to 1; otherwise it is set to 0.<br><br>SLOTS SET: Mead.Outflow; FloodControlOutput.Exclusive Space Flag<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "FloodControlOutput.Flood Control Flag" [] AND NOT IsNaN $ "Mead.Storage" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>SB, 201907011: Edited execution constraint to check if FC slot was greater than 0 (not just Not NaN). This rule was setting Mead outflow during very low scenarios in which flood control rules should not be executing.<br>MC, 20170518: Modified rule to use only 1 IF statement instead of 2, and only print statement in the case the IF statement is TRUE<br>MC, 20170920: Modified calculation of Mead.Outflow to take the larger of outflow to reach min space requirement or outflow to meet downstream requirement per Sep 19 email from Shana T. and Corinne H. (previously did not consider downstream requirement)";
    BEGIN

    DESCRIPTION          "If Mead storage exceeds what provides the minimum space requirement, <br>recalculate outflow so the storage provides the minimum space.";
      IF_STATEMENT ($ "Mead.Storage" [] >= "ComputeMinimumSpace"( % "Mead" ) COMMENTED_BY "Storage with min space requirement" OR $ "Mead.Outflow" [] < "VolumeToFlow"( $ "Lower Basin Output.DownstreamReq" [], @"t" ) COMMENTED_BY "Storage with min space requirement") THEN
            $ "Mead.Outflow" [] := "Max"( "ComputeOutflowAtGivenStorage"( % "Mead", "ComputeMinimumSpace"( % "Mead" ) ), "VolumeToFlow"( $ "Lower Basin Output.DownstreamReq" [], @"t" ) ) COMMENTED_BY "Calculate outflow to reach storage with min space requirement or meet <br>downstream requirement, whichever volume is larger<br>(This will be constrained to MaxSpaceBuildingRelease outflow) <br>";

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "FloodControlOutput.Exclusive Space Flag" []) THEN
            $ "FloodControlOutput.Exclusive Space Flag" [] := IF ( $ "Mead.Storage" [] >= "ComputeMinimumSpace"( % "Mead" ) )
 THEN
  1.00000000
 ELSE
  0.00000000
 ENDIF;

      END_IF_STATEMENT;

      PRINT "Flood Control due to violating Exclusive Flood Control Space: Mead Storage reset";

    END
    UUID "{b584d84f-954a-4de0-a90e-9ff926312f05}";;

    RULE                 "Set Flood Control Release";
    DESCRIPTION          "DESCRIPTION: This rule sets the Mead flood control release according to Table 1 in Exhibit A of the Flood Control Manual, which dictates release steps given inflow and available storage, during flood control months (January 1 - July 31) or as the minimum of either releases needed to achieve target storage or the maximum space building release (28,000 cfs) during space building months (August 1 - December 31).<br><br>SLOTS SET: FloodControlOutput.FCrelease<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.FCrelease" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "FloodControlOutput.FCrelease" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  GET @INDEX 0.00000000 FROM "ForecastRunoffSeason "(  )
 ELSE
  "ComputeTargetStorageRelease"(  )
 ENDIF;

      PRINT IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "entering Runoff Forecast Season routine for" CONCAT "GetMonthAsString"( @"t" )
 ELSE
  "Mead Flood Control Release is not computed in" CONCAT "GetMonthAsString"( @"t" )
 ENDIF;

    END
    UUID "{9e309501-08e3-4740-be14-4e5b097ffc6a}";;

    RULE                 "Set Without Release";
    DESCRIPTION          "DESCRIPTION: This rule calculates the forecasted Mead inflow and the Mead inflow volume in excess of the available space in Mead and Powell<br><br>SLOTS SET: FloodControlOutput.Forecas; FloodControlOutput.Withoutrel<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND IsNaN $ "FloodControlOutput.Withoutrel" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: The AvailableSpace, DeltaBankStorage, and FloodControlEvap values were previously calculated in Set Forecast Data. Can those slot values be used here instead of recalculating those values? Also, replace call to ForecastMeadInflow with appropriate call to SumFlowsToVolume";
    BEGIN

      $ "FloodControlOutput.Forecas" [] := "ForecastMeadInflow"(  );

    DESCRIPTION          "Calculate the Mead inflow volume in excess of available space";
      $ "FloodControlOutput.Withoutrel" [] := "ForecastMeadInflow"(  ) - "AvailableSpace"( % "Mead" ) - "AvailableSpace"( % "Powell" ) + $ "MeadFloodControlData.MinSpace" [0.00000000, 0.00000000] - "DeltaBankStorage"(  ) - "FloodControlEvap"( % "Mead" ) - "FloodControlEvap"( % "Powell" ) - $ "FloodControlOutput.Consnev" [];

    END
    UUID "{233d9dc6-c094-473e-9541-54d87a8038f7}";;

    RULE                 "Set Effective Space";
    DESCRIPTION          "DESCRIPTION: This rule calculates the total effective space available in Flaming Gorge (incl. Fontenelle), Blue Mesa, and Navajo until the end of July of the current year by choosing, for each individual reservoir, the minimum of the total available space remaining (*use) or the difference between the Inflow and Outflow (*pred) for the period and summing those values. Used in ForecastMeadInflow function to calculate Mead inflow forecast for calculation of flood control releases according to the Flood Control Algorithm in Exhibit One of the Flood Control Manual.<br><br>SLOTS SET: FloodControlOutput.UBEffective<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.UBEffective" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "FloodControlOutput.UBEffective" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "Min"( $ "FloodControlOutput.FGuse" [], $ "FloodControlOutput.FGpred" [] ) + "Min"( $ "FloodControlOutput.BMuse" [], $ "FloodControlOutput.BMpred" [] ) + "Min"( $ "FloodControlOutput.NAVuse" [], $ "FloodControlOutput.NAVpred" [] )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

    END
    UUID "{ffd0a61e-94c5-4661-9b00-3a8d117f12ea}";;

    RULE                 "Set Consnev";
    DESCRIPTION          "DESCRIPTION: This rule calculates the total diversion volume requested by SNWP from the current timestep to the end of July of the current year<br><br>SLOTS SET: FloodControlOutput.Consnev<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND IsNaN $ "FloodControlOutput.Withoutrel" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: The function call in this rule can be replaced by a call to the predefined function SumFlowsToVolume <br>MC, 20180312: The above replacement was made sometime between these two comments. The MTOM changelog may have the specific month that the change was made.";
    BEGIN

      $ "FloodControlOutput.Consnev" [] := "SumFlowsToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested", @"t", @"24:00:00 July Max DayOfMonth, Current Year" );

    END
    UUID "{9820997f-5922-492e-801d-37a351282497}";;

    RULE                 "Set Forecast Data";
    DESCRIPTION          "DESCRIPTION: This rule calculates and stores the current available storage and expected net change in storage between the current timestep and the end of July of the current year for Flaming Gorge, Blue Mesa, Navajo, Powell and Mead. The change in bank storage and the evaporation are also calculated and stored. These storage calculations are used to determine effective upstream reservoir storage in the Mead Space Building rule. Effective UB storage is used to calculate Mead inflow forecast in the ForecastMeadInflow function for determination of flood control releases using the Flood Control Algorithmin Exhibit One of the Flood Control Manual.<br><br>SLOTS SET: FloodControlOutput.FGuse; FloodControlOutput.FGpred; FloodControlOutput.BMuse; FloodControlOutput.BMpred; FloodControlOutput.NAVuse; FloodControlOutput.NAVpred; FloodControlOutput.MeadPred; FloodControlOutput.MeadCredEff; FloodControlOutput.PowellPred; FloodControlOutput.PowellCredEff; FloodControlOutput.Deltabs; FloodControlOutput.Evapmd; FloodControlOutput.Evapow<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.Withoutrel" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170717: Replaced explicit calculations for UC reservoirs with calls to AvailableSpace function<br>MC, 20170531 - the GetLiveCapacity(reservoir) - reservoir.Storage[@&quot;t-1&quot;] calculation is codified in the function AvailableSpace; call that function here?";
    BEGIN

      WITH_STATEMENT (LIST MonthlyDatelist = "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" )) DO
          DESCRIPTION          "(Inflow - Outflow) between current timestep and end of July of current year";
      $ "FloodControlOutput.FGuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "SumSlotVolume"( $ "FlamingGorgeInflow.Unregulated", MonthlyDatelist ) - "SumSlotVolume"( $ "FlamingGorge.Outflow", MonthlyDatelist )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

          DESCRIPTION          "Calculate additional available storage in Flaming Gorge";
      $ "FloodControlOutput.FGpred" [] := "AvailableSpace"( % "FlamingGorge" ) + "AvailableSpace"( % "Fontenelle" );

          DESCRIPTION          "(Inflow - Outflow) between current timestep and end of July of current year";
      $ "FloodControlOutput.BMuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "SumSlotVolume"( $ "BlueMesaInflow.Unregulated", MonthlyDatelist ) - "SumSlotVolume"( $ "BlueMesa.Outflow", MonthlyDatelist )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

          DESCRIPTION          "Calculate additional available storage in Blue Mesa";
      $ "FloodControlOutput.BMpred" [] := "AvailableSpace"( % "BlueMesa" );

          DESCRIPTION          "(Inflow - Outflow) between current timestep and end of July of current year";
      $ "FloodControlOutput.NAVuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "SumSlotVolume"( $ "Navajo.Inflow", MonthlyDatelist ) - "SumSlotVolume"( $ "Navajo.Outflow", MonthlyDatelist )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

          DESCRIPTION          "Calculate additional available storage in Navajo";
      $ "FloodControlOutput.NAVpred" [] := "AvailableSpace"( % "Navajo" );

          DESCRIPTION          "Calculate additional available storage in Mead";
      $ "FloodControlOutput.MeadPred" [] := "AvailableSpace"( % "Mead" );

            $ "FloodControlOutput.MeadCredEff" [] := "AvailableSpace"( % "Mead" );

          DESCRIPTION          "Calculate additional available storage in Powell";
      $ "FloodControlOutput.PowellPred" [] := "AvailableSpace"( % "Powell" );

            $ "FloodControlOutput.PowellCredEff" [] := "AvailableSpace"( % "Powell" );

          DESCRIPTION          "Calculate change in bank storage with available space";
      $ "FloodControlOutput.Deltabs" [] := "DeltaBankStorage"(  );

          DESCRIPTION          "Calculate evaporation between current timestep and end of July of current year";
      $ "FloodControlOutput.Evapmd" [] := "FloodControlEvap"( % "Mead" );

            $ "FloodControlOutput.Evapow" [] := "FloodControlEvap"( % "Powell" );

      END_WITH_STATEMENT;

    END
    UUID "{3aa54334-7508-4ad3-9e14-4ee1e37d0180}";;

    RULE                 "Set Schedule Release";
    DESCRIPTION          "DESCRIPTION: This rule copies the initial Mead release needed to meet downstream demands to the FloodControlOutput data object in slot MeadSchedRel. The value should only be reported the first time Mead calculates its outflow based on downstream demands.<br><br>SLOTS SET: Lower Basin Output.MeadSchedRel<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Lower Basin Output.MeadSchedRel" [] AND NOT IsNaN $ "Mead.Outflow" [] AND "GetRunCycleIndex"(  ) == 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Lower Basin Output.MeadSchedRel" [] := $ "Mead.Outflow" [];

    END
    UUID "{2d2f0f91-da59-4386-8aaa-9d9d4270a686}";;

  END
  UUID "{9605f34a-8ce0-4545-8453-6df3df83363a}";;

  POLICY_GROUP   "ICS Accounting and Releases";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "MX Diversion Reduction";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] OR $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] ) ) AND $ "MTOMRunType.RunType" [] != 1.00000000;
    NOTES                "";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( "FlowToVolume"( $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date], date ) - $ "Mexico Shortage and Surplus.Mexico Recoverable Water Savings_AnnualContribution" [@"24:00:00 December Max DayOfMonth, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Mexico"], date );

      ENDFOREACH;

    END
    UUID "{c0ad0cb4-4363-4f0d-9b4a-f149af07515a}";;

    RULE                 "NV Diversion Adjustment";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] OR $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] ) ) AND $ "MTOMRunType.RunType" [] != 1.00000000 AND NOT ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC AdditionalDCPReductionNV = ( ( $ "ICS Credits.AnnualSimultaneousCreationDCPICS_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualConversionCurrentECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] ) / "SystemTaxAdjustment_DCP"(  ) + $ "ICS Credits.AnnualSysWaterforDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] ) COMMENTED_BY "Simultaneous Creation was calculated in accounting rule as the sum of any conversion from <br>current EC ICS creation and any additional simulatenous DCP ICS creation up to bank capacity/  <br>required DCP contribution. If any additional schedule redcutions were needed to meet the DCP <br>contribution this would be taken as system water. Only decrease SNWP diversion by additional <br>DCP ICS creation + sys water creation for DCP because the remainder of the reduction was <br>accounted for in the SNWP diversion volume for the year<br><br>AP 11/19/19<br>") DO
            WITH_STATEMENT (NUMERIC SNWPdivRequested = "SumFlowsToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested", @"t", @"24:00:00 December Max DayOfMonth, Current Year" )) DO
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC monthPercent = 1.00000000 / "GetDaysLeftInYear"(  ) * "GetDaysInMonth"( date )) DO
            FOREACH (SLOT slot IN { $ "PumpingFromLakeMead:SNWP.Diversion Requested" , $ "PumpingFromLakeMead:SNWP.Depletion Requested" }) DO
            slot [date] := "VolumeToFlow"( ( SNWPdivRequested - AdditionalDCPReductionNV ) * monthPercent, date );

      ENDFOREACH;

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{bde8a45f-6afe-4ca8-bb72-e79b4a6c743a}";;

    RULE                 "CA Diversion Adjustment";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] OR $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] ) ) AND $ "MTOMRunType.RunType" [] != 1.00000000 AND NOT ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC dcpContributionCVWD = $ "ICS Credits.AnnualDCPContribution_Coachella" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "AAC:Coachella.Diversion Requested" [date] := $ "AAC:Coachella.Diversion Requested" [date] - "VolumeToFlow"( dcpContributionCVWD * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Equal"], date );

      ENDFOREACH;

      END_WITH_STATEMENT;

    BREAKPOINT AFTER_EXEC TRUE;
      WITH_STATEMENT (NUMERIC IIDadjustment = $ "ICSProjectionData.AnnualDeliveryEC_IID_Default" ["Dec31ofYear"( @"t" )] + $ "ICSProjectionData.AnnualCreationEC_IID_Default" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.AnnualDeliveryEC_IID" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationEC_IID" ["Dec31ofYear"( @"t" )] )) DO
            WITH_STATEMENT (NUMERIC totalDeliveryMWDICS = IF ( @"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" OR NOT "IsMRM"(  ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  $ "ICS Credits.AnnualICSDelivery_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"]
 ENDIF) DO
            WITH_STATEMENT (NUMERIC totalCreationECICS = IF ( @"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" OR NOT "IsMRM"(  ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  $ "ICS Credits.AnnualCreationEC_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"]
 ENDIF) DO
            WITH_STATEMENT (NUMERIC DCPreductionMWD = $ "ICS Credits.AnnualSimultaneousCreationDCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] / "SystemTaxAdjustment_DCP"(  ) + $ "ICS Credits.AnnualSysWaterforDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDCPContribution_Coachella" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            WITH_STATEMENT (LIST newMWDDivDepList = FOR ( DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year" ) WITH LIST result = {  } DO
  WITH NUMERIC newMWDDivAmount = WITH NUMERIC DeliveryToDate = "GetDiversionToDate"( $ "California_CU_Actual.MWD" ) DO
   WITH NUMERIC monthPercent = 1.00000000 / "GetDaysLeftInYear"(  ) * "GetDaysInMonth"( date ) DO
    "VolumeToFlow"( "Min"( $ "MWDDiversionData.MWDCanal_DailyCapacity" [] * "GetDaysInMonth"( date ), ( "SumFlowsToVolume"( $ "MWDDiversion:MWD.Diversion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + ( totalDeliveryMWDICS - totalCreationECICS - DCPreductionMWD - DeliveryToDate - IIDadjustment ) COMMENTED_BY "Increase the MWD depletion amount by the total delivery less any over delivery that might be <br>occuring in a given scenario, or decrease the delivery if any creation of water for a given <br>scenario. TP 12/22/2017  <br>" ) * monthPercent ), date )
   ENDWITH
  ENDWITH DO
   WITH NUMERIC newDivReq = newMWDDivAmount - $ "MWDDiversion:Tijuana.Diversion Requested" [date] DO
    WITH NUMERIC newDepReq = newMWDDivAmount - ( "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date ) + $ "MWDDiversion:Tijuana.Diversion Requested" [date] ) DO
     APPEND { date , newDivReq , newDepReq } ONTO result
    ENDWITH
   ENDWITH
  ENDWITH
 ENDFOR COMMENTED_BY "Adjust the MWD Diversion Request to reduce the request if there is not enough total ICS in the <br>system for the total delivery to California.  The reduction will be the difference between the <br>determined delivery to california above the state apportionment minus the availalbe ICS volume.  <br>MWD takes the reduction.   <br>") DO
            FOREACH (LIST subList IN newMWDDivDepList) DO
            $ "MWDDiversion:MWD.Diversion Requested" [GET @INDEX 0.00000000 FROM subList] := GET @INDEX 1.00000000 FROM subList;

            $ "MWDDiversion:MWD.Depletion Requested" [GET @INDEX 0.00000000 FROM subList] := GET @INDEX 2.00000000 FROM subList;

      ENDFOREACH;

          DESCRIPTION          "Adjust IID Diversion Requested <br>";
      IF_STATEMENT (IIDadjustment != 0.00000000 "acre-ft") THEN
            FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "AAC:IID.Diversion Requested" [date] := $ "AAC:IID.Diversion Requested" [date] + "VolumeToFlow"( IIDadjustment * $ "Shortage.MonthlyPercents" ["GetMonth"( date ) - 1.00000000, "Equal"], date );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{6a54fd44-a0fc-456b-bdff-5faea9c4fc1e}";;

    RULE                 "AZ Diversion Adjustment";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] OR $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] ) ) AND $ "MTOMRunType.RunType" [] != 1.00000000 AND NOT ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC CAWCDICSdiversionAdjustment = $ "ICS Credits.AnnualICSDelivery_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICSProjectionData.AnnualICSDelivery_CAWCD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            WITH_STATEMENT (NUMERIC DCPreductionCAWCD = $ "ICS Credits.AnnualSimultaneousCreationDCPICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] / "SystemTaxAdjustment_DCP"(  ) + $ "ICS Credits.AnnualSysWaterforDCP_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            WITH_STATEMENT (NUMERIC CAPDivRequested = "SumFlowsToVolume"( $ "CAPDiversion.Total Diversion Requested", @"t", @"24:00:00 December Max DayOfMonth, Current Year" )) DO
            FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC MonthPercent = 1.00000000 / "GetDaysLeftInYear"(  ) * "GetDaysInMonth"( date )) DO
            $ "CAPDiversion.Total Diversion Requested" [date] := "VolumeToFlow"( ( CAPDivRequested - ( DCPreductionCAWCD + CAWCDICSdiversionAdjustment ) ) * MonthPercent, date );

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{1574216e-dc24-4ea2-9307-60c03d96cdbb}";;

    RULE                 "Flood Control ICS Reduction";
    DESCRIPTION          "DESCRIPTION: This rule will use the Flood Control Volume to reduce the amount of Extraordinary Conservation ICS for each state. If the Flood Control Volume is greater than the volume of EC ICS water for all of the states and EC Delivery for each state, the balance of EC water is taken to 0 AF for each state. If the volume of FC water is less than the total EC volume, then the volume reduced from each state will be proportional to the volume that each state has when the Flood Control occurs. This rule assigns the new values of EC ICS water for California, Nevada, and Arizona and also re calculates and assignes the Total ICS Volumes for each state. TP 11/4/2014<br><br>SLOTS SET: ICS Credits.ExtraordinaryConservationICS_CA; ICS Credits.ExtraordinaryConservationICS_NV; ICS Credits.ExtraordinaryConservationICS_AZ; ICS Credits.TotalICS_CA; ICS Credits.TotalICS_NV; ICS Credits.TotalICS_AZ; ICS Credits.AnnualDeliveryEC_CA; ICS Credits.AnnualDeliveryEC_NV; ICS Credits.AnnualDeliveryEC_AZ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 4.00000000 AND ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) AND ( @"t" == @"24:00:00 December Max DayOfMonth, Current Year" OR @"t" == @"Finish Timestep" ) AND NOT "HasRuleFiredSuccessfully"( "True" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 11/4/2014<br><br>12/11/18, AP: edited to include MWD / IID ICS CA split";
    BEGIN

      WITH_STATEMENT (NUMERIC floodControlVol = "SumFlowsToVolume"( $ "Lower Basin Output.MexicoExcessFlow", @"24:00:00 January Max DayOfMonth, Current Year", "DateMin"( @"24:00:00 December Max DayOfMonth, Current Year", @"Finish Timestep" ) )) DO
            WITH_STATEMENT (LIST stateECBalances = "FloodControlECICSBalance"( floodControlVol )) DO
            $ "ICS Credits.ExtraordinaryConservationICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 1.00000000 FROM stateECBalances ) + GET @INDEX 2.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_CAWCD" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_CRIT" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_GRIC" ["Dec31ofYear"( @"t" )] := GET @INDEX 6.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_MVIDD" ["Dec31ofYear"( @"t" )] := GET @INDEX 7.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_WM" ["Dec31ofYear"( @"t" )] := GET @INDEX 8.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_AZ" ["Dec31ofYear"( @"t" )] := ( ( ( ( GET @INDEX 4.00000000 FROM stateECBalances ) + GET @INDEX 5.00000000 FROM stateECBalances ) + GET @INDEX 6.00000000 FROM stateECBalances ) + GET @INDEX 7.00000000 FROM stateECBalances ) + GET @INDEX 8.00000000 FROM stateECBalances;

            $ "ICS Credits.TotalICS_MWD" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 9.00000000 FROM stateECBalances );

            $ "ICS Credits.TotalICS_IID" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 10.00000000 FROM stateECBalances );

            $ "ICS Credits.TotalICS_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 9.00000000 FROM stateECBalances ) + ( GET @INDEX 10.00000000 FROM stateECBalances );

            $ "ICS Credits.Bank_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.Bank_CA" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.ExtraordinaryConservationICS_CA" ["Dec31ofYear"( @"t" )] - ( ( GET @INDEX 1.00000000 FROM stateECBalances ) + GET @INDEX 2.00000000 FROM stateECBalances ) );

            $ "ICS Credits.TotalICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 11.00000000 FROM stateECBalances );

            $ "ICS Credits.Bank_NV" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.Bank_NV" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] - GET @INDEX 3.00000000 FROM stateECBalances );

            $ "ICS Credits.TotalICS_CAWCD" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 12.00000000 FROM stateECBalances );

            $ "ICS Credits.TotalICS_AZ" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.TotalICS_AZ" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.ExtraordinaryConservationICS_AZ" ["Dec31ofYear"( @"t" )] - ( ( ( ( ( GET @INDEX 4.00000000 FROM stateECBalances ) + GET @INDEX 5.00000000 FROM stateECBalances ) + GET @INDEX 6.00000000 FROM stateECBalances ) + GET @INDEX 7.00000000 FROM stateECBalances ) + GET @INDEX 8.00000000 FROM stateECBalances ) );

            $ "ICS Credits.Bank_AZ" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.Bank_AZ" ["Dec31ofYear"( @"t" )] - ( $ "ICS Credits.ExtraordinaryConservationICS_AZ" ["Dec31ofYear"( @"t" )] - ( ( ( ( ( GET @INDEX 4.00000000 FROM stateECBalances ) + GET @INDEX 5.00000000 FROM stateECBalances ) + GET @INDEX 6.00000000 FROM stateECBalances ) + GET @INDEX 7.00000000 FROM stateECBalances ) + GET @INDEX 8.00000000 FROM stateECBalances ) );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{1d4c55e4-42ce-4d4d-a961-8d71f2ad62f0}";;

    RULE                 "MX Accounting";
    DESCRIPTION          "DESCRIPTION: This rule calculates the value of the ICMA balance for Mexico<br><br>SLOTS SET: Mexico Shortage and Surplus.ICMA Balance";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 December 31, Current Year" OR @"t" == "RunEndDate"(  ) AND "GetRunCycleIndex"(  ) == 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE;<br>MC, 20160908: Moved slot Mexico Shortage and Surplus.AnnualCreationICMA inside parentheses so it is subject to 0.97 factor per Shana T. email on 20160831<br><br>GCAA, 20181030: Replaced references to ICMA slots to Mexico Water Reserve slots";
    BEGIN

      WITH_STATEMENT (NUMERIC WaterReserveBal = $ "Mexico Shortage and Surplus.Mexico Water Reserve Balance" [@"24:00:00 December 31, Previous Year"] - $ "Mexico Shortage and Surplus.AnnualDeliveryMexicoWaterReserve" [@"24:00:00 December 31, Current Year"] - $ "ICS Credits.AnnualCreationBiNat_AZ" [@"24:00:00 December 31, Current Year"] - $ "ICS Credits.AnnualCreationBiNat_CA" [@"24:00:00 December 31, Current Year"] - $ "ICS Credits.AnnualCreationBiNat_NV" [@"24:00:00 December 31, Current Year"] + $ "Mexico Shortage and Surplus.AnnualCreationMexicoWaterReserve" [@"24:00:00 December 31, Current Year"] * "SystemTaxAdjustment_DCP"(  )) DO
            $ "Mexico Shortage and Surplus.Mexico Water Reserve Balance" [@"24:00:00 December 31, Current Year"] := WaterReserveBal;

            WITH_STATEMENT (NUMERIC RecoverableWater_prelim = $ "Mexico Shortage and Surplus.Mexico Recoverable Water Savings Balance" [@"24:00:00 December 31, Previous Year"] - $ "Mexico Shortage and Surplus.AnnualDeliveryMXRecoverableWaterSavings" [@"24:00:00 December 31, Current Year"]) DO
            WITH_STATEMENT (NUMERIC MXBank_prelim = RecoverableWater_prelim + WaterReserveBal) DO
            WITH_STATEMENT (NUMERIC MXRemainingBankSpace = $ "ICS Credits.MeadBankParameters" ["Mexico", "Max Capacity"] - MXBank_prelim) DO
            WITH_STATEMENT (NUMERIC MXRemainingBankSpace_PreTax = MXRemainingBankSpace / "SystemTaxAdjustment_DCP"(  )) DO
            WITH_STATEMENT (NUMERIC annualBWSPcontribution = $ "Mexico Shortage and Surplus.Mexico Recoverable Water Savings_AnnualContribution" [@"24:00:00 December 31, Current Year"]) DO
            WITH_STATEMENT (NUMERIC recoverablewaterBWSCPcontribution = "Max"( "Min"( MXRemainingBankSpace_PreTax, annualBWSPcontribution ), 0.00000000 "acre-ft" )) DO
            WITH_STATEMENT (NUMERIC syswaterBWSCPcontribution = annualBWSPcontribution - recoverablewaterBWSCPcontribution) DO
            WITH_STATEMENT (NUMERIC RecoverableWaterSavingsBalance = RecoverableWater_prelim + recoverablewaterBWSCPcontribution * "SystemTaxAdjustment_DCP"(  )) DO
            $ "Mexico Shortage and Surplus.AnnualBWSCP_SysWater" [@"24:00:00 December 31, Current Year"] := syswaterBWSCPcontribution;

            $ "Mexico Shortage and Surplus.AnnualCreationMXRecoverableWaterSavings" [@"24:00:00 December 31, Current Year"] := recoverablewaterBWSCPcontribution;

            $ "Mexico Shortage and Surplus.Mexico Recoverable Water Savings Balance" [@"24:00:00 December 31, Current Year"] := RecoverableWaterSavingsBalance;

            $ "Mexico Shortage and Surplus.Mexico Water Reserve Balance" [@"24:00:00 December 31, Current Year"] := WaterReserveBal;

            $ "Mexico Shortage and Surplus.Total Combined MX Savings and Reserve" [@"24:00:00 December 31, Current Year"] := RecoverableWaterSavingsBalance + WaterReserveBal;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{3cf25486-9222-4d9a-9f7b-d151fe589f1b}";;

    RULE                 "NV Accounting";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND "IsMRM"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] OR $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] OR ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) ) );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (LIST ICSAccounting = "ICSAccountingForNV"(  )) DO
            $ "ICS Credits.SystemEfficiencyICS_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 0.00000000 FROM ICSAccounting;

            $ "ICS Credits.BiNationalICS_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 1.00000000 FROM ICSAccounting;

            $ "ICS Credits.ImportedICS_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 2.00000000 FROM ICSAccounting;

            $ "ICS Credits.TributaryICS_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 3.00000000 FROM ICSAccounting;

            $ "ICS Credits.AnnualConversionCurrentECtoDCP_NV" [@"24:00:00 December 31, Current Year"] := ( $ "ICSProjectionData.AnnualCreationEC_SNWP_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] - GET @INDEX 5.00000000 FROM ICSAccounting ) * "SystemTaxAdjustment_DCP"(  );

            $ "ICS Credits.AnnualSimultaneousCreationDCPICS_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 4.00000000 FROM ICSAccounting;

            $ "ICS Credits.AnnualCreationEC_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 5.00000000 FROM ICSAccounting;

            $ "ICS Credits.AnnualSysWaterforDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 6.00000000 FROM ICSAccounting;

            $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 7.00000000 FROM ICSAccounting;

            $ "ICS Credits.DCPICS_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 8.00000000 FROM ICSAccounting;

            $ "ICS Credits.AnnualCreationDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] + GET @INDEX 4.00000000 FROM ICSAccounting;

            $ "ICS Credits.Bank_NV" [@"24:00:00 December 31, Current Year"] := GET @INDEX 9.00000000 FROM ICSAccounting;

            $ "ICS Credits.TotalICS_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 10.00000000 FROM ICSAccounting;

      END_WITH_STATEMENT;

    END
    UUID "{6a434372-0c7e-459f-babc-5eb600511d40}";;

    RULE                 "CA Accounting";
    DESCRIPTION          "DESCRIPTION: This Rule assigns the values for the California ICS.  The function &quot;ICSAccountingForCA&quot; calculates the delivery and annual values based on input<br>creation values, and assigns the appropriate slots for California ICS.  The rule also re-sets the MWD Diversion request each month to the percentage<br>that is applied each month to an average Shortage delivery pattern for a year.  The rule only fires in January or the Start timestep. TP 9/10/2014<br><br>SLOTS SET: ICS Credits.AnnualDeliveryEC_MWD; ICS Credits.AnnualDeliverySysEff_MWD; ICS Credits.AnnualDeliveryBiNat_MWD; ICS Credits.AnnualCreationEC_MWD; ICS Credits.ExtraordinaryConservationICS_MWD; ICS Credits.ExtraordinaryConservationICS_IID: ICS Credits.SystemEfficiencyICS_MWD; ICS Credits.BiNationalICS_MWD; ICS Credits.BiNationalICS_IID; ICS Credits.TotalICS_CA; ICS Credits.TotalICS_MWD; ICS Credits.TotalICS_IID; MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested; MWDDiversion:Tijuana.Depletion Requested<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND "IsMRM"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] OR ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) ) );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 9/10/2014<br><br>MC, 20180125: Made changes to newMWDDivAmount local variable and subsequent assignments based on changes USBR made in their ruleset<br>CH, 5/10/18: Added assignments for: IID EC ICS balance, IID Binat ICS balance, and total IID ICS (binat + EC) and edited total CA ICS assignment to include total MWD and total IID in order to distinguish MWD ICS creation/delivery/balance from IID ICS creation/delivery/balance ";
    BEGIN

      WITH_STATEMENT (LIST iidICSValues = "ICSAccountingForIID"(  )) DO
            WITH_STATEMENT (LIST mwdICSValues = "ICSAccountingForMWD"(  )) DO
          DESCRIPTION          "Annual Delivery BiNatational ICS  <br>";
      $ "ICS Credits.AnnualDeliveryBiNat_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM iidICSValues;

            $ "ICS Credits.AnnualDeliveryBiNat_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualDeliveryBiNat_MWD" ["Dec31ofYear"( @"t" )] + GET @INDEX 0.00000000 FROM iidICSValues;

          DESCRIPTION          "Annual Extraordinary ICS Delivery  <br>";
      $ "ICS Credits.AnnualDeliveryEC_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM iidICSValues;

            $ "ICS Credits.AnnualDeliveryEC_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualDeliveryEC_MWD" ["Dec31ofYear"( @"t" )] + GET @INDEX 1.00000000 FROM iidICSValues;

          DESCRIPTION          "Annual Delivery System Efficiency ICS <br>";
      $ "ICS Credits.AnnualDeliverySysEff_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualDeliverySysEff_MWD" ["Dec31ofYear"( @"t" )];

          DESCRIPTION          "Annual Delivery DCP ICS  <br>";
      $ "ICS Credits.AnnualDeliveryDCP_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualDeliveryDCP_MWD" ["Dec31ofYear"( @"t" )];

          DESCRIPTION          "Annual Creation Extraordinary Conservation ICS  <br>";
      $ "ICS Credits.AnnualCreationEC_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM iidICSValues;

            $ "ICS Credits.AnnualCreationEC_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM mwdICSValues;

            $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 3.00000000 FROM mwdICSValues ) + GET @INDEX 2.00000000 FROM iidICSValues;

          DESCRIPTION          "Annual Creation BiNational ICS <br>";
      $ "ICS Credits.AnnualCreationBiNat_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualCreationBiNat_IID" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationBiNat_MWD" ["Dec31ofYear"( @"t" )];

          DESCRIPTION          "Annual Creation System Efficiency ICS <br>";
      $ "ICS Credits.AnnualCreationSysEff_CA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualCreationSysEff_MWD" ["Dec31ofYear"( @"t" )];

          DESCRIPTION          "Annual Creation DCP ICS  <br>";
      $ "ICS Credits.AnnualCreationDCP_MWD" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" ["Dec31ofYear"( @"t" )] + GET @INDEX 2.00000000 FROM mwdICSValues;

            $ "ICS Credits.AnnualSimultaneousCreationDCPICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM mwdICSValues;

            $ "ICS Credits.AnnualCreationDCP_Coachella" ["Dec31ofYear"( @"t" )] := GET @INDEX 6.00000000 FROM mwdICSValues;

            $ "ICS Credits.AnnualCreationDCP_CA" ["Dec31ofYear"( @"t" )] := ( $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" ["Dec31ofYear"( @"t" )] + GET @INDEX 2.00000000 FROM mwdICSValues ) COMMENTED_BY "Coachella DCP ICS is a sub account for MWD. MWD makes full DCP contribution for state of CA .  <br>";

          DESCRIPTION          "Extraordinary Conservation ICS Balances <br>";
      $ "ICS Credits.ExtraordinaryConservationICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 8.00000000 FROM mwdICSValues;

            $ "ICS Credits.ExtraordinaryConservationICS_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM iidICSValues;

            $ "ICS Credits.ExtraordinaryConservationICS_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 8.00000000 FROM mwdICSValues ) + GET @INDEX 3.00000000 FROM iidICSValues;

          DESCRIPTION          "System Efficiency ICS Balances <br>";
      $ "ICS Credits.SystemEfficiencyICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM mwdICSValues;

            $ "ICS Credits.SystemEfficiencyICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM mwdICSValues;

          DESCRIPTION          "BiNational ICS  <br>";
      $ "ICS Credits.BiNationalICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM mwdICSValues;

            $ "ICS Credits.BiNationalICS_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM iidICSValues;

            $ "ICS Credits.BiNationalICS_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 4.00000000 FROM iidICSValues ) + GET @INDEX 1.00000000 FROM mwdICSValues;

          DESCRIPTION          "DCP ICS <br>";
      $ "ICS Credits.DCPICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM mwdICSValues;

            $ "ICS Credits.DCPICS_Coachella" ["Dec31ofYear"( @"t" )] := ( $ "ICS Credits.DCPICS_Coachella" [@"24:00:00 December Max DayOfMonth, Previous Year"] + GET @INDEX 6.00000000 FROM mwdICSValues ) - $ "ICS Credits.AnnualDeliveryDCP_Coachella" ["Dec31ofYear"( @"t" )];

            $ "ICS Credits.DCPICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM mwdICSValues;

          DESCRIPTION          "Total ICS Balances <br>";
      $ "ICS Credits.TotalICS_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 9.00000000 FROM mwdICSValues;

            $ "ICS Credits.TotalICS_IID" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM iidICSValues;

            $ "ICS Credits.TotalICS_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 9.00000000 FROM mwdICSValues ) + GET @INDEX 5.00000000 FROM iidICSValues;

            $ "ICS Credits.Bank_CA" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 10.00000000 FROM mwdICSValues ) + GET @INDEX 5.00000000 FROM iidICSValues;

          DESCRIPTION          "DCP System Water Contributions <br>";
      $ "ICS Credits.AnnualSysWaterforDCP_MWD" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM mwdICSValues;

            $ "ICS Credits.AnnualSysWaterforDCP_Coachella" ["Dec31ofYear"( @"t" )] := GET @INDEX 7.00000000 FROM mwdICSValues;

            $ "ICS Credits.AnnualSysWaterforDCP_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM mwdICSValues;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{91e7030e-d0a9-4803-abae-a6255d74df51}";;

    RULE                 "AZ Accounting";
    DESCRIPTION          "DESCRIPTION: This Rule assigns the values for the Arizona ICS.  The function &quot;ICSAccountingForAZ&quot; calculates the delivery and annual values based on input creation values, and assigns the appropriate slots for Arizona ICS. The rule only sets informative values to data object slots and not any simulation object slots, the Lower Basin Demand Variability, Surplus and Shortage Logic will reference this data in later rules.  The rule only fires in January or the Start timestep. TP 9/10/2014<br><br>SLOTS SET: ICS Credits.AnnualDeliveryEC_AZ; ICS Credits.AnnualDeliverySysEff_AZ; ICS Credits.AnnualDeliveryBiNat_AZ; ICS Credits.ExtraordinaryConservationICS_AZ; ICS Credits.SystemEfficiencyICS_AZ; ICS Credits.BiNationalICS_AZ; ICS Credits.TotalICS_AZ<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND "IsMRM"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] OR $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] OR ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) ) ) ) COMMENTED_BY "Rule executes in Run Cycle 3 at the Start Timestep or January, if the rule has not already <br>executed successfully or in run cycle 4 in the LB System condition switched from run cycle 3<br>";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 9/10/2014<br><br>AP, 9/18/2018: Added constraints to fire rule if the LB condition changed between RC 3 and RC 4";
    BEGIN

      WITH_STATEMENT (LIST azICSvalues = "ICSAccountingForAZ"(  )) DO
            $ "ICS Credits.AnnualCreationSysEff_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 0.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationEC_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 1.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationBiNat_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 2.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualDeliverySysEff_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 3.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualDeliveryEC_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 4.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualDeliveryBiNat_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 5.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualDeliveryDCP_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 6.00000000 FROM azICSvalues;

            $ "ICS Credits.ExtraordinaryConservationICS_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 7.00000000 FROM azICSvalues;

            $ "ICS Credits.ExtraordinaryConservationICS_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 8.00000000 FROM azICSvalues;

            $ "ICS Credits.ExtraordinaryConservationICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 9.00000000 FROM azICSvalues;

            $ "ICS Credits.ExtraordinaryConservationICS_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 10.00000000 FROM azICSvalues;

            $ "ICS Credits.ExtraordinaryConservationICS_WM" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 11.00000000 FROM azICSvalues;

            $ "ICS Credits.ExtraordinaryConservationICS_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 12.00000000 FROM azICSvalues;

            $ "ICS Credits.BiNationalICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 13.00000000 FROM azICSvalues;

            $ "ICS Credits.BiNationalICS_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 14.00000000 FROM azICSvalues;

            $ "ICS Credits.SystemEfficiencyICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 15.00000000 FROM azICSvalues;

            $ "ICS Credits.SystemEfficiencyICS_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 16.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualSimultaneousCreationDCPICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 17.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualSysWaterforDCP_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 18.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationDCP_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 19.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationDCP_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 20.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualSysWaterforDCP_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 21.00000000 FROM azICSvalues;

            $ "ICS Credits.DCPICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 22.00000000 FROM azICSvalues;

            $ "ICS Credits.TotalICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 23.00000000 FROM azICSvalues;

            $ "ICS Credits.DCPICS_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 24.00000000 FROM azICSvalues;

            $ "ICS Credits.Bank_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 25.00000000 FROM azICSvalues;

            $ "ICS Credits.TotalICS_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 26.00000000 FROM azICSvalues;

            $ "ICS Credits.FirmingAgreementBalance_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 27.00000000 FROM azICSvalues;

            $ "ICS Credits.FirmingAgreementBalance_US" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 28.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationEC_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 29.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationEC_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 30.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 31.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 32.00000000 FROM azICSvalues;

            $ "ICS Credits.AnnualCreationEC_WM" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 33.00000000 FROM azICSvalues;

      END_WITH_STATEMENT;

    END
    UUID "{880fdd8a-b06f-4f83-a7c8-f99bf19d486d}";;

    RULE                 "NV ICS Delivery";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND "IsMRM"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC AnnualDelivery = "ICSDeliveryReduction_DCP"( $ "ICSProjectionData.AnnualICSDelivery_NV_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"], "Nevada", "Max Delivery", "Max"( 0.00000000 "acre-ft", "Min"( $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] + ( $ "ICS Credits.MeadBankParameters" ["Nevada", "Max Capacity"] - $ "ICS Credits.Bank_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] ), $ "ICS Credits.AnnualDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) )) DO
            WITH_STATEMENT (NUMERIC TribSurplusDeliv = IF ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 )
 THEN
  $ "ICS Credits.AnnualCreationTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  )
 ELSE
  0.00000000 "acre-ft"
 ENDIF) DO
            WITH_STATEMENT (NUMERIC ImpSurplusDeliv = IF ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 )
 THEN
  $ "ICS Credits.AnnualCreationImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  )
 ELSE
  0.00000000 "acre-ft"
 ENDIF) DO
            WITH_STATEMENT (LIST DeliveryChargedList = FOR ( NUMERIC CategoryBalance IN { $ "ICS Credits.DCPICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] COMMENTED_BY "If there is an ICS deivery amount, take out of accounts in the following order.<br><br>DCP ICS (if above recovery elevation)<br>EC ICS<br>Tributary ICS <br>System Efficiency<br>BiNational <br><br>AP 11/19/19  <br>" , ( $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] + "Max"( $ "ICS Credits.AnnualRemainingDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.TributaryICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.ImportedICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"], 0.00000000 "acre-ft" ) ) COMMENTED_BY "Previous years balance less any conversion for DCP ICS. No need to take current year ICS <br>creation into account because the two are mutually exclusive. Based on SNWP ICS creation and <br>delivery logic, SNWP is either creating OR delivering EC ICS based on the demand vs basic <br>apportionment. Still need to add previous year Trib/Imported ICS creation since it will be <br>converted to EC ICS in the current year but it needs to take into account any silumtaneous <br>creation for DPC ICS<br><br>AP 11/19/19     <br>" , $ "ICS Credits.AnnualCreationTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  ) , $ "ICS Credits.SystemEfficiencyICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] , $ "ICS Credits.BiNationalICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] , $ "ICS Credits.AnnualCreationImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  ) } ) WITH LIST result = {  } DO
  WITH NUMERIC RemainingBalance = IF ( ( LENGTH result ) == 0.00000000 )
  THEN
   AnnualDelivery
  ELSE
   AnnualDelivery - "Sum"( result )
  ENDIF DO
   WITH NUMERIC DeliveryAmount = IF ( ( ( ( LENGTH result ) == 0.00000000 AND $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] < $ "DCP.RecoveryElevation" [] ) OR ( ( LENGTH result ) == 2.00000000 OR ( LENGTH result ) == 5.00000000 AND ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) ) COMMENTED_BY "If surplus, do not take any ICS out of Tributary or Imported ICS accounts because they were <br>already cleared in the logic above. <br>" ) COMMENTED_BY "Don't take DCP ICS if the Mead elevation is below the recovery elevation of 1110 <br>" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "Min"( RemainingBalance, CategoryBalance )
   ENDIF DO
    APPEND DeliveryAmount ONTO result
   ENDWITH
  ENDWITH
 ENDFOR) DO
            $ "ICS Credits.AnnualDeliveryDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 0.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 1.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( GET @INDEX 2.00000000 FROM DeliveryChargedList ) + TribSurplusDeliv;

            $ "ICS Credits.AnnualDeliverySysEff_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 3.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryBiNat_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 4.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := ( GET @INDEX 5.00000000 FROM DeliveryChargedList ) + ImpSurplusDeliv;

            $ "ICS Credits.AnnualICSDelivery_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Sum"( DeliveryChargedList ) + TribSurplusDeliv + ImpSurplusDeliv;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{060b25bf-4fd4-45e9-a045-c846eff6827e}";;

    RULE                 "CA ICS Delivery";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) AND $ "MTOMRunType.RunType" [] != 1.00000000;
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC AnnualDelivery = "ICSDeliveryReduction_DCP"( $ "ICSProjectionData.AnnualICSDelivery_MWD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"], "California", "Max Delivery", "Max"( 0.00000000 "acre-ft", "Min"( $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] + ( $ "ICS Credits.MeadBankParameters" ["California", "Max Capacity"] - $ "ICS Credits.Bank_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] ), $ "ICS Credits.AnnualDCPContribution_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) ) COMMENTED_BY "Checks desired ICS delivery amount against DCP policy restrictions <br>") DO
            WITH_STATEMENT (LIST DeliveryChargedList = FOR ( NUMERIC CategoryBalance IN { $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] COMMENTED_BY "If there is an ICS deivery amount, take out of accounts in the following order.<br><br>DCP ICS (if above recovery elevation)<br>EC ICS<br>System Efficiency<br>BiNational <br><br>AP 11/19/19  <br>" , "Min"( $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"], $ "ICS Credits.MeadBankParameters" ["California", "Max Delivery"] ) COMMENTED_BY "Previous years balance less any conversion for DCP ICS. No need to take current year ICS <br>creation into account because the two are mutually exclusive. Based on MWD ICS creation and <br>delivery logic, MWD is either creating OR delivering EC ICS based SAC WY Index.<br><br>AP 11/19/19     <br>" , $ "ICS Credits.SystemEfficiencyICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] , $ "ICS Credits.BiNationalICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] } ) WITH LIST result = {  } DO
  WITH NUMERIC RemainingBalance = IF ( ( LENGTH result ) == 0.00000000 )
  THEN
   AnnualDelivery
  ELSE
   AnnualDelivery - "Sum"( result )
  ENDIF DO
   WITH NUMERIC DeliveryAmount = IF ( ( LENGTH result ) == 0.00000000 AND "GetProjectedPoolElevation"( "Mead", @"24:00:00 December Max DayOfMonth, Previous Year" ) < $ "DCP.RecoveryElevation" [] )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "Min"( RemainingBalance, CategoryBalance )
   ENDIF DO
    APPEND DeliveryAmount ONTO result
   ENDWITH
  ENDWITH
 ENDFOR) DO
            $ "ICS Credits.AnnualDeliveryDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 0.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 1.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliverySysEff_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 2.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryBiNat_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := GET @INDEX 3.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualICSDelivery_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Sum"( DeliveryChargedList );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{eae562f8-31fd-4638-9ba6-2f6cd97320b2}";;

    RULE                 "AZ ICS Delivery";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND "IsMRM"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] AND $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] ) );
    NOTES                "";
    BEGIN

      WITH_STATEMENT (NUMERIC AnnualDelivery = "ICSDeliveryReduction_DCP"( $ "ICSProjectionData.AnnualICSDelivery_CAWCD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"], "Arizona", "Max Delivery", "Max"( 0.00000000 "acre-ft", "Min"( $ "ICS Credits.MeadBankParameters" ["Arizona", "Max Capacity"] - $ "ICS Credits.Bank_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"], $ "ICS Credits.AnnualDesiredDCPICSCreation_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) )) DO
            WITH_STATEMENT (LIST DeliveryChargedList = FOR ( NUMERIC CategoryBalance IN { $ "ICS Credits.DCPICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] , "Min"( $ "ICS Credits.ExtraordinaryConservationICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"], $ "ICS Credits.MeadBankParameters" ["Arizona", "Max Delivery"] ) , $ "ICS Credits.BiNationalICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] , $ "ICS Credits.SystemEfficiencyICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] } ) WITH LIST result = {  } DO
  WITH NUMERIC RemainingBalance = IF ( ( LENGTH result ) == 0.00000000 )
  THEN
   AnnualDelivery
  ELSE
   AnnualDelivery - "Sum"( result )
  ENDIF DO
   WITH NUMERIC DeliveryAmount = IF ( ( ( LENGTH result ) == 0.00000000 AND "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) < $ "DCP.RecoveryElevation" [] ) COMMENTED_BY "Don't take DCP ICS if the Mead elevation is below the recovery elevation of 1110 <br>" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "Min"( RemainingBalance, CategoryBalance )
   ENDIF DO
    APPEND DeliveryAmount ONTO result
   ENDWITH
  ENDWITH
 ENDFOR) DO
            $ "ICS Credits.AnnualDeliveryDCP_CAWCD" [@"24:00:00 December 31, Current Year"] := GET @INDEX 0.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December 31, Current Year"] := GET @INDEX 1.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliveryBiNat_CAWCD" [@"24:00:00 December 31, Current Year"] := GET @INDEX 2.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualDeliverySysEff_CAWCD" [@"24:00:00 December 31, Current Year"] := GET @INDEX 3.00000000 FROM DeliveryChargedList;

            $ "ICS Credits.AnnualICSDelivery_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Sum"( DeliveryChargedList );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{ccb68901-761d-4298-aba0-749bec3b23f9}";;

    RULE                 "Nevada Banking";
    DESCRIPTION          "DESCRIPTION: This rule assigns the Banked Storage from NV in CA and AZ for each year.  As of implementation Unbanked water from CA and AZ is 0 af and will continue to be for the foreseable future.  The values of 0 acre-feet are input on those slots.  If logic is used to solve for those, then logic will have to go into this rule where appropriate. This rule only sets data objects and that data is used in subsequent rules in the Shortage, Surplus and LBDV logic. TP 7.28.2015<br><br>SLOTS SET: ICS Credits.AnnualNevadaUnused, ICS Credits.CumulativeNVBankedinCA, ICS Credits.CumulativeNVBankedinAZ, ICS Credits.AnnualNVBankedinCA, ICS Credits.AnnualNVBankedinAZ, ICS Credits.AnnualNVRecoverableCA, ICS Credits.AnnualNVRecoverableAZ, ICS Credits.AnnualNVUnBankedFromCA, ICS Credits.AnnualNVUnbankedFromAZ<br><br><br><br>";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND "IsMRM"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015<br><br>AP, 9/18/2018: Added constraints to fire rule if the LB condition changed between RC 3 and RC 4";
    BEGIN

      WITH_STATEMENT (NUMERIC unusedNV = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  ( 300000.00000000 "acre-ft" - $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )] + IF ( "MeadPumpingDemandVariabilityFactor"( @"t" ) == 0.95000000 )
  THEN
   ( "SumAnnualSNWADivRequest"(  ) * 0.05000000 ) COMMENTED_BY "Side inflows are high"
  ELSE
   IF ( "MeadPumpingDemandVariabilityFactor"( @"t" ) == 1.05000000 )
   THEN
    ( "SumAnnualSNWADivRequest"(  ) * - 0.05000000 ) COMMENTED_BY "Side Inflows are low"
   ELSE
    0.00000000 "acre-ft" COMMENTED_BY "Normal Side inflows above Hoover"
   ENDIF
  ENDIF COMMENTED_BY "With Regard to Lower Basin Demand Variability, if the side inflows above Hoover are high, <br>then the SNWA diversion is reduced and the available unused Nevada water is increased <br>by 5% of the SNWA diversion. If the side inflows are low, then the SNWA diversion is <br>increased by 5% and the amount of unused Nevada water is decreased by that amount. <br>In a normal year, do not apply any change. TP 7/30/2015" ) COMMENTED_BY "MC, 20170512: Add in a Max&lcub; ..., 0 acre-ft&rcub; here to ensure unused never negative?"
 ENDIF) DO
          DESCRIPTION          "Right now, all unused NV water is going to CA Banking, more logic will  have to go in the following With statements <br>to get that figured out. ";
      WITH_STATEMENT (NUMERIC nvBankedCA = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  unusedNV - $ "ICSProjectionData.NV_LeftinMead" ["Dec31ofYear"( @"t" )]
 ENDIF) DO
            WITH_STATEMENT (NUMERIC nvBankedAZ = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  0.00000000 "acre-ft"
 ENDIF) DO
          DESCRIPTION          "Nevada is permitted to recover up to 40,000 AF from AZ and 30,000 AF from CA annually, added based on <br>an email, April 27, 2015 subject &quot;Re: MTOM Action Items&quot; from Shana Tighi to Tony Powell";
      WITH_STATEMENT (NUMERIC annNVRecoverableAZ = "Min"( 40000.00000000 "acre-ft", $ "ICS Credits.CumulativeNVBankedinAZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] )) DO
            WITH_STATEMENT (NUMERIC annNVRecoverableCA = "Min"( 30000.00000000 "acre-ft", $ "ICS Credits.CumulativeNVBankedinCA" [@"24:00:00 December Max DayOfMonth, Previous Year"] )) DO
          DESCRIPTION          "When the NV unbanked to CA logic needs to be improved, the next two With statements is <br>where that should happen. Currently, the values for unbanked to CA and AZ will be 0 acre-feet.  <br>When logic is generated it needs to be limited to the Recoverable water available to NV. ";
      WITH_STATEMENT (NUMERIC nvUnbankedCA = "Min"( 0.00000000 "acre-ft", annNVRecoverableCA )) DO
            WITH_STATEMENT (NUMERIC nvUnbankedAZ = "Min"( 0.00000000 "acre-ft", annNVRecoverableAZ )) DO
          DESCRIPTION          "Annual Nevada Water not Used";
      $ "ICS Credits.AnnualNevadaUnused" ["Dec31ofYear"( @"t" )] := unusedNV;

            $ "ICS Credits.CumulativeNVBankedinCA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.CumulativeNVBankedinCA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + nvBankedCA * 0.66666600 - nvUnbankedCA;

            $ "ICS Credits.CumulativeNVBankedinAZ" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.CumulativeNVBankedinAZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] + nvBankedAZ - nvUnbankedAZ;

            $ "ICS Credits.AnnualNVBankedinCA" ["Dec31ofYear"( @"t" )] := nvBankedCA;

            $ "ICS Credits.AnnualNVBankedinAZ" ["Dec31ofYear"( @"t" )] := nvBankedAZ;

            $ "ICS Credits.AnnualNVRecoverableCA" ["Dec31ofYear"( @"t" )] := annNVRecoverableCA;

            $ "ICS Credits.AnnualNVRecoverableAZ" ["Dec31ofYear"( @"t" )] := annNVRecoverableAZ;

            $ "ICS Credits.AnnualNVUnBankedFromCA" ["Dec31ofYear"( @"t" )] := nvUnbankedCA;

            $ "ICS Credits.AnnualNVUnbankedFromAZ" ["Dec31ofYear"( @"t" )] := nvUnbankedAZ;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{3caeca45-d10b-4123-98f1-f4aff264ea4b}";;

  END
  UUID "{3f523123-2536-4487-a732-9f06f03e16f6}";;

  POLICY_GROUP   "Lower Basin Demand Variability/ICS Creation and Delivery";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "SNWP ICS Creation and Delivery";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] OR ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) ) ) AND $ "MTOMRunType.RunType" [] != 1.00000000;
    NOTES                "";
    BEGIN

    DESCRIPTION          "This rule determines Nevada ICS creation or delivery based on the annual apportionment <br>";
      WITH_STATEMENT (NUMERIC ICS = $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] - IF ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000 )
 THEN
  $ "Shortage.State Shortage Volumes" [( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) - 1.00000000, "Nevada"]
 ELSE
  0.00000000 "acre-ft"
 ENDIF - IF ( "GetRunCycleIndex"(  ) == 3.00000000 )
 THEN
  ( "SumFlowsToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested", @"t", @"24:00:00 December Max DayOfMonth, Current Year" ) + "GetDiversionToDate"( $ "Nevada_CU_Actual.SNWP" ) )
 ELSE
  $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] * "MeadPumpingDemandVariabilityFactor"( @"24:00:00 December Max DayOfMonth, Current Year" )
 ENDIF) DO
            $ "ICSProjectionData.AnnualICSDelivery_NV_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] := "MinItem"( { IF ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 )
 THEN
  "Max"( "Abs"( "Min"( ICS, 0.00000000 "acre-ft" ) ) - $ "Surplus Volume Entitlements.SNWA Domestic" ["Dec31ofYear"( @"t" )], 0.00000000 "acre-ft" ) COMMENTED_BY "If the year has domestic surplus, reduce ICS delivery by the amount of surplus entitlement for <br>SNWP<br>"
 ELSE
  "Abs"( "Min"( ICS, 0.00000000 "acre-ft" ) ) COMMENTED_BY "No surplus <br>"
 ENDIF , $ "ICS Credits.MeadBankParameters" ["Nevada", "Max Delivery"] COMMENTED_BY "Max possible delivery <br>" , IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) > $ "DCP.RecoveryElevation" [] )
 THEN
  $ "ICS Credits.TotalICS_NV" [@"24:00:00 December 31, Previous Year"]
 ELSE
  $ "ICS Credits.TotalICS_NV" [@"24:00:00 December 31, Previous Year"] - $ "ICS Credits.DCPICS_NV" [@"24:00:00 December 31, Previous Year"]
 ENDIF COMMENTED_BY "Total available ICS to take in delivery scenario <br>" } );

            $ "ICSProjectionData.AnnualCreationEC_SNWP_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] := IF ( ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "MinItem"( { "Max"( ICS, 0.00000000 "acre-ft" ) , $ "ICS Credits.MeadBankParameters" ["Nevada", "Max Creation"] , "Max"( ( ( $ "ICS Credits.MeadBankParameters" ["Nevada", "Max Capacity"] - $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) - ( $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.DCPICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.BiNationalICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.TributaryICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.ImportedICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) / "SystemTaxAdjustment_DCP"(  ) + $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"], 0.00000000 "acre-ft" ) COMMENTED_BY "Max EC ICS creation based on bank availability. ICS is not taxed if it is paid back from the <br>previous year's delivery. Max bank capacity less any delivery from previous year,  minus the <br>bank + any trib/imported ICS being converted to EC ICS + annual creation biNat (input slot) = <br>the available ICS creation that can be taxed. EC delivery amount added back in post tax <br>adjustment since any volume equal to the delivery wont be taxed.<br>" } )
 ENDIF;

      END_WITH_STATEMENT;

    END
    UUID "{5d5e351e-06c4-4fc7-995b-88253e582c4a}";;

    RULE                 "Reset Monthly Forecast SNWP LC Demand Variability";
    DESCRIPTION          "DESCRIPTION: This rule will reset the SNWP diversion request for Lower Basin Demand Variability outside of Surplus or Shortage.  If the local inflows above Hoover Dam are greater than the 90% historic local inflow volume then the pumping is reduced by 5%.  In the case that the local inflows are less than the 10% exceedence historic local inflow volume then the pumping is increased by 5%. The factor is applied to the monthly pumping requests and set by this rule. This rule also sets the data slot to show if LBDV was set for the Above Hoover local inflows in the AbvHooverTriggerSet slot. TP 7/27/2015<br><br>SLOTS SET: PumpingFromLakeMead:SNWP.Diversion Requested; PumpingFromLakeMead:SNWP.Depletion Requested; LowerBasinDemandVariability.AbvHooverTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) AND $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] == 0.00000000 AND "IsMRM"(  ) AND $ "MTOMRunType.RunType" [] != 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 7/27/2015<br><br>SB 06/20/2018: Added execution constraint to simulate only in operational MTOM runs. <br>SB 07/08/2019: Updated constraints to have Run Type not equal to 1 (allows for no dependence on BHOPS during development testing). ";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (SLOT slot IN { $ "PumpingFromLakeMead:SNWP.Diversion Requested" , $ "PumpingFromLakeMead:SNWP.Depletion Requested" }) DO
            slot [date] := $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] * "MeadPumpingDemandVariabilityFactor"( date );

      ENDFOREACH;

            $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := IF ( "MeadPumpingDemandVariabilityFactor"( date ) == 1.00000000 )
 THEN
  0.00000000
 ELSE
  IF ( "MeadPumpingDemandVariabilityFactor"( date ) == 0.95000000 )
  THEN
   1.00000000
  ELSE
   - 1.00000000
  ENDIF
 ENDIF;

      ENDFOREACH;

    END
    UUID "{a37cf253-5fbe-4866-b617-27f9e52d0419}";;

    RULE                 "MWD ICS Creation and Delivery";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND "IsMRM"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] OR ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) ) );
    NOTES                "";
    BEGIN

      IF_STATEMENT (@"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" OR NOT "IsMRM"(  )) THEN
            $ "ICSProjectionData.AnnualCreationEC_MWD_Preliminary" ["Dec31ofYear"( @"t" )] := $ "ICSProjectionData.AnnualCreationEC_MWD_Default" ["Dec31ofYear"( @"t" )];

            $ "ICSProjectionData.AnnualICSDelivery_MWD_Preliminary" ["Dec31ofYear"( @"t" )] := $ "ICSProjectionData.AnnualDeliveryBiNat_MWD_Default" ["Dec31ofYear"( @"t" )] + $ "ICSProjectionData.AnnualDeliverySysEff_MWD_Default" ["Dec31ofYear"( @"t" )] + $ "ICSProjectionData.AnnualDeliveryEC_MWD_Default" ["Dec31ofYear"( @"t" )];

      ELSE
            $ "ICSProjectionData.AnnualICSDelivery_MWD_Preliminary" ["Dec31ofYear"( @"t" )] := "MinItem"( { IF ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) COMMENTED_BY "If the year has domestic surplus, reduce the ICS Delivery by the amount of <br>Domestic surplus entitlement for MWD. TP 12/18/2017 <br>" )
 THEN
  "Max"( ( $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] - $ "Surplus Volume Entitlements.MWD Domestic" ["Dec31ofYear"( @"t" )] ), 0.00000000 "acre-ft" )
 ELSE
  $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] COMMENTED_BY "Not Surplus or Shortage <br>"
 ENDIF , ( $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - "SumFlowsToVolume"( $ "MWDDiversion:MWD.Depletion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) ) COMMENTED_BY "MWD at full ditch (Conveyance Capacity)<br>" , "Min"( $ "ICS Credits.MeadBankParameters" ["California", "Max Delivery"] - ( $ "ICSProjectionData.AnnualDeliveryBiNat_IID_Default" [@"24:00:00 December 31, Current Year"] + $ "ICSProjectionData.AnnualDeliveryEC_IID_Default" [@"24:00:00 December 31, Current Year"] ), IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) > $ "DCP.RecoveryElevation" [] )
 THEN
  $ "ICS Credits.TotalICS_MWD" [@"24:00:00 December 31, Previous Year"]
 ELSE
  $ "ICS Credits.TotalICS_MWD" [@"24:00:00 December 31, Previous Year"] - $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December 31, Previous Year"]
 ENDIF COMMENTED_BY "Make sure the amount of Delivery taken is within the MWD ICS bank or below the Maximum Take <br>that MWD can have. TP 12/18/2017<br><br>Adjusted this to get rid of current year EC ICS creation sicne the two are mutually exclusive <br>(either create or deliver, not both). Max avaiable ICS now limited based on recovery elevation <br>for DCP AP 11/19/19  <br>" ) COMMENTED_BY "Available ICS Water <br>" } );

            $ "ICSProjectionData.AnnualCreationEC_MWD_Preliminary" ["Dec31ofYear"( @"t" )] := IF ( ( ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR NaNToZero ( $ "FloodControlOutput.Flood Control Flag" [] ) > 0.00000000 OR NaNToZero ( $ "FloodControlOutput.Exclusive Space Flag" [] ) > 0.00000000 ) COMMENTED_BY "If a Quantified Surplus Year, a Flood Control Year, or if the run is a deterministic Min, Max or <br>Most run, do not Create any ICS TP 12/18/2017, updated for DCP AP 10/21/19<br>" )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "MinItem"( { $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Put Step 1"] COMMENTED_BY "Annual Max <br>" , "Max"( ( ( ( ( $ "ICS Credits.MeadBankParameters" ["MWD", "Max Capacity"] - $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) - ( $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December 31, Previous Year"] + ( $ "ICS Credits.BiNationalICS_MWD" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_MWD" [@"24:00:00 December 31, Current Year"] ) + $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December 31, Previous Year"] ) ) / "SystemTaxAdjustment_DCP"(  ) ) COMMENTED_BY "Taxable ICS creation space <br>" + $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] COMMENTED_BY "Non Taxable ICS creation space. If EC delivery is paid back the following year, creation amount <br>equal to said delivery is not taxed   <br>" ), 0.00000000 "acre-ft" ) COMMENTED_BY "Bank space <br>" , ( $ "ICS Credits.MeadBankParameters" ["California", "Max Creation"] - $ "ICSProjectionData.AnnualCreationEC_IID_Default" [@"24:00:00 December 31, Current Year"] ) COMMENTED_BY "Maximum Creation of MWD ICS <br>" , "Max"( "SumFlowsToVolume"( $ "MWDDiversion:MWD.Diversion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) - $ "AnnualWaterUse.MWDMinimumAnnualDelivery" [], 0.00000000 "acre-ft" ) COMMENTED_BY "Difference between Diversion Requests and Minimum Required MWD Delivery <br>" } )
 ENDIF;

      END_IF_STATEMENT;

    END
    UUID "{c16ff88f-1baa-46a3-9410-6ba82373f4a6}";;

    RULE                 "AZ Annual ICS Delivery";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND "IsMRM"(  ) AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] OR ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) OR $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] ) );
    NOTES                "";
    BEGIN

      IF_STATEMENT (@"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" OR NOT "IsMRM"(  )) THEN
            $ "ICSProjectionData.AnnualICSDelivery_CAWCD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "ICSProjectionData.AnnualICSDelivery_CAWCD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"];

      ELSE
          DESCRIPTION          "This rule was based on the MWD delivery logic. AP 11/14/19 <br>";
      WITH_STATEMENT (NUMERIC AnnualICSDelivery = $ "ICSProjectionData.AnnualICSDelivery_CAWCD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"] + "CAWCD Mitigation Water"(  ) + "CAWCD DCP ICS Delivery"(  ) + "CAWCD Post 2026 ICS Delivery"(  )) DO
            WITH_STATEMENT (NUMERIC NonCAPICSDelivery = $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_WM" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            $ "ICSProjectionData.AnnualICSDelivery_CAWCD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] := "MinItem"( { IF ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) COMMENTED_BY "If the year has domestic surplus, reduce the ICS Delivery by the amount of Domestic surplus <br>entitlement for CAP <br>" )
 THEN
  "Max"( ( AnnualICSDelivery - $ "Surplus Volume Entitlements.CAP Domestic" ["Dec31ofYear"( @"t" )] ), 0.00000000 "acre-ft" )
 ELSE
  AnnualICSDelivery COMMENTED_BY "Not Surplus or Shortage <br>"
 ENDIF , "CAWCD Available Canal Space"(  ) COMMENTED_BY "CAP at full ditch (Conveyance Capacity)<br>" , "Min"( $ "ICS Credits.MeadBankParameters" ["Arizona", "Max Delivery"] - NonCAPICSDelivery, IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) > $ "DCP.RecoveryElevation" [] )
 THEN
  $ "ICS Credits.TotalICS_CAWCD" [@"24:00:00 December 31, Previous Year"]
 ELSE
  $ "ICS Credits.TotalICS_CAWCD" [@"24:00:00 December 31, Previous Year"] - $ "ICS Credits.DCPICS_CAWCD" [@"24:00:00 December 31, Previous Year"]
 ENDIF COMMENTED_BY "EC ICS creation and delivery are mutually exclusive (either create or deliver, not both). Max <br>avaiable ICS now limited based on recovery elevation for DCP AP 11/19/19  <br>" ) COMMENTED_BY "Available ICS Water <br>" } );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{ff4606ef-0ef2-43e0-bcdf-caaa1f19fbc4}";;

    RULE                 "Reset Monthly Forecast CAP LC Demand Variability";
    DESCRIPTION          "DESCRIPTION: This rule resets the CAP Diversion request based on a demand variability factor.  The Function CAPDemandVariabilityFactor will return a scale value that will either decrease the CAP Diversion Request in Non Shortage or Surplus years to 90% of the original diversion schedule if local inflows to the system below Parker Dam are greater than the 90% exceedence of historic local inflows.  If the local inflows are below the 10% exceedence of the historic local inflows, then the diversion requested can be increased in an amount equal to the difference in the State Apportionment for the year and the volume of Senior Prority user diversion requests.  This value is added to any ICS delivery if Lake Mead is above 1,100 Ft.  The sum of the remaining state apportionment and the ICS Delivery is what CAP is allowed to divert.  TP 7/27/2015<br><br>SLOTS SET: CAPDiversion.Total Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] OR $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] ) ) AND $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] == 0.00000000 AND "IsMRM"(  ) AND $ "MTOMRunType.RunType" [] != 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 7/27/2015<br><br>S.Baker 06/20/2018: Added execution constraint to simulate only in operational MTOM runs. <br>AP, 9/18/2018: Added  run constraint to refire rule of the schedule check value set in run cycle 3 does not equal the LB condition in RC 4. Adjusted constraint logic to fire when LB condition is normal instead of condition not equaling surplus, shortage, etc. Cleaned up rule logic, added to note in rule<br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). <br>SB 07/08/2019: Updated constraints to have Run Type not equal to 1 (allows for no dependence on BHOPS during development testing). ";
    BEGIN

    DESCRIPTION          "Sets CAP Diversion requested slot based on demand variability. Adds in firming agreement water <br>(if neccessary, year> 2026). If the lower basin is under DCP and a contribution is needed by the <br>state of AZ, there is no demand variabilty and the demand variability factor is set to 1.    <br>";
      WITH_STATEMENT (LIST AZFirming = "AZ Firming Agreement"(  )) DO
            FOREACH (DATETIME date IN "DateMax"( "GetFirstDate"( @"t" ), @"Start Timestep" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := $ "CAPDiversion.Total Diversion Requested" [date] * "CAPDemandVariabilityFactor"( date ) + "VolumeToFlow"( GET @INDEX 0.00000000 FROM AZFirming, @"t" ) * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"];

          INACTIVE      $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( date )] := IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker90"] )
 THEN
  1.00000000
 ELSE
  IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker10"] )
  THEN
   - 1.00000000
  ELSE
   0.00000000
  ENDIF
 ENDIF;

      ENDFOREACH;

      END_WITH_STATEMENT;

    END
    UUID "{0e324d32-831e-422c-b1f8-647a99859240}";;

    RULE                 "LB_ScheduleReset";
    DESCRIPTION          "9/18/2018, AP: This rule resets lower basin water user diversion when the lower basin condition switches between run cycles 3 and 4 (from either shortage/surplus to normal operating condition). ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] != $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) AND "IsMRM"(  ) AND $ "MTOMRunType.RunType" [] != 1.00000000 AND $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] == 0.00000000;
    NOTES                "9/18/2018, AP: The rule needs to be cleaned up at a later date when all CU_schedules slots have the same name as the diversion requested slots.<br>SB 07/08/2019: Updated constraints to have Run Type not equal to 1 (allows for no dependence on BHOPS during development testing). ";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
          DESCRIPTION          "For statement resets LB_SchedCheck (non JP user and mexico) subbasin when LB condition <br>switches between run cycles   <br>";
      FOREACH (OBJECT user IN "ListSubbasin"( "LB_SchedCheck" )) DO
          DESCRIPTION          "Resets LB_SchedCheck subbasin members when LB condition switches from shortage(1) to normal <br>(0) condtions between RC3 and RC4    <br>";
      IF_STATEMENT ($ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] == 1.00000000) THEN
            IF_STATEMENT (user == % "GilaAndYumaUsers:GilaMonsterFarms") THEN
            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.Gila Monster Farms" [date], date );

      ELSE
            user & "Diversion Requested" [date] := "VolumeToFlow"( % "Arizona_CU_Schedules" & "GetElementName"( user ) [date], date );

      END_IF_STATEMENT
      ELSEIF_COND ( user == % "AzPkrToImp:Parker" )
      ELSEIF_CLAUSE
            $ "AzPkrToImp:Parker.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.City of Parker" [date], date );
      END_ELSEIF
      ELSEIF_COND ( user == % "GilaAndYumaUsers:CocopahIndRes" )
      ELSEIF_CLAUSE
            $ "GilaAndYumaUsers:CocopahIndRes.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.Cocopah Indian Res" [date], date );
      END_ELSEIF;

      END_IF_STATEMENT;

          DESCRIPTION          "Resets Users in LB_SchedCheck subbasin with surplus entitlement if there is a switch between <br>RC3 and RC4<br>";
      IF_STATEMENT ($ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] == 2.00000000) THEN
            IF_STATEMENT (user == % "GilaAndYumaUsers:GilaMonsterFarms") THEN
            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.Gila Monster Farms" [date], date );

      END_IF_STATEMENT;

            IF_STATEMENT (user == % "OthersBlwImp:AzPumpersBlwImp") THEN
            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersBlwImp" [date], date );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

          DESCRIPTION          "Resets MWD diversion and depletion in model when switching from suplus to normal condition<br>";
      IF_STATEMENT ($ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] == 2.00000000) THEN
            WITH_STATEMENT (NUMERIC mwdDepletionAmount = "MWD_Outyear_Schedules"( date )) DO
            $ "MWDDiversion:MWD.Depletion Requested" [date] := mwdDepletionAmount;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := mwdDepletionAmount + "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

          DESCRIPTION          "This resets SNWP, CAP, and Mexico if the lower basin operating condition switches for shortage <br>or surplus to normal operating cindtions between run cycles    <br>";
      FOREACH (SLOT slot IN { $ "PumpingFromLakeMead:SNWP.Diversion Requested" , $ "PumpingFromLakeMead:SNWP.Depletion Requested" , $ "CAPDiversion.Total Diversion Requested" , $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" }) DO
            slot [date] := IF ( slot == $ "CAPDiversion.Total Diversion Requested" )
 THEN
  "CAP_Outyear_Schedules"( date )
 ELSE
  "SNWP_Schedules"( date )
 ENDIF
 ELSEIF_COND ( slot == $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" )
 ELSEIF_CLAUSE ( "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date], date ) )
 END_ELSEIF;

      ENDFOREACH;

      ENDFOREACH;

    END
    UUID "{cfa6afbc-e22d-4a75-8570-036ac0c0da10}";;

  END
  UUID "{7d23b72b-fd8b-40be-8e47-056a0c6b9de8}";;

  POLICY_GROUP   "LB Surplus";
  DESCRIPTION    "This policy group contains the rules required to simulate Lower Basin Surplus operations. Lower Basin Surplus operations are based on the 2007 Interim Guidelines as well as IBWC Minute 323. Surplus volume entitlements are based on contracts between Reclamation and the various water users, as well as the 2007 Interim Guidelines and Minute 323.";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Quantified Surplus Schedules Data Volume to Simulation Flow";
    DESCRIPTION          "DESCRIPTION: This rule converts volumes allowed under Quantified Surplus into monthly flow rates and sets associated slots. Surplus flags and LBDV.AbvHooverTriggerSet flag are also set in this rule.<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Quantified Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet; PumpingFromLakeMead:SNWP.Diversion Requested; MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested; GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested; OthersBlwImp:AzPumpersBlwImp.Diversion Requested; CAPDiversion.Total Diversion Requested; AAC.Coachella.Diversion Requested; AAC:IID.Diversion Requested; AzPkrToImp:CibolaValleyIID.Diversion Requested; AzPkrToImp:Parker.Diversion Requested<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND @"t" == @"24:00:00 January 31, Current Year" AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170706: Moved the setting of Surplus.Surplus Flag and Surplus.Quantified Surplus Flag slots to new rule Set Quantified Surplus Flag; removed IsNaN Surplus.Surplus Flag[] execution constraint from this rule";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
          INACTIVE      $ "Surplus.Surplus Flag" [date] := 2.00000000;

          INACTIVE      $ "Surplus.Quantified Surplus Flag" [date] := 1.00000000;

          INACTIVE      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

          INACTIVE      $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

            $ "PumpingFromLakeMead:SNWP.Depletion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "MWD" ), date );

            $ "MWDDiversion:MWD.Depletion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "MWD" ), date ) - "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "Coachella" ), date );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "IID" ), date );

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "AzPumpersBlwImp" ), date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "Gila Monster Farms" ), date );

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "CibolaValleyIID" ), date );

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "City of Parker" ), date );

            $ "CAPDiversion.Total Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "CAP" ), date );

      ENDFOREACH;

    END
    UUID "{9892870c-49e3-4be0-a878-a66a6b9c2981}";;

    RULE                 "Domestic Surplus Schedules Data Volume to Simulation Flow";
    DESCRIPTION          "DESCRIPTION: This rule converts volumes allowed under Domestic Surplus into monthly flow rates and sets associated slots. Surplus flags and LBDV.AbvHooverTriggerSet flag are also set in this rule.<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Domestic Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet; PumpingFromLakeMead:SNWP.Diversion Requested; MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested; GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested; OthersBlwImp:AzPumpersBlwImp.Diversion Requested; CAPDiversion.Total Diversion Requested<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Surplus.Domestic Surplus Trigger Elevation" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170706: Moved the setting of Surplus.Surplus Flag and Surplus.Domestic Surplus Flag slots to new rule Set Domestic Surplus Flag; removed IsNaN Surplus.Surplus Flag[] execution constraint from this rule<br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). ";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
          INACTIVE      $ "Surplus.Surplus Flag" [date] := 1.00000000;

          INACTIVE      $ "Surplus.Domestic Surplus Flag" [date] := 1.00000000;

          INACTIVE      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

          INACTIVE      $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

            $ "PumpingFromLakeMead:SNWP.Depletion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "MWD" ), date );

            $ "MWDDiversion:MWD.Depletion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "MWD" ), date ) - "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "Gila Monster Farms" ), date );

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "AzPumpersBlwImp" ), date );

            $ "CAPDiversion.Total Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] > "SumAnnualCAPDivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "CAP" ), date )
 ENDIF;

      ENDFOREACH;

    END
    UUID "{31928722-6d2a-45c1-8fa7-5172286d140a}";;

    RULE                 "Set Flood Control Surplus Schedules";
    DESCRIPTION          "DESCRIPTION: If a the Flood Control or Exclusive Space Flag is on (greater than 0) this rule will fire and set the Surplus Schedules for all water users impacted by Flood Control Surplus. The computed schedules are the Total Annual Schedules for each water user, meaning Normal and Surplus schedules.  Flood Control Surplus is in priority over Quantified Surplus Volumes. -HMG 8/2/11<br><br>SLOTS SET: Surplus Total Annual Schedules.AzPumpersBlwImp; Surplus Total Annual Schedules.CAP; Surplus Total Annual Schedules.CibolaValleyIID; Surplus Total Annual Schedules.City of Parker; Surplus Total Annual Schedules.Gila Monster Farms; Surplus Total Annual Schedules.SNWA; Surplus Total Annual Schedules.MWD; Surplus Total Annual Schedules.Coachella; Surplus Total Annual Schedules.IID; Surplus Total Annual Schedules.Needles; Surplus Total Annual Schedules.CaPumpersAbvImp; Surplus Total Annual Schedules.Mexico<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/2011<br>S.Baker 06/20/2018: Added constraint to only allow historical water use in surplus by CAP prior to 2008.<br><br>GCAA, 10302018: Replaced hardcoded values for MWDCanal_AnnualCapacity and Mexico Flood Control Delivery.  Corrected references to Forecast1 slots for CAP and SNWP to the Reset slots";
    BEGIN

      $ "Surplus Total Annual Schedules.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"];

    DESCRIPTION          "Testbed Hindcast Simulation - Allow CAP to only take water up to capacity prior to 2008  <br>";
      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) > 2008.00000000 )
 THEN
  $ "AnnualWaterUse.CAPCanal_AnnualCapacity" []
 ELSE
  $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"]
 ENDIF;

      $ "Surplus Total Annual Schedules.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CibolaValleyIID" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.City of Parker" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.City of Parker" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.City of Parker" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] := $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.SNWA Quantified and FC" [@"24:00:00 December 31, Current Year"] + ( ( $ "ICS Credits.AnnualCreationImp_NV" [@"24:00:00 December 31, Current Year"] + $ "ICS Credits.AnnualCreationTrib_NV" [@"24:00:00 December 31, Current Year"] ) * "SystemTaxAdjustment_DCP"(  ) ) COMMENTED_BY "Annual Delivery of ICS from Nevada of Imported and Tributary ICS Water";

      $ "Surplus Total Annual Schedules.MWD" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [];

      $ "Surplus Total Annual Schedules.Coachella" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.Coachella" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 0.00000000] + 100000.00000000 "acre-ft";

      $ "Surplus Total Annual Schedules.IID" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.IID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 1.00000000];

      $ "Surplus Total Annual Schedules.Needles" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.Needles" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Needles" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CaPumpersAbvImp" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.CaPumpersAbvImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CaPumpersAbvImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Mexico" [@"24:00:00 December 31, Current Year"] := $ "Mexico Shortage and Surplus.Mexico Flood Control Delivery" [];

    END
    UUID "{9d2289ac-3985-4175-a06c-3adeab09ca45}";;

    RULE                 "Set Quantified Surplus Schedules";
    DESCRIPTION          "DESCRIPTION: If there is a positive Quantified Surplus Volume this rule will fire and set the Total Annual Schedules for all water Users Impacted by Quantified Surplus. The Total Annual Schedules include both the Normal and Surplus Schedules. Rule fires only once per year during January. Quantified Surplus is higher in priority than Domestic Surplus, but lower in priority than Flood Control Surplus. Therefore, this rule will override any Domestic Surplus Schedules, but may then be overriden by Flood Control Surplus Schedules if a Flood Control Surplus exists. -HMG 8/2/11<br><br>SLOTS SET: Surplus Total Annual Schedules.MWD; Surplus Total Annual Schedules.Coachella; Surplus Total Annual Schedules.IID; Surplus Total Annual Schedules.AzPumpersBlwImp; Surplus Total Annual Schedules.Gila Monster Farms; Surplus Total Annual Schedules.City of Parker; Surplus Total Annual Schedules.CibolaValleyIID; Surplus Total Annual Schedules.CAP; Surplus Total Annual Schedules.SNWA<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/11<br><br>GCAA, 20181030: Corrected reference to the Forecast1 SNWP slot to the SNWPResetAnnualFC slot.  Removed &quot;- Minute 323&quot; from rule name.";
    BEGIN

      $ "Surplus Total Annual Schedules.MWD" [@"24:00:00 December 31, Current Year"] := $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Coachella" [@"24:00:00 December 31, Current Year"] := IF ( $ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"] )
 THEN
  $ "California_CU_Forecast1.Coachella" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 0.00000000]
 ELSE
  $ "California_CU_Forecast1.Coachella" [@"24:00:00 December 31, Current Year"]
 ENDIF;

      $ "Surplus Total Annual Schedules.IID" [@"24:00:00 December 31, Current Year"] := IF ( $ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"] )
 THEN
  $ "California_CU_Forecast1.IID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 1.00000000]
 ELSE
  $ "California_CU_Forecast1.IID" [@"24:00:00 December 31, Current Year"]
 ENDIF;

      $ "Surplus Total Annual Schedules.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.City of Parker" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.City of Parker" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.City of Parker" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CibolaValleyIID" [@"24:00:00 December 31, Current Year"];

    INACTIVE      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := 1835000.00000000 "acre-ft" COMMENTED_BY "<assumes CAP will take a full ditch even lacking full surplus volume for interstate banking. Surplus Volume Entitlement contains actual CAP quantified surplus volume>";

      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := ( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CAP Quantified" [@"24:00:00 December 31, Current Year"] + $ "ICS Credits.AnnualDeliverySysEff_AZ" [@"24:00:00 December 31, Current Year"] ) COMMENTED_BY "CAP Diversion Request plus Quantified CAP entitlement plus ICS Available";

      $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] := $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.SNWA Quantified and FC" [@"24:00:00 December 31, Current Year"] + ( ( $ "ICS Credits.AnnualCreationImp_NV" [@"24:00:00 December 31, Current Year"] + $ "ICS Credits.AnnualCreationTrib_NV" [@"24:00:00 December 31, Current Year"] ) * "SystemTaxAdjustment_DCP"(  ) ) COMMENTED_BY "Annual Delivery of ICS from Nevada of Imported and Tributary ICS Water";

    END
    UUID "{e12f7e26-7b0d-4a0b-8ca3-55b0125684cf}";;

    RULE                 "Set Domestic Surplus Schedules";
    DESCRIPTION          "DESCRIPTION: If a Domestic Surplus exists, meaning that Mead's Pool Elevation is greater than the Domestic Surplus Trigger, then this rule will fire in January of the Current Year and set the Total Annual Schedules for all water users impacted by Domestic Surplus. Domestic Surplus is the lowest priority surplus, meaning that a Quantified or Flood Control Surplus will override these values.  -HMG 8/2/11<br><br>SLOTS SET: Surplus Total Annual Schedules.SNWA; Surplus Total Annual Schedules.MWD; Surplus Total Annual Schedules.Gila Monster Farms; Surplus Total Annual Schedules.AzPumpersBlwImp; Surplus Total Annual Schedules.CAP<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Surplus.Domestic Surplus Trigger Elevation" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170512: No execution constraint that forces execution in January (i.e., could happen in Start Timestep or any timestep)?<br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). <br><br>GCAA, 20181030: Changed reference from the Forecast1 slots to ResetAnnualFC slots and replaced hardcoded MWD annual canal capacity with the MWDCanal_AnnualCapacity slot. Removed &quot;- Minute 323&quot; from rule name.";
    BEGIN

      $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] := $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.SNWA Domestic" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.MWD" [@"24:00:00 December 31, Current Year"] := "Min"( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] - $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December 31, Current Year"], $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December 31, Current Year"] );

      $ "Surplus Total Annual Schedules.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] + IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= 1100.00000000 "feet" )
 THEN
  10305.00000000 "acre-ft"
 ELSE
  0.00000000 "acre-ft"
 ENDIF COMMENTED_BY "If Mead is above 1,100 Ft then release the annual ICS System Efficiency amount of water <br>which is calculated as 1/10 of the 2014 System Efficiency ICS Volume for Arizona of 103,050 AF. <br>";

    END
    UUID "{9621c0f9-717b-412a-93e9-d568c632783b}";;

    RULE                 "Set Quantified Surplus Entitlement Vols CAP and MWD";
    DESCRIPTION          "DESCRIPTION: This rule distributes the volume of quantified surplus available between MWD and CAP<br><br>SLOTS SET: Surplus Volume Entitlements.MWD Quantified; Surplus Volume Entitlements.CAP Quantified<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker 06/20/2018: Added constraint to not allow Quantified surplus to be taken by CPAT prior to 1992.<br><br>GCAA, 20181030: Removed &quot;- Minute 323&quot; from rule name. Replaced hardcoded MWD surplus entitlement values with reference to DefaultSurplusEntitlement slot";
    BEGIN

      $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"] := IF ( $ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] )
 THEN
  $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
   "FlowToVolume"( $ "MWDDiversion:MWD.Diversion Requested" [date], date )
  ENDFOR COMMENTED_BY "Total current year MWD diversion request volume"
 ELSE
  $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"]
 ENDIF;

      $ "Surplus Volume Entitlements.CAP Quantified" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) > 1992.00000000 )
 THEN
  WITH NUMERIC RemainingCanalCapacity = $ "AnnualWaterUse.CAPCanal_AnnualCapacity" [] - "SumAnnualCAPDivRequest"(  ) - $ "ICS Credits.AnnualDeliverySysEff_AZ" [@"24:00:00 December 31, Current Year"] DO
   WITH NUMERIC RemainingQS_AZ = $ "Surplus.Arizona Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] - ( $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] ) DO
    IF ( RemainingQS_AZ > 0.00000000 "acre-feet" )
    THEN
     "Min"( RemainingQS_AZ, RemainingCanalCapacity )
    ELSE
     $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"]
    ENDIF
   ENDWITH
  ENDWITH
 ELSE
  0.00000000 "acre-ft"
 ENDIF COMMENTED_BY "Testbed Hindcast Simulations - Prior to 1992 do not allow CAP to take water since canal was not built  <br>";

    END
    UUID "{662dfa55-5c5c-49c7-9015-5ad6055fd735}";;

    RULE                 "Set Domestic and FC Surplus Entitlement Vols for MWD";
    DESCRIPTION          "DESCRIPTION: In Domestic Surplus then MWD gets 1,250 KAF less the MWD Diversion to date, less 1/3 the Mexico Shortage and surplus volume if the year is prior to 2017, after 2017 then the calculation is 250 KAF less 1/3 the Mexico annual surplus value. In a flood control year MWD is entitled to a Full Canal so their entitlement is the current diversion plus what it takes to fill the canal. TP 7/28/2015<br><br>SLOTS SET: Surplus Volume Entitlements.MWD Domestic; Surplus Volume Entitlements.MWD FC<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015<br><br>GCAA, 20181030: Removed &quot;- Minute 323&quot; from name, replaced hardcoded CAP surplus entitlement value with reference to Surplus Volume Entitlements.CAP Domestic slot, replaced hardcoded share of surplus by state value with ShareofMexicoSurplusbyState() function, and replaced CAP surplus entitlement value with reference to Surplus.Default Surplus Entitlements slot.";
    BEGIN

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
 THEN
  $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
   "FlowToVolume"( $ "MWDDiversion:MWD.Diversion Requested" [date], date )
  ENDFOR - "ShareofMexicoSurplusbyState"(  ) * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"]
 ELSE
  IF ( $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-ft" AND $ "Surplus Volume Entitlements.SNWA Domestic" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-ft" )
  THEN
   $ "Surplus.Default Surplus Entitlements" [0.00000000, 1.00000000] - "ShareofMexicoSurplusbyState"(  ) * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"]
  ELSE
   $ "Surplus.Default Surplus Entitlements" [0.00000000, 1.00000000]
  ENDIF
 ENDIF;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.MWD FC" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.MWD FC" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - "SumAnnualMWDDivRequest"(  );

      END_IF_STATEMENT;

    END
    UUID "{aff04063-da50-435d-872e-1a22a0d7fad4}";;

    RULE                 "Set Domestic and FC Surplus Entitlement Vols for CAP";
    DESCRIPTION          "DESCRIPTION: If the year is greater than 2017, then determine the Domestic Surplus entitlement for CAP which is calculated as 100 KAF - 1/3*Mexico Annual Surplus - (Surplus entitlements for Gila Monster Farms + AZ pumpers blw Imp).  If the system is in Flood Control, the CAP FC volume is set to 1,835 KAF less the current CAP Diversion Request so that they are entitled to a full canal volume of 1,835 KAF in a year of Flood Control. TP 7/28/2015<br><br>SLOTS SET: Surplus Volume Entitlements.CAP Domestic, Surplus Volume Entitlements.CAP FC<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015<br><br>GCAA, 20181030: Replaced hardcoded CAP default surplus entitlement value with reference to Surplus.Default Surplus Entitlements slot, replaced share of Mexico surplus by state value with ShareofMexicoSurplusbyState() function, and removed &quot;-Minute 323&quot; from rule name.";
    BEGIN

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  $ "Surplus.Default Surplus Entitlements" [0.00000000, 0.00000000] - "ShareofMexicoSurplusbyState"(  ) * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"] - ( $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] )
 ENDIF;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.CAP FC" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.CAP FC" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.CAPCanal_AnnualCapacity" [] - "SumAnnualCAPDivRequest"(  );

      END_IF_STATEMENT;

    END
    UUID "{cb1d29bd-a1c6-4f53-9311-a9939da062ea}";;

    RULE                 "Set Quantified Volumes by State";
    DESCRIPTION          "DESCRIPTION: If there is a positive Quantified Surplus volume, this rule will distribute it among the lower basin states of AZ, CA, and NV. The distribution amounts (shares) are stored in a slot on the Surplus object. If there is not a positive Quantified Surplus, the execution contraints will prevent this rule from firing. -HMG 8/2/11<br><br>SLOTS SET: Surplus.<state> Quantified Surplus Volume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/2011";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "Surplus" & ( state CONCAT " Quantified Surplus Volume" ) [@"24:00:00 December 31, Current Year"] := $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of Quantified Surplus by State" [0.00000000, state];

      ENDFOREACH;

    END
    UUID "{5b328700-3564-4714-b5ad-22cdf863945f}";;

    RULE                 "Set Outyear Surplus Schedules for Mexico";
    DESCRIPTION          "DESCRIPTION: This rule uses the volume associated with the Mexico Surplus Flag to set the Mexico diversion request for surplus according to the Mexico Surplus Table TP 7/28/2015<br><br>SLOTS SET: MexicanTreatyDelivery:MexicoSched.Diversion Requested, Mexico Shortage and Surplus.Mexico Annual Surplus<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND $ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>GCAA, 20181030: Removed &quot;- Minute 323&quot; from rule name";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date] + $ "Mexico Shortage and Surplus.Mexico Surplus Table" [$ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Volume"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Mexico"], date );

      ENDFOREACH;

      $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"] := $ "Mexico Shortage and Surplus.Mexico Surplus Table" [$ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Volume"];

    END
    UUID "{f3dbd19c-a6c1-48f9-84f5-897b39f6ea58}";;

  END
  UUID "{cbb72186-2e5b-4e67-b3cf-19fc35925e1c}";;

  POLICY_GROUP   "Shortage";
  DESCRIPTION    "This policy group contains the rules required to simulate Lower Basin Shortage operations. Lower Basin Shortage operations are based on the 2007 Interim Guidelines as well as IBWC Minute 323. <br><br>Shortage volumes in Arizona are based on the Arizona Shortage Sharing Agreement. All shortage volumes are the volumes used during the 2007 Interim Guidelines EIS, and were provided by the state of Arizona for use in the EIS process.<br><br>Mexico shortage volumes are based on IBWC Minute 323.   ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Mexico Outyear Shortage Schedules";
    DESCRIPTION          "DESCRIPTION: This rule sets a shortage diversion amount to the water use object MexicanTreatyDelivery:MexicoSched. The Mexico schedule is reduced by the shortage volume. The Mexico shortage volume is specified in IBWC Minute 323.<br><br>SLOTS SET: MexicanTreatyDelivery:MexicoSched.Diversion Requested, Mexico Shortage and Surplus.Mexico Annual Shortage<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>GCAA, 20181030: Removed &quot;- Minute 323&quot; from rule name";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date] - $ "Mexico Shortage and Surplus.Mexico Shortage Volumes" [$ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Mexico"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Mexico"], date );

      ENDFOREACH;

      $ "Mexico Shortage and Surplus.Mexico Annual Shortage" [@"24:00:00 December 31, Current Year"] := $ "Mexico Shortage and Surplus.Mexico Shortage Volumes" [$ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Mexico"];

    END
    UUID "{f13c7a8a-558d-4eb4-bf43-63f15c6c5e25}";;

    RULE                 "Set Outyear Shortage Schedules";
    DESCRIPTION          "DESCRIPTION: This rule sets the shortage schedules located in data objects or calculated to the diversion requested slots of the appropriate U.S. water use simulation objects.<br><br>SLOTS SET: PumpingFromLakeMead:SNWP.Diversion Requested, PumpingFromLakeMead:SNWP.Depletion Requested, AzDvsToPkr:LakeHavasuCity.Diversion Requested, AzDvsToPkr:MohaveValleyIID.Diversion Requested, AzDvsToPkr:BullheadCity.Diversion Requested, AzDvsToPkr:CibolaValleyIID.Diversion Requested, AzDvsToPkr:Parker.Diversion Requested, AzDvsToPkr:Ehrenberg.Diversion Requested, GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested, GilaAndYumaUsers:CocopahIndRes.Diversion Requested, AzPkrToImp:AzPumpersAbvImp.Diversion Requested, OthersBlwImp:AzPumpersBlwImp.Diversion Requested, AzDvsToPkr:AzPumpersDvsToPkr.Diversion Requested, CAPDiversion.Total Diversion Requested<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170306: Calculation of snwpDivVol modified by Sarah B. to correct an error";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
          DESCRIPTION          "snwpDivVol modified by Sarah B. 20170306 to correct error";
      WITH_STATEMENT (NUMERIC snwpDivVol = "VolumeToFlow"( WITH NUMERIC dssDeliveries = $ "ICS Credits.AnnualDeliveryTribDSS_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualDeliveryImpDSS_NV" ["Dec31ofYear"( @"t" )] DO
  WITH NUMERIC shortageVolume = $ "Shortage.State Shortage Volumes" [( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) - 1.00000000, "Nevada"] DO
   WITH NUMERIC NonSNWANevadaDivReqs = FOR ( DATETIME date2 IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year" ) STAT_SUM
    "FlowToVolume"( $ "FtMohaveIndRes:NV.Diversion Requested" [date2], date ) + "FlowToVolume"( $ "NvDvsToPkr:BigBend.Diversion Requested" [date2], date ) + "FlowToVolume"( $ "NvDvsToPkr:SCE.Diversion Requested" [date2], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date2], date )
   ENDFOR DO
    ( ( "Min"( $ "AnnualWaterUse.NV_BasicApportionment" [] - shortageVolume, $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )] ) - NonSNWANevadaDivReqs ) + dssDeliveries ) COMMENTED_BY "Annual SNWP volume = (NV annual allotment - Priority users diversions + Developed Shortage <br>Supplies - Shortage volume) <br>"
   ENDWITH
  ENDWITH
 ENDWITH * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"] COMMENTED_BY "Multiply by monthly percentage to get monthly volume", date ) COMMENTED_BY "Calculate the monthly SNWP diversion request under Shortage as a flow rate") DO
            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := snwpDivVol;

            $ "PumpingFromLakeMead:SNWP.Depletion Requested" [date] := snwpDivVol;

      END_WITH_STATEMENT;

          DESCRIPTION          "Set AZ users' diversion requests under shortage";
      $ "AzDvsToPkr:LakeHavasuCity.Diversion Requested" [date] := "Arizona Shortage Depletion"( "LakeHavasuCity", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzDvsToPkr:MohaveValleyIID.Diversion Requested" [date] := "Arizona Shortage Depletion"( "MohaveValleyIID", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzDvsToPkr:BullheadCity.Diversion Requested" [date] := "Arizona Shortage Depletion"( "BullheadCity", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := "Arizona Shortage Depletion"( "CibolaValleyIID", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := "Arizona Shortage Depletion"( "City of Parker", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:Ehrenberg.Diversion Requested" [date] := "Arizona Shortage Depletion"( "Ehrenberg", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "Arizona Shortage Depletion"( "Gila Monster Farms", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "GilaAndYumaUsers:CocopahIndRes.Diversion Requested" [date] := "Arizona Shortage Depletion"( "Cocopah Indian Res", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:AzPumpersAbvImp.Diversion Requested" [date] := "Arizona Shortage Depletion"( "AzPumpersAbvImp", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "Arizona Shortage Depletion"( "AzPumpersBlwImp", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzDvsToPkr:AzPumpersDvsToPkr.Diversion Requested" [date] := "Arizona Shortage Depletion"( "AzPumpersDvsToPkr", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "CAPDiversion.Total Diversion Requested" [date] := "CAP Shortage Depletion"( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

      ENDFOREACH;

    END
    UUID "{3e5be3a1-a8df-42f7-8506-128654735141}";;

    RULE                 "Set CAP Annual Shortage Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the annual shortage volume for CAP in Arizona. The CAP shortage volume is based on the Arizona Shortage Sharing Agreement. It is calculated as the total Arizona shortage volume (based on Lake Mead trigger elevation) minus the sum of the shortage volumes of the other Arizona water users.<br><br>SLOTS SET: Shortage.CAP Annual Shortage Volume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Shortage.CAP Annual Shortage Volume" [@"24:00:00 December 31, Current Year"] := IF ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000 )
 THEN
  "GetAnnualCAPShortage"( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000 )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

    END
    UUID "{dfb9c5fe-a754-4910-a3ca-e4c806e39af8}";;

  END
  UUID "{87c5c0a0-f901-479e-a5c8-62bbf53b39f5}";;

  POLICY_GROUP   "DCP and BWSCP";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "California DCP";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] );
    NOTES                "";
    BEGIN

      IF_STATEMENT ($ "ICS Credits.AnnualDCPContribution_CA" [@"24:00:00 December Max DayOfMonth, Current Year"] > 0.00000000 "acre-ft") THEN
          DESCRIPTION          "This assignment calculates whether MWD's DCP contribution will be made as schedule <br>reduction or conversion of EC ICS to DCP ICS. Accounting for this will happen in the ICS <br>Accounting policy group.<br><br>If a schedule reduction to meet the DCP contribution is needed, it assumed that the schedule <br>reduction will be converted to DCP ICS through EC ICS.   <br><br>Check EC ICS balance, check current year EC creation, else reduce schedule to create EC ICS<br>which will then be converted to DCP ICS<br><br><br>AP, 7/11/19<br><br><br>Coachella can not &quot;officially&quot; create DCP ICS. Instead DCP creation for Coachella will be done <br>&quot;unofficially&quot; and held in MWD account. Coachella will reduce diversion by 7% to help CA meet <br>DCP contribution and will be stored store in MWD's system. MWD to pay tax for now. Logic will <br>be disabled for Coachella besides 7% reduction to diversion to create system water for MWD. <br>It is assumed there will be enough space for MWD to create DCP ICS with coachellas system <br>water + their own. Will be adjusted downward in accounting rule if not enough space. CVWD <br>account in MWD system will not be tracked, all DCP ICS will be assumed to be MWD.<br><br>AP 7/31/19          <br>";
      WITH_STATEMENT (NUMERIC dcpContribution = $ "ICS Credits.AnnualDCPContribution_CA" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            WITH_STATEMENT (NUMERIC PreviousECtoDCP = "Min"( dcpContribution, $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] )) DO
            WITH_STATEMENT (NUMERIC RemainingContribution = IF ( dcpContribution == PreviousECtoDCP )
 THEN
  0.00000000 "acre-ft"
 ELSE
  dcpContribution - PreviousECtoDCP
 ENDIF) DO
            $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := PreviousECtoDCP;

            $ "ICS Credits.AnnualRemainingDCPContribution_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := RemainingContribution;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000 "acre-ft";

            $ "ICS Credits.AnnualRemainingDCPContribution_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000 "acre-ft";

            $ "ICS Credits.AnnualSimultaneousCreationDCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000 "acre-ft";

            $ "ICS Credits.AnnualSysWaterforDCP_Coachella" [@"24:00:00 December 31, Current Year"] := 0.00000000 "acre-ft";

            $ "ICS Credits.AnnualCreationDCP_Coachella" [@"24:00:00 December 31, Current Year"] := 0.00000000 "acre-ft";

            $ "ICS Credits.AnnualSysWaterforDCP_MWD" [@"24:00:00 December 31, Current Year"] := 0.00000000 "acre-feet";

      END_IF_STATEMENT;

    END
    UUID "{c862f2bd-77c9-4b9d-957d-8c1f3f2b3bfe}";;

    RULE                 "Nevada DCP";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] );
    NOTES                "";
    BEGIN

      IF_STATEMENT ($ "ICS Credits.AnnualDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] > 0.00000000 "acre-feet") THEN
          DESCRIPTION          "This assignment calculates whether NV's DCP contribution will be made as through a schedule <br>reduction to create EC ICS then DCP ICS or conversion of EC ICS to DCP ICS. Accounting for <br>this will happen in the ICS Accounting policy group.<br><br>If a schedule reduction to meet the DCP contribution is needed, it assumed that the schedule <br>reduction will be converted to DCP ICS through EC ICS.   <br><br>Check EC ICS balance, check current year EC creation, else reduce schedule to create EC ICS <br>which will then be converted to DCP ICS<br><br>AP, 7/11/19<br>";
      WITH_STATEMENT (NUMERIC dcpContribution = $ "ICS Credits.AnnualDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"]) DO
            WITH_STATEMENT (NUMERIC PreviousECtoDCP = "Min"( dcpContribution, $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] )) DO
            WITH_STATEMENT (NUMERIC RemainingContribution = IF ( dcpContribution == PreviousECtoDCP )
 THEN
  0.00000000 "acre-ft"
 ELSE
  dcpContribution - PreviousECtoDCP
 ENDIF) DO
            $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := PreviousECtoDCP;

            $ "ICS Credits.AnnualRemainingDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := RemainingContribution;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000 "acre-ft";

            $ "ICS Credits.AnnualRemainingDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000 "acre-ft";

      END_IF_STATEMENT;

    END
    UUID "{6e31581a-a7c2-4a0d-b9ae-34e4ae15b347}";;

    RULE                 "Arizona DCP";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND ( ( "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 4.00000000 AND $ "DCP Flags.LB DCP Tier Check" ["Dec31ofYear"( @"t" )] != $ "DCP Flags.LB DCP Tier" ["Dec31ofYear"( @"t" )] ) );
    NOTES                "";
    BEGIN

    DESCRIPTION          "Rule sets AZ DCP contribution. AZSched_DCPICS is an input from the 24MS (desired DCP ICS <br>creation). The desired DCP ICS creation is set here and will be adjusted down in the AZ <br>accounting rule based on bank space. AZ system water for DCP contribution is also calculated in <br>the AZ accounting rule. <br>";
      IF_STATEMENT ($ "ICS Credits.AnnualDCPContribution_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] > 0.00000000 "acre-ft") THEN
            $ "ICS Credits.AnnualDesiredDCPICSCreation_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := $ "DCP.ArizonaSched_DCPICS" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  );

      ELSE
            $ "ICS Credits.AnnualDesiredDCPICSCreation_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000 "acre-ft";

      END_IF_STATEMENT;

    END
    UUID "{0ae60bc0-928a-4151-b115-4a58787c56dd}";;

    RULE                 "Determine DCP and BWSCP Contrib";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) >= 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) );
    NOTES                "";
    BEGIN

    DESCRIPTION          "This rule determines DCP contributions in outyears. Rule fires in run cycles 3 and 4. Does not fire <br>in the first year (start timestep) since DCP condition is already known. DCP contributions in the <br>first year are DMI inputs from the 24 MS. <br>";
      WITH_STATEMENT (NUMERIC MeadPoolElevation = "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" )) DO
          DESCRIPTION          "Determine the DCP contribion needed for AZ, CA, NV and MX based on Meads previous EOCY <br>projection <br>";
      FOREACH (STRING user IN "DCP Users"(  )) DO
            IF_STATEMENT (user == "MX") THEN
            $ "Mexico Shortage and Surplus.Mexico Recoverable Water Savings_AnnualContribution" [@"24:00:00 December 31, Current Year"] := "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, "GetColumnIndex"( $ "DCP.Contributions", user ), MeadPoolElevation, @"t", FALSE );

      ELSE
            % "ICS Credits" & "AnnualDCPContribution_" CONCAT user [@"24:00:00 December 31, Current Year"] := "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, "GetColumnIndex"( $ "DCP.Contributions", user ), MeadPoolElevation, @"t", FALSE );

      END_IF_STATEMENT;

      ENDFOREACH;

          DESCRIPTION          "DCP flag. Set in both run cycle 3 and run cycle 4 <br>";
      $ "DCP Flags.LB DCP Tier" [@"24:00:00 December 31, Current Year"] := "GetRowIndex"( $ "DCP.Contributions", STRINGIFY "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, 0.00000000, MeadPoolElevation, @"t", FALSE ) );

          DESCRIPTION          "DCP flag check. This is only set in run cycle 3. This flag is used in run cycle 4 to refire rules if the <br>DCP condition changed between run cycle 3 and run cycle 4. <br>";
      IF_STATEMENT ("GetRunCycleIndex"(  ) == 3.00000000) THEN
            $ "DCP Flags.LB DCP Tier Check" [@"24:00:00 December 31, Current Year"] := "GetRowIndex"( $ "DCP.Contributions", STRINGIFY "TableLookupDefaultTol"( $ "DCP.Contributions", 0.00000000, 0.00000000, MeadPoolElevation, @"t", FALSE ) );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{938b73ef-6bd0-48ac-9cf9-a371f9ad9e95}";;

  END
  UUID "{9e01eacb-5079-4b62-90bd-edea3c9a6313}";;

  POLICY_GROUP   "Mead and Lower Basin Condition Determination";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Quantified Surplus Flags";
    DESCRIPTION          "DESCRIPTION: This rule sets the flags that indicate a Quantified Surplus condition<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Quantified Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND @"t" == @"24:00:00 January 31, Current Year" AND IsNaN $ "Surplus.Surplus Flag" [] AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170706<br><br>MC, 20170706: The setting of these flags was moved from the rule Quantified Surplus Schedules Data Volume to Simulation Flow at the suggestion of Shana T. to consolidate setting of flags related to Mead condition. Note that the Execution Constraints for this rule depend on the Surplus.Quantified Surplus Volume slot, which isn't set until Rule 39-Copute Quantified Surplus Volume - Minute 323; so, this rule will not fire successfully until after that rule<br><br>A.Pivarnik, 20180921: Disabled statement setting LowerBasinDemandVariability.AbvHooverTriggerSet. Was causing MTOM to fail in August run when trying to set Mead operations. ";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 2.00000000;

            $ "Surplus.Quantified Surplus Flag" [date] := 1.00000000;

      ENDFOREACH;

    INACTIVE      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" [@"24:00:00 December 31, Current Year"] := 2.00000000;

    END
    UUID "{daaf29da-016c-4ea8-966c-f83cf3956b4d}";;

    RULE                 "Set Domestic Surplus Flags";
    DESCRIPTION          "DESCRIPTION: This rule sets the flags that indicate a Domestic Surplus condition<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Domestic Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Surplus.Domestic Surplus Trigger Elevation" [] AND IsNaN $ "Surplus.Surplus Flag" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170706<br><br>MC, 20170706: The setting of these flags was moved from the rule Domestic Surplus Schedules Data Volume to Simulation Flow at the suggestion of Shana T. to consolidate setting of flags related to Mead condition<br><br>A.Pivarnik, 20180921: Disabled statement setting LowerBasinDemandVariability.AbvHooverTriggerSet. Was causing MTOM to fail in August run when trying to set Mead operations. <br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). ";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 1.00000000;

            $ "Surplus.Domestic Surplus Flag" [date] := 1.00000000;

      ENDFOREACH;

    INACTIVE      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" [@"24:00:00 December 31, Current Year"] := 2.00000000;

    END
    UUID "{80df0f7b-b6ae-4c02-86da-f2fcd9a0bff8}";;

    RULE                 "Compute Quantified Surplus Volume";
    DESCRIPTION          "DESCRIPTION: This rule computes the total volume of Quantified Surplus water for the year. This slot only computes once per year in January and is NOT recalculated if Lower Basin demands are revised. If this value is postitive, there is a Quantified Surplus determination and water use schedules are revised as appropriate. <br>Equation:   Surplus Volume = (Powell Storage + Mead Storage - maxstorage - previous year ICS credits)*(1+avgBankStorcoef) + runoff - UBDemand - LBDemand <br>Variable Definitions:<br>  Powell Storage = Powell storage at beginning of the year (December month-end) <br>  Mead Storage = Mead storage at the beginning of the year (December month-end) <br>  Max Storage = 47.96 maf <br>  Previous year ICS credits - cumulative ICS credits over entire Lower Basin over all years <br>  avgBankStorcoef = average of Powell and Mead bank storage coefficients <br>  Runoff = 17.4 maf (70th percentile non-exceedence flow) <br>  UBDemand = Upper Basin depletion scheduled for the year + average evaporation loss in the Upper Basin (same as in 602a calculation, 560 kaf) <br>  LBDemand = sum of depletions below Powell + evaporation losses in the Lower Basin (avg 900 kaf) ? avg gains below Powell (Powell to Mead and below Mead) <br><br>-HMG 8/2/11<br><br>SLOTS SET: Surplus.Quantified Surplus Volume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/11<br>MC, 20160114: There is a function, QuantifiedSurplusVolume, with the same calculation in it.  Are both necessary?<br>MC, 20170512: Need to edit Execution Constraints to ensure execution in January?<br>GCAA, 20181030: Removed &quot;- Minute 323&quot; from rule name";
    BEGIN

      $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] := "QuantifiedSurplusVolume"(  );

    END
    UUID "{ad6802dc-2ef8-4a9b-be08-65b9452a4fe8}";;

    RULE                 "Determine Mead and Lower Basin Condition";
    DESCRIPTION          "DESCRIPTION: This rule sets a slot that determines the Condition of Lake Mead and the Lower Basin. A setting of 0 means a normal year, a 1 means shortage, a 2 means Domestic Surplus and a 3 is Quantified Surplus.  In the condition of anything that is not normal. TP 7/28/2015<br>                         Sets LBDV.schedulecheck to something other than 0 if the LB condition changes in RC 3. AP 9/18/2018<br><br>SLOTS SET: LowerBasinDemandVariability.LowerBasinCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015<br><br>9/18/2018, AP: Removed logic to determine LB operating condition and moved it into LBConditionDetermination function. Rule now sets LBDV.Schedule check value to either a 1 (shortage) or 2 (surplus) if the LB condition switches to something other than normal in run cycle 3. This value does not change after run cycle 3.<br>S.Baker, 20180925: Changed execution constraint to allow rule to execute in start timestep since 24MS projected Mead PE is known. Edited time in function to Dec Previous year. This will allow the rule to execute correctly in start timestep. Edited date input in second assignment to be consistent with the first assignment (shouldnt change how rule works). ";
    BEGIN

      $ "LowerBasinDemandVariability.LowerBasinCondition" [@"24:00:00 December 31, Current Year"] := "LBConditionDetermination"(  );

      $ "LowerBasinDemandVariability.ScheduleCheck" [@"24:00:00 December 31, Current Year"] := IF ( "GetRunCycleIndex"(  ) == 3.00000000 AND "LBConditionDetermination"(  ) != 0.00000000 )
 THEN
  IF ( "LBConditionDetermination"(  ) == 1.00000000 )
  THEN
   1.00000000
  ELSE
   2.00000000
  ENDIF
 ENDIF;

    END
    UUID "{f22ba73e-2bb4-4e47-83d8-d6a0aaf4321a}";;

    RULE                 "Set Mexico Surplus Flag";
    DESCRIPTION          "DESCRIPTION: This rule sets the Mexico Surplus flag as a function of Mead compared to the Mexico Surplus Table. A Mead elevation of >= 1,200 ft. receives a value of 3, a value greater than 1,170 ft and less than the level 3 elevation, receives a value of 2, a value of 1,145 ft and less than a level 2 receives a value of 0 and any other condition receives a value of 0. This flag is used in subsequent Mexico Surplus rules. TP 7/28/2015<br><br>SLOTS SET: Mexico Shortage and Surplus.Mexico Surplus Flag<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170706: Moved from Priority 41 while consolidating Mead conditions flag-setting per Shana T. suggestion<br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). Changed execution constraint to allow execution in start timestep.<br><br>GCAA, 20181030: Removed &quot;- Minute 323&quot; from rule name";
    BEGIN

      $ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] := IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [2.00000000, "Elevation"] )
 THEN
  3.00000000
 ELSE
  IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [1.00000000, "Elevation"] )
  THEN
   2.00000000
  ELSE
   IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [0.00000000, "Elevation"] )
   THEN
    1.00000000
   ELSE
    0.00000000
   ENDIF
  ENDIF
 ENDIF;

    END
    UUID "{e61bbf9a-a73d-4513-953d-9bf386f620cd}";;

    RULE                 "Set Shortage Flag";
    DESCRIPTION          "DESCRIPTION: In the event that a Lower Basin shortage is projected, this rule sets the Shortage Flag slot to indicate the level of shortage. No shortage = 0. Most severe shortage (Mead < 1025 feet) = 3. Mead < 1050 ft = 2, Mead < 1075 ft = 1. If there is a shortage or surplus then the Abv Hoover Trigger is set to a 2 and no LBDV will occur for the parties that look at the Above Hoover Trigger Set for LBDV.  (SNWP)<br><br>SLOTS SET: Shortage.Shortage Flag, LowerBasinDemandVariability.AbvHooverTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170706: Moved from Priority 46 while consolidating Mead conditions flag-setting per Shana T. suggestion<br>S.Baker, 20180925: Changed IF statements to use function 'GetProjectedPoolElevation' instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). Changed execution constraint to allow rule to execute in start timestep since 24MS projected Mead PE is known. Edited time in function to Dec Previous year. This will allow the rule to execute correctly in start timestep.";
    BEGIN

      $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] := IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) < $ "Shortage.Mead Shortage Elevations" [2.00000000, 0.00000000] )
 THEN
  3.00000000
 ELSE
  IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) < $ "Shortage.Mead Shortage Elevations" [1.00000000, 0.00000000] )
  THEN
   2.00000000
  ELSE
   IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
   THEN
    1.00000000
   ELSE
    0.00000000
   ENDIF
  ENDIF
 ENDIF;

    INACTIVE      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" [@"24:00:00 December 31, Current Year"] := IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
 THEN
  2.00000000
 ENDIF;

    END
    UUID "{9d0ab11a-d5e2-4e62-80df-1c527c3532f9}";;

  END
  UUID "{59a47bfe-f3f4-40f3-814a-1b05921b744f}";;

  POLICY_GROUP   "Powell Steady Flow Experiment";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Steady Flow Experiment Release";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT $ "PowellData.SteadyFlowExperimentFlag" [] == 1.00000000 AND "GetRunCycleIndex"(  ) == 3.00000000;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("MonthIs"( { "September" } )) THEN
            $ "Powell.Outflow" [] := "GetSeptemberSteadyFlowRelease"( $ "PowellData.TargetAnnualReleaseVolume" [] );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "October" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [@"t - 1"];

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "April" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.5_ReduceApril" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "May" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.6_ReduceMay" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "June" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - ( $ "PowellSteadyFlowExperiment.4_ReduceJune_2" ["CurrentYear"(  )] + $ "PowellSteadyFlowExperiment.3_ReduceJune_1" ["CurrentYear"(  )] ) / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "July" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.2_ReduceAugust" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "July" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.1_ReduceJuly" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

    END
    UUID "{ea5d36ab-9eb5-48a7-ba12-c5e217d176de}";;

    RULE                 "Set Steady Flow Reductions";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "April" } ) AND "GetRunCycleIndex"(  ) == 3.00000000;
    NOTES                "";
    BEGIN

      $ "PowellSteadyFlowExperiment.1_ReduceJuly" ["CurrentYear"(  )] := "SteadyFlowReduce_1_July"(  );

      $ "PowellSteadyFlowExperiment.2_ReduceAugust" ["CurrentYear"(  )] := "SteadyFlowReduce_2_August"(  );

      $ "PowellSteadyFlowExperiment.3_ReduceJune_1" ["CurrentYear"(  )] := "SteadyFlowReduce_3_June1"(  );

      $ "PowellSteadyFlowExperiment.4_ReduceJune_2" ["CurrentYear"(  )] := "SteadyFlowReduce_4_June2"(  );

      $ "PowellSteadyFlowExperiment.5_ReduceApril" ["CurrentYear"(  )] := "SteadyFlowReduce_5_April"(  );

      $ "PowellSteadyFlowExperiment.6_ReduceMay" ["CurrentYear"(  )] := "SteadyFlowReduce_6_May"(  );

    END
    UUID "{00b3bf07-1db5-40af-b0f4-59929943fad1}";;

  END
  UUID "{8b1f28ea-1166-42a1-b266-40f95b9da449}";;

  POLICY_GROUP   "PowellAfterLBDV";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Lower Balancing Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Lower Elevation Balancing Tier. This version of the rule executes in Run Cycle 4.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 4.00000000 AND ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND "TierIs"( "Lower", @"t", FALSE ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 20180925: Rule should not fire in the start timestep (execution constraint removed and IF statement removed). This is done in a separate rule. Removed IsYearDemandVariabilityandRunCycle4() since rule should always execute in Run Cycle 4. Added TierIs() to execution constraint.";
    BEGIN

    DESCRIPTION          "For August timestep with Lower Balancing Release Tier in next outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t + 2" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{852392ad-b511-4677-b6e1-4d10704c4210}";;

    RULE                 "Set Mid-Elevation Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Mid-Elevation Tier. This version of the rule executes in Run Cycle 4.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 4.00000000 AND ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND "TierIs"( "Mid", @"t", FALSE ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 20180925: Rule should not fire in the start timestep (execution constraint removed and IF statement removed). This is done in a separate rule. Removed IsYearDemandVariabilityandRunCycle4() since rule should always execute in Run Cycle 4. Added TierIs() to execution constraint.<br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation).";
    BEGIN

    DESCRIPTION          "In August with Mid-elevation tier for the next outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Current Year" ) ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF;

      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{c2dfcd2b-d19d-46fd-9838-08812e43404f}";;

    RULE                 "Refine Equalization Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule refines the annual release volume from Powell when either the Equalization Tier or Upper Elevation Balancing Tier B3 branch is operative for setting the annual release from Powell.  The release needs to be refined by this rule because when it is originally set, it is a preliminary &quot;guess&quot; for the volume it will take to arrive at the appropriate final (end of water year) condition (Equalized storage volumes, or Powell at a specific pool elevation at the end of the year - see Equalization Tier logic for more details as to what the final eowy condition should be).  This volume is then released and the end of year condition is checked against what it is supposed to be.  The first guess will almost always be off by some amount because of the non-linear elements in the water balance in both Powell and Mead of Evaporation and Bank Storage.  So rather than trying to set up a calculation or mini-simulation to calculate the exact right release volume to hit the end of water year condtion the first time, the guess volume is actually released and then this rule, because it can see the results of the original release, adjusts the release volume to eliminate the deviation from the target that it observes as a result of the initial guess release.  This rule is allowed to fire multiple times in a timestep and may do so in order to hit exactly the end of water year target condition. - sc 06/21/12<br><br>This version of the rule executes in Run Cycle 4 with Lower Basin Demand Variability in effect.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT WITH DATETIME eoyDate = IF ( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
 THEN
  "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )
 ELSE
  "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )
 ENDIF DO
  "HasRuleFiredSuccessfully"( "Set Equalization Release Volume post-LBDV" ) OR ( "HasRuleFiredSuccessfully"( "Set Upper Balancing Release Volume post-LBDV" ) AND $ "PowellData.UpperElevBalBranch" [eoyDate] == 1.30000000 ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) ) AND "GetRunCycleIndex"(  ) == 4.00000000 AND ( "TierIs"( "Upper", @"t", TRUE ) OR "TierIs"( "Equalization", @"t", TRUE ) )
 ENDWITH;
    NOTES                "S.Baker, 2018/10/17: Copied from normal Powell policy set and changed execution constraints for Run Cycle 4 and LBDV. Go to original rule for development details prior to this date. <br>S.Baker, 2018/11/26: [edited to match normal Powell rule for RC #3] Added WITH statement to store TARV and use in IF statement to look if solved TARV was equal to previous TARV. Then, allow for setting of the PowellData.ReleaseVolumeSetFlag when TARV solved in the current iteration is equal to the previously set TARV. This is necessary for solving for the carryover release pattern from Powell. This occurs normally when TARV is not changed from 8.23 MAF. ";
    BEGIN

      IF_STATEMENT (( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) ) COMMENTED_BY "At Start Timestep for initial water year when release tier is either Upper Elevation Balancing or Equalization") THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t" ) )) DO
            IF_STATEMENT ("Abs"( ReleaseAdjustment ) > $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            WITH_STATEMENT (NUMERIC PowellnewTARV = "MaxItem"( { $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] + ReleaseAdjustment , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } )) DO
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := PowellnewTARV;

          DESCRIPTION          "If TARV solved in this rule is equal to the previous TARV solved, then set the <br>ReleaseVolumeSetFlag. This allow carryover releases to be set if necessary.  <br>";
      IF_STATEMENT (PowellnewTARV == $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Check in August timestep or StartMonth of September with UEBT or Equalization for outyear";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  )) THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t + 2" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t + 2" ) )) DO
            IF_STATEMENT ("Abs"( VolumeDeviation ) > 0.00000000 "acre-feet") THEN
            WITH_STATEMENT (NUMERIC CurrentAnnualRelease = FOR ( DATETIME dates IN "GetDates"( "OffsetDate"( @"24:00:00 September Max DayOfMonth, Next Year", - 11.00000000, "1 months" ), @"24:00:00 September Max DayOfMonth, Next Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Outflow" [dates], dates )
 ENDFOR) DO
          DESCRIPTION          "MC, 20171102: This version added to handle carryover situation by setting ReleaseVolumeSetFlag <br>";
      IF_STATEMENT ("Abs"( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] - ( CurrentAnnualRelease + VolumeDeviation ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) + 1.00000000 "year" )] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) ) > ( $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) COMMENTED_BY "The tolerance of the TARV slot; if the proposed change is less than this value the slot value won't change <br>") THEN
            WITH_STATEMENT (NUMERIC PowellnewTARV = "MaxItem"( { IF ( "Abs"( ReleaseAdjustment ) > 0.00000000 "acre-ft" )
 THEN
  ( CurrentAnnualRelease - IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 999.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] )
  ENDIF COMMENTED_BY "Remove the Carryover That has been Added from last year Unless an Equalization Tier is the <br>current tier. <br>" ) + ReleaseAdjustment + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) + 1.00000000 "year" )] )
 ELSE
  $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] + ReleaseAdjustment
 ENDIF , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } )) DO
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := PowellnewTARV;

            IF_STATEMENT (PowellnewTARV == $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )]) THEN
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{6f4bc009-d2e0-4fbb-a2ec-a66a7ffe29ec}";;

    RULE                 "Set Upper Balancing Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Upper Elevation Balancing Tier. It also sets the Upper Elevation Balancing Branch, which indicates the conditions controlling the release volume, and resets the Release Tier and the Controlling Equalization Condition if necessary (UEB Branch = 1.3). This version of the rule executes in Run Cycle 4.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.UpperElevBalBranch; PowellData.ReleaseTier; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "TierIs"( "Upper", @"t", FALSE ) AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: Unknown<br>MC, 20161215: In the conditional statement checking for EqualizationTeirCalculationForRelease, changed PowellToMeadData.AugEOYPowellPEProjection[meadProjectionDate] to Powell.Pool Elevation[DateToCheckEOWYElevation(@&quot;t&quot;,TRUE)]. The check needs to be on the EOWY pool elevation, not the previous year's projected EOY pool elevation, because this is checking to see if the decision tree should follow the branch from Upper Elevation Balancing to Equalization. I had incorrectly changed the date used when adding the carryover functionality.<br><br>MC, 20170511: The GetRunCycleIndex()==3 condition will never be satisfied due to the Execution Constraints. Compare with initial version of rule for Run Cycle 4 and correct<br><br>S.Baker, 20180829: Edited the function 'UpperEleavationBalancingBranchCalculation' to have the correct number of inputs. <br><br>S.Baker, 20180925: Rule should not fire in the start timestep (execution constraint removed and IF statement removed). This is done in a separate rule. Removed IsYearDemandVariabilityandRunCycle4() since rule should always execute in Run Cycle 4. Added TierIs() to execution constraint.<br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead Pool Elevation. This will allow MTOM to determine which PE projection to use (ie. AugEOYProjectedMeadPE).";
    BEGIN

    DESCRIPTION          "In August or September start month with UEBT for outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", FALSE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) )
 THEN
  ( GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "DateToCheckEOWYElevation"( @"t", FALSE ) )] )
 ELSE
  IF ( ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Current Year" ) ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1075.00000000 "ft" ) COMMENTED_BY "Determine which branch of UEBT to follow" )
  THEN
   "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ELSE
   "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ENDIF
 ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue...";

    DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", FALSE ) )) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 0.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{1eba6ddb-8796-468b-9d12-fa2dc80da02c}";;

    RULE                 "Set Equalization Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) for years when the Release Tier is Equalization. It also calculates and sets the Controlling Equalization Condition slot, which indicates the equalization condition that dictated the volume to be released. This version executes in Run Cycle 4 if Lower Basin Demand Variability is in effect.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "TierIs"( "Equalization", @"t", FALSE ) AND $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 0.00000000 AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) COMMENTED_BY "This rule only fires in Run Cycle 4 with demand variability in effect, it is August, and the model has selected the Equalization teir for the current year. - sc 02/02/11; TP 08/20/2014; MC, 20170511";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 20180925: Rule should not fire in the start timestep (execution constraint removed and IF statement removed). This is done in a separate rule. Removed IsYearDemandVariabilityandRunCycle4() since rule should always execute in Run Cycle 4. Added TierIs() to execution constraint. Disabled PowellData.ReleaseVolumeSetFlag since this flag should be set in the Refine Equalization rule. <br>S.Baker, 2018/10/17: updated run cycle execution constraint to RC == 4 (was 3 which was incorrect).";
    BEGIN

    DESCRIPTION          "Outyear with Equalization";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

      $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

    INACTIVE      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{796178cf-8f6b-44cf-83f1-7b016f6d805b}";;

    RULE                 "Set Release Tier post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule fires at the Start Timestep and in August timesteps to set the Powell Release tier, as well as preliminarily setting the Upper Elevation Balancing Branch and Controlling Equalization Condition values to 999<br><br>SLOTS SET: PowellData.ReleaseTier; PowellData.UpperElevBalBranch; PowellData.ControllingEqualizationCondition<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) ) AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: SC, 02/02/2011 (copied to LBDV from Powell policy group)<br><br>S.Baker, 20180925: Added rule to post-LBDV since rule in Powell policy set wont fire in Run Cycle 4 due to condiditon of HasRuleFiredSucessfully() constraint. <br>S.Baker, 20180925: Changed order of rules. Moved &quot;Set Release Tier post-LBDV&quot; to a higher priority than &quot;Preliminary Set Out Year Release Volume to 8.23MAF post-LBDV&quot;. The priority issue was causing incorrectly calculated Release Tiers in the post-LBDV rules. When the ruleset got to the rule &quot;Set Release Tier post-LBDV&quot; the release for the water year was still set to a higher TARV (9.0MAF). This caused the rules to calculate the wrong release. MTOM then reset the TARV to 8.23MAF in &quot;Preliminary Set Out Year Release Volume to 8.23MAF post-LBDV&quot;. Switching the order of the rules allows for the TARV to be reset to 8.23MAF before calculating the release tier. ";
    BEGIN

    DESCRIPTION          "Model needs to set the teir for the following water year if current timestep is August. <br>";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND @"t + 2" IN "WaterYearDatesByGroup"( 2.00000000 )) THEN
            WITH_STATEMENT (NUMERIC Carryover = NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] )) DO
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - Carryover )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( IF ( @"t" == @"Start Timestep" )
 THEN
  $ "PowellToMeadData.AugEOYPowellPEProjection" ["DateToCheckJan1Elevation"( @"t + 2", TRUE )]
 ELSE
  EffectivePoolElevation
 ENDIF, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "The model will set the tier for the third year of the model run (second out year)";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 3.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Third out year of the model run";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 4.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Fourth out year of model run";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 5.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Fifth out year of model run if it exists in the forecast";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 6.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{1e37ef40-8fde-4d4e-9d5c-09507136bf11}";;

    RULE                 "Preliminary Set Out Year Release Volume To 8.23MAF post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: SC, 03/25/2011<br><br>S.Baker, 20190710: Edited the Max() statement to match the normal rule. The rule was using a function used in the Equalization rule instead of setting initial TARV to 8.23 (or close). <br>S.Baker, 20180925: Removed IsYearDemandVariabilityandRunCycle4() since rule should always execute in Run Cycle 4. <br>S.Baker, 20180925: Changed order of rules. Moved &quot;Set Release Tier post-LBDV&quot; to a higher priority than &quot;Preliminary Set Out Year Release Volume to 8.23MAF post-LBDV&quot;. The priority issue was causing incorrectly calculated Release Tiers in the post-LBDV rules. When the ruleset got to the rule &quot;Set Release Tier post-LBDV&quot; the release for the water year was still set to a higher TARV (9.0MAF). This caused the rules to calculate the wrong release. MTOM then reset the TARV to 8.23MAF in &quot;Preliminary Set Out Year Release Volume to 8.23MAF post-LBDV&quot;. Switching the order of the rules allows for the TARV to be reset to 8.23MAF before calculating the release tier. ";
    BEGIN

      WITH_STATEMENT (NUMERIC waterYearNumber = "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF) DO
            WITH_STATEMENT (NUMERIC AvailablePowellWater = ( IF ( "GetMonth"( @"Start Timestep" ) == 9.00000000 )
 THEN
  $ "Powell.Storage" [@"t - 1"]
 ELSE
  $ "Powell.Storage" [@"t + 1"]
 ENDIF COMMENTED_BY "MC, 20170511: I don't understand the below conditions" + FOR ( DATETIME date IN "WaterYearDatesByGroup"( waterYearNumber ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Inflow" [date], date )
 ENDFOR ) COMMENTED_BY "This is added to check that in years when Powell might go very low, the model won't bomb out <br>when setting the preliminary release when Powell is low. TP 1/22/2013<br>") DO
            WITH_STATEMENT (DATETIME WY_EndOfCalendarYearDate = "Dec31ofYear"( "OffsetDate"( "RelativeEOWYDate"( @"Start Timestep" ), waterYearNumber - 1.00000000, "1 years" ) )) DO
            WITH_STATEMENT (NUMERIC VolumeToRelease = "Min"( "MaxItem"( { 8230.00000000 "1000 acre-feet" , WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  "Min"( 8230.00000000 "1000 acre-feet", releaseTable ["AnnualTotal", "NumColumns"( releaseTable ) - 2.00000000] )
 ENDWITH COMMENTED_BY "Ensure release enough so Powell doesn't exceed max pool elevation" , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" [WY_EndOfCalendarYearDate] ) COMMENTED_BY "User input minimum annual release volume" } ), AvailablePowellWater )) DO
            IF_STATEMENT (NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", WY_EndOfCalendarYearDate )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" [WY_EndOfCalendarYearDate] := VolumeToRelease;

          DESCRIPTION          "These flags have to be reset and set again if go to LBDV <br>";
      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 0.00000000;

          INACTIVE      $ "PowellData.CarryoverSetFlag" ["Dec31ofYear"( "GetWaterYearEndDate"( @"t + 2" ) )] := 0.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{00ac8008-5e6e-42a9-b9c2-8c5d6d8671a9}";;

    RULE                 "Set WY1 Release Volume post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) for the first WY for any release Tier designation. It also calculates and sets the Controlling Equalization Condition slot, which indicates the condition that dictated the volume to be released based on which Tier has been set. <br><br>SLOTS SET: Some combination of the following - PowellData.TargetAnnualReleaseVolume; PowellData.ControllingEqualizationCondition; PowellData.UpperElevBalBranch<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) COMMENTED_BY "This rule only executes in Run Cycle 4; at the Start Timestep for only the first <br>WY;  and if the rule has not already fired successfully for the timestep   <br>";
    NOTES                "AUTHOR, DATE: Unknown (copied rule from Powell policy group)<br><br>S.Baker, 20180925: Added rule to post-LBDV since rule in Powell policy set wont fire in Run Cycle 4 due to condiditon of HasRuleFiredSucessfully() constraint. <br>AP, 2019/04/11: Added contstraint where it sets TARV to make sure the model won't equalize when the upper elevation balan branch is an input";
    BEGIN

      IF_STATEMENT ("TierIs"( "Equalization", @"t", TRUE ) COMMENTED_BY "Initial water year, in an Equalization Condition in Start Year <br>") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , 8230000.00000000 "acre-feet" } );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep in Run Cycle 3 with UEBT in Start Year";
      IF_STATEMENT ("TierIs"( "Upper", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := WITH DATETIME meadProjectionDate = IF ( @"t" <= @"September 30" )
 THEN
  @"24:00:00 December 31, Previous Year"
 ELSE
  @"24:00:00 December 31, Current Year"
 ENDIF DO
  IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", TRUE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) AND NOT "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.30000000 ) )
  THEN
   GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) )
  ELSE
   IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" [meadProjectionDate] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) ) >= 1075.00000000 "ft" OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND NOT $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.20000000 ) )
   THEN
    "Max"( "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ELSE
    "Max"( "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ENDIF COMMENTED_BY "Determine which branch of UEBT to follow"
  ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue..."
 ENDWITH;

          DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = IF ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) )
 THEN
  $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]
 ELSE
  "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", TRUE ) )
 ENDIF) DO
          DESCRIPTION          "Check if branch is input before trying to set slot <br>";
      IF_STATEMENT (NOT "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := upperElevBranch;

      END_IF_STATEMENT;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 0.00000000;

            IF_STATEMENT (NOT "IsInput"( $ "PowellData.ControllingEqualizationCondition", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep with Mid-Elevation tier in initial water year";
      IF_STATEMENT ("TierIs"( "Mid", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF, NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep with Lower Balancing Release Tier in initial water year";
      IF_STATEMENT ("TierIs"( "Lower", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

      END_IF_STATEMENT;

    END
    UUID "{be04a389-6176-4607-9ddf-1d26fb5a16f9}";;

    RULE                 "Set WY1 Release Tier post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule fires at the Start Timestep and in August timesteps to set the Powell Release tier, as well as preliminarily setting the Upper Elevation Balancing Branch and Controlling Equalization Condition values to 999, for the First Water Year<br><br>SLOTS SET: PowellData.ReleaseTier; PowellData.UpperElevBalBranch; PowellData.ControllingEqualizationCondition";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND ( "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) AND IsNaN $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )];
    NOTES                "AUTHOR, DATE: SC, 02/02/2011 (copied rule from Powell policy group)<br><br>S.Baker, 20180925: Added rule to post-LBDV since rule in Powell policy set wont fire in Run Cycle 4 due to condiditon of HasRuleFiredSucessfully() constraint";
    BEGIN

    DESCRIPTION          "Model needs to set the teir for the current year if at the start timestep, regardless of month. <br>";
      $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "PowellReleaseTier"( $ "PowellToMeadData.AugEOYPowellPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )], "RelativeEOWYDate"( @"t" ) );

      IF_STATEMENT (IsNaN $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

    END
    UUID "{b7ba1dd0-7e9c-4d59-ada8-66d94dffa65d}";;

    RULE                 "Preliminary Set WY1 Release Volume To 8.23MAF post-LBDV";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 4.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) );
    NOTES                "AUTHOR, DATE: SC, 03/25/2011<br><br>S.Baker, 20180925: Edited execution constraints to match Powell policy group rule. Changed rule TARV calculation to match Powell policy set rule. <br><br>S.Baker, 2018/10/17: Changed column number in releaseTable[AnnualVolume, Ncol - 3]<br>MTOM was failing in testbed runs in this rule in high inflow years when Powell was trying to release a large volume. In the historical run of 1983-06, the model aborted since it sets the initial TARV to 30 MAF based on the condition releaseTable[AnnualVolume, Ncol ? 2].  This caused the model to look for too high of upper bound in the function ?CalculatePowellMonthlyRelease?.  The upper bound was being reset in function 'FindRemainingReleaseUpperBoundColumn' by adding + 1 index which cause model to look for table index that didn?t exist. When we use Ncol ? 3, the TARV is initially set to 20 MAF and MTOM runs successfully finding a realistic TARV (18 MAF). ";
    BEGIN

      IF_STATEMENT (NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { 8230.00000000 "1000 acre-feet" , WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  "Min"( "CalcReleaseForMaxPoolElevation"( "WaterYearDatesByGroup"( 1.00000000 ) ), releaseTable ["AnnualTotal", "NumColumns"( releaseTable ) - 3.00000000] )
 ENDWITH COMMENTED_BY "Ensure enough water released so Powell does not exceed max pool elevation" , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) COMMENTED_BY "User input min annual volume was added to allow overriding automatic determination" , IF ( "GetMonth"( @"t" ) != 10.00000000 )
 THEN
  "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( @"t", "MonthsSinceEOWY"( @"t" ), "-1 months" ), @"Start Timestep - 1" )
 ELSE
  0.00000000 "acre-foot"
 ENDIF COMMENTED_BY "Ensure TARV is not less than volume already released in water year" } );

          DESCRIPTION          "These flags have to be reset and set again if go to LBDV <br>";
      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 0.00000000;

          INACTIVE      $ "PowellData.CarryoverSetFlag" ["Dec31ofYear"( "GetWaterYearEndDate"( @"t" ) )] := 0.00000000;

      END_IF_STATEMENT;

    END
    UUID "{c0de35a8-26d3-43b9-9349-a5c393b3de46}";;

  END
  UUID "{2b602780-8fa0-4012-8cf3-2c6a6ec1bdd2}";;

  POLICY_GROUP   "Powell";
  DESCRIPTION    "Annual operations of Lake Powell follow the guidelines specified in the 2007 Record of Decision for the Colorado River Interim Guidelines for Lower Basin Shortages and the Coordinated Operations for Lake Powell and Lake Mead (2007 Interim Guidelines). The 2007 Interim Guidelines specify several requirements that coordinate annual operations between Lake Powell and Lake Mead. The objective of coordinated operations is to avoid curtailment of uses in the Upper Basin, minimize shortages in the Lower Basin, and not adversely affect the yield for development available in the Upper Basin.<br>The 2007 Interim Guidelines specify annual release volumes for each of the four tiers, described herein. Operating tiers are set based upon the August projection of the following January 1 elevation, but in some cases are subject to an April adjustment.   <br>Equalization Tier <br>In water years when the Lake Powell January 1 pool elevation is projected to be greater than or equal to the Equalization elevation for the water year (see the 2007 Interim Guidelines), an amount of water greater than 8.23 MAF will be released from Lake Powell to the extent necessary to avoid spills or equalize the storage in the two reservoirs, otherwise to remain at 8.23 MAF. If, however, Lake Powell reaches the Equalization elevation and the September 30 projected Lake Mead elevation is below 1,105 feet, then additional water will be released until the first of the following occur: (i) Lake Powell and Lake Mead storages equalize, (ii) Lake Mead pool elevation reaches 1,105 feet, or (iii) Lake Powell pool elevation is equal to 20 feet less than the Equalization level for that year. <br>Upper Elevation Balancing Tier <br>If the August 24-Month Study projects the Lake Powell pool elevation for January 1 to be less than the elevation stated in the Lake Powell Equalization Elevation Table and at or above 3,575 feet, then the tier is Upper Elevation Balancing Tier. If the August 24-Month Study also projects the Lake Mead January 1 pool elevation to be greater than 1,075 feet, then 8.23 MAF will be released from Lake Powell. <br>If the August 24-Month Study projects the January 1 Lake Powell elevation to be below the elevation stated in the Lake Powell Equalization Elevation Table and at or above 3,575 feet, and the projected January 1 Lake Mead elevation is below 1,075 feet, the release from Lake Powell shall balance the contents of Lake Mead and Lake Powell, but shall be not more than 9.0 MAF and not less than 7.0 MAF in the water year. <br>When operating in the Upper Elevation Balancing Tier, if the April 24-Month Study projects the September 30 Lake Powell elevation to be greater than the elevation in the Lake Powell Equalization Elevation Table, the Equalization Tier will govern the operation of Lake Powell for the remainder of the water year (through September). <br>When operating under the Upper Elevation Balancing Tier with an 8.23 MAF release, if the April 24-Month Study projects the September 30 Lake Mead elevation to be below 1,075 feet and the September 30 Lake Powell elevation to be at or above 3,575 feet, the releases from Lake Powell shall balance the contents of Lake Mead and Lake Powell, but shall not be more than 9.0 MAF and not less than 8.23 MAF in the water year. <br>Mid-Elevation Release Tier <br>If the August 24-Month Study projects the January 1 Lake Powell pool elevation to be less than 3,575 feet and greater than or equal to 3,525 feet, the operating tier is the Mid-Elevation Release Tier. Within this tier, if the August 24-Month Study projects the Lake Mead January 1 pool elevation to be greater than 1,025 feet, Lake Powell will release 7.48 MAF. If the August 24-Month Study projects the Lake Mead January 1 pool elevation to be less than or equal to 1,025 feet, Lake Powell will release 8.23 MAF. Once established in August, this Lake Powell annual release volume is set for the duration of the upcoming water year. <br>Lower Elevation Balancing Tier <br>If the August 24-Month Study projects the Lake Powell January 1 pool elevation to be less than 3,525 feet, the operating tier is Lower Elevation Balancing Tier. The release from Lake Powell is set to balance the contents of Lakes Powell and Mead by the end of the upcoming water year, but will not be greater than 9.5 MAF and not less than 7.0 MAF. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Lower Balancing Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Lower Elevation Balancing Tier. <br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND "TierIs"( "Lower", @"t", FALSE ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: Unknown<br><br>TP 20171017: Removed Setting the volume for the first water year, only sets outyear volumes now<br>S.Baker, 20180924: Added new Execution Constraint that looks at TierIs(). This allows the removal of the IF statement.";
    BEGIN

    DESCRIPTION          "For August timestep with Lower Balancing Release Tier in next outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t + 2" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{e337f335-de97-4570-b3be-44b2ff132897}";;

    RULE                 "Set Mid-Elevation Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Mid-Elevation Tier for Out Years. <br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND "TierIs"( "Mid", @"t", FALSE ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170718: Added &quot;OR StartMonthIsSeptember()&quot; to condition originally for August; Sarah B. discovered this error and proposed the fix<br><br>TP, 20171017: Removed any setting of the First water year from this Rule<br><br>S.Baker, 20180924: Added new Execution Constraint that looks at TierIs(). This allows the removal of the IF statement.<br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation).";
    BEGIN

    DESCRIPTION          "In August with Mid-elevation tier for the next outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Current Year" ) ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF;

      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{0842e232-37ba-4aec-a27b-581fe16ea9aa}";;

    RULE                 "Refine Equalization Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule refines the annual release volume from Powell when either the Equalization Tier or Upper Elevation Balancing Tier B3 branch is operative for setting the annual release from Powell.  The release needs to be refined by this rule because when it is originally set, it is a preliminary &quot;guess&quot; for the volume it will take to arrive at the appropriate final (end of water year) condition (Equalized storage volumes, or Powell at a specific pool elevation at the end of the year - see Equalization Tier logic for more details as to what the final eowy condition should be).  This volume is then released and the end of year condition is checked against what it is supposed to be.  The first guess will almost always be off by some amount because of the non-linear elements in the water balance in both Powell and Mead of Evaporation and Bank Storage.  So rather than trying to set up a calculation or mini-simulation to calculate the exact right release volume to hit the end of water year condtion the first time, the guess volume is actually released and then this rule, because it can see the results of the original release, adjusts the release volume to eliminate the deviation from the target that it observes as a result of the initial guess release.  This rule is allowed to fire multiple times in a timestep and may do so in order to hit exactly the end of water year target condition. - sc 06/21/12<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT WITH DATETIME eoyDate = IF ( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
 THEN
  "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )
 ELSE
  "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )
 ENDIF COMMENTED_BY "Make sure using appropriate year value" DO
  ( "TierIs"( "Upper", @"t", TRUE ) OR "TierIs"( "Equalization", @"t", TRUE ) ) AND ( "GetRunCycleIndex"(  ) == 3.00000000 AND ( "HasRuleFiredSuccessfully"( "Set Equalization Release Volume" ) OR ( "HasRuleFiredSuccessfully"( "Set Upper Balancing Release Volume" ) AND $ "PowellData.UpperElevBalBranch" [eoyDate] == 1.30000000 ) ) ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
 ENDWITH;
    NOTES                "AUTHOR, DATE: SC, 06/21/2012<br><br>MC, 20171102: Added use of new slot PowellData.TARVTolerance to determine when refinement of TARV will stop.<br><br>S.Baker, 20180924: Added new Execution Constraint that looks at TierIs(). This allows the removal of the IF statement. Add time step run constraint to match IFs in rule.<br><br>S.Baker, 2018/10/17 & 2018/11/26: (edited #1 at later date)<br>(1) Added WITH statement to store TARV and use in IF statement to look if solved TARV was equal to previous TARV. Then, allow for setting of the PowellData.ReleaseVolumeSetFlag when TARV solved in the current iteration is equal to the previously set TARV. This is necessary for solving for the carryover release pattern from Powell. This occurs normally when TARV is not changed from 8.23 MAF. <br>(2) When calculating if the [ TARV - (CurrentAnnualRelease + VolumeDeviation) ] is within the TARV tolerance, carryover needs to be subtracted from the calculated volume. If there was a carryover volume calculated from the current year, the CurrentAnnualRelease would not account for this carryover volume that could not be released from Powell. <br>(3) When taking the MaxItem, the first IF statement needs to account for negative values for ReleaseAdjustment. This is done by taking the absolute value of ReleaseAdjustment. <br>(4) The calculation resulting from a true IF statement (in the MaxItem function) needs to account for carryover. The new TARV calculation should account be: [ CurrentAnnualRelease - Carryover(from last year if not UEB) + Release Adjust + Carryover(from current year) ] ";
    BEGIN

      IF_STATEMENT (( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) ) COMMENTED_BY "At Start Timestep for initial water year when release tier is either Upper Elevation Balancing or Equalization") THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t" ) )) DO
            IF_STATEMENT ("Abs"( ReleaseAdjustment ) > $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            WITH_STATEMENT (NUMERIC PowellnewTARV = "MaxItem"( { $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] + ReleaseAdjustment , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } )) DO
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := PowellnewTARV;

          DESCRIPTION          "If TARV solved in this rule is equal to the previous TARV solved, then set the <br>ReleaseVolumeSetFlag. This allow carryover releases to be set if necessary.  <br>";
      IF_STATEMENT (PowellnewTARV == $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Check in August timestep or StartMonth of September with UEBT or Equalization for outyear";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  )) THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t + 2" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t + 2" ) )) DO
            IF_STATEMENT ("Abs"( VolumeDeviation ) > 0.00000000 "acre-feet") THEN
            WITH_STATEMENT (NUMERIC CurrentAnnualRelease = FOR ( DATETIME dates IN "GetDates"( "OffsetDate"( @"24:00:00 September Max DayOfMonth, Next Year", - 11.00000000, "1 months" ), @"24:00:00 September Max DayOfMonth, Next Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Outflow" [dates], dates )
 ENDFOR) DO
          DESCRIPTION          "MC, 20171102: This version added to handle carryover situation by setting ReleaseVolumeSetFlag <br>";
      IF_STATEMENT ("Abs"( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] - ( CurrentAnnualRelease + VolumeDeviation ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) + 1.00000000 "year" )] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) ) > ( $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) COMMENTED_BY "The tolerance of the TARV slot; if the proposed change is less than this value the slot value won't change <br>") THEN
            WITH_STATEMENT (NUMERIC PowellnewTARV = "MaxItem"( { IF ( "Abs"( ReleaseAdjustment ) > 0.00000000 "acre-ft" )
 THEN
  ( CurrentAnnualRelease - IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 999.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] )
  ENDIF COMMENTED_BY "Remove the Carryover That has been Added from last year Unless an Equalization Tier is the <br>current tier. <br>" ) + ReleaseAdjustment + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) + 1.00000000 "year" )] )
 ELSE
  $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] + ReleaseAdjustment
 ENDIF , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } )) DO
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := PowellnewTARV;

            IF_STATEMENT (PowellnewTARV == $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )]) THEN
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{004129ca-00d8-4c75-a919-5b276b24b972}";;

    RULE                 "Set Upper Balancing Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Upper Elevation Balancing Tier for out years. It also sets the Upper Elevation Balancing Branch, which indicates the conditions controlling the release volume, and resets the Release Tier and the Controlling Equalization Condition if necessary (UEB Branch = 1.3)<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.UpperElevBalBranch; PowellData.ReleaseTier; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "TierIs"( "Upper", @"t", FALSE ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: Unknown<br><br>SB, 20190712: Added NaNToZero to PowelltoMead.Carryover() so rule doesnt fail. <br><br>MC, 20161215: In the conditional statement checking for EqualizationTeirCalculationForRelease, changed PowellToMeadData.AugEOYPowellPEProjection[meadProjectionDate] to Powell.Pool Elevation[DateToCheckEOWYElevation(@&quot;t&quot;,TRUE)]. The check needs to be on the EOWY pool elevation, not the previous year's projected EOY pool elevation, because this is checking to see if the decision tree should follow the branch from Upper Elevation Balancing to Equalization. I had incorrectly changed the date used when adding the carryover functionality.<br><br>MC, 20170511: The IsYearDemandVariabilityAndRunCycle4 condition will never be met because the rule does not execute in Run Cycle 4 due to the Execution Constraints<br><br>TP, 10/17/2017: Only allow out year to be set by this rule<br><br>MC, 20171102: This rule was changed by Tony to only operate on out years after the addition of two new rules that set WY1 only; I added IF-ELSE version to only set Release flag if NOT in EQ from UEB<br><br>S.Baker, 20180829: Added function 'GetMeadProjectedPoolElevation' instead of using Mead.Pool Elevation. Also, edited the function 'UpperEleavationBalancingBranchCalculation' to have the correct number of inputs. <br>S.Baker, 20180924: Added new Execution Constraint that looks at TierIs(). This allows the removal of the IF statement.<br>S.Baker, 20180925: Replaced function 'GetMeadProjectedPoolElevation' with function 'GetProjectedPoolElevation'.";
    BEGIN

    DESCRIPTION          "In August or September start month with UEBT for outyear";
      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", FALSE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) )
 THEN
  ( GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "DateToCheckEOWYElevation"( @"t", FALSE ) )] )
 ELSE
  IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Current Year" ) ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1075.00000000 "ft" )
  THEN
   "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ELSE
   "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ENDIF COMMENTED_BY "Determine which branch of UEBT to follow"
 ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue...";

    DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", FALSE ) )) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 0.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{a693c163-6bf2-41f9-b83f-93d706c536d3}";;

    RULE                 "Set Equalization Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) for out years when the Release Tier is Equalization. It also calculates and sets the Controlling Equalization Condition slot, which indicates the equalization condition that dictated the volume to be released.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "TierIs"( "Equalization", @"t", FALSE ) AND $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 0.00000000 AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) COMMENTED_BY "This rule only executes in Run Cycle 3; at the Start Timestep in September or in any August; with <br>a timestep more than 2 away from the model run finish; and if the rule has not already fired <br>successfully for the timestep and only sets volumes in out years <br>";
    NOTES                "AUTHOR, DATE: Unknown<br>Initial changes: sc 02/02/11;TP 08/20/2014; MC, 20170511; TP 10/17/2017  <br><br>S.Baker, 20180924: Added new Execution Constraint that looks at TierIs(). This allows the removal of the IF statement. Disabled PowellData.ReleaseVolumeSetFlag since this flag should be set in the Refine Equalization rule. ";
    BEGIN

      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "MaxItem"( { GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , 8230000.00000000 "acre-feet" } );

      $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

    INACTIVE      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END
    UUID "{9ba2115d-0379-411e-a5b3-c5ea3e72e673}";;

    RULE                 "Set Release Tier";
    DESCRIPTION          "DESCRIPTION: This rule fires at the Start Timestep and in August timesteps to set the Powell Release tier, as well as preliminarily setting the Upper Elevation Balancing Branch and Controlling Equalization Condition values to 999<br><br>SLOTS SET: PowellData.ReleaseTier; PowellData.UpperElevBalBranch; PowellData.ControllingEqualizationCondition<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination<br>S.Baker, 20180924: Added IsInput(TARV) constraint to execution constraints and removed from each IF statement in rule.<br>S.Baker, 20180925: Changed order of rules. Moved &quot;Set Release Tier&quot; to a higher priority than &quot;Preliminary Set Out Year Release Volume to 8.23MAF&quot;. This doesn't cause problems in the normal Powell policy group since the rule &quot;Set Release Tier&quot; doesn't have the EOCY Powell Pool Elevation. Therefore, the rule &quot;Set Release Tier&quot; is skipped until the rule &quot;Preliminary Set Out Year Release Volume to 8.23MAF&quot; has executed successfully. The rule priorities were changed to make the ruleset more efficiently. ";
    BEGIN

    DESCRIPTION          "Model needs to set the teir for the following water year if current timestep is August. <br>";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND @"t + 2" IN "WaterYearDatesByGroup"( 2.00000000 )) THEN
            WITH_STATEMENT (NUMERIC Carryover = NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] )) DO
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - Carryover )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( IF ( @"t" == @"Start Timestep" )
 THEN
  $ "PowellToMeadData.AugEOYPowellPEProjection" ["DateToCheckJan1Elevation"( @"t + 2", TRUE )]
 ELSE
  EffectivePoolElevation
 ENDIF, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "The model will set the tier for the third year of the model run (second out year)";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 3.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Third out year of the model run";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 4.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Fourth out year of model run";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 5.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Fifth out year of model run if it exists in the forecast";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 6.00000000 )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{f9011329-c1b8-44d2-af80-f51d7715c21e}";;

    RULE                 "Preliminary Set Out Year Release Volume To 8.23MAF";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: SC, 03/25/2011<br>MC, 20160728: Changed the local variable &quot;watYearIndex&quot; name to &quot;waterYearNumber&quot; for consistency with the rule Set Powell Outflow; make a function to do the calculation?; added the setting of Powell.Outflow values for testing with new carryover functionality<br>MC, 20170405: Can add use of user-defined function GetWaterYearNumber in calculation of local varaible waterYearNumber<br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.<br>S.Baker, 20180925: Changed order of rules. Moved &quot;Set Release Tier&quot; to a higher priority than &quot;Preliminary Set Out Year Release Volume to 8.23MAF&quot;. This doesn't cause problems in the normal Powell policy group since the rule &quot;Set Release Tier&quot; doesn't have the EOCY Powell Pool Elevation. Therefore, the rule &quot;Set Release Tier&quot; is skipped until the rule &quot;Preliminary Set Out Year Release Volume to 8.23MAF&quot; has executed successfully. The rule priorities were changed to make the ruleset more efficiently. ";
    BEGIN

      WITH_STATEMENT (NUMERIC waterYearNumber = ( "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF ) COMMENTED_BY "See notes on this calculation in Preliminarily Set Navajo Outflow to Desired Base Flow") DO
            WITH_STATEMENT (NUMERIC AvailablePowellWater = ( IF ( "GetMonth"( @"Start Timestep" ) == 9.00000000 )
 THEN
  $ "Powell.Storage" [@"t - 1"]
 ELSE
  $ "Powell.Storage" [@"t + 1"]
 ENDIF COMMENTED_BY "MC, 20170510: I don't understand the timesteps used for the <br>below condition" + FOR ( DATETIME date IN "WaterYearDatesByGroup"( waterYearNumber ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Inflow" [date], date )
 ENDFOR ) COMMENTED_BY "This is added to check that in years when Powell might go very low, the model won't bomb out <br>when setting the preliminary release when Powell is low. TP 1/22/2013<br>") DO
            WITH_STATEMENT (DATETIME WY_EndOfCalendarYearDate = "Dec31ofYear"( "OffsetDate"( "RelativeEOWYDate"( @"Start Timestep" ), waterYearNumber - 1.00000000, "1 years" ) )) DO
            WITH_STATEMENT (NUMERIC VolumeToRelease = "Min"( "MaxItem"( { 8230.00000000 "1000 acre-feet" , WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  "Min"( 8230.00000000 "1000 acre-feet", releaseTable ["AnnualTotal", "NumColumns"( releaseTable ) - 2.00000000] )
 ENDWITH COMMENTED_BY "Ensure release enough so Powell doesn't exceed max pool elevation" , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" [WY_EndOfCalendarYearDate] ) COMMENTED_BY "User input minimum annual release volume" } ), AvailablePowellWater )) DO
            IF_STATEMENT (NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", WY_EndOfCalendarYearDate )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" [WY_EndOfCalendarYearDate] := VolumeToRelease;

      END_IF_STATEMENT;

          INACTIVE    DESCRIPTION          "Set Powell.Outflow values based on preliminary Target Annual Release Volume";
      IF_STATEMENT (NOT IsNaN $ "Powell.Outflow" ["RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 AND @"t" == @"Start Timestep" )
 THEN
  waterYearNumber
 ELSE
  waterYearNumber - 1.00000000
 ENDIF ) )]) THEN
            FOREACH (LIST dateRelease IN "GetPowellReleasesCorrectedForBypass"( "Sort"( "GetPowellMonthlyReleases_v2"( "WaterYearDatesByGroup"( waterYearNumber ), VolumeToRelease ) ) )) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{384fa5e9-52e1-4d86-8e40-4f9e0c257d01}";;

    RULE                 "Set WY1 Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) for the first WY for any release Tier designation. It also calculates and sets the Controlling Equalization Condition slot, which indicates the condition that dictated the volume to be released based on which Tier has been set. <br><br>SLOTS SET: Some combination of the following - PowellData.TargetAnnualReleaseVolume; PowellData.ControllingEqualizationCondition; PowellData.UpperElevBalBranch<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) COMMENTED_BY "This rule only executes in Run Cycle 3; at the Start Timestep for only the first WY;  and if the rule <br>has not already fired successfully for the timestep <br>";
    NOTES                "AUTHOR, DATE: Unknown<br>Initial changes: SC 02/02/11;TP 08/20/2014; MC, 20170511; TP 10/13/2017  <br><br>TP: 20171017: Added and set the rule to only set the first water year.<br><br>S.Baker, 20180829: Edited the function 'UpperEleavationBalancingBranchCalculation' to have the correct number of inputs. Edited setting of 'PowellData.UpperElevBalBranch to check if this value is input before trying to set it. This issue was initially causing this rule to exit without setting values. <br>S.Baker, 20180921: Removed run cycle constraint in rule (2nd IF). Removed IF @t = start timestep within rules since this is an execution constraint. Added IsInput(TARV) constraint to execution constraints and removed from each IF statement in rule.";
    BEGIN

      IF_STATEMENT ("TierIs"( "Equalization", @"t", TRUE ) COMMENTED_BY "Initial water year, in an Equalization Condition in Start Year <br>") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , 8230000.00000000 "acre-feet" } );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep in Run Cycle 3 with UEBT in Start Year";
      IF_STATEMENT ("TierIs"( "Upper", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := WITH DATETIME meadProjectionDate = IF ( @"t" <= @"September 30" )
 THEN
  @"24:00:00 December 31, Previous Year"
 ELSE
  @"24:00:00 December 31, Current Year"
 ENDIF DO
  IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", TRUE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.30000000 ) )
  THEN
   GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) )
  ELSE
   IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" [meadProjectionDate] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) ) >= 1075.00000000 "ft" OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND NOT $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.20000000 ) )
   THEN
    "Max"( "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ELSE
    "Max"( "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ENDIF COMMENTED_BY "Determine which branch of UEBT to follow"
  ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue..."
 ENDWITH;

          DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = IF ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) )
 THEN
  $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]
 ELSE
  "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", TRUE ) )
 ENDIF) DO
          DESCRIPTION          "Check if branch is input before trying to set slot <br>";
      IF_STATEMENT (NOT "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := upperElevBranch;

      END_IF_STATEMENT;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 0.00000000;

            IF_STATEMENT (NOT "IsInput"( $ "PowellData.ControllingEqualizationCondition", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep with Mid-Elevation tier in initial water year";
      IF_STATEMENT ("TierIs"( "Mid", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF, NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep with Lower Balancing Release Tier in initial water year";
      IF_STATEMENT ("TierIs"( "Lower", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

      END_IF_STATEMENT;

    END
    UUID "{7561a941-f58b-4338-99f6-5cf62ad5033d}";;

    RULE                 "Set WY1 Release Tier";
    DESCRIPTION          "DESCRIPTION: This rule fires at the Start Timestep and in August timesteps to set the Powell Release tier, as well as preliminarily setting the Upper Elevation Balancing Branch and Controlling Equalization Condition values to 999, for the First Water Year<br><br>SLOTS SET: PowellData.ReleaseTier; PowellData.UpperElevBalBranch; PowellData.ControllingEqualizationCondition";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND ( "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) AND IsNaN $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )];
    NOTES                "AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination<br>TP, 20171017: Added this rule and only allow it to execute in the start timestep for the first water year<br>S.Baker, 20180924: Added IsNaN(ReleaseTier) constraint to execution constraints. <br><br><br>";
    BEGIN

    DESCRIPTION          "Model needs to set the teir for the current year if at the start timestep, regardless of month. <br>";
      $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "PowellReleaseTier"( $ "PowellToMeadData.AugEOYPowellPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )], "RelativeEOWYDate"( @"t" ) );

      IF_STATEMENT (IsNaN $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

    END
    UUID "{ccd7a271-a9bc-435b-8ca2-afb3947b3e3b}";;

    RULE                 "Preliminary Set WY1 Release Volume To 8.23MAF";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) );
    NOTES                "AUTHOR, DATE: SC, 03/25/2011<br>MC, 20160908: Previously added SumFlowsToVolume(...) to MaxItem; added IF-ELSE to deal with October when no previous WY release would have occurred<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.<br>S.Baker, 20180924: Added IsInput(TARV) constraint to execution constraints. <br>S.Baker, 2018/10/17: Changed column number in releaseTable[AnnualVolume, Ncol - 3]<br>MTOM was failing in testbed runs in this rule in high inflow years when Powell was trying to release a large volume. In the historical run of 1983-06, the model aborted since it sets the initial TARV to 30 MAF based on the condition releaseTable[AnnualVolume, Ncol ? 2].  This caused the model to look for too high of upper bound in the function ?CalculatePowellMonthlyRelease?.  The upper bound was being reset in function 'FindRemainingReleaseUpperBoundColumn' by adding + 1 index which cause model to look for table index that didn?t exist. When we use Ncol ? 3, the TARV is initially set to 20 MAF and MTOM runs successfully finding a realistic TARV (18 MAF). ";
    BEGIN

      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { 8230.00000000 "1000 acre-feet" , WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  "Min"( "CalcReleaseForMaxPoolElevation"( "WaterYearDatesByGroup"( 1.00000000 ) ), releaseTable ["AnnualTotal", "NumColumns"( releaseTable ) - 3.00000000] )
 ENDWITH COMMENTED_BY "Ensure enough water released so Powell does not exceed max pool elevation" , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) COMMENTED_BY "User input min annual volume was added to allow overriding automatic determination" , IF ( "GetMonth"( @"t" ) != 10.00000000 )
 THEN
  "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( @"t", "MonthsSinceEOWY"( @"t" ), "-1 months" ), @"Start Timestep - 1" )
 ELSE
  0.00000000 "acre-foot"
 ENDIF COMMENTED_BY "Ensure TARV is not less than volume already released in water year" } );

    END
    UUID "{9b30a316-5de8-44fc-88d2-411206e90a9d}";;

    RULE                 "Set Powell Outflow";
    DESCRIPTION          "DESCRIPTION: In most months, interpolate values from the monthly release table using the current value of annual release volume. In August and September the annual release volume has already been set for the subsequent water year, so use the previous water year's annual volume. <br><br>SLOTS SET: Powell.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep";
    NOTES                "AUTHOR, DATE: Unknown<br><br>SB, 20190712: Edited how carryover is set. Added IF so carryover is only set during EQ or UEBT. This is what is done in CRSS. Carryover was causing this rule to reach max executions when Powell and Mead were at very low pool elevations. ";
    BEGIN

      IF_STATEMENT (@"t" == @"Start Timestep" AND NOT IsNaN $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )]) THEN
            WITH_STATEMENT (LIST PowellOutflowsAndCarryover = "GetPowellReleasesCorrectedForBypass"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( 1.00000000 ) ) )) DO
          DESCRIPTION          "Set the outflow for the initial water year, checking for the necessity of bypass based on pool elevations";
      FOREACH (LIST dateRelease IN PowellOutflowsAndCarryover) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

          DESCRIPTION          "Track carryover only if Powell is in UEBT or Equalization, not LEBR or MEBR  <br>";
      IF_STATEMENT ("TierIs"( "Equalization", @"t", TRUE ) OR "TierIs"( "Upper", @"t", TRUE )) THEN
            WITH_STATEMENT (NUMERIC iterMax = ( LENGTH PowellOutflowsAndCarryover ) - 1.00000000) DO
            WITH_STATEMENT (DATETIME CarryoverYear = "OffsetDate"( "Dec31ofYear"( GET @INDEX 0.00000000 FROM GET @INDEX iterMax FROM PowellOutflowsAndCarryover ), 12.00000000, "1 Months" )) DO
            $ "PowellToMeadData.CarryoverVolume" [CarryoverYear] := "Max"( "Floor"( GET @INDEX 3.00000000 FROM GET @INDEX iterMax FROM PowellOutflowsAndCarryover, 1.00000000 "acre-feet" ), 0.00000000 "acre-feet" );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      WITH_STATEMENT (NUMERIC waterYearNumber = ( "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF ) COMMENTED_BY "Calculate water year number for outyears") DO
            WITH_STATEMENT (DATETIME WaterYear = "Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
            IF_STATEMENT ("IsInput"( $ "PowellData.TargetAnnualReleaseVolume", WaterYear )) THEN
            FOREACH (LIST dateRelease IN "Sort"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

      ELSE
            IF_STATEMENT (( NOT IsNaN $ "PowellData.TargetAnnualReleaseVolume" [WaterYear] ) COMMENTED_BY "TARV for waterYearNumber has been set" AND ( NOT IsNaN $ "Powell.Outflow" ["RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( IF ( ( "GetMonth"( @"Start Timestep" ) > 9.00000000 AND @"t" == @"Start Timestep" ) COMMENTED_BY "in StartTimestep>Sep" )
 THEN
  waterYearNumber
 ELSE
  ( waterYearNumber - 1.00000000 ) COMMENTED_BY "in StartTimestep<=Sep OR non-StartTimestep August"
 ENDIF ) )] ) COMMENTED_BY "Outflow for Sep 30 of the current or prior water year is set (either by rule or as input)<br>MC, 20170510: I don't understand the necessity of this condition") THEN
            WITH_STATEMENT (LIST PowellOutflowsAndCarryover = "GetPowellReleasesCorrectedForBypass"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
          DESCRIPTION          "Set the monthly Powell Releases for the Water Year <br>";
      FOREACH (LIST dateRelease IN PowellOutflowsAndCarryover) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

          DESCRIPTION          "Track carryover only if Powell is in UEBT or Equalization, not LEBR or MEBR  <br>";
      IF_STATEMENT ("TierIs"( "Equalization", @"t", FALSE ) OR "TierIs"( "Upper", @"t", FALSE )) THEN
          DESCRIPTION          "If there is carryover volume in the last element of the PowellOutflowsAndCarryover List, then <br>add that to the next Water Year to be released in the next water year.  <br>";
      WITH_STATEMENT (DATETIME CarryoverYear = "Dec31ofYear"( WaterYear + 1.00000000 "year" )) DO
            $ "PowellToMeadData.CarryoverVolume" [CarryoverYear] := "Max"( "Floor"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH PowellOutflowsAndCarryover ) - 1.00000000 FROM PowellOutflowsAndCarryover, 1.00000000 "acre-feet" ), 0.00000000 "acre-feet" );

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{db2794b4-ad21-451b-99d5-cc1c1ccc2536}";;

  END
  UUID "{b598eb01-ae32-4ca3-b3e5-951d80941e68}";;

  POLICY_GROUP   "Navajo";
  DESCRIPTION    "SB, 20180501: Old 1999 spring peak release operational protocol. Need to impliment new spring peak release method.<br><br>The main goals of the operations of Navajo Reservoir are to benefit the environmental needs of the San Juan River, the irrigators downstream of Navajo Reservoir, the diversion of NIIP water from Navajo Reservoir, and other municipal and industrial uses throughout the San Juan Basin. The environmental requirements are detailed in Flow Recommendations for the San Juan River, May 1999 (1999 Flow Recommendations) prepared by the San Juan River Basin Recovery Implementation Program (SJRIP). A general overview of the 1999 Flow Recommendations from Chapter 8 of the document includes: <br>         Flows greater than 10,000 cfs during spring runoff must flow for a minimum of 5 days between March 1 and July 31 in 20% of the years with a maximum interval of 11 years. <br>         Flows greater than 8,000 cfs during spring runoff must flow for a minimum of 10 days between March 1 and July 31 in 33% of years with a maximum interval of 7 years. <br>         Flows greater than 5,000 cfs during spring runoff must flow for a minimum of 21 days between March 1 and July 31 in 50% of the years with a maximum interval of 5 years. <br>         Flows greater than 2,500 cfs during spring runoff must flow for a minimum of 10 days between March 1 and July 31 in 80% of the years with a maximum interval of 3 years. <br>         Peak flows must occur within 5 days of the historic mean peak date of May 31 (based on modeling for the period 1929 ? 1993). <br>         Weekly target base flows are 500 cfs but range between 500 and 1,000 cfs where the actual target flow is the average of the weekly base flow at three of four stream flow gaging stations on the San Juan River below Navajo in accordance with the Biological Opinion. <br>         Flood control releases will be handled as high magnitude, short duration spikes and releases when the flood control rules require except the release shall not occur earlier than September 1 unless necessary for protection of life and property. <br>The operations at Navajo Reservoir call for a spring peak flow to occur between April and July and base flow operations to occur the rest of the year. The spring peak is determined using the flow chart in Figure 8.1 of the 1999 Flow Recommendations document. The date of the spring peak release is determined by the flow from the Animas River downstream of Navajo Reservoir and is within the specified time range of the 1999 Flow Recommendations. <br>During base operations there is a weekly minimum flow target of an average of 500 cfs at each of four gaging stations downstream of the confluence with the Animas River: Farmington, Shiprock, Four Corners, and Bluff. The target flow range at each of the four gages is between 500 and 1,000 cfs; the modeled flows depend on the hydrologic conditions in the basin and the local inflows between Navajo Reservoir and the gaging stations. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Fall Peak Release ";
    DESCRIPTION          "DESCRIPTION: This Rule Uses the already set pool elevations for Navajo from the prevoius rule and uses the October Pool elevation to check if the elevation is above 6,065 ft.  If the volume at the beginning of October is above 6,065, then increase the September release so the pool elevation at the beginning of October is 6,065.  The reason we are looking at the October pool elevation is in the rare event that October is Wet, then the pool elevation in September will allow for the high flows in October to result in a Pool Elevation of 6,065 heading into the Winter months.  If we use the September Pool elevation and don' t release enough the system might have to release more the next spring than needed. <br><br>This rule only fires in months after the Spring Peak Release cannot be set (July - September) and only after the model has the opportunity to set outflows from Navajo at the maximum 1,000 cfs per day for the months of July - September. <br><br>SLOTS SET: Navajo.Outflow[September, Current Year]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonth"( @"t" ) >= 7.00000000 AND "GetMonth"( @"t" ) <= 9.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: TP 9/13/2012<br><br>MC, 20170502: The description written by Tony suggests the rule is targeting an end of October pool elevation, but the rule is setting the September outflow to lead to a beginning of October (end of September) target pool elevation";
    BEGIN

    DESCRIPTION          "Retrieve the storage at the beginning of October (end of September)";
      WITH_STATEMENT (NUMERIC NavajoOctoberStorage = "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [@"24:00:00 September Max DayOfMonth, Current Year"] )) DO
          DESCRIPTION          "Retrieve the end of water year target pool elevation";
      WITH_STATEMENT (NUMERIC TargetPEStorage = "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" ["Dec31ofYear"( @"24:00:00 September Max DayOfMonth, Current Year" )] )) DO
          DESCRIPTION          "If the October storage is greater than that of the target, increase the release to meet the target";
      IF_STATEMENT (NavajoOctoberStorage > TargetPEStorage) THEN
            $ "Navajo.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"] := $ "Navajo.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"] + "VolumeToFlow"( NavajoOctoberStorage - TargetPEStorage, @"24:00:00 September Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{e13a04a1-4575-487e-91f0-7b70a7ada925}";;

    RULE                 "Dam Protection Flood Control";
    DESCRIPTION          "DESCRIPTION: If Navajo Pool Elevation is in threat of going above the maximum pool elevation (6,082 ft) then release the amount of outflow to reduce the pool elevation to the max pool elevation. This rule is a flood protection rule. <br><br>SLOTS SET: Navajo.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      WITH_STATEMENT (DATETIME EndOfWY = @"24:00:00 September 30, Current Year") DO
            IF_STATEMENT ($ "Navajo.Pool Elevation" [] > $ "NavajoData.PostDamProtectionPE" []) THEN
          DESCRIPTION          "Calculate list of lists of form &lcub;Modified outflow, Outflow volume modification, Volume released to achieve dam protection&rcub;";
      WITH_STATEMENT (LIST damProtectionNavajo = "NavajoAboveMaxPEOperations"(  )) DO
          DESCRIPTION          "Update outflow";
      $ "Navajo.Outflow" [] := GET @INDEX 0.00000000 FROM damProtectionNavajo;

            $ "NavajoData.DamProtectionFlag" [@"t"] := 1.00000000;

          DESCRIPTION          "Store annual volume released for dam protection";
      $ "NavajoData.VolumeReleasedForDamProtection" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM damProtectionNavajo;

            IF_STATEMENT (@"t" < EndOfWY) THEN
            WITH_STATEMENT (NUMERIC lessRelFromNav = GET @INDEX 2.00000000 FROM damProtectionNavajo) DO
          DESCRIPTION          "Reduce remaining WY outflows to account for released volume, but not below base release value";
      FOREACH (DATETIME date IN @"t + 1" TO EndOfWY) DO
            WITH_STATEMENT (NUMERIC numberOfMonths = "GetMonth"( EndOfWY ) - "GetMonth"( @"t" )) DO
            $ "Navajo.Outflow" [date] := "Max"( $ "Navajo.Outflow" [date] - "VolumeToFlow"( lessRelFromNav / numberOfMonths, date ), $ "NavajoData.BaseRelease" [] );

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{252de405-ae8d-4e31-a66d-547d1115e403}";;

    RULE                 "Reduce Outflow and Diversions if Navajo is below Min Level";
    DESCRIPTION          "DESCRIPTION: If the reservoir is in threat of going below 5,990 ft, apply shortage sharing to the outflow of Navajo and NIIP diversions.<br><br>SLOTS SET: Navajo.Outflow; NavajoIndianIrrigationProjectNIIP.Diversion<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsLowFlowAdjustmentNecessary"(  ) AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (LIST DateDiffR IN "DetermineLowFlowsatNavajo"(  )) DO
            $ "Navajo.Outflow" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 1.00000000 FROM DateDiffR;

            $ "NavajoIndianIrrigationProjectNIIP.Diversion" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 2.00000000 FROM DateDiffR;

          INACTIVE      $ "NavajoIndianIrrigationProjectNIIP.Depletion Requested" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 2.00000000 FROM DateDiffR;

      ENDFOREACH;

    END
    UUID "{c4aa7edc-31a4-4ac6-b8db-635f00f72db7}";;

    RULE                 "SumNavajoOutflowtoMonthly";
    DESCRIPTION          "DESCRIPTION: Solve Navajo Daily outflow on the data object and set the monthly outflow on the Reservoir simulation object.  This rule only on the start timestep and in March timesteps.<br><br>SLOTS SET: Navajo.Outflow<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: TP 9/30/2015";
    BEGIN

      WITH_STATEMENT (DATETIME endDate = IF ( "GetMonth"( @"t" ) < 3.00000000 )
 THEN
  @"24:00:00 February Max DayOfMonth, Current Year"
 ELSE
  @"24:00:00 February Max DayOfMonth, Current Year + 12"
 ENDIF) DO
            IF_STATEMENT (@"t" == @"Start Timestep") THEN
            FOREACH (DATETIME date IN "GetDates"( @"t", endDate, "1 months" )) DO
            $ "Navajo.Outflow" [date] := "VolumeToFlow"( "DetermineNavajoMonthlyFlowVolumeNew"( date ), date );

      ENDFOREACH;

      END_IF_STATEMENT;

            IF_STATEMENT ("MonthIs"( { "March" } )) THEN
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 31, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 months" )) DO
            $ "Navajo.Outflow" [date] := "VolumeToFlow"( "DetermineNavajoMonthlyFlowVolumeNew"( date ), date );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{95fb933b-6275-42ad-8e67-e8476f0e23ce}";;

    RULE                 "March through July Daily Release";
    DESCRIPTION          "DESCRIPTION: Calculate the Daily release given the policy constraints outlined by the Flow recomendation document from the San Juan Flow Recommendations and recommendations on the policy by the Bureau of Reclation.  These flows will be based on the policy from the release level calculated and not the actual available water. That will come after a scale value is applied. <br><br>SLOT SET: NavajoData.MarchThruJulyDaily<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP, 20120531 (?)";
    BEGIN

    DESCRIPTION          "Determine the Daily Releases from Navajo Reservoir for the release level and spring peak volumes";
      FOREACH (DATETIME date IN "GetDates"( @"t - 1", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.MarchThruJulyDaily" [date] := "DailyOutflowsForNavajo"( date, $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoData.NoseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoData.ExcessOfRelease" ["Dec31ofYear"( @"t" )] );

      ENDFOREACH;

    END
    UUID "{0193b39c-4e50-4bf7-bffc-f22637d74f87}";;

    RULE                 "DetermineReleaseLevelValues";
    DESCRIPTION          "DESCRIPTION: Determine the release level (0-4) for the spring release based on the calculated available flow to achieve the EOWYTargetPE. The determination of level is based on the values in the SpringPeakReleaseLevels table.  The Rule sets the Release Level, the Spring Peak Release Volume, the Nose Level (If Applicable), the Nose Volume (if Applicable), and the excess of a Nose Volume (If Applicable).<br><br>SLOTS SET: NavajoData.ReleaseLevel; NavajoData.SpringPeakRelease; NavajoData.NoseLevel; NavajoData.SpringPeakNose; NavajoData.ExcessOfRelease<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "March" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: TP, 5/31/2012 (?)<br><br>MC, 20170717: Reorganized rule to combine the cases for Month == March and (Start Timestep AND Month < Oct)";
    BEGIN

    DESCRIPTION          "Determines the Release Levels, Nose Levels and Volumes to be set to meet the Navajo Target elevation <br>for the end of September.  This rule only executes on the start timestep or in March.";
      WITH_STATEMENT (LIST EoWYRelLevel = "DetermineNavajoEoWYReleaseLevel"( "Dec31ofYear"( @"t" ) )) DO
            IF_STATEMENT (@"t" == @"Start Timestep" AND "GetMonth"( @"t" ) >= 10.00000000) THEN
          DESCRIPTION          "Set all values to zero";
      IF_STATEMENT (NOT "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( @"t" ) )) THEN
            $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )] := 0.00000000;

      END_IF_STATEMENT;

            $ "NavajoData.SpringPeakRelease" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

            $ "NavajoData.NoseLevel" ["Dec31ofYear"( @"t" )] := 0.00000000;

            $ "NavajoData.SpringPeakNose" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

            $ "NavajoData.ExcessOfRelease" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

      ELSE
          DESCRIPTION          "Month is March or (Start Timestep AND Month < 10) <br>";
      IF_STATEMENT (NOT "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( @"t" ) )) THEN
            $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM EoWYRelLevel;

      END_IF_STATEMENT;

            $ "NavajoData.SpringPeakRelease" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM EoWYRelLevel;

            $ "NavajoData.NoseLevel" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM EoWYRelLevel;

            $ "NavajoData.SpringPeakNose" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM EoWYRelLevel;

            $ "NavajoData.ExcessOfRelease" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM EoWYRelLevel;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{ae014cdc-e3af-453b-a984-47582f24ec07}";;

    RULE                 "Preliminarily Set Navajo Outflow to Desired Base Flow";
    DESCRIPTION          "DESCRIPTION: This rule sets the outflow from Navajo for the current timestep to the end of February of the next year. The outflow is set to the greater of the Base Release or what is necessary, together with the Animas contribution, to meet the downstream flow targets. Doing this allows Navajo to solve for the Available water calculation.<br><br>SLOTS SET: Navajo.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "For the current timestep to the End of February of the next year, set the outflow from Navajo to the greater of <br>the Base Release from Navajo or what is necessary to meet the downstream flow targets with the Animas <br>contribution. Doing this will allow Navajo to solve for the Available water calculation";
      WITH_STATEMENT (NUMERIC waterYearNumber = ( "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF ) COMMENTED_BY "This variable is not used in the body, so delete it.") DO
            WITH_STATEMENT (LIST dateList = IF ( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( @"t" ) ) AND "GetMonth"( @"t" ) < 10.00000000 )
 THEN
  @"t" TO "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12 Month", @"Finish Timestep" )
 ELSE
  @"t" TO "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12 Month", @"Finish Timestep" )
 ENDIF COMMENTED_BY "MC, 20170508: Both conditions use the same calculation?") DO
            FOREACH (DATETIME date IN dateList) DO
            $ "Navajo.Outflow" [date] := "Max"( $ "NavajoData.MinTargetBaseflow" [] - $ "AnimasRiverInflow.Animas_at_Durango" [date], $ "NavajoData.BaseRelease" [] );

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{82e1f2ad-ebbe-420b-bec3-6d7762bef2ea}";;

    RULE                 "SetNavajoDiversions";
    DESCRIPTION          "DESCRIPTION: Sets the NIIPDiversions Requested slot, the SanJuanBelowNavajo.TotalDiversion Slot, and NIIP.Fractional Return Flow Slot values based on user input.  The Fractional Inflow values will at some point need to be changed in the future to the value that would be the fractional return flow. This rule fires so that the input values in the NavajoData.NIIPAnnualRequest and NavajoData.SJDownstreamDiversions slots  are assigned if input is provided for those two slots. <br><br>SLOTS SET: SanJuanBelowNavajo.Total Diversion; NavajoIndianIrrigationProjectNIIP.Fractional Return Flow; NavajoIndianIrrigationProjectNIIP.Diversion; Azotea Tunnel.Diversion<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND @"t" == @"Start Timestep";
    NOTES                "AUTHOR, DATE: TP, 8/5/2012 (?)";
    BEGIN

    DESCRIPTION          "Set the Diversions for the NIIP and Azotea Tunnel to the Diversion Requests so that the <br>appropriate water is allowed to be diverted.  For the Azotea Tunnel diversion make sure a <br>minimum flow is left in the Upper San Juan River above Navajo. ";
      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (IsNaN $ "SanJuanBelowNavajo.Total Diversion" [date]) THEN
            $ "SanJuanBelowNavajo.Total Diversion" [date] := $ "NavajoData.SJDownstreamDepletions" [date, 0.00000000];

      END_IF_STATEMENT;

            $ "NavajoIndianIrrigationProjectNIIP.Fractional Return Flow" [date] := 0.00000000;

            $ "NavajoIndianIrrigationProjectNIIP.Diversion" [date] := $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [date];

            $ "Azotea Tunnel.Diversion" [date] := "Min"( $ "Azotea Tunnel.Diversion Requested" [date], "Max"( $ "UpperSanJuan.Inflow" [date] - $ "NavajoData.UpperSanJuanMinFlow" [date, 0.00000000], 0.00000000 "cfs" ) );

      ENDFOREACH;

    END
    UUID "{c2a7d396-3fd7-4241-aff3-ade982c96f28}";;

  END
  UUID "{ace26fd8-670c-4d8a-b177-5911c12384ad}";;

  POLICY_GROUP   "Flaming Gorge ";
  DESCRIPTION    "CF, 20180501: Operations have changed since 2012 and continue to evolve according to the FGTWG. <br><br>The operations of Flaming Gorge Reservoir meet the requirements detailed in the 2006 Record of Decision for the Operation of Flaming Gorge Dam Final Environmental Impact Statement (2006 ROD) that were designed to achieve the authorized purposes of the CRSP Act while addressing environmental requirements. The 2006 ROD outlines the operational guidelines of Flaming Gorge and implements, to the extent possible, recommendations to assist in the recovery of four endangered fish species, outlined in the 2000 Flow and Temperature Recommendations for Endangered Fish in the Green River Downstream of Flaming Gorge Dam (2000 Flow and Temperature Recommendations). This report outlines the peak flow magnitudes, high flow duration, and outflow temperature recommendations for three reaches of the Green River: <br><br>Reach 1<br>Reach 1 is 65 river miles long, beginning at Flaming Gorge Dam and ending at the confluence of the Green and Yampa Rivers. Flaming Gorge Dam releases comprise the primary component of Green River flow in this reach. The peak flow requirements for Reach 1 are compiled in Table 5.4 of the 2000 Flow and Temperature Recommendations and are summarized below. <br>Peak flow magnitude of at least 4,600 cfs each year and at least 8,600 cfs in wet years (0 to 10% Exceedance) <br>  <br>The peak flow period should coincide with the spring peak and immediate post peak flows of the Yampa River <br>  <br>Reach 1 Mean baseflow magnitude requirements are established for five hydrologic year classifications: <br>o   Wet (0-10% Exceedance): between 1,800 and 2,700 cfs <br>o   Moderately Wet (10-30% Exceedance): between 1,500 and 2,600 cfs <br>o   Average (30-70% Exceedance): between 800 and 2,200 cfs <br>o   Moderately Dry (70-90% Exceedance): between 800 and 1,300 cfs <br>o   Dry (90-100% Exceedance): between 800 and 1,000 cfs <br>  <br>The daily rate of decline from the peak flow period is limited as follows: <br>o   For Wet and Moderately Wet years (0-30% Exceedance):  approximately 1,000 cfs /day <br>o   For Average years (30-70% Exceedance):  approximately 500 cfs /day <br>o   For Dry and Moderately Dry years (70-100% Exceedance):  approximately 350 cfs /day <br>Where applicable, the historic unregulated Flaming Gorge inflow between the years of 1963 and 1996 are used to determine the respective percent exceedances for the criteria established. Hydrologic classifications and percent exceedances for the Yampa River basin are established using the historic record from 1922 to 1996. This is the case for all reaches. <br><br>Reach 2<br>Reach 2 is 99 river miles in length and extends from the confluence of the Green and Yampa Rivers to the confluence of the Green and White Rivers. In this reach, Flaming Gorge Dam releases and the Yampa River are the primary contributors to river flow. Flow recommendations establish peak flow and sustained high flow requirements at the Green River at the Jensen, Utah USGS stream gage for five hydrologic year types. These requirements are established in Table 5.5 of the 2000 Flow and Temperature Recommendations and are summarized below. <br>Peak releases should coincide with the annual spring peak and immediate post peak of the Yampa River <br>  <br>Peak flow magnitude recommendations measured on the Green River at Jensen are established for five hydrologic classifications as follows: <br>o   Wet (0-10% Exceedance): at least 26,400 cfs <br>o   Moderately Wet (10-30% Exceedance): at least 20,300 cfs <br>o   Average (30-70% Exceedance): at least 18,600 cfs in one of two average years and 8,300 cfs in other average years <br>o   Dry and Moderately Dry (70-100% Exceedance): at least 8,300 cfs <br>  <br>Recommendations for the duration of peak flows are established as follows: <br>o   Wet (0-10% Exceedance): maintain at least 22,700 cfs for at least 2 weeks and 18,600 cfs for at least 4 weeks <br>o   Moderately Wet (10-30% Exceedance): maintain at least 18,600 cfs for at least 2 weeks <br>o   Average (30-70% Exceedance): maintain at least 18,600 cfs for at least 2 weeks in 1 of 4 average years <br>o   Moderately Dry (70-90% Exceedance): maintain at least 8,300 cfs for at least 1 week <br>o   Dry (90-98% Exceedance): maintain at least 8,300 cfs for at least 2 days <br>o   Extremely Dry (98-100% Exceedance): no flow duration recommendations <br>  <br>Mean baseflow magnitudes are recommended for each hydrologic classification as follows: <br>o   Wet (0-10% Exceedance): between 2,800 and 3,000 cfs <br>o   Moderately Wet (10-30% Exceedance): between 2,400 and 2,800 cfs <br>o   Average (30-70% Exceedance): between 1,500 and 2,400 cfs <br>o   Moderately Dry (70-90% Exceedance): between 1,100 and 1,500 cfs <br>o   Dry (90-100% Exceedance): between 900 and 1,100 cfs <br><br>Rate of decline from the peak flow is regulated by the rate of decline in Reach 1 and the rate of decline of the Yampa River <br>  <br>Baseflow variation should be consistent with the variability observed in the pre-dam era <br><br>Reach 3 <br>Reach 3 is 246 river miles in length and extends from the confluence of the White and Green River to the confluence of the Green and Colorado Rivers. Flow in this reach is supplemented primarily by tributary flow from the White, Duchesne, Price, and San Rafael Rivers as well as releases from Flaming Gorge Dam and flow from the Yampa River. Although independent flow recommendations were outlined for Reach 3 as well as Reaches 1 and 2, it is assumed that meeting the flow requirements in Reach 1 and Reach 2 will result in the flow requirements for Reach 3 being adequately met. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Calculate Daily Jensen Flows";
    DESCRIPTION          "DESCRIPTION: Calculates the daily Jensen flow using daily FG releases and daily Yampa flows with the assumption that FG releases are lagged one day.<br><br>SLOTS SET: KNN_MTOM.JensenDaily<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Calculates the daily Jensen flow using daily FG releases and daily Yampa flows with the assumption <br>that FG releases are lagged one day.";
      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.JensenDaily" [date] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  $ "KNN_MTOM.FlamingGorgeDaily" [date]
 ELSE
  $ "KNN_MTOM.FlamingGorgeDaily" [date - 1.00000000 "day"]
 ENDIF + IF ( "GetMonth"( @"t" ) >= 4.00000000 AND "GetMonth"( @"t" ) <= 7.00000000 )
 THEN
  $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date]
 ELSE
  $ "YampaRiverInflow.Yampa_at_Deerlodge" []
 ENDIF;

      ENDFOREACH;

    END
    UUID "{e9b9f76f-9ace-456e-a4dc-bc831a6b7283}";;

    RULE                 "Fill Daily Flaming Gorge Releases for Months Outside of April-July";
    DESCRIPTION          "DESCRIPTION: Sets the daily FG releases and daily Yampa releases to the average monthly FG outflow and Yampa gaged outflow, respectively.<br><br>SLOTS SET: KNN_MTOM.FlamingGorgeDaily; KNN_MTOM.YampaDailyDeerlodgeDepleted<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "MonthIs"( { "April" , "May" , "June" , "July" , "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [date] := $ "FlamingGorge.Outflow" [];

            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date] := $ "YampaRiverInflow.Yampa_at_Deerlodge" [];

      ENDFOREACH;

    END
    UUID "{5e8b6416-af1e-41f9-b6b7-1099b1a9c734}";;

    RULE                 "Sum Daily Flaming Gorge Release Schedule to Monthly";
    DESCRIPTION          "Execution Constraint: April-August <br>  <br>Description: Sets FG outflow to the aggregated daily release volume.<br><br>IF daily flow summation is greater than the amount of water that is in FG reassign daily flows to only release as much water as is in FG (constant value).<br><br> <br>Slots Set: FlamingGorge.Outflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "April" , "May" , "June" , "July" , "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "CF, 20181212: Added a constraint on outflow via FGConstrainedOutflow() to allow running VIC hydrology. Change to include an IF daily flow summation is greater than the amount of water that is in FG reassign daily flows to only release as much water as is in FG (constant value).   <br> ";
    BEGIN

      $ "FlamingGorge.Outflow" COMMENTED_BY "Sets FG outflow to the aggregated daily release volume." [] := "FGConstrainedOutflow"( "VolumeToFlow"( "SumFlowsToVolume"( $ "KNN_MTOM.FlamingGorgeDaily", @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ), @"t" ) );

      IF_STATEMENT ("VolumeToFlow"( "SumFlowsToVolume"( $ "KNN_MTOM.FlamingGorgeDaily", @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ), @"t" ) > "SolveOutflow"( % "FlamingGorge", $ "FlamingGorge.Inflow" [@"t"], $ "UBRuleCurveData.ReservoirData" ["FlamingGorge", "inactiveCapacityStorage"], $ "FlamingGorge.Storage" [@"t - 1"], @"t" )) THEN
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [date] := "FGConstrainedOutflow"( "VolumeToFlow"( "SumFlowsToVolume"( $ "KNN_MTOM.FlamingGorgeDaily", @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ), @"t" ) );

      ENDFOREACH;

      END_IF_STATEMENT;

    END
    UUID "{7c3f5e96-c79a-44f0-a2d6-d715ed73c0f0}";;

    RULE                 "Min Flow in Extremely Dry Years with Low Storage";
    DESCRIPTION          "Execution Constraint: NA <br>  <br>Description: Flaming Gorge releases 800 cfs to protect the remaining water in storage if Flaming Gorge pool elevation is below MinReleaseTrigger and there is extremely low hydrology (.98 exceedance). This is reduce this further via funcion constraint when FG can't release 800 cfs without draining the live storage. <br><br>The rule sets the LowReleaseFlag when FG is releasing max water in FG (second IF) or MinFlow in HClass = 0 and PE < MinReleaseTrigger (first IF). <br><br>Slots Set: FlamingGorge.Outflow, FlamingGorgeData.LowReleaseFlag Execution Constraint: Not May, June or July ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "CF, 20181212: Exec Const removed, rule now fires in all timesteps. Rule moved earlier in priority than Sum Daily. Added a constraint on outflow via FGConstrainedOutflow() to MinFlow. AbsoluteMinRelease no longer needed since it was changed to MinFlow of 800 cfs based on the latest FEIS according to HP.  Rule sets the LowReleaseFlag when FG is releasing max water in FG or MinFlow in HClass = 0 and PE < MinReleaseTrigger. Fixes to allow running VIC. ";
    BEGIN

      IF_STATEMENT ($ "FlamingGorge.Pool Elevation" [] < $ "FlamingGorgeData.MinReleaseTrigger" [] AND $ "KNN_MTOM.BaseFlowHClass" [] == 0.00000000 AND NOT "MonthIs"( { "May" , "June" , "July" } ) COMMENTED_BY "CF: Old Execution Constraint <br>") THEN
            $ "FlamingGorge.Outflow" [] := "FGConstrainedOutflow"( $ "FlamingGorgeData.MinFlow" [] COMMENTED_BY "CF: Changed to MinFlow since AbsoluteMinRelease no longer needed since it was changed to <br>MiinFlow of 800 cfs based on the latest FEIS according to HP <br>" );

            $ "FlamingGorgeData.LowReleaseFlag" [] := 1.00000000;

      END_IF_STATEMENT;

      IF_STATEMENT ($ "FlamingGorge.Outflow" [@"t"] == "SolveOutflow"( % "FlamingGorge", $ "FlamingGorge.Inflow" [@"t"], $ "UBRuleCurveData.ReservoirData" ["FlamingGorge", "inactiveCapacityStorage"], $ "FlamingGorge.Storage" [@"t - 1"], @"t" )) THEN
            $ "FlamingGorgeData.LowReleaseFlag" [] := 1.00000000;

      END_IF_STATEMENT;

    END
    UUID "{f7fdf711-46e9-4b08-8415-e511284ba19f}";;

    RULE                 "Adjust Daily for August Base Flow";
    DESCRIPTION          "DESCRIPTION: Determines if July releases were at power plant or bypass capacity during moderately wet and wet hydrology and ramps down in August.  Rule sets August releases at steady base flows or downramps from high FG releases through July 31st to August base flows. August ramp down is contained in the Flow Recommendations. <br><br>SLOTS SET: KNN_MTOM.FlamingGorgeDaily; KNN_MTOM.YampaDailyDeerlodgeDepleted<br><br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      WITH_STATEMENT (NUMERIC RampRate = $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs") DO
            WITH_STATEMENT (NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] - $ "FlamingGorge.Outflow" [] ) / RampRate * 1.00000000 "day" )) DO
            IF_STATEMENT ($ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] > $ "FlamingGorge.Outflow" [] + RampRate) THEN
          DESCRIPTION          "Multiple days of downramping required";
      FOREACH (LIST AugustFlows IN "AugustDownRamp"(  )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [GET @INDEX 0.00000000 FROM AugustFlows] := GET @INDEX 1.00000000 FROM AugustFlows;

      ENDFOREACH;

      ELSE
          DESCRIPTION          "Downramping not required";
      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [date] := "GetFGBaseFlowMagnitude"(  );

      ENDFOREACH;

      END_IF_STATEMENT;

          DESCRIPTION          "Set Daily Deerlodge Depleted";
      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date] := $ "YampaRiverInflow.Yampa_at_Deerlodge" [];

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{0fcd207a-cdbe-4bcd-864f-42338e918980}";;

    RULE                 "Set Flaming Gorge Daily April to July Schedule";
    DESCRIPTION          "Execution Constraint: April-July <br>  <br>Description: Makes the daily date and flow list using function MakeDailyFlamingGorgeReleaseDateandFlowList and assigns it to the data object.<br><br>SLOTS SET: KNN_MTOM.FlamingGorgeDaily<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "MonthIs"( { "April" , "May" , "June" , "July" } ) AND "GetRunCycleIndex"(  ) == 2.00000000 ) COMMENTED_BY "CF,20190129: Changed to match CRSS. MTOM was only executing this in April or at start <br>timestep which wasn't setting dailyflows in later months.   <br>";
    NOTES                "CF,20190129: Changed to match CRSS. MTOM was only executing this in April or at start timestep which wasn't setting dailyflows in later months.  <br><br>AUTHOR, DATE: Unknown<br>MC, 20170503: Should the rule fire for an August Start Timestep? No consideration for August date in rule, but will use July 1 based on logic";
    BEGIN

      FOREACH (LIST dateandflow IN "MakeDailyFlamingGorgeReleaseDateandFlowList_LTSP"( IF ( "MonthIs"( { "April" } ) )
 THEN
  @"24:00:00 April 1, Current Year"
 ELSE
  IF ( "MonthIs"( { "May" } ) )
  THEN
   @"24:00:00 May 1, Current Year"
  ELSE
   IF ( "MonthIs"( { "June" } ) )
   THEN
    @"24:00:00 June 1, Current Year"
   ELSE
    @"24:00:00 July 1, Current Year" COMMENTED_BY "CF: July  <br>"
   ENDIF
  ENDIF
 ENDIF )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [GET @INDEX 0.00000000 FROM dateandflow] := GET @INDEX 1.00000000 FROM dateandflow;

      ENDFOREACH;

    END
    UUID "{24d265a0-4531-4f3d-9a46-1799d67e85bf}";;

    RULE                 "Release to Meet ULDE";
    DESCRIPTION          "Execution Constraint: March, April <br>  <br>Description: Release at whatever rate is necessary to meet the May 1 upper limit draw-down elevation (ULDE) from the EIS.  Note that if the reservoir is already below the ULDE, then the outflow will be constrained to the minimum base flow for the current year type. <br><br>HP: March-April are the only months that do not have BC constraints regulated by the ROD. The constraint here is a physical constraint, no magnitude constraints are applied to Mar-Apr unlike other months (Baseflow Operations Rule) <br>  <br>Slots Set: FlamingGorge.Outflow ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "March" , "April" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "CF, 20181212: Added a constraint on outflow via FGConstrainedOutflow() to allow running VIC hydrology.";
    BEGIN

    DESCRIPTION          "If it is March or April, then release whatever necessary to meet the May 1 ULDE";
      $ "FlamingGorge.Outflow" [] := "FGConstrainedOutflow"( "GetFGBaseFlowMagnitudeUnconstrained"(  ) COMMENTED_BY "HP: March-April are the only months that do not have BC constraints regulated by the ROD. The <br>constraint here is a physical constraint, no magnitude constraints are applied to Mar-Apr unlike <br>other months (Baseflow Operations Rule) <br>" );

    END
    UUID "{6fff01bb-f66b-467b-8c81-3ede4a955404}";;

    RULE                 "Spring Flow Hydrologic Classification";
    DESCRIPTION          "DESCRIPTION: Sets the spring flow classification based on ROD percent exceedance ranges.  Hydrologic class exceedance percentile limits: Dry (0) = 100-90%; ModDry (1) = 90-70%; Average (2) = 70-30%; ModWet (3) = 30-10%; Wet (4) = 10-0%<br><br>SLOTS SET: KNN_MTOM.SpringHClass<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "March" , "April" , "May" , "June" , "July" , "August" } AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Sets the spring hydrologic classification based on the forecasted April-July volume.";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "KNN_MTOM.SpringHClass" []) THEN
            $ "KNN_MTOM.SpringHClass" [] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    DESCRIPTION          "Yampa";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "FlamingGorgeData.YampaAprJulPercentExceedance" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "FlamingGorgeData.YampaHClass" []) THEN
            $ "FlamingGorgeData.YampaHClass" [] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END
    UUID "{f3f1fef7-d6f9-43e9-82f4-fd7dec0b0ddd}";;

    RULE                 "Base Flow Operations";
    DESCRIPTION          "Execution Constraint: Not March, April <br>  <br>Description: Sets the base flows for all months except March and April.  Base flow releases are set to stay below maximum pool elevation (PE), minimum flows or stay within the base flow range based on the hydrologic classification.  <br><br>Slots Set: FlamingGorge.Outflow ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "MonthIs"( { "March" , "April" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "CF, 20190128: MaxPE and MinFlow applied at the rule level to match CRSS.  <br><br>CF, 20181212: Added a constraint on outflow via FGConstrainedOutflow() to allow running VIC hydrology.";
    BEGIN

      $ "FlamingGorge.Outflow" COMMENTED_BY "Sets the base flows for all months except March and April.  Base flow releases are set to stay<br>below maximum pool elevation (6039 ft), minimum flows or stay within the base flow range <br>based on the hydrologic classification." [] := "FGConstrainedOutflow"( "Max"( "Max"( "TargetHWGivenInflowOneMonth"( % "FlamingGorge", @"t - 1", @"t", $ "FlamingGorgeData.MaxPE" [] COMMENTED_BY "CF: Prv fct (TargetHWGivenInflowforOneMonth) just took in Elevation but this matches <br>TargetHW arguements and is more explicit.    <br>", "FlowToVolume"( $ "FlamingGorge.Inflow" [], @"t" ) COMMENTED_BY "CF: MTOM's unregulated inflow accounts for the evaporation and upstream delta storage <br>therefore it does not need to include EstimateEvaporation like CRSS. <br>", $ "FlamingGorge.Storage" [@"t - 1"] ) COMMENTED_BY "This will only be positive if PE @t-1 is > than MaxPE and will only control if release needed to get <br>back to MaxPE is greater than MinFlow and BaseFlow.  <br>", $ "FlamingGorgeData.MinFlow" [] ), "GetFGBaseFlowMagnitude"(  ) ) );

    END
    UUID "{cb796919-89ab-491b-a325-89b2425caddb}";;

    RULE                 "Base Flow Hydrologic Classification";
    DESCRIPTION          "DESCRIPTION: Sets the base flow classification based on ROD percent exceedance ranges.  Under ROD compliance, base flows can change one classification higher or lower depending upon the previous month's observed unregulated inflow. Hydrologic class exceedance percentile limits: Dry (0) = 100-90%; ModDry (1) = 90-70%; Average (2) = 70-30%; ModWet (3) = 30-10%; Wet (4) = 10-0%<br><br>SLOTS SET: KNN_MTOM.BaseFlowHClass<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "KNN_MTOM.AprJulPercentExceedanceBaseFlow" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "KNN_MTOM.BaseFlowHClass" []) THEN
            $ "KNN_MTOM.BaseFlowHClass" [] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  index
 ELSE
  IF ( ( index > $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] + 1.00000000 ) COMMENTED_BY "If index is at least 2 greater than previous timestep's, then increase" )
  THEN
   $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] + 1.00000000
  ELSE
   IF ( ( index < $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] - 1.00000000 ) COMMENTED_BY "If index is at least 2 less than previous timestep's, then decrease" )
   THEN
    $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] - 1.00000000
   ELSE
    index
   ENDIF
  ENDIF
 ENDIF;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END
    UUID "{7ba18385-6e1b-4617-bfe9-e24266438389}";;

    RULE                 "Calc Percent Exceedance";
    DESCRIPTION          "DESCRIPTION: Calculate the percent exceedance for the April-July Base and Spring flow volumes, and the Yampa April-July flow volume<br><br>SLOTS SET: KNN_MTOM.AprJulPercentExceedanceSpringFlow; KNN_MTOM.AprJulPercentExceedanceBaseFlow; FlamingGorgeData.YampaAprJulPercentExceedance<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170725: Modified some date calculations to remove use of CONCAT in favor of more recent RW capabilities (e.g., &quot;Previous Year&quot;)<br>MC, 20160913: Calculate exceedance percentages for April to July Spring and Base flow volumes; is the UpdateHistoricRecord flag still necessary after the changes to the HDB DMI and automating the HydrologicClassificationEndYear dates?";
    BEGIN

      $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.AprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
 THEN
  @"24:00:00 December Max DayOfMonth, Previous Year" COMMENTED_BY "Use the end of the previous year"
 ELSE
  "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ) ) ) COMMENTED_BY "Use the end year specified on the KNN_MTOM object"
 ENDIF ), $ "KNN_MTOM.AprJulVolSpringFlow" [] );

      $ "KNN_MTOM.AprJulPercentExceedanceBaseFlow" [] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.AprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
 THEN
  @"24:00:00 December Max DayOfMonth, Previous Year" COMMENTED_BY "Use the end of the previous year"
 ELSE
  "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ) ) ) COMMENTED_BY "Use the end year specified on the KNN_MTOM object"
 ENDIF ), $ "KNN_MTOM.AprJulVolBaseFlow" [] );

      $ "FlamingGorgeData.YampaAprJulPercentExceedance" [] := 1.00000000 - "PercentRank"( IF ( "GetYear"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) < "GetYear"( "RunStartDate"(  ) ) - 1.00000000 AND $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
 THEN
  IF ( "GetYear"( @"t" ) == "GetYear"( "RunStartDate"(  ) ) )
  THEN
   "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) ) ) COMMENTED_BY "Use Hydrologic Classification Start and End years"
  ELSE
   WITH LIST futureData = "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "RunStartDate"(  ) ) ), @"24:00:00 December Max DayOfMonth, Previous Year" ) COMMENTED_BY "From end of Start Year to end of year prior to current year" DO
    FOR ( NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH futureData ) - 1.00000000, 1.00000000 ) ) WITH LIST result = "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) ) ) DO
     ( APPEND GET @INDEX i FROM futureData ONTO result ) COMMENTED_BY "Add futureData values to YampaHydrologicClassification data list values"
    ENDFOR
   ENDWITH
  ENDIF
 ELSE
  "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
  THEN
   @"24:00:00 December Max DayOfMonth, Previous Year" COMMENTED_BY "Use end of previous year"
  ELSE
   "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) ) COMMENTED_BY "Use year specified as HydrologicClassificationEndYear"
  ENDIF )
 ENDIF, $ "FlamingGorgeData.YampaAprJulVol" [] );

    END
    UUID "{2efe4d7c-3ce5-4382-b362-be90e40af1a3}";;

    RULE                 "Calc April July Volume Monthly";
    DESCRIPTION          "DESCRIPTION: This rule calculates the April-July unregulated inflow volumes for Flaming Gorge for Base Flow and Spring Flow purposes, and the April-July volume for the Yampa at the Deerlodge gage.<br><br>SLOTS SET: KNN_MTOM.AprJulSpringFlow; KNN_MTOM.AprJulVolBaseFlow; FlamingGorgeData.YampaAprJulVol<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "For spring flow operations we are interested in the april - july volume for the upcoming season beginning in January through April. <br>The May official forecast is used for spring operations through July. <br>This number is needed in march to determine releases to meet the ULDE. ";
      $ "KNN_MTOM.AprJulVolSpringFlow" [] := "SpringFlowA-JVolumeUpdate"(  );

    DESCRIPTION          "For base flow operations we are interested in the available observed volume in the previous april - july season. <br>Since base flow may actually start in june calculate this number then. <br>The August - December base flows use the observed A-J volume.  Jan-Feb use forecast A-J and ULDE and base flow range.<br>";
      $ "KNN_MTOM.AprJulVolBaseFlow" [] := "BaseFlowA-JVolumeUpdate"(  );

      $ "FlamingGorgeData.YampaAprJulVol" [] := IF ( "MonthIs"( { "April" } ) )
 THEN
  "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"t" COMMENTED_BY "CF: shouldn't this be April 1 <br>", @"t + 3" )
 ELSE
  IF ( IsNaN $ "FlamingGorgeData.YampaAprJulVol" [@"t - 1"] )
  THEN
   "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) COMMENTED_BY "CF: Replace IF @t = startrun, 0 ac-ft   <br>"
  ELSE
   $ "FlamingGorgeData.YampaAprJulVol" [@"t - 1"]
  ENDIF
 ENDIF;

    END
    UUID "{0cd3036c-c59a-4808-a8fe-b6dc0e0c72f2}";;

    RULE                 "Update Historic Record";
    DESCRIPTION          "DESCRIPTION: If necessary (i.e., the April-July Volume is NaN), the most recent April to July volume (previous year if earlier than August, current year if later) is calculated. <br><br>SLOTS SET: FlamingGorgeData.YampaAprJulVolAnnual; FlamingGorgeData.AprJulVolAnnual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "August" } ) OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unkinown<br><br>MC, 20160913: Was this made unnecessary by automating the HydrologicClassificationEndYear slots for FG and Yampa?";
    BEGIN

    DESCRIPTION          "If earlier than August, use the previous year's data";
      IF_STATEMENT ("GetMonth"( @"t" ) < 8.00000000) THEN
            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] := "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Previous Year", @"24:00:00 July Max DayOfMonth, Previous Year" );

      END_IF_STATEMENT;

            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] := "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Previous Year", @"24:00:00 July Max DayOfMonth, Previous Year" );

      END_IF_STATEMENT;

      ELSE
          DESCRIPTION          "Othewise, use the current year";
      IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] := "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] := "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END
    UUID "{7b8ad7a9-1a01-458b-9c98-344bda546984}";;

    RULE                 "Calculate April To July Volume Annual Slot";
    DESCRIPTION          "DESCRIPTION: Calculates the Flaming Gorge Unregulated Inflow and Yampa River at Deerlodge April to July volumes for each year between the classification Start Year and End Year<br><br>SLOTS SET: FlamingGorgeData.AprJulVolAnnual; FlamingGorgeData.YampaAprJulVolAnnual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == "RunStartDate"(  ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20160908: Changed variable reference in calculation of FlamingGorgeData.YampaAprJulVolAnnual from KNN_MTOM.HistoricYampaAtDeerlodge to YampaRiverInflow.Yampa_at_Deerlodge; <br><br>S.Baker June 2018 EDITS: update where the historic data is located for MTOM Testbed Hindcast vs Operational MTOM Runs<br>S.Baker 07/08/2019: changed the order of IF statemetns for historical testbed data. This allows the rules to work for new development RunType. <br>";
    BEGIN

    DESCRIPTION          "Flaming Gorge Unregulated Apr-Jul Inflow volume";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ), "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ), "1 years" )) DO
            $ "FlamingGorgeData.AprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := "SumFlowsToVolume"( IF ( $ "MTOMRunType.RunType" [] == 1.00000000 )
 THEN
  $ "HistoricData.FlamingGorgeUnregulatedInflow"
 ELSE
  $ "FlamingGorgeInflow.Unregulated"
 ENDIF COMMENTED_BY "For operational runs, use unregulated forecast slot; otherwise, use historical data slot <br>", "GetDate"( "April, " CONCAT "GetYearAsString"( time ) ), "GetDate"( "July, " CONCAT "GetYearAsString"( time ) ) );

      ENDFOREACH;

    DESCRIPTION          "Yampa Apr-Jul Inflow Vol";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ), "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ), "1 years" )) DO
            $ "FlamingGorgeData.YampaAprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := "SumFlowsToVolume"( IF ( $ "MTOMRunType.RunType" [] == 1.00000000 )
 THEN
  $ "HistoricData.Yampa_at_Deerlodge"
 ELSE
  $ "YampaRiverInflow.Yampa_at_Deerlodge"
 ENDIF COMMENTED_BY "For operational runs, use unregulated forecast slot; otherwise, use historical data slot  <br>", "GetDate"( "April, " CONCAT "GetYearAsString"( time ) ), "GetDate"( "July, " CONCAT "GetYearAsString"( time ) ) );

      ENDFOREACH;

    END
    UUID "{916568d9-180b-4440-8650-ca2940fcb8f8}";;

  END
  UUID "{bcb5d346-8b73-41a4-97b1-8d33805678d8}";;

  POLICY_GROUP   "KNN Yampa Daily Flow";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Peak Yampa Flow";
    DESCRIPTION          "DESCRIPTION: This rule finds the maximum daily flow of Deerlodge Depleted for the current year's KNN StartMonth to EndMonth period (currently April - July)<br><br>SLOTS SET: KNN_MTOM.YampaPeakDailyFlow[Current year]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      $ "KNN_MTOM.YampaPeakDailyFlow" [@"24:00:00 December Max DayOfMonth, Current Year"] := "MaxItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", "GetDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ) CONCAT " 1, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ), "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT "," ) CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ) ) );

    END
    UUID "{5a19ce60-15da-4a76-9226-d3573cf8a329}";;

    RULE                 "Set Yampa Daily Depleted Flow at Deerlodge For Second Stage Disagg";
    DESCRIPTION          "DESCRIPTION: Sets the daily depleted flow value at Deerlodge equal to the daily natural flow after the second stage disaggregation<br><br>SLOTS SET: KNN_MTOM.YampaDailyDeerlodgeDepleted[Current year's spring period]<br><br>";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "HasRuleFiredSuccessfully"( "Set Yampa Daily Natural - Second Stage Disagg" ) AND "GetRunCycleIndex"(  ) == 1.00000000 AND $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] == 1.00000000;
    NOTES                "CF,20181010: Disabled. This is only needed for CRSS since MTOM isn't in natural flow space. <br><br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )];

      ENDFOREACH;

    END
    UUID "{a77dc1ca-6bd0-45b7-8837-b0e1ccfbd36c}";;

    RULE                 "Set Yampa Daily Natural - Second Stage Disagg";
    DESCRIPTION          "DESCRIPTION: This rule calculates a daily flow rate for each day in the current year's period based on the volume proportion for the day in the historical index year's monthly volume<br><br>SLOTS SET: KNN_MTOM.YampaDailyNatural[Current year's dates]; KNN_MTOM.SecondStageDisaggFlag[Current year]<br>";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "MinItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) ) < 0.00000000 "cfs" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "CF,20181010: Disabled. This is only needed for CRSS since MTOM isn't in natural flow space. <br><br>AUTHOR, DATE: Unknown<br><br>";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := ( ( GET @INDEX i FROM "GetSecondStageProportionVector"(  ) ) * "GetCurrentMonthlyNaturalInflow"( GET @INDEX i FROM "GetCurrentYearDailyList"(  ) ) ) COMMENTED_BY "Multiply daily proportion by monthly volume" / 24.00000000 "hour";

      ENDFOREACH;

    DESCRIPTION          "Set flag for current year";
      $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] := 1.00000000;

    END
    UUID "{86446b6a-4f7a-46df-b6b4-7d728d9b7139}";;

    RULE                 "Set Yampa Daily Depleted Flow at Deerlodge";
    DESCRIPTION          "DESCRIPTION: Sets the daily depleted flow value at Deerlodge equal to the daily natural flow<br><br>SLOTS SET: KNN_MTOM.YampaDailyDeerlodgeDepleted[Current year's spring period]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )];

      ENDFOREACH;

    END
    UUID "{a71b74d2-2e2c-48d0-a4db-d570bd911990}";;

    RULE                 "Set Yampa Daily Natural Flow from KNN - primary disagg";
    DESCRIPTION          "DESCRIPTION: This function calcluates a daily flow vector that represents a disaggregation of the current spring volume based on the daily volume proportions of the historical index year and sets the second stage disaggregation slot flag to a value of 0.<br><br>SLOTS SET: KNN_MTOM.YampaDailyNatural[Current year's spring period]; KNN_MTOM.SecondStageDisaggFlag[Dec 31, Current Year]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Loop over the historical proportions vector and multiply the current year's spring volume by each daily proportion";
      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetProportionVector"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := "VolumeToFlow"( ( GET @INDEX i FROM "GetProportionVector"(  ) ) * "GetSpringVolume"(  ), GET @INDEX i FROM "GetCurrentYearDailyList"(  ) );

      ENDFOREACH;

    DESCRIPTION          "Initialize the flag to 0";
      $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000;

    END
    UUID "{d98dbbfe-0032-4078-ac78-5551cfa26ebd}";;

    RULE                 "Set Index Year- Ratios";
    DESCRIPTION          "DESCRIPTION: This rule sets the value of the index year chosen from the K nearest neighbors of the current year. The K nearest neighbors are calculated based on the seasonal volume proportions of each month in the April-July period<br><br>SLOTS SET: KNN_MTOM.IndexYear[Current Year]<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"] := WITH NUMERIC seasonalVol = "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) DO
  "ChooseIndexYearRatio"( "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 April Max DayOfMonth, Current Year"], @"24:00:00 April Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 May Max DayOfMonth, Current Year"], @"24:00:00 May Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 June Max DayOfMonth, Current Year"], @"24:00:00 June Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 July Max DayOfMonth, Current Year"], @"24:00:00 July Max DayOfMonth, Current Year" ) / seasonalVol ) COMMENTED_BY "Select the index year"
 ENDWITH;

    END
    UUID "{ed25973f-ccd8-4fff-9a8f-00e8a772df67}";;

    RULE                 "Set Random Number";
    DESCRIPTION          "DESCRIPTION: This rule generates a random number between 0 and 1 used in selecting a nearest neighbor historical year to use as an index year<br><br>SLOTS SET: KNN_MTOM.randomNum[Current Year]";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000 ) COMMENTED_BY "Changing the month this rule executes will change the random number generated <br>by the funciton call as the random number index is different for every month/year.<br>";
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      $ "KNN_MTOM.randomNum" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Random"( "GetRandSeed"(  ), $ "KNN_MTOM.randomIndex" [], 0.00000000 );

    END
    UUID "{c8a7fb58-f313-4e85-93ac-48558d6afad4}";;

  END
  UUID "{de4834ef-d1df-4dbb-874d-362d8ee2cfd7}";;

  POLICY_GROUP   "Aspinall Ops";
  DESCRIPTION    "The April 2012 Record of Decision for the Aspinall Unit Operations Final Environmental Impact Statement (2012 Aspinall ROD) and the decree quantifying the Federal Reserved Water Right for the Black Canyon of the Gunnison specify the spring peak outflow hydrograph and base flow for the rest of the year based on the hydrologic conditions upstream of Blue Mesa Reservoir, specifically the forecasted inflow to Blue Mesa Reservoir for April through July in the year of interest.  The 2012 Aspinall ROD provides specifications to avoid jeopardizing the continued existence of fish listed under the Endangered Species Act and to ensure the dam's operations do not result in the destruction or adverse modification of critical habitat in the Gunnison and Colorado rivers. <br><br>Data used to calculate the peak flow and duration targets are on the BlueMesaData object in the slots GunnisonDurationTargets, CanyonFlowCalcData, PeakFlowCalcData";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Crystal Outflow";
    DESCRIPTION          "Execution Constraint: Only fires if the rule has not successfully fired yet. <br>  <br>Description: Crystal and Morrow Point Reservoirs just need to pass inflow which Blue Mesa is sending down to meet flow requirements while accounting for evaporation in order to maintain a constant storage. Blue Mesa releases do not attempt to get Crystal to its storage target if it not already there. Instead Crystal holds back/releases more water in the first timestep to meet this goal. This logic should be revisited later. UBConstrainedOutflow() prevents this from exceeding min/max constraints.  <br>  <br>Slots Set: Crystal.Outflow ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "ThisRule" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "CF,20190403: Moved in from Apr 2019 Offc CRSS. <br><br>CF,20190409: Get Crystal to target Elevation by holding back water.<br><br>CF,20190405: Created to replace old rule Set Morrow Point and Crystal Storage which did not allow for Morrow Point and Crystal to respond to Blue Mesa operations. ";
    BEGIN

      $ "Crystal.Outflow" [@"t"] := "UBConstrainedOutflow"( % "Crystal", "VolumeToFlow"( "ElevationToStorage"( % "Crystal", $ "Crystal.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t" ) + $ "Crystal.Inflow" [@"t"] - "VolumeToFlow"( "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ), @"t" ) );

    END
    UUID "{1ee9a8f7-5d21-45a4-b979-5200956076d9}";;

    RULE                 "Morrow Point Outflow";
    DESCRIPTION          "Execution Constraint: Only fires if the rule has not successfully fired yet. <br>  <br>Description: Crystal and Morrow Point Reservoirs just need to pass inflow which Blue Mesa is sending down to meet flow requirements while accounting for evaporation in order to maintain a constant storage. Blue Mesa also releases to get Morrow Point to its storage target if it not already there. UBConstrainedOutflow() prevents this from exceeding min/max constraints.  <br>  <br>Slots Set: MorrowPoint.Outflow ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "HasRuleFiredSuccessfully"( "ThisRule" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "CF,20190403: Moved in from Apr 2019 Offc CRSS. <br><br>CF,20190405: Created to replace old rule Set Morrow Point and Crystal Storage which did not allow for Morrow Point and Crystal to respond to Blue Mesa operations. ";
    BEGIN

      $ "MorrowPoint.Outflow" [@"t"] := "UBConstrainedOutflow"( % "MorrowPoint", $ "MorrowPoint.Inflow" [@"t"] - "VolumeToFlow"( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) COMMENTED_BY "CF: MP should reach target by end of timestep. <br>", @"t", @"t" ) + ( "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) - $ "MorrowPoint.Storage" [@"t - 1"] ) COMMENTED_BY "CF: Vol to get MP to target. <br>", @"t" ) );

    END
    UUID "{f0b98f34-c4e9-4d6b-bb2c-96ae74d26131}";;

    RULE                 "Blue Mesa Operations";
    DESCRIPTION          "DESCRIPTION: This rule uses the function BlueMesaOutflowCalc to determine monthly releases from Blue Mesa Reservoir<br><br>SLOTS SET: BlueMesa.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "BlueMesa.Outflow" [] AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      $ "BlueMesa.Outflow" [] := "BlueMesaOutflowCalc"(  );

    END
    UUID "{c9154d16-9c94-4c9c-8e8d-4ff3bc17ddf6}";;

    RULE                 "Calculate May Release Volume";
    DESCRIPTION          "DESCRIPTION: Sets the Total May release volume by summing the daily flow requirements necessary to meet the 2012 ROD Flows for the Whitewater Gage and the Federal Reserve Water Right flows through the Black Canyon.  This rule also calculates the daily outflow from Blue Mesa necessary to meet those two flow requirements.  That data is written to the Blue Mesa Data object and is for informative purposes only.  TP 9/25/2015<br><br>SLOTS SET: BlueMesaData.MayReleaseVolume; BlueMesaData.TargetDailyOutflowFromBlueMesa<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170705: In calculation of MayReleaseVolume, conditional statement was IF (date < @&quot;Start Timestep&quot; AND NOT GetMonth(date) == 5.00), and was changed to just IF (date < @&quot;Start Timestep&quot;) because all dates being considered are in May, so second part of Boolean was never true and past outflows were not being used for May dates prior to Start Timestep<br><br>MC, 20170712: Added DateMin(..., @&quot;Finish Timestep&quot;) to calculation of BMD.TargetDailyOutflowFromBlueMesa; without it, the final year of the run could not calculate completely, and the rule was finishing ineffectively meaning the MayReleaseVolume did not get populated for the final year of the run";
    BEGIN

      $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] := FOR ( DATETIME date IN "GetDates"( @"24:00:00 May 1, Current Year", @"24:00:00 May 31, Current Year", "1 days" ) ) STAT_AVE
  IF ( date < @"Start Timestep" AND ( NOT "GetMonth"( date ) == 5.00000000 ) COMMENTED_BY "MC, 20170725: This doesn't make sense because all dates being considered <br>are in May. Should current year May use the previously determined outflow, <br>or should all dates, whether prior to Start Timestep or not calculate outflow?  <br>" )
  THEN
   $ "BlueMesa.Outflow" ["MaxDayOfMonth"( date )]
  ELSE
   "SolveBlueMesaReleaseForDownstreamTargets"( $ "BlueMesaData.TargetDailyWhitewaterFlows" [date], "MaxDayOfMonth"( date ), $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date] )
  ENDIF
 ENDFOR COMMENTED_BY "Calculate average daily flow in May" * 31.00000000 "day";

    DESCRIPTION          "Set daily flows for remainder of current year";
      FOREACH (DATETIME date IN "GetDates"( "DateMax"( @"24:00:00 January 1, Current Year", "MinDayOfMonth"( @"Start Timestep" ) ), "DateMin"( @"24:00:00 December 31, Current Year", @"Finish Timestep" ), "1 days" )) DO
            $ "BlueMesaData.TargetDailyOutflowFromBlueMesa" [date] := "Max"( "SolveBlueMesaReleaseForDownstreamTargets"( $ "BlueMesaData.TargetDailyWhitewaterFlows" [date], "MaxDayOfMonth"( date ), $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date] ), 0.00000000 "cfs" );

      ENDFOREACH;

    END
    UUID "{ec8b29c0-33e2-4ee1-a85b-804a593b83d0}";;

    RULE                 "Annual Daily Black Canyon Flow Determination";
    DESCRIPTION          "DESCRIPTION: This rule calculates the preliminary daily flow targets for the flow through the Black Cayone that satisfies the Federal Reserve Water Right for the entire year of a model run.  The ramp up and down to the peak date are included.   This rule will set each day to either the ramp up or down value, the peak flow (as determined on the algorithm to satisfy the Water Right) or the base flow value for any day outside of this range for the Flow through the Black Canyon.  Though the model is monthly, these values are written to a daily slot on BlueMesaData that will be aggregated and converted to a monthly release from Blue Mesa Res in a subsequent rule (Blue Mesa Operations). - sc 12/27/10<br><br>SLOTS SET: BlueMesaData.TargetDailyBlackCanyonFlows<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Black Canyon Target Peak Flow";
      WITH_STATEMENT (NUMERIC peakCanyonFlow = $ "BlueMesaData.CanyonPeakFlowTarget" [@"24:00:00 December 31, Current Year"]) DO
          DESCRIPTION          "May Base Flow Value";
      WITH_STATEMENT (NUMERIC mayCanyonBaseFlow = $ "BlueMesaData.MinimumBlackCanyonFlow" [@"24:00:00 May 31, Current Year"]) DO
          DESCRIPTION          "Number of days to ramp up<br>Solve for x = no. days in &lcub;BaseFlow*(1+UpRate)^x >= PeakFlow&rcub;";
      WITH_STATEMENT (NUMERIC daysOfRampUp = "Ceiling"( "Ln"( peakCanyonFlow / mayCanyonBaseFlow, 0.00000000 ) / "Ln"( 1.00000000 + $ "BlueMesaData.CanyonRampUpRateToPeak" [], 0.00000000 ), 1.00000000 ) * 1.00000000 "day") DO
          DESCRIPTION          "Number of days to ramp down";
      WITH_STATEMENT (NUMERIC daysOfRampDown = "Ceiling"( "Ln"( mayCanyonBaseFlow / peakCanyonFlow, 0.00000000 ) / "Ln"( 1.00000000 - $ "BlueMesaData.CanyonRampDownRateFromPeak" [], 0.00000000 ), 1.00000000 ) * 1.00000000 "day") DO
          DESCRIPTION          "Calculate peak date, and dates on which to begin and end ramping";
      WITH_STATEMENT (DATETIME peakDate = "CompletePartialDate"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" )) DO
            WITH_STATEMENT (DATETIME startRampUpDate = peakDate - daysOfRampUp) DO
            WITH_STATEMENT (DATETIME endRampDownDate = peakDate + daysOfRampDown) DO
          DESCRIPTION          "Set daily flow rates for current calendar year";
      FOREACH (DATETIME date IN "GetDates"( "DateMax"( @"24:00:00 January 1, Current Year", "GetStartDayOfMonth"(  ) ), @"24:00:00 December 31, Current Year", "1 days" )) DO
            WITH_STATEMENT (NUMERIC baseFlow = $ "BlueMesaData.MinimumBlackCanyonFlow" [date]) DO
            $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date] := IF ( date >= @"April 1" AND date <= @"July 25" )
 THEN
  IF ( date >= startRampUpDate AND date < peakDate )
  THEN
   WITH NUMERIC nDaysUp = ( date - startRampUpDate + 1.00000000 "day" ) / 1.00000000 "day" DO
    baseFlow * ( 1.00000000 + $ "BlueMesaData.CanyonRampUpRateToPeak" [] ) ^ nDaysUp
   ENDWITH COMMENTED_BY "Flows during ramp up period"
  ELSE
   IF ( date == peakDate )
   THEN
    peakCanyonFlow
   ELSE
    IF ( date > peakDate AND date <= endRampDownDate - 1.00000000 "day" )
    THEN
     WITH NUMERIC nDaysDown = ( date - peakDate ) / 1.00000000 "day" DO
      peakCanyonFlow * ( 1.00000000 - $ "BlueMesaData.CanyonRampDownRateFromPeak" [] ) ^ nDaysDown
     ENDWITH COMMENTED_BY "Flows during ramp down period"
    ELSE
     baseFlow
    ENDIF
   ENDIF
  ENDIF
 ELSE
  baseFlow
 ENDIF;

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{3847fb08-6f07-4dc8-ae0b-95289d2ea75b}";;

    RULE                 "Annual Daily Whitewater Flow Determination";
    DESCRIPTION          "DESCRIPTION: This rule calculates the preliminary daily flow targets for the Whitewater Gage for the entire year of a model run. They are preliminary in that the ramp up and ramp down from the peak flow target are not included yet. This rule will set each day to either the shoulder flow, the peak flow (as determined on the Spring Peak And Duration Canyon Targets slot) or the base flow value for any day outside of this range for the Whitewater Gage. Though the model is monthly, these values are written to a daily slot on BlueMesaData.TargetDailyWhitewaterFlows that will be aggregated and converted to a monthly release from Blue Mesa Res in a subsequent rule (Blue Mesa Operations). <br><br>SLOTS SET: BlueMesaData.TargetDailyWhitewaterFlows<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170705: Added BlueMesaData.WhitewaterOpsAssurance value to the peak and shoulder flows per Rick C.'s recommendation to improve probability of achieving ROD Whitewater targets. The daily flows are then averaged into the local variable MonthlyWhitewaterTarget in the function BlueMesaOutflowCalc<br><br>CF, 5/5/2017:  This rule was restructured so that new slots  Peak & ShoulderFlowDuration. The shoulder flow function was removed since shoulder/half-bank flow is now fixed by the ROD to 8,070. This value is stored in slot BlueMesaData.ShoulderFlowTarget. - CF 5/5/2017<br><br>TP/MC, 9/25/2015: This rule calculates the may peak flow target for the Whitewater Gage, the shoulder flow is set to 8,070 cfs as part of the 2012 ROD, the May Peak Flow Level which is a value between 0 adn 5 that is based on the 2012 ROD for the Aspinall Unit which is calculated with the Blue Mesa Unregulated Inflow for April through July.  The rule also determines the Black Canyon Peak flow that will meet the Federal Reserve Water Right and the April through July volume for Blue Mesa Reservoir unregulated inflow. This rule only fires on the first day of the year or first day of the run.";
    BEGIN

    DESCRIPTION          "ROD peak flow Target";
      WITH_STATEMENT (NUMERIC peakFlow = $ "BlueMesaData.WhitewaterPeakFlowTarget" [@"24:00:00 December 31, Current Year"]) DO
          DESCRIPTION          "ROD Shoulder Flow Target";
      WITH_STATEMENT (NUMERIC shoulderFlow = $ "BlueMesaData.HalfBankFlow" []) DO
          DESCRIPTION          "ROD Peak Flow Hydrologic Year classification,";
      WITH_STATEMENT (NUMERIC level = $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"]) DO
          DESCRIPTION          "Number of Days at Peak Flow based on the ROD Target";
      WITH_STATEMENT (NUMERIC daysOfPeak = $ "BlueMesaData.PeakFlowDuration" [@"24:00:00 December 31, Current Year"]) DO
            WITH_STATEMENT (NUMERIC daysOfShoulder = $ "BlueMesaData.ShoulderFlowDuration" [@"24:00:00 December 31, Current Year"]) DO
            WITH_STATEMENT (DATETIME peakDate = "CompletePartialDate"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" )) DO
            WITH_STATEMENT (DATETIME startShoulderFlowDate = peakDate - daysOfShoulder / 2.00000000) DO
            WITH_STATEMENT (DATETIME endShoulderDate = startShoulderFlowDate + daysOfShoulder - 1.00000000 "day") DO
            WITH_STATEMENT (DATETIME startPeakFlowDate = peakDate - daysOfPeak / 2.00000000) DO
            WITH_STATEMENT (DATETIME endPeakFlowDate = startPeakFlowDate + daysOfPeak - 1.00000000 "day") DO
            FOREACH (DATETIME date IN "GetDates"( "DateMax"( @"24:00:00 January 1, Current Year", "GetStartDayOfMonth"(  ) ), @"24:00:00 December 31, Current Year", "1 days" )) DO
            WITH_STATEMENT (NUMERIC baseFlow = $ "BlueMesaData.BaseFlowTarget" [date, level]) DO
            $ "BlueMesaData.TargetDailyWhitewaterFlows" [date] := IF ( date >= @"April 1" AND date <= @"July 25" )
 THEN
  IF ( date >= startShoulderFlowDate )
  THEN
   IF ( date >= startPeakFlowDate AND date <= endPeakFlowDate )
   THEN
    ( peakFlow + $ "BlueMesaData.WhitewaterOpsAssurance" [] ) COMMENTED_BY "This is the period of time to ramp up to the Peak flow, this is assuming that the ramp up will only <br>be for about one day, this can be edited if this logic needs to be more precise. TP 9/19/2015"
   ELSE
    IF ( date <= endShoulderDate )
    THEN
     $ "BlueMesaData.HalfBankFlow" [] + $ "BlueMesaData.WhitewaterOpsAssurance" []
    ELSE
     baseFlow
    ENDIF
   ENDIF
  ELSE
   baseFlow
  ENDIF
 ELSE
  baseFlow
 ENDIF;

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{fecfb05f-0915-4705-a990-e3f109c4fec8}";;

    RULE                 "Calculate Gunnison Flow Targets";
    DESCRIPTION          "DESCRIPTION: This rule calculates: <br>- The peak flow target for the Whitewater Gage. <br>- The hydrologic year classification which is a value between 0 (Dry) and 5 (Wet) that is based on the 2012 ROD which is calculated with the Blue Mesa Unregulated Inflow for April-July. <br>- The Black Canyon peak flow that will meet the Federal Reserve Water Right <br>- The April through July volume for Blue Mesa Reservoir unregulated inflow.  <br>- The WW peak and shoulder flow durations acording to the ROD.  <br><br>SLOTS SET: BlueMesaData.WWPeakFlowTarget; BlueMesaData.GunnisonHClass; BlueMesaData.CanyonPeakFlowTarget; BlueMesaData.BlueMesaAprilThroughJulyVolume <br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>TP/MC, 20150925: This rule calculates the may peak flow target for the Whitewater Gage, the shoulder flow is set to 8,070 cfs as part of the 2012 ROD, the May Peak Flow Level which is a value between 0 adn 5 that is based on the 2012 ROD for the Aspinall Unit which is calculated with the Blue Mesa Unregulated Inflow for April through July.  The rule also determines the Black Canyon Peak flow that will meet the Federal Reserve Water Right and the April through July volume for Blue Mesa Reservoir unregulated inflow. This rule only fires on the first day of the year or first day of the run.<br><br>CF, 5/5/2017: This rule and the accompanying functions were restructured so that AprilThoughJulyVolume and  Gunnison Hydroglogic year class (GunnisonHClass), previously called MayFlowLevel, are calculated only once and then passed as arguments to the functions rather than being recalculated by each function. The shoulder flow function was removed since shoulder/half-bank flow is now fixed by the ROD to 8,070. This value is stored in slot BlueMesaData.ShoulderFlowTarget. - The WW peak and shoulder flow durations are now calculated and set to seperate slots for reference by later rules. <br><br><br>";
    BEGIN

      WITH_STATEMENT (NUMERIC currentForecast = "SumFlowsToVolume"( $ "BlueMesaInflow.Unregulated", @"24:00:00 April 30, Current Year", @"24:00:00 July 31, Current Year" )) DO
            $ "BlueMesaData.BlueMesaAprilThroughJulyVolume" [@"24:00:00 December 31, Current Year"] := currentForecast;

            WITH_STATEMENT (NUMERIC HClass = "CalcGunnisonHClass"( currentForecast )) DO
            $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] := HClass;

            $ "BlueMesaData.WhitewaterPeakFlowTarget" [@"24:00:00 December 31, Current Year"] := "CalcGunnisonWWPeakFlowTarget"( HClass, currentForecast );

            $ "BlueMesaData.CanyonPeakFlowTarget" [@"24:00:00 December 31, Current Year"] := "CalcCanyonPeakFlowTarget"( currentForecast );

            $ "BlueMesaData.ShoulderFlowDuration" [@"24:00:00 December 31, Current Year"] := $ "BlueMesaData.GunnisonDurationTargets" [HClass, 1.00000000];

            $ "BlueMesaData.PeakFlowDuration" [@"24:00:00 December 31, Current Year"] := $ "BlueMesaData.GunnisonDurationTargets" [HClass, 2.00000000];

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{302768b5-b051-4b14-8eaf-ae66980ad7e7}";;

  END
  UUID "{58d25a58-3b97-4339-9183-7a33ff77e4cd}";;

  POLICY_GROUP   "Vallecito Ops";
  DESCRIPTION    "The operations of Vallecito Reservoir are based on analysis of the historic record in which a target pool elevation curve was created (VallecitoData.VallecitoGuide). A flow of 2,000 cfs is the maximum target outflow for Vallecito Reservoir to minimize downstream bank damage, but in times of flood control, outflow can be greater than the maximum release target. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "VallecitoFloodControlProtection";
    DESCRIPTION          "DESCRIPTION: Determines the Vallacito outflow when the pool elevation exceeds the target elevation for the given month. The Vallecito outflow is increased until either the maximum outflow is reached, or the Vallecito pool elevation is equal to the end of month target elevation for Vallecito. -ce 6/6/13<br><br>SLOTS SET: Vallecito.Outflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND $ "Vallecito.Pool Elevation" [] > "GetEOMTargetElevation"( % "Vallecito", @"t" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE, 6/6/2013 (?)";
    BEGIN

      WITH_STATEMENT (NUMERIC previousPoolElevation = $ "Vallecito.Pool Elevation" [@"t - 1"]) DO
            $ "Vallecito.Outflow" [@"t"] := "Min"( "GetReservoirMaxConstraint"( % "Vallecito", @"t", previousPoolElevation ), "VolumeToFlow"( "ElevationToStorageAtDate"( % "Vallecito", $ "Vallecito.Pool Elevation" [], @"t" ) - "ElevationToStorageAtDate"( % "Vallecito", "GetEOMTargetElevation"( % "Vallecito", @"t" ), @"t" ), @"t" ) + $ "Vallecito.Outflow" [@"t"] );

      END_WITH_STATEMENT;

    END
    UUID "{7d7b30d5-e8b7-4677-86ef-78d2e5bc32ee}";;

    RULE                 "Vallecito Guide Release";
    DESCRIPTION          "DESCRIPTION: This rule sets the Vallecito Reservoir releases for the entire run on the first timestep.  The ability to do this is predicated on the fact that Vallecito operations only need to know the inflow to the reservoir and nothing else about the state of the system.  If this changes, then it will have be done each timestep.<br><br>SLOTS SET: Vallecito.Outflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE:  SC, 12/15/2010";
    BEGIN

      FOREACH (LIST dateOutflowElevation IN "SimulateHeadwaterRes"( % "Vallecito" )) DO
            $ "Vallecito.Outflow" [GET @INDEX 0.00000000 FROM dateOutflowElevation] := GET @INDEX 1.00000000 FROM dateOutflowElevation;

      ENDFOREACH;

    END
    UUID "{f754bebd-258b-43e4-8736-0e46494ab34b}";;

  END
  UUID "{f6314f3c-2895-4538-96d6-eb510aec3bcf}";;

  POLICY_GROUP   "Taylor Park Ops";
  DESCRIPTION    "The operational guide curves for Taylor Park in MTOM are based on an analysis of the historic record which served as the foundation for developing target pool elevations for each month (TaylorParkData.TaylorParkGuide). The target pool elevation is used to set an outflow for a specific month where the outflow is bound by a minimum monthly flow and a maximum monthly flow depending on the pool elevation of the previous month. At Taylor Park, the maximum flow is constrained by the outlet works based on the data in the TaylorPark.Max Release table. Minimum flows are reduced if they would cause the reservoir to go below its minimum pool elevation.";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Taylor Park Guide Release";
    DESCRIPTION          "DESCRIPTION: This rule sets the Taylor Park Reservoir releases for the entire run on the first timestep.  The ability to do this is predicated on the fact that Taylor Park operations only need to know the inflow to the reservoir and nothing else about the state of the system.  If this changes, then it will have be done each timestep<br><br>SLOTS SET: TaylorPark.Outflow<br><br><br><br>";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: SC, 12/31/2010<br><br>MC, 20170720: Wrote modifed version of reduced MinFlow situation to adaptively reduce MinFlow values so that MinElevation is avoided; not active yet because haven't run it by USBR<br><br>MC, 20170621: (a) Changed reference  in local variable ToSpillway from 9,330 feet to TaylorParkData.SpillwayElevation; (b) Changed reference in first IF statement from TaylorParkData.TaylorPark_LowestFlow to TaylorParkData.MinFlow * TaylorParkData.MinFlowReductionFactor. (b) will allow more flexibility in flow reductions due to low pool elevations than hard-coding new min flow values.<br><br>MC, 20170508: Added conditional logic and LowestFlow slot to address problems Sarah B. was having with her model runs; changes developed by Sarah and confirmed with Erik K.<br><br>MC, 20170124: With midmonth ensembles, situation occurred in which the maximum release constraint in SimulateHeadwaterRes prevented use of spillway and led to storage greater than maximum in storage-volume table and aborted runs. I rewrote the rule so now TP only solves one timestep at a time but utilizes spill possibility. Three possibilities for relative size of outflows calculated:<br>1. ToSpillway < ToTarget < MaximumControlled: release to hit target<br>2. ToSpillway < MaximumControlled < ToTarget: release maximum and end of month elevation will be lower than spillway but higher than target<br>3. MaximumControlled < ToSpillway < ToTarget: release to spillway, which will require spill, but not excessive spill that would be required to reach target<br><br>Need Minimum Flow in case inflow is insufficient to reach Target";
    BEGIN

      WITH_STATEMENT (DATETIME EndDate = "DateMin"( "GetWaterYearEndDate"( @"t" ), @"Finish Timestep" )) DO
            $ "TaylorPark.Outflow" [@"t"] := IF ( ( $ "TaylorPark.Pool Elevation" [@"t - 1"] < ( $ "TaylorParkData.TaylorParkGuide" [@"t - 1"] - 70.00000000 "ft" ) ) COMMENTED_BY "Previous pool elevation is more than 70ft below guide curve OR (more than 20ft below AND inflows less than lowest outflows)" OR ( $ "TaylorPark.Pool Elevation" [@"t - 1"] < ( $ "TaylorParkData.TaylorParkGuide" [@"t - 1"] - 20.00000000 "ft" ) AND "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) < "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) * $ "TaylorParkData.MinFlowReductionFactor" [] ) )
 THEN
  "VolumeToFlow"( "FlowToVolume"( $ "TaylorParkData.MinFlow" [@"t"], @"t" ) * $ "TaylorParkData.MinFlowReductionFactor" [], @"t" )
 ELSE
  WITH NUMERIC MaximumControlled = $ "TaylorPark.Maximum Controlled Release" [0.00000000, 0.00000000] DO
   WITH NUMERIC ToTarget = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.TaylorParkGuide" [@"t"] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the pool elevation target" DO
    WITH NUMERIC ToSpillway = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.SpillwayElevation" [] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the spillway" DO
     "Max"( "Max"( "Min"( ToTarget, MaximumControlled ), ToSpillway ), $ "TaylorParkData.MinFlow" [@"t"] )
    ENDWITH
   ENDWITH
  ENDWITH
 ENDIF;

      END_WITH_STATEMENT;

    INACTIVE      WITH_STATEMENT (DATETIME EndDate = "DateMin"( "GetWaterYearEndDate"( @"t" ), @"Finish Timestep" )) DO
          DESCRIPTION          "MC, 20170720: I added this prospective change because I thought the conditions for reducing the Min Flow <br>and the reduction factor (0.67) were too arbitrary. Haven't run this by USBR yet, though.   <br>";
      $ "TaylorPark.Outflow" [@"t"] := IF ( ( $ "TaylorPark.Storage" [@"t - 1"] + "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) - "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) < "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.MinElevation" [] ) ) COMMENTED_BY "Min outflows lead to EOWY PE less than minimum <br>" )
 THEN
  WITH NUMERIC FlowReductionFactor = ( ( "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) + $ "TaylorPark.Storage" [@"t - 1"] - "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.MinElevation" [] ) ) / "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) * 1.00000000 ) COMMENTED_BY "Scale MinFlow either to reach MinElevation (multiply by 1) or reduce coefficient for factor of safety <br>" DO
   "VolumeToFlow"( "FlowToVolume"( $ "TaylorParkData.MinFlow" [@"t"], @"t" ) * FlowReductionFactor, @"t" )
  ENDWITH
 ELSE
  WITH NUMERIC MaximumControlled = $ "TaylorPark.Maximum Controlled Release" [0.00000000, 0.00000000] DO
   WITH NUMERIC ToTarget = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.TaylorParkGuide" [@"t"] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the pool elevation target" DO
    WITH NUMERIC ToSpillway = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.SpillwayElevation" [] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the spillway" DO
     "Max"( "Max"( "Min"( ToTarget, MaximumControlled ), ToSpillway ), $ "TaylorParkData.MinFlow" [@"t"] )
    ENDWITH
   ENDWITH
  ENDWITH
 ENDIF;

      END_WITH_STATEMENT;

    END
    UUID "{8add48ac-d036-4418-9bf6-471a36b3ddf3}";;

    RULE                 "Taylor Park Guide Release_new";
    DESCRIPTION          "DESCRIPTION: This rule sets the Taylor Park Reservoir releases for the entire run on the first timestep.  The ability to do this is predicated on the fact that Taylor Park operations only need to know the inflow to the reservoir and nothing else about the state of the system.  If this changes, then it will have be done each timestep<br><br>SLOTS SET: TaylorPark.Outflow<br><br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: SC, 12/31/2010<br><br>SB, 20190709: Taylor Park needed lower release for very dry scenarios. Added a max statement to release only the available water in Taylor Park. <br><br>MC, 20170720: Wrote modifed version of reduced MinFlow situation to adaptively reduce MinFlow values so that MinElevation is avoided; not active yet because haven't run it by USBR<br><br>MC, 20170621: (a) Changed reference  in local variable ToSpillway from 9,330 feet to TaylorParkData.SpillwayElevation; (b) Changed reference in first IF statement from TaylorParkData.TaylorPark_LowestFlow to TaylorParkData.MinFlow * TaylorParkData.MinFlowReductionFactor. (b) will allow more flexibility in flow reductions due to low pool elevations than hard-coding new min flow values.<br><br>MC, 20170508: Added conditional logic and LowestFlow slot to address problems Sarah B. was having with her model runs; changes developed by Sarah and confirmed with Erik K.<br><br>MC, 20170124: With midmonth ensembles, situation occurred in which the maximum release constraint in SimulateHeadwaterRes prevented use of spillway and led to storage greater than maximum in storage-volume table and aborted runs. I rewrote the rule so now TP only solves one timestep at a time but utilizes spill possibility. Three possibilities for relative size of outflows calculated:<br>1. ToSpillway < ToTarget < MaximumControlled: release to hit target<br>2. ToSpillway < MaximumControlled < ToTarget: release maximum and end of month elevation will be lower than spillway but higher than target<br>3. MaximumControlled < ToSpillway < ToTarget: release to spillway, which will require spill, but not excessive spill that would be required to reach target<br><br>Need Minimum Flow in case inflow is insufficient to reach Target";
    BEGIN

      WITH_STATEMENT (DATETIME EndDate = "DateMin"( "GetWaterYearEndDate"( @"t" ), @"Finish Timestep" )) DO
            $ "TaylorPark.Outflow" [@"t"] := IF ( ( $ "TaylorPark.Pool Elevation" [@"t - 1"] < ( $ "TaylorParkData.TaylorParkGuide" [@"t - 1"] - 70.00000000 "ft" ) ) COMMENTED_BY "Previous pool elevation is more than 70ft below guide curve OR (more than 20ft below AND inflows less than lowest outflows)" OR ( $ "TaylorPark.Pool Elevation" [@"t - 1"] < ( $ "TaylorParkData.TaylorParkGuide" [@"t - 1"] - 20.00000000 "ft" ) AND "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) < "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) * $ "TaylorParkData.MinFlowReductionFactor" [] ) )
 THEN
  "VolumeToFlow"( "Min"( "FlowToVolume"( $ "TaylorParkData.MinFlow" [@"t"], @"t" ) * $ "TaylorParkData.MinFlowReductionFactor" [], $ "TaylorPark.Storage" [@"t - 1"] + "FlowToVolume"( $ "TaylorPark.Inflow" [@"t"], @"t" ) ), @"t" )
 ELSE
  WITH NUMERIC MaximumControlled = $ "TaylorPark.Maximum Controlled Release" [0.00000000, 0.00000000] DO
   WITH NUMERIC ToTarget = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.TaylorParkGuide" [@"t"] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the pool elevation target" DO
    WITH NUMERIC ToSpillway = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.SpillwayElevation" [] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the spillway" DO
     "Max"( "Max"( "Min"( ToTarget, MaximumControlled ), ToSpillway ), $ "TaylorParkData.MinFlow" [@"t"] )
    ENDWITH
   ENDWITH
  ENDWITH
 ENDIF;

      END_WITH_STATEMENT;

    INACTIVE      WITH_STATEMENT (DATETIME EndDate = "DateMin"( "GetWaterYearEndDate"( @"t" ), @"Finish Timestep" )) DO
          DESCRIPTION          "MC, 20170720: I added this prospective change because I thought the conditions for reducing the Min Flow <br>and the reduction factor (0.67) were too arbitrary. Haven't run this by USBR yet, though.   <br>";
      $ "TaylorPark.Outflow" [@"t"] := IF ( ( $ "TaylorPark.Storage" [@"t - 1"] + "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) - "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) < "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.MinElevation" [] ) ) COMMENTED_BY "Min outflows lead to EOWY PE less than minimum <br>" )
 THEN
  WITH NUMERIC FlowReductionFactor = ( ( "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) + $ "TaylorPark.Storage" [@"t - 1"] - "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.MinElevation" [] ) ) / "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) * 1.00000000 ) COMMENTED_BY "Scale MinFlow either to reach MinElevation (multiply by 1) or reduce coefficient for factor of safety <br>" DO
   "VolumeToFlow"( "FlowToVolume"( $ "TaylorParkData.MinFlow" [@"t"], @"t" ) * FlowReductionFactor, @"t" )
  ENDWITH
 ELSE
  WITH NUMERIC MaximumControlled = $ "TaylorPark.Maximum Controlled Release" [0.00000000, 0.00000000] DO
   WITH NUMERIC ToTarget = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.TaylorParkGuide" [@"t"] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the pool elevation target" DO
    WITH NUMERIC ToSpillway = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.SpillwayElevation" [] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the spillway" DO
     "Max"( "Max"( "Min"( ToTarget, MaximumControlled ), ToSpillway ), $ "TaylorParkData.MinFlow" [@"t"] )
    ENDWITH
   ENDWITH
  ENDWITH
 ENDIF;

      END_WITH_STATEMENT;

    END
    UUID "{86f6a5d5-3ec7-4cd4-901c-3041d0db3ee5}";;

  END
  UUID "{eefa021d-c2c5-4714-9e1d-babdcd14fcbf}";;

  POLICY_GROUP   "Fontenelle";
  DESCRIPTION    "The Fontenelle Reservoir operational policies implemented in MTOM were developed based on operator experience and analysis of historic operations. In general, releases are set to meet various target elevations throughout the year while staying within practical and authorized limits. The target elevations for various months are as follows: <br>         October through March outflows are controlled by the April 1 target elevation of 6,468 feet <br>         April and June outflows are controlled by the July 1 target elevation of 6,500 feet ; May outflow is controlled by an intermediate target of 6,480 ft.<br>         July outflow is controlled by the August 1 target elevation of 6,505.5 feet <br>         The maximum release is about 11,500 cfs (Safe Channel Capacity)<br>         Minimum releases are set to 400 cfs during the months Sep-Mar and to 600 cfs during the months Apr-Aug<br>  <br>Maximum and minimum releases take precedence over releases required to meet a specific month?s target elevation. A release that will cause the pool elevation to drop below 6,465 feet will be reduced such that the minimum elevation will not be violated except for minimum releases required to maintain flow in the reach below Fontenelle. Spills may occur as necessary to limit the pool elevation to 6,506 feet or to meet the target pool elevation in August. The spill algorithm releases the entire volume necessary to enforce the maximum pool elevation in a single month. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Fontenelle Outflow";
    DESCRIPTION          "DESCRIPTION: This rule uses a more in depth function that replaces 11 rules that previously set the Fontenelle outflow.  The rule uses the function to set the Fontenelle outflow for the current timestep.<br><br>SLOTS SET: Fontenelle.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: TP, 5/11/2015";
    BEGIN

      $ "Fontenelle.Outflow" [] := "FontenelleMonthlyOutflow"(  );

    END
    UUID "{133be1ab-b7bd-4a13-9381-5453d74aaa1c}";;

    RULE                 "Set Unset Outflow";
    DESCRIPTION          "DESCRIPTION: Sets the outflow equal to inflow so that  spillCalc and power methods can execute, registering dependencies so that higher priority rules can set values. <br><br>SLOTS SET: Fontenelle.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>";
    BEGIN

      $ "Fontenelle.Outflow" [] := $ "Fontenelle.Inflow" [];

    END
    UUID "{48c935bf-7af4-4a02-aa8d-fbb9fd70490b}";;

    RULE                 "ForecastFutureFGInflow";
    DESCRIPTION          "DESCRIPTION: Determines the projected inflow for Flaming Gorge based on the sum of the projected outflow from Fontenelle and the local inflows between Fontenelle and Flaming Gorge.<br><br>SLOTS SET: FlamingGorgeData.ProjectedInflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: ce 6/6/13 (?)";
    BEGIN

      FOREACH (NUMERIC index IN "GetNumbers"( 1.00000000, IF ( ( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) < 0.00000000 ) COMMENTED_BY "Next month is greater than April, forecast to April of next year" )
 THEN
  12.00000000 - "Abs"( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) ) + 1.00000000
 ELSE
  ( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) + 1.00000000 ) COMMENTED_BY "Forecast to April of current year"
 ENDIF, 1.00000000 )) DO
            $ "FlamingGorgeData.ProjectedInflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] := ( GET @INDEX index - 1.00000000 FROM GET @INDEX 1.00000000 FROM "ForecastFontenelleRelease"( @"t + 1", @"24:00:00 April Max DayOfMonth, Next Year" ) ) + $ "GreenAboveFlamingGorge:InterveningAboveFlamingGorge.Local Inflow" ["OffsetDate"( @"t", index, "1 MONTHS" )];

      ENDFOREACH;

    END
    UUID "{f3b8d2cf-5fb7-4ee1-8f49-cc2b4eb4874f}";;

  END
  UUID "{7a873760-5a4f-477c-9bc5-253bd2d64401}";;

  POLICY_GROUP   "Set LB Outflows";
  DESCRIPTION    "This policy group contains rules that pertain to Lake Mead operations. Lake Mead has 2 basic modes of operation - meeting downstream demands or flood control.<br><br>There are two primary modes of operation at Lake Mead: Flood Control, and meet downstream demand. Flood Control operations are the highest priority, and are consistent with the 1984 Field Working Agreement between Reclamation and the U.S. Army Corps of Engineers (USACE Flood Control Manual). When Lake Mead is not in Flood Control, the system is operated to meet downstream water demands. In this mode of operation, releases from Lake Mead are currently governed by the 2007 Interim Guidelines. These guidelines specify conditions for determining when the Lower Basin water supply is under the Surplus, Normal, or Shortage Conditions. The guidelines also specify that when certain conditions exist, equalization or balancing of the contents of Lake Powell and Lake Mead shall be achieved. The coordinated operations of the reservoirs are consistent with the described methodology for Lake Powell operations in the previous section and follow the Lake Powell annual release flow chart. Other factors in setting Lake Mead operations are the 1944 Treaty with Mexico and International Boundary and Water Commission (IBWC) Minutes. <br><br>Lake Mohave<br>Lake Mead outflow takes into consideration the amount of water needed to be stored or released from Lake Mohave. The release from Lake Mohave is set to meet the downstream water demands while retaining the end of month target storage (see LBRuleCurveData.Mohave Target Storage).<br><br>Lake Havasu<br>As stated above, Lake Mead outflow takes into consideration the amount of water needed to be stored or released from Lake Mohave and Lake Havasu. The release from Lake Havasu is set with the objectives of meeting the downstream water demands while retaining the end of month target storage (see LBRuleCurveData.Havasu Target Storage). ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Flow To Mexico (flow at NIB) exp";
    DESCRIPTION          "DESCRIPTION: This rule computes the flow to Mexico as the scheduled diversion requested plus the excess and stores it on the Lower Basin Output data object in the slot NIBFlow for subsequent write to hdb<br><br>SLOTS SET: Lower Basin Output.NIBFlow<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>";
    BEGIN

    DESCRIPTION          "Calculate the NIB Flow based on any calculated excess to Mexico less the scheduled request for Mexico. ";
      $ "Lower Basin Output.NIBFlow" [] := $ "Lower Basin Output.MexicoExcessFlow" [] + $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [];

    END
    UUID "{f513418f-ed37-4b6c-9b46-826cf5092a9c}";;

    RULE                 "Set Mexico Excess";
    DESCRIPTION          "DESCRIPTION:  This rule determines the excess flow to Mexico which is just the actual Mead release minus the release determined to meet downstream requirements <br><br>SLOTS SET: Lower Basin Output.MexicoExcessFlow<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "If the Mead outflow is greater than the sum of the downtream demands, then Mexico gets the excess";
      $ "Lower Basin Output.MexicoExcessFlow" [] := $ "Mead.Outflow" [] - "VolumeToFlow"( $ "Lower Basin Output.DownstreamReq" [], @"t" );

    END
    UUID "{ebcafa4d-1d82-481b-ab17-51b9b4033083}";;

    RULE                 "Set DownStream Requirement exp";
    DESCRIPTION          "DESCRIPTION: This rule calculates the demand downstream of Lake Mead. It should get reset if shortage or surplus schedules are applied.<br><br>SLOTS SET: Lower Basin Output.DownstreamReq<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>S.Baker 06/20/2018: Added constraint to not use HavasuOutflow.BHOPSParkerOutflow slot prior during Testbed simulations.<br>";
    BEGIN

    DESCRIPTION          "Set the data object that reports the necessary water required downstream of Mead to meet all demands. ";
      $ "Lower Basin Output.DownstreamReq" [] := IF ( @"t" <= @"Start Timestep" AND ( $ "MTOMRunType.RunType" [] == 0.00000000 ) COMMENTED_BY "For operational MTOM only <br>" )
 THEN
  "FlowToVolume"( $ "HavasuOutflow.BHOPSParkerOutflow" [], @"t" )
 ELSE
  $ "HavasuOutflow.ParkerRequirement" []
 ENDIF + "SumAllDiversionsBelowVolume"( % "Mead", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Mead", @"t", @"t" ) + "ComputeDeltaTargetStorage"( % "Mohave" ) + "ComputeDeltaTargetStorage"( % "Havasu" ) + $ "Mohave.Evaporation" [] + $ "Havasu.Evaporation" [];

    END
    UUID "{3e563966-f875-4a72-9b74-d19d15d4a098}";;

    RULE                 "Set Parker Final Requirement";
    DESCRIPTION          "DESCRIPTION: This rule sets the data object slot HavasuOutflow.ParkerRequirement to the difference between the diversions and the local inflows below Havasu<br><br>SLOTS SET: HavasuOutflow.ParkerRequirement<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>S.Baker 06/20/2018: Added time constraint to use historical Gila flows during the testbed simulation during high Gila flows.";
    BEGIN

      $ "HavasuOutflow.ParkerRequirement" [] := "SumAllDiversionsBelowVolume"( % "Havasu", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Havasu", @"t", @"t" ) + IF ( "GetDate"( "January 31, 1993" ) <= @"t" AND @"t" <= "GetDate"( "April 30, 1993" ) )
 THEN
  "FlowToVolume"( $ "BelowImperialDam:Gila River.Local Inflow" [@"t"], @"t" )
 ELSE
  0.00000000 "acre-ft"
 ENDIF COMMENTED_BY "Testbed Hindcasts - for historical period when Gila had large inflows to the Colorado <br>";

    END
    UUID "{ad06f8d1-9152-457d-bd20-cb2228db89fe}";;

    RULE                 "Havasu Rule Curve";
    DESCRIPTION          "DESCRIPTION: In any month except the Start Timestep, set the Havasu outflow such that the reservoir pool elevation target is met. For testbed hindcasts, this rule executes in the Start Timestep to solve for outflow which is not input using the slot HavasuOutflow.BHOPSParkerOutflow.<br><br>SLOTS SET: Havasu.Outflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000 AND ( @"t" > @"Start Timestep" OR ( @"t" >= @"Start Timestep" AND $ "MTOMRunType.RunType" [] != 0.00000000 ) COMMENTED_BY "For testbed hindcasts, this rule solves for Havasu.Outflow in Start Timestep <br>" );
    NOTES                "AUTHOR, DATE: Unknown<br>Unknown Commenter, Unknown Date: This rule could just as easily use a target elevation rather than a storage. It would probably be safer to do so.<br><br>S.Baker 06/20/2018: Added execution constraint to solve this rule at start timestep for Testbed simulations.<br>SB 07/08/2019: Updated constraints to have Run Type not equal to 0 (allows for no dependence on BHOPS during development testing). ";
    BEGIN

      $ "Havasu.Outflow" [] := "SolveOutflow"( % "Havasu", $ "Havasu.Inflow" [], "GetTargetStorage"( % "Havasu", @"t" ), $ "Havasu.Storage" [@"t - 1"], @"t" );

    END
    UUID "{0375c354-2ed5-4241-9eca-df876c536bc8}";;

    RULE                 "Set Havasu Outflow Exp";
    DESCRIPTION          "DESCRIPTION: If the Havasu outflow is not set at the Start Timestep, set it to the BHOPS Parker Outflow, which is a user input value and comes from the 24 MS. <br><br>SLOTS SET: Havasu.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Havasu.Outflow" [] AND @"t" <= @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 1.00000000 AND ( $ "MTOMRunType.RunType" [] == 0.00000000 ) COMMENTED_BY "For operational MTOM only <br>";
    NOTES                "AUTHOR, DATE: Unknown<br>MC, 20160426: LC changed this from setting the first 2 months of the run to just the first month<br><br>S.Baker 06/20/2018: Added execution constraint to not use HavasuOutflow.BHOPSParkerOutflow slot prior during Testbed simulations.";
    BEGIN

      $ "Havasu.Outflow" [] := $ "HavasuOutflow.BHOPSParkerOutflow" [];

    END
    UUID "{33b3442f-e3fe-4cc1-bf0d-3e91221f5a39}";;

    RULE                 "Mohave Rule Curve";
    DESCRIPTION          "DESCRIPTION: Set the Outflow from Mohave to what is necesary to hit the Mohave Target Storages. This rule passes the inflow necessary to meet downstream demands and preserve the target storage for Mohave.<br><br>SLOTS SET: Mohave.Outflow<br><br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>Unknown Commenter, Unknow Date: This rule could just as easily use a target elevation rather than a storage. It would probably be safer to do so.";
    BEGIN

      $ "Mohave.Outflow" [] := "SolveOutflow"( % "Mohave", $ "Mohave.Inflow" [], "GetTargetStorage"( % "Mohave", @"t" ), $ "Mohave.Storage" [@"t - 1"], @"t" );

    END
    UUID "{eb9fe1ff-9f68-4273-9f41-8671b11fb9b9}";;

    RULE                 "Set Mead Outflow To Demands";
    DESCRIPTION          "DESCRIPTION: Set the Lake Mead outflow to the smaller of the sum of the lower basin demands OR the water available in Mead (if Run Cycle >=3; otherwise use 9,999,999 acre-ft/month). This rule can execute as many times as necessary to set releases to meet demands. <br><br>SLOTS SET: Mead.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>S.Baker 06/20/2018: Added constraint to not use HavasuOutflow.BHOPSParkerOutflow slot prior during Testbed simulations.<br>S.Baker 2018/10/17: Replace SumAllDiversionsBelowVolume(Havasu) - SumAllGainsBelowVolume(Havasu) with HavasuOutflow.ParkerRequirement. This change was made because this calculation was already performed in rule &quot;Set Parker Final Requirement&quot;, so it was repetative and problematic to recalculate them. This change is important during hindcast runs when the Gila River has ver high local inflows (Jan-Apr 1993). ";
    BEGIN

      $ "Mead.Outflow" [] := "Min"( IF ( "GetRunCycleIndex"(  ) >= 3.00000000 )
 THEN
  "CheckResPhysicalConstraint"( % "Mead", @"t" )
 ELSE
  9999999.00000000 "acre-ft/month"
 ENDIF, IF ( @"t" <= @"Start Timestep" AND ( $ "MTOMRunType.RunType" [] == 0.00000000 ) COMMENTED_BY "For operational MTOM only <br>" )
 THEN
  "VolumeToFlow"( "FlowToVolume"( $ "HavasuOutflow.BHOPSParkerOutflow" [], @"t" ) + "SumAllDiversionsBelowVolume"( % "Mead", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Mead", @"t", @"t" ) + "ComputeDeltaTargetStorage"( % "Mohave" ) + "ComputeDeltaTargetStorage"( % "Havasu" ) + $ "Mohave.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Mohave", "GetTargetStorage"( % "Mohave", @"t" ) ) + "StorageToArea"( % "Mohave", $ "Mohave.Storage" [@"t - 1"] ) ) / 2.00000000 ) * 1.00000000 "month" + $ "Havasu.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Havasu", "GetTargetStorage"( % "Havasu", @"t" ) ) + "StorageToArea"( % "Havasu", $ "Havasu.Storage" [@"t - 1"] ) ) / 2.00000000 ) * 1.00000000 "month", @"t" )
 ELSE
  "VolumeToFlow"( $ "HavasuOutflow.ParkerRequirement" [@"t"] + "SumAllDiversionsBelowVolume"( % "Mead", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Mead", @"t", @"t" ) + "ComputeDeltaTargetStorage"( % "Mohave" ) + "ComputeDeltaTargetStorage"( % "Havasu" ) + $ "Mohave.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Mohave", "GetTargetStorage"( % "Mohave", @"t" ) ) + "StorageToArea"( % "Mohave", "GetTargetStorage"( % "Mohave", @"t - 1" ) ) ) / 2.00000000 ) * 1.00000000 "month" + $ "Havasu.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Havasu", "GetTargetStorage"( % "Havasu", @"t" ) ) + "StorageToArea"( % "Havasu", "GetTargetStorage"( % "Havasu", @"t - 1" ) ) ) / 2.00000000 ) * 1.00000000 "month", @"t" )
 ENDIF );

    END
    UUID "{5a2f1e38-f3a3-4800-9a33-a26b907141e7}";;

  END
  UUID "{586ddaa3-719a-454a-a6a5-6f7dae3e56c7}";;

  POLICY_GROUP   "Set Future Uses - SNWP, CAP, MWD";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Reset Monthly Forecast Use CAP - Nov and Dec, Cur Year";
    DESCRIPTION          "DESCRIPTION: Reset the CAP Diversion requests based on the estimated available to CAP from the state apportionment and the other user diversion requests and the forecast scheduled volume for CAP.  This rule will only execute in the start timestep and set values for November and December.  This is so that if CAP sets a schedule in a timestep prior to November, the schedule can be adjusted in the last two months of the year such that there are no Arizona overruns. <br><br>SLOTS SET: CAPDiversion.Total Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND NOT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetMonth"( @"t" ) < 11.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "reset the CAP Diversion requests based on the estimated available to CAP from the state apportionment and the other user diversion requests and the forecast scheduled volume for CAP.  This <br><br>rule will only execute in the start timestep and set values for November and December.  This is so that if CAP sets a schedule in a timestep prior to November, the schedule can be adjusted in <br><br>the last two months of the year such that there are no Arizona overruns. ";
      FOREACH (DATETIME date IN @"24:00:00 November Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := ( ( "VolumeToFlow"( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Arizona_CU_Forecast1.CAP" ["Dec31ofYear"( date )], date ) ) / 2.00000000 + "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date ) );

      ENDFOREACH;

    END
    UUID "{46c06ffb-507e-4fc1-bc8d-a98cd4cb34ac}";;

    RULE                 "Reset Monthly Forecast Use CAP - All Months Outyears";
    DESCRIPTION          "DESCRIPTION: Reset the CAP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests). <br><br>SLOTS SET: CAPDiversion.Total Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>AP, 9/18/2018: Moved CAP logic to function called CAP_Outyear_Schedules. Referenced function in rule.";
    BEGIN

    DESCRIPTION          "Reset the CAP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests). ";
      FOREACH (DATETIME date IN "GetFirstDate"( @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := "CAP_Outyear_Schedules"( date );

      ENDFOREACH;

    END
    UUID "{21db1fa6-6df2-4b18-9acf-f722210fb9b7}";;

    RULE                 "Reset Monthly Forecast Use SNWP All Years";
    DESCRIPTION          "DESCRIPTION: Reset the SNWP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests).  Sets LBDV.ScehduleCheck value to 0 (normal operating condition)<br><br>SLOTS SET: PumpingFromLakeMead:SNWP.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>AP, 9/18/2018: Moved SNWP logic to function called SNWP_Schedules. Referenced function in rule. Changed logic in SNWP Schedules function to refernce Nevada_CU_Schedules instead of PumpingfromMead. Added LBDV.Schedule check inital set up value";
    BEGIN

    DESCRIPTION          "Reset the SNWP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests).  ";
      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (SLOT slot IN { $ "PumpingFromLakeMead:SNWP.Diversion Requested" , $ "PumpingFromLakeMead:SNWP.Depletion Requested" }) DO
            slot [date] := "SNWP_Schedules"( date );

      ENDFOREACH;

      ENDFOREACH;

      $ "LowerBasinDemandVariability.ScheduleCheck" ["Dec31ofYear"( @"t" )] := 0.00000000;

    END
    UUID "{d8c940fe-8ff1-4a07-89c2-08629557ebd0}";;

    RULE                 "Redistribute MWD Nov & Dec Div Request";
    DESCRIPTION          "DESCRIPTION: This rule redistributes Nov and Dec MWD requests that may be over the canal capacity.  This can occur when LBDV is initiated below Parker and there is additional supply available to MWD.<br><br>SLOTS SET: MWDDiversion:MWD.Diversion Requested; ICS Credits.AnnualCreationEC_CA<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND NOT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetMonth"( @"t" ) < 11.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: MC/JR, Unknown<br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed, also changing ForecastUse.MWDResetAnnualFC, because creation of EC ICS (an Input value) is not allowed in that case (Shortage).<br>MC, 20180125: Removed Shortage as condition for Execution Constraint based on USBR changes to rules<br>CH, 4/25/18: Removed run cycle == 3.0 constraint since rule only fires in start year (therefore should not refire in run cycle 3 for any reason, even in shortage conditions - causes the rule to add twice the amount of water available)<br>GCAA, 20181030: Changed reference from MWDDiversionData.MWDCanal_DailyCapacity slot to MWDAndCAPRech: MWDDiversion. Diversion Capacity slot";
    BEGIN

      WITH_STATEMENT (NUMERIC InitialTotalRequest = FOR ( DATETIME date IN "GetDates"( @"t", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "MWDDiversion.Total Diversion Requested" [date], date )
 ENDFOR) DO
          DESCRIPTION          "<br>If Nov or Dec diversion request exceeds canal capacity, redistribute the excess request to months between the current month and October of the current year.<br>";
      WITH_STATEMENT (NUMERIC NovExcessRequest = "Max"( $ "MWDDiversion.Total Diversion Requested" [@"24:00:00 November Max DayOfMonth, Current Year"] - $ "MWDDiversionData.MWDCanal_DailyCapacity" [], 0.00000000 "acre-feet/month" )) DO
            WITH_STATEMENT (NUMERIC DecExcessRequest = "Max"( $ "MWDDiversion.Total Diversion Requested" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "MWDDiversionData.MWDCanal_DailyCapacity" [], 0.00000000 "acre-feet/month" )) DO
            IF_STATEMENT (NovExcessRequest + DecExcessRequest > 0.00000000 "acre-feet/month") THEN
          DESCRIPTION          "Redistribute excess diversion requests";
      FOREACH (DATETIME date IN "GetDates"( @"t", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" )) DO
            $ "MWDDiversion:MWD.Diversion Requested" [date] := ( GET @INDEX "GetMonth"( date ) - 1.00000000 FROM "CheckAndAdjustToCapacity"( $ "MWDDiversion.Total Diversion Requested", $ "MWDDiversionData.MWDCanal_DailyCapacity" [] ) ) - $ "MWDDiversion:Tijuana.Diversion Requested" [date];

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC FinalTotalRequest = FOR ( DATETIME date IN "GetDates"( @"t", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "MWDDiversion.Total Diversion Requested" [date], date )
 ENDFOR) DO
          DESCRIPTION          "If the request excess is more than available capacity, assign the remainder to <br>ICS EC credits";
      WITH_STATEMENT (NUMERIC ICSAddition = "Max"( InitialTotalRequest - FinalTotalRequest, 0.00000000 "acre-feet" )) DO
            $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )] := NaNToZero ( $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )] ) + ICSAddition;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END
    UUID "{5e060dc1-bbce-4060-af25-f6f7b749b1a6}";;

    RULE                 "Reset Monthly Forecast Use MWD - Nov and Dec, Cur Year";
    DESCRIPTION          "DESCRIPTION: Reset the MWD DIversion and depletion requests based on the estimated available to MWD from the state apportionment and the other user diversion requests and the forecast scheduled volume for MWD.  This rule will only execute in the start timestep and set values for November and December.  This is so that if MWD sets a schedule in a timestep prior to November, the schedule can be adjusted in the last two months of the year such that there are no California overruns. <br><br>SLOTS SET: MWDDiversion:MWD.Depletion Requested; MWDDiversion:MWD.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND NOT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetMonth"( @"t" ) < 11.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed, also changing ForecastUse.MWDResetAnnualFC, because creation of EC ICS (an Input value) is not allowed in that case.<br>MC, 20180125: Removed Shortage as condition for Execution Constraint based on USBR changes to rules<br>CH, 3/18: Removed run cycle == 3.0 constraint since rule only fires in start year (therefore should not refire in run cycle 3 for any reason, even in shortage conditions - causes the rule to add twice the amount of water available)";
    BEGIN

    DESCRIPTION          "reset the MWD DIversion and depletion requests based on the estimated <br>available to MWD from the state apportionment and the other user diversion <br>requests and the forecast scheduled volume for MWD.  <br><br>This rule will only execute in the start timestep and set values for November and December.  This is so that if MWD sets a schedule in a timestep prior to November, the schedule can be adjusted in the last two months of the year such that there are no California overruns. ";
      FOREACH (DATETIME date IN @"24:00:00 November Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC mwdDepletionAmount = "Max"( 0.00000000 "acre-ft/month", ( "VolumeToFlow"( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "California_CU_Forecast1.MWD" ["Dec31ofYear"( date )], date ) ) / 2.00000000 + $ "MWDDiversion:MWD.Depletion Requested" [date] )) DO
            $ "MWDDiversion:MWD.Depletion Requested" [date] := mwdDepletionAmount;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := mwdDepletionAmount + "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

      END_WITH_STATEMENT;

      ENDFOREACH;

    END
    UUID "{efcb9e54-8d56-452f-b9f7-d8a6b6402d05}";;

    RULE                 "Reset Monthly Forecast Use MWD - All Months Outyears";
    DESCRIPTION          "DESCRIPTION: Reset the MWD Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests).  This calculation gives the amount of water that California can take as a consumptive use amount so the diversion needs to be set to that amount plus the estimated return flow that is returned at the diversion location. <br><br>SLOTS SET: MWDDiversion:MWD.Depletion Requested; MWDDiversion:MWD.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND ( ( "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 3.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 ) );
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed, also changing ForecastUse.MWDResetAnnualFC, because creation of EC ICS (an Input value) is not allowed in that case.<br><br>AP, 9/18/2018: Moved MWD  logic to function called MWD_Outyear_Schedules. Referenced function in rule. ";
    BEGIN

    DESCRIPTION          "Reset the MWD Diversion request based on the reset annual forecast use (difference in state apportionment and the other <br>diversion requests).  This calculation gives the amount of water that California can take as a consumptive use amount so <br>the diversion needs to be set to that amount plus the estimated return flow that is returned at the diversion location. ";
      FOREACH (DATETIME date IN "GetFirstDate"( @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC mwdDepletionAmount = "MWD_Outyear_Schedules"( date )) DO
            $ "MWDDiversion:MWD.Depletion Requested" [date] := mwdDepletionAmount;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := mwdDepletionAmount + "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

      END_WITH_STATEMENT;

      ENDFOREACH;

    END
    UUID "{563dc57a-88df-4805-b064-14156d08eab3}";;

    RULE                 "SumAnnualStateUse - Div Req";
    DESCRIPTION          "DESCRIPTION: Sum the Annual State Use based on the monthly orders for AZ without CAP, NV, and CA without MWD<br><br>SLOTS SET: AnnualWaterUse.AzNoCAPTotalAnnual; AnnualWaterUse.NvTotalAnnual; AnnualWaterUse.CaNoMWDTotalAnnual";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Sum the Annual State Use based on the Monthly orders for AZ without CAP, Nevada, and <br><br>California with no MWD considered. ";
      FOREACH (STRING state IN { "AzNoCAP" , "Nv" , "CaNoMWD" }) DO
            "AnnualWaterUse." CONCAT state CONCAT "TotalAnnual" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
 THEN
  "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyOrder" ), @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" ) + "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyActual" ), @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" )
 ELSE
  "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyOrder" ), @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" )
 ENDIF;

      ENDFOREACH;

    END
    UUID "{83e8f68d-0c6d-4521-975e-289b72ece3e4}";;

    RULE                 "SumStateMonthlyOrders - DivReq";
    DESCRIPTION          "DESCRIPTION: Sum the monthly AZ no CAP, NV, and CA no MWD orders based on the set diversion request for each state's diversion locations.<br><br>SLOTS SET: AnnualWaterUse.AzNoCAPTotalMonthlyOrder; AnnualWaterUse.NvTotalMonthlyOrder; AnnualWaterUse.CaNoMWDTotalMonthlyOrder";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Sum the Monthly AZ no CAP, Nevada, and CA no MWD orders based on the set diversion request <br><br>for each state's diversion locations. ";
      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "AnnualWaterUse.AzNoCAPTotalMonthlyOrder" [date] := "FlowToVolume"( $ "AzPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaGravityMainCanal.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaAndYumaUsers.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR:CRIRAz.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:BlmPumpersBlwImp.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:SouthernPacific.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:YAO.Diversion Requested" [date], date ) + "FlowToVolume"( $ "FtMohaveIndRes:AZ.Diversion Requested" [date], date ) + "FlowToVolume"( $ "AzDvsToPkr.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "PumpingFromLakeMead:LMNRA Az Mead.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Az Mohave.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:Ft Yuma.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:DavisDamProject.Diversion Requested" [date], date );

            $ "AnnualWaterUse.NvTotalMonthlyOrder" [date] := "FlowToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date], date ) + "FlowToVolume"( $ "NvDvsToPkr.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "FtMohaveIndRes:NV.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date], date );

            $ "AnnualWaterUse.CaNoMWDTotalMonthlyOrder" [date] := "FlowToVolume"( $ "AAC.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaDvsToPkr.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR:CRIRCa.Diversion Requested" [date], date ) + "FlowToVolume"( $ "FtMohaveIndRes:CA.Diversion Requested" [date], date ) + "FlowToVolume"( $ "PaloVerde.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:YumaIsland.Diversion Requested" [date], date );

      ENDFOREACH;

    END
    UUID "{7764ff99-7df7-485a-b1de-8bf3e55a4fab}";;

    RULE                 "Set Normal Schedules MWD & SNWP";
    DESCRIPTION          "DESCRIPTION: Set the MWD Diversion Request and Depletion Request and the SNWP Diversion request to the normal schedules input to the MTOM model.<br><br>SLOTS SET: MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested; PumpingFromLakeMead:SNWP.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>Need to separate CAP & CVWD from MWD & SNWP for full surplus";
    BEGIN

    DESCRIPTION          "Set the MWD Diversion Request and Depletion Request and the SNWP Diversion request to the <br><br>normal schedules input to the MTOM model.";
      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December 31, Finish Year") DO
            $ "MWDDiversion:MWD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.MWDDiversion" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.MWDDiversion" [date], date )
 ENDIF;

            $ "MWDDiversion:MWD.Depletion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.MWD" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.MWD" [date], date )
 ENDIF;

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.SNWP" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.SNWP" [date], date )
 ENDIF;

      ENDFOREACH;

    END
    UUID "{768e94db-8bd9-47ef-9543-f7c6fe069ced}";;

    RULE                 "Set Normal Schedules CAP";
    DESCRIPTION          "DESCRIPTION: Set the CAP Diversion Request to the Normal input schedule for CAP<br><br>SLOTS SET: CAPDiversion.Total Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>May need 2nd condition (@t = Jan, current year) for full surplus<br>Need to separate CAP from MWD & SNWP for full surplus";
    BEGIN

    DESCRIPTION          "Set the CAP Diversion Request to the Normal input schedule for CAP";
      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December 31, Finish Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CAP" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date )
 ENDIF;

      ENDFOREACH;

    END
    UUID "{ffb99887-2fbd-4288-8b05-6034020e4dc0}";;

    RULE                 "Reset MWD Annual Forecast Use - Force to CA Apportionment";
    DESCRIPTION          "DESCRIPTION: Set the MWD Forecast annual diversion to the state apportionment (in the deterministic run or in the first year of the run, use the input state apportionment, in an outyear use the adjusted state apportionment), less any senior users to MWD diversion requested. <br><br>SLOTS SET: ForecastUse.MWDResetAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000 OR ( "GetRunCycleIndex"(  ) == 3.00000000 AND ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND NOT "HasRuleFiredSuccessfully"( "True" ) AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed because creation of EC ICS (an Input value) is not allowed in that case.";
    BEGIN

    DESCRIPTION          "Set the MWD Forecast annual diversion to the state apportionment (in the deterministic run or in <br><br>the first year of the run, use the input state apportionment, in an outyear use the adjusted state <br><br>apportionment), less any senior users to MWD diversion requested. ";
      $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] := "Min"( $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [], IF ( "IsMRM"(  ) )
 THEN
  IF ( @"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" )
  THEN
   $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
  ELSE
   $ "AnnualWaterUse.California_PreliminaryAdjustedApportionment" [@"24:00:00 December 31, Current Year"]
  ENDIF
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF - FOR ( DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 January Max DayOfMonth, Current Year" ) TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  FOR ( OBJECT diversionSite IN "ListSubbasin"( "California nonMWD WaterUsers" ) ) STAT_SUM
   IF ( diversionSite == % "PaloVerde" )
   THEN
    "FlowToVolume"( diversionSite & "Total Diversion Requested" [date], date )
   ELSE
    "FlowToVolume"( diversionSite & "Diversion Requested" [date], date )
   ENDIF
  ENDFOR
 ENDFOR COMMENTED_BY "Sum all Non MWD Diversion Requests" );

    END
    UUID "{544ed018-d60e-4aad-acb5-dd4c656bc465}";;

    RULE                 "Reset Annual CAP Forecast Use - Force to AZ Apportionment";
    DESCRIPTION          "DESCRIPTION: Set the CAP annual diversion to the AZ state apportionment less the more senior Arizona diversions. <br><br>SLOTS SET: ForecastUse.CAPResetAnnualFC<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Set the CAP annual diversion to the AZ state apportionment less the more senior Arizona diversions. ";
      $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.Arizona_Apportionment" [@"24:00:00 December 31, Current Year"] - FOR ( DATETIME date IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year" ) STAT_SUM
  FOR ( OBJECT nonCAPUser IN "ListSubbasin"( "ArizonaNonCAPWaterUsers" ) ) STAT_SUM
   "FlowToVolume"( nonCAPUser & "Diversion Requested" [date], date )
  ENDFOR
 ENDFOR COMMENTED_BY "Sum all Non CAP Diversion Requests";

    END
    UUID "{668578ea-2770-4bda-80d5-476c189e9839}";;

    RULE                 "Reset Annual SNWP Forecast Use - Force to NV Apportionment";
    DESCRIPTION          "DESCRIPTION: Set the SNWP Forecast value to the difference between the Nevada State Apportionment and the other Nevada users. <br><br>SLOTS SET: ForecastUse.SNWPResetAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Set the SNWP Forecast value to the difference between the Nevada State <br>Apportionment and the other Nevada users. ";
      $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"] - FOR ( DATETIME date IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year" ) STAT_SUM
  "FlowToVolume"( $ "FtMohaveIndRes:NV.Diversion Requested" [date], date ) + "FlowToVolume"( $ "NvDvsToPkr:BigBend.Diversion Requested" [date], date ) + "FlowToVolume"( $ "NvDvsToPkr:SCE.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date], date )
 ENDFOR COMMENTED_BY "Sum all Non SNWP Nevada Diversion Requests";

    END
    UUID "{6b824f48-1616-4d21-8f3e-816e455c3b3e}";;

  END
  UUID "{7e173aff-9bcd-40e6-b773-b139658bd9bb}";;

  POLICY_GROUP   "LC WaterUse Data Setup";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Below Parker Hydrologic Demand Variability";
    DESCRIPTION          "DESCRIPTION: Allow the senior users in the Lower Basin to take additional water or decrease their demand based on the Below Parker Hydrologic Demand Variability.  If the local inflows below Parker are greater than the historic 90th percentile (wet) observed value, then decrease the diversion requests by 10%. If the local inflows are less than the 10th percentile (dry) observed value, then increase the diversion requests by 5%. <br><br>SLOTS SET: PaloVerde.Total Diversion Requested; CRIR:CRIRAz.Diversion Requested; AAC:IID.Diversion Requested; AAC:Coachella.Diversion Requested; GilaGravityMainCanal:WMIDD.Diversion Requested; GilaGravityMainCanal:YCWUA.Diversion Requested; GilaGravityMainCanal:YMIDD.Diversion Requested; LowerBasinDemandVariability.BlwParkerTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) AND "IsMRM"(  );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "PaloVerde.Total Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.PaloVerde" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "PVID" );

            $ "CRIR:CRIRAz.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.CRIRAz" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "CRIRaz" );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.IID" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "IID" );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.Coachella" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "CVWD" );

            $ "GilaGravityMainCanal:WMIDD.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.WMIDD" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "WMIDD" );

            $ "GilaGravityMainCanal:YCWUA.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.YCWUA" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "YCWUA" );

            $ "GilaGravityMainCanal:YMIDD.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.YMIDD" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "YMIDD" );

            $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( date )] := IF ( "AgUsersBelowParkerDemandVariabilityFactor"( date, "PVID" ) == 1.00000000 )
 THEN
  0.00000000
 ELSE
  IF ( "AgUsersBelowParkerDemandVariabilityFactor"( date, "PVID" ) == 0.90000000 )
  THEN
   1.00000000
  ELSE
   - 1.00000000
  ENDIF
 ENDIF;

      ENDFOREACH;

    END
    UUID "{4a2b56f7-5971-4b70-9d9b-c299bd8286dc}";;

    RULE                 "Set Operational GainLoss";
    DESCRIPTION          "DESCRIPTION: Set the Operational Gain loss on the Havasu to Imperial Reach object by taking the difference between what is scheduled on the reach objects and what is input to the model as the Scheduled outflow from Havasu. <br><br>SLOTS SET: HavasuToImperial:DailyOperationalGainLoss.LocalInflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker 06/20/2018: Added constraint to not use HavasuOutflow.BHOPSParkerOutflow slot prior during Testbed simulations.";
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "HavasuToImperial:DailyOperationalGainLoss.Local Inflow" [date] := IF ( date <= @"Start Timestep + 1" AND ( $ "MTOMRunType.RunType" [] == 0.00000000 ) COMMENTED_BY "For operational MTOM only <br>" )
 THEN
  ( "VolumeToFlow"( $ "HavasuOutflow.ParkerScheduleRequirement" [date], date ) - $ "HavasuOutflow.BHOPSParkerOutflow" [date] )
 ELSE
  0.00000000 "acre-ft/month"
 ENDIF;

      ENDFOREACH;

    END
    UUID "{04bca818-17f0-4220-96b3-05d37ba74ece}";;

    RULE                 "Set Parker Schedule Requirement";
    DESCRIPTION          "DESCRIPTION: Sum the diversion requests that were set in a previous rule and set the slot value for the total required release from Havasu for the model run period.<br><br>SLOTS SET: HavasuOutflow.ParkerScheduleRequirement<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND IsNaN $ "HavasuOutflow.ParkerScheduleRequirement" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "HavasuOutflow.ParkerScheduleRequirement" [date] := "FlowToVolume"( $ "AAC.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "AzPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaAndYumaUsers.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaGravityMainCanal.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "PaloVerde.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "MexicanTreatyDelivery.Total Diversion Requested" [date], date ) - ( "FlowToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date], date ) + "FlowToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date], date ) + "FlowToVolume"( $ "BelowImperialDam:Gila River.Local Inflow" [date], date ) );

      ENDFOREACH;

    END
    UUID "{dfdd7d1f-c7ac-4df0-9c43-f80279333e84}";;

    RULE                 "Sum State Monthly Actual CU";
    DESCRIPTION          "DESCRIPTION: Calculate the Annual Consumptive Use values for all users in each of the lower basin states less the junior priority users, if applicable, for the beginning of the current year to the timestep prior to the run start. For Arizona, calculate the consumptive use forecast without CAP considered. For Nevada calculate the total Consumptive use forecast. For California, calculate the consumptive use forecast without MWD being considered.<br><br>SLOTS SET: AnnualWaterUse.AzNoCAPTotalMonthlyActual; AnnualWaterUse.NvTotalMonthlyActual; AnnualWaterUse.CaNoMWDTotalMonthlyActual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
            $ "AnnualWaterUse.AzNoCAPTotalMonthlyActual" [date] := $ "Arizona_CU_Actual.CRIRAz" [date] + $ "Arizona_CU_Actual.CibolaNWR" [date] + $ "Arizona_CU_Actual.CibolaValleyIID" [date] + $ "Arizona_CU_Actual.City of Parker" [date] + $ "Arizona_CU_Actual.ImperialNWR" [date] + $ "Arizona_CU_Actual.BrookeWater" [date] + $ "Arizona_CU_Actual.Ehrenberg" [date] + $ "Arizona_CU_Actual.AzPumpersAbvImp" [date] + $ "Arizona_CU_Actual.AzPumpersBlwImp" [date] + $ "Arizona_CU_Actual.BlmPumpersAbvImp" [date] + $ "Arizona_CU_Actual.BlmPumpersBlwImp" [date] + $ "Arizona_CU_Actual.NGVIDD" [date] + $ "Arizona_CU_Actual.WMIDD" [date] + $ "Arizona_CU_Actual.YCWUA" [date] + $ "Arizona_CU_Actual.MCAirStation" [date] + $ "Arizona_CU_Actual.YMIDD" [date] + $ "Arizona_CU_Actual.YID" [date] + $ "Arizona_CU_Actual.UnitB" [date] + $ "Arizona_CU_Actual.City of Yuma" [date] + $ "Arizona_CU_Actual.UofA" [date] + $ "Arizona_CU_Actual.LakeHavasuCity" [date] + $ "Arizona_CU_Actual.YumaUnionHighScl" [date] + $ "Arizona_CU_Actual.YumaProvingGround" [date] + $ "Arizona_CU_Actual.Cocopah Indian Res" [date] + $ "Arizona_CU_Actual.Gila Monster Farms" [date] + $ "Arizona_CU_Actual.DesertLawnMemorial" [date] + $ "Arizona_CU_Actual.SouthernPacific" [date] + $ "Arizona_CU_Actual.YAO" [date] + $ "Arizona_CU_Actual.BullheadCity" [date] + $ "Arizona_CU_Actual.FtMohaveAz" [date] + $ "Arizona_CU_Actual.DavisDamProject" [date] + $ "Arizona_CU_Actual.MohaveValleyIID" [date] + $ "Arizona_CU_Actual.MohaveWaterConsDist" [date] + $ "Arizona_CU_Actual.HavasuNWR" [date] + $ "Arizona_CU_Actual.GoldenShores" [date] + $ "Arizona_CU_Actual.LMNRA Az Mead" [date] + $ "Arizona_CU_Actual.LMNRA Az Mohave" [date] + $ "Arizona_CU_Actual.Ft Yuma" [date] + $ "Arizona_CU_Actual.AzPumpersDvsToPkr" [date];

            $ "AnnualWaterUse.NvTotalMonthlyActual" [date] := $ "Nevada_CU_Actual.SNWP" [date] + $ "Nevada_CU_Actual.FtMohaveNv" [date] + $ "Nevada_CU_Actual.BigBend" [date] + $ "Nevada_CU_Actual.SCE" [date] + $ "Nevada_CU_Actual.LMNRA Mohave" [date];

            $ "AnnualWaterUse.CaNoMWDTotalMonthlyActual" [date] := $ "California_CU_Actual.CaPumpersAbvImp" [date] + $ "California_CU_Actual.Chemehuevi" [date] + $ "California_CU_Actual.Coachella" [date] + $ "California_CU_Actual.CRIRCa" [date] + $ "California_CU_Actual.FtMohaveCa" [date] + $ "California_CU_Actual.IID" [date] + $ "California_CU_Actual.Needles" [date] + $ "California_CU_Actual.OtherLCWSP" [date] + $ "California_CU_Actual.PaloVerde" [date] + $ "California_CU_Actual.Ranch5" [date] + $ "California_CU_Actual.SaltonSea" [date] + $ "California_CU_Actual.Winterhaven" [date] + $ "California_CU_Actual.YumaIsland" [date] + $ "California_CU_Actual.YumaProject" [date];

      ENDFOREACH;

    END
    UUID "{074e3a35-f288-4627-9263-86bb45d7b920}";;

    RULE                 "Overruns Based on State Apportionments";
    DESCRIPTION          "DESCRIPTION: Estimate each lower basin state's Overrun based on the forecast values and the state apportionment values<br><br>SLOTS SET: California_CU_Overrun.California_Overrun_State_Ap;Arizona_CU_Overrun.Arizona_Overrun_State_Ap; Nevada_CU_Overrun.Nevada_Overrun_State_Ap;<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            "GetObject"( state CONCAT "_CU_Overrun" ) & ( state CONCAT "_Overrun_State_Ap" ) [] := % "AnnualWaterUse" & ( state CONCAT "_Forecast1" ) [@"24:00:00 December 31, Current Year"] - % "AnnualWaterUse" & ( state CONCAT "_Apportionment" ) [@"24:00:00 December 31, Current Year"];

      ENDFOREACH;

    END
    UUID "{ba177302-b731-43b6-8149-bf9008564815}";;

    RULE                 "Sum Annual Approvals for Lower Basin States";
    DESCRIPTION          "DESCRIPTION: Sum the monthly Annual Approval input values to Annual Approval values calculated from the input consumptive use schedules at the beginning of the run. <br><br>SLOTS SET: AnnualWaterUse.California_AnnualApproval; AnnualWaterUse.Nevada_AnnualApproval; AnnualWaterUse.Arizona_AnnualApproval;<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "AnnualWaterUse" & ( state CONCAT "_AnnualApproval" ) [@"24:00:00 December 31, Current Year"] := IF ( state == "Nevada" )
 THEN
  $ "Nevada_CU_AnnualApproval.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.BigBend" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.FtMohaveNv" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.LMNRA Mohave" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.SCE" [@"24:00:00 December 31, Current Year"]
 ELSE
  IF ( state == "California" )
  THEN
   "SumSlotListDates"( "GetObject"( state CONCAT "_CU_AnnualApproval" ), @"24:00:00 December 31, Current Year" ) - $ "California_CU_AnnualApproval.MWDDiversion" [@"24:00:00 December 31, Current Year"] - $ "California_CU_AnnualApproval.MWDReturns" [@"24:00:00 December 31, Current Year"]
  ELSE
   "SumSlotListDates"( "GetObject"( state CONCAT "_CU_AnnualApproval" ), @"24:00:00 December 31, Current Year" )
  ENDIF
 ENDIF;

      ENDFOREACH;

    END
    UUID "{3c7abdfe-ad66-44e1-bea0-7bb0c3e018fa}";;

    RULE                 "Sum Annual Forecast1 for Lower Basin States";
    DESCRIPTION          "DESCRIPTION: Sum the various components for each state forecast and set and Annual Forecast estimation for each state<br><br>SLOTS SET: AnnualWaterUse.California_Forecast1; AnnualWaterUse.Nevada_Forecast1; AnnualWaterUse.Arizona_Forecast1<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "AnnualWaterUse" & ( state CONCAT "_Forecast1" ) [@"24:00:00 December 31, Current Year"] := IF ( state == "Nevada" )
 THEN
  $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.BigBend" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.FtMohaveNv" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.LMNRA Mohave" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.SCE" [@"24:00:00 December 31, Current Year"]
 ELSE
  IF ( state == "California" )
  THEN
   "SumSlotListDates"( % "California_CU_Forecast1", @"24:00:00 December 31, Current Year" ) - $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"] - $ "California_CU_Forecast1.MWDReturns" [@"24:00:00 December 31, Current Year"]
  ELSE
   "SumSlotListDates"( % "Arizona_CU_Forecast1", @"24:00:00 December 31, Current Year" )
  ENDIF
 ENDIF;

      ENDFOREACH;

    END
    UUID "{a0c88090-f56a-4e20-8edf-bea9a8bd42c1}";;

    RULE                 "Set Forecast1";
    DESCRIPTION          "DESCRIPTION: Determine the Annual Demand for each user in each &quot;State_CU_Forecast1&quot; object by summing the actual and consumptive use schedules for each user. <br><br>SLOTS SET: <state>_CU_Forecast1.<user><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" , "Mexico" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Forecast1" ) )) DO
            "GetObject"( state CONCAT "_CU_Forecast1" ) & user [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
 THEN
  "SumSlot"( "GetObject"( state CONCAT "_CU_Actual" ) & user, @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" ) + "SumSlot"( "GetObject"( state CONCAT "_CU_Schedules" ) & user, @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" )
 ELSE
  "AnnualVolumeSlot"( "GetObject"( state CONCAT "_CU_Schedules" ) & user )
 ENDIF;

      ENDFOREACH;

      ENDFOREACH;

    END
    UUID "{9d1216c4-ec52-4468-a32d-0b92fff6e234}";;

    RULE                 "Set Schedules Volume to Flow";
    DESCRIPTION          "DESCRIPTION: For Each user in California, Arizona and Nevada, set the Reach Simulation Diversion request as this will allow the simulation of the Basin for the RiverWare model.  Setting these diversion requests so early in the ruleset allows for this initial setting of Lower Basin Demands that will ultimately sum to be the outflow from Lake Mead.  This step and the following rules will allow for the MTOM model to simulate in a somewhat realistic way and help in the Lake Powell Tier determination that occurs later in the policy. This rule sets the monthly diversion requests for lower basin diversion for each timestep in the run period. - CE 9/17/13<br><br>SLOTS SET:<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December 31, Finish Year") DO
            $ "PaloVerde.Total Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.PaloVerde" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.PaloVerde" [date], date )
 ENDIF;

            $ "CRIR:CRIRAz.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CRIRAz" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CRIRAz" [date], date )
 ENDIF;

            $ "CRIR:CRIRCa.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.CRIRCa" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.CRIRCa" [date], date )
 ENDIF;

            $ "CaPkrToImp:Winterhaven.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Winterhaven" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Winterhaven" [date], date )
 ENDIF;

            $ "CaPkrToImp:CaPumpersAbvImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.CaPumpersAbvImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.CaPumpersAbvImp" [date], date )
 ENDIF;

            $ "AzPkrToImp:AzPumpersAbvImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersAbvImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersAbvImp" [date], date )
 ENDIF;

            $ "AzPkrToImp:BlmPumpersAbvImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BlmPumpersAbvImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BlmPumpersAbvImp" [date], date )
 ENDIF;

            $ "AzPkrToImp:BrookeWater.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BrookeWater" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BrookeWater" [date], date )
 ENDIF;

            $ "AzPkrToImp:CibolaNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CibolaNWR" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CibolaNWR" [date], date )
 ENDIF;

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CibolaValleyIID" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CibolaValleyIID" [date], date )
 ENDIF;

            $ "AzPkrToImp:Ehrenberg.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Ehrenberg" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Ehrenberg" [date], date )
 ENDIF;

            $ "AzPkrToImp:ImperialNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.ImperialNWR" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.ImperialNWR" [date], date )
 ENDIF;

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.City of Parker" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.City of Parker" [date], date )
 ENDIF;

            $ "AAC:SaltonSea.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.SaltonSea" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.SaltonSea" [date], date )
 ENDIF;

            $ "AAC:IID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.IID" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.IID" [date], date )
 ENDIF;

            $ "AAC:Coachella.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Coachella" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Coachella" [date], date )
 ENDIF;

            $ "AAC:YumaProject.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.YumaProject" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.YumaProject" [date], date )
 ENDIF;

            $ "AAC:Ranch5.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Ranch5" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Ranch5" [date], date )
 ENDIF;

            $ "GilaAndYumaUsers:CocopahIndRes.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Cocopah Indian Res" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Cocopah Indian Res" [date], date )
 ENDIF;

            $ "GilaAndYumaUsers:DesertLawnMemorial.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.DesertLawnMemorial" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.DesertLawnMemorial" [date], date )
 ENDIF;

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Gila Monster Farms" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Gila Monster Farms" [date], date )
 ENDIF;

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersBlwImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersBlwImp" [date], date )
 ENDIF;

            $ "OthersBlwImp:BlmPumpersBlwImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BlmPumpersBlwImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BlmPumpersBlwImp" [date], date )
 ENDIF;

            $ "OthersBlwImp:SouthernPacific.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.SouthernPacific" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.SouthernPacific" [date], date )
 ENDIF;

            $ "OthersBlwImp:YAO.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YAO" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YAO" [date], date )
 ENDIF;

            $ "OthersBlwImp:YumaIsland.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.YumaIsland" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.YumaIsland" [date], date )
 ENDIF;

            $ "OthersBlwImp:Ft Yuma.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Ft Yuma" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Ft Yuma" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:CityOfYuma.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.City of Yuma" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.City of Yuma" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:MCAirStation.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.MCAirStation" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.MCAirStation" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:NGVIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.NGVIDD" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.NGVIDD" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:UnitB.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.UnitB" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.UnitB" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:UofA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.UofA" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.UofA" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:WMIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.WMIDD" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.WMIDD" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YCWUA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YCWUA" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YCWUA" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YID" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YID" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YMIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YMIDD" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YMIDD" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YumaProvingGround.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YumaProvingGround" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YumaProvingGround" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YumaUnionHighScl.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YumaUnionHighScl" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YumaUnionHighScl" [date], date )
 ENDIF;

            $ "MWDDiversion:Tijuana.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoTJ" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoTJ" [date], date )
 ENDIF;

            $ "MWDDiversion:Tijuana.Depletion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoTJ" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoTJ" [date], date )
 ENDIF;

            $ "MWDDiversion.Total Return Flow" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.MWDReturns" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date )
 ENDIF;

            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoSched" [date] - $ "Mexico_CU_Actual.MexicoTJ" [date], date )
 ELSE
  "VolumeToFlow"( $ "AnnualWaterUse.Mexico_OutyearVolume" ["Dec31ofYear"( date )] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Mexico"] + $ "Mexico Shortage and Surplus.AnnualCreationMexicoWaterReserve" ["Dec31ofYear"( date )] - $ "Mexico Shortage and Surplus.AnnualDeliveryMexicoWaterReserve" ["Dec31ofYear"( date )], date )
 ENDIF
 ELSEIF_COND ( "GetYear"( date ) == "GetYear"( @"Start Timestep" ) )
 ELSEIF_CLAUSE ( "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date], date ) )
 END_ELSEIF;

            $ "MexicanTreatyDelivery:MexicoBypass.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoBypass" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoBypass" [date], date )
 ENDIF;

            $ "MexicanTreatyDelivery:MexicoExcess.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoExcess" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoExcess" [date], date )
 ENDIF;

            $ "FtMohaveIndRes:NV.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.FtMohaveNv" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.FtMohaveNv" [date], date )
 ENDIF;

            $ "FtMohaveIndRes:CA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.FtMohaveCa" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.FtMohaveCa" [date], date )
 ENDIF;

            $ "FtMohaveIndRes:AZ.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.FtMohaveAz" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.FtMohaveAz" [date], date )
 ENDIF;

            $ "NvDvsToPkr:SCE.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.SCE" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.SCE" [date], date )
 ENDIF;

            $ "NvDvsToPkr:BigBend.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.BigBend" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.BigBend" [date], date )
 ENDIF;

            $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.LMNRA Mohave" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.LMNRA Mohave" [date], date )
 ENDIF;

            $ "AzDvsToPkr:BullheadCity.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BullheadCity" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BullheadCity" [date], date )
 ENDIF;

            $ "CaDvsToPkr:Chemehuevi.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Chemehuevi" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Chemehuevi" [date], date )
 ENDIF;

            $ "CaDvsToPkr:Needles.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Needles" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Needles" [date], date )
 ENDIF;

            $ "CaDvsToPkr:OtherLCWSP.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.OtherLCWSP" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.OtherLCWSP" [date], date )
 ENDIF;

            $ "OthersMeadToMohave:DavisDamProject.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.DavisDamProject" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.DavisDamProject" [date], date )
 ENDIF;

            $ "AzDvsToPkr:GoldenShores.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.GoldenShores" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.GoldenShores" [date], date )
 ENDIF;

            $ "AzDvsToPkr:HavasuNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.HavasuNWR" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.HavasuNWR" [date], date )
 ENDIF;

            $ "AzDvsToPkr:LakeHavasuCity.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LakeHavasuCity" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LakeHavasuCity" [date], date )
 ENDIF;

            $ "AzDvsToPkr:MohaveValleyIID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.MohaveValleyIID" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.MohaveValleyIID" [date], date )
 ENDIF;

            $ "AzDvsToPkr:MohaveWaterConsDist.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.MohaveWaterConsDist" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.MohaveWaterConsDist" [date], date )
 ENDIF;

            $ "AzDvsToPkr:AzPumpersDvsToPkr.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersDvsToPkr" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersDvsToPkr" [date], date )
 ENDIF;

            $ "PumpingFromLakeMead:LMNRA Az Mead.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mead" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mead" [date], date )
 ENDIF;

            $ "PumpingFromLakeMead:LMNRA Az Mead.Depletion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mead" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mead" [date], date )
 ENDIF;

            $ "OthersMeadToMohave:LMNRA Az Mohave.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mohave" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mohave" [date], date )
 ENDIF;

      ENDFOREACH;

    END
    UUID "{4dd9099d-3e6d-4111-a897-474da814c0ed}";;

    RULE                 "Set LC Actuals";
    DESCRIPTION          "DESCRIPTION: This rule sets the historical flows for California MWD and Nevada SNWP for January of the start year to the month before the start timestep. - CE, 9/17/13<br><br>SLOTS SET: California_CU_Actual.MWD; Nevada_CU_Actual.SNWP<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
          DESCRIPTION          "Set the MWD Consumptive Use actual values based on the input MWDDiversion actual values <br>and the Actual MWD Return input values. <br>";
      $ "California_CU_Actual.MWD" [date] := IF ( IsNaN $ "California_CU_Actual.MWD" [date] AND NOT IsNaN $ "California_CU_Actual.MWDDiversion" [date] )
 THEN
  $ "California_CU_Actual.MWDDiversion" [date] - $ "California_CU_Actual.MWDReturns" [date]
 ENDIF;

          DESCRIPTION          "Set the SNWP Actuals to the Actual input party values for SNWP";
      $ "Nevada_CU_Actual.SNWP" [date] := $ "Nevada_CU_Actual.SNWADiversion" [date] + $ "Nevada_CU_Actual.BasicManagement" [date] + $ "Nevada_CU_Actual.LMNRA Mead" [date] + $ "Nevada_CU_Actual.BoulderCanyonProject" [date] + $ "Nevada_CU_Actual.NvDeptFishGame" [date] + $ "Nevada_CU_Actual.PacificCoastBuilding" [date] + $ "Nevada_CU_Actual.City of Henderson" [date] - $ "Nevada_CU_Actual.LVWashReturns" [date];

      ENDFOREACH;

    END
    UUID "{581b1aba-ee47-4881-8442-d91bc7410d1d}";;

    RULE                 "Set Actuals to Zero In Future";
    DESCRIPTION          "DESCRIPTION: This rule sets the actual water use to zero over the run period for the each user in the lower basin. This rule fires at the start timestep of the first runcycle. -CE 9/17/13<br><br>SLOTS SET: AnnualWaterUse.AzNoCAPTotalMonthlyActual; AnnualWaterUse.CaNoPVYPIIDTotalMonthlyActual; AnnualWaterUse.NvTotalMonthlyActual; AnnualWaterUse.P123bTotalMonthlyActual; <state>_CU_Actual.<user><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Actual" ) )) DO
            "GetObject"( state CONCAT "_CU_Actual" ) & user [date] := 0.00000000 "acre-ft";

      ENDFOREACH;

      ENDFOREACH;

      ENDFOREACH;

    END
    UUID "{3f121043-d655-4942-b140-865ea1fbb2a9}";;

    RULE                 "Set NaN Actuals To Schedule";
    DESCRIPTION          "DESCRIPTION: This rule sets the Acutal schedules for each state to the Consumptive use schedule if the Actual schedule was not input to the MTOM Model. This step is done to prevent any model failure if data does not exist due to that data not being entered or imported into the MTOM model. This rule fires only on the start timestep of the first run cycle<br><br>SLOTS SET: <state>_CU_Actual.<user><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
            FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" , "Mexico" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Actual" ) )) DO
            "GetObject"( state CONCAT "_CU_Actual" ) & user [date] := IF ( user != "SNWP" )
 THEN
  IF ( IsNaN "GetObject"( state CONCAT "_CU_Actual" ) & user [date] )
  THEN
   "GetObject"( state CONCAT "_CU_Schedules" ) & user [date]
  ENDIF
 ENDIF;

      ENDFOREACH;

      ENDFOREACH;

      ENDFOREACH;

    END
    UUID "{1f5051b8-0547-4455-9dea-c362fee8881d}";;

    RULE                 "Set LC Annual Schedules";
    DESCRIPTION          "DESCRIPTION: This rule calculates the annual consumptive use (CU) schedules for Nevada and California. This rule fires for all run cycles. -CE 9/17/13<br><br>SLOTS SET: Nevada_CU_AnnualApproval.SNWP; California_CU_AnnualApproval.MWDReturns; California_CU_AnnualApproval.MWD<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Thist rule sets the data slots for Annual Consumptive Use Approval for SNWP and MWD";
      $ "Nevada_CU_AnnualApproval.SNWP" [@"24:00:00 December 31, Current Year"] := "AnnualVolumeSlot"( $ "Nevada_CU_Schedules.SNWP" );

      $ "California_CU_AnnualApproval.MWDReturns" [@"24:00:00 December 31, Current Year"] := "AnnualVolumeSlot"( $ "California_CU_Schedules.MWDReturns" );

      $ "California_CU_AnnualApproval.MWD" [@"24:00:00 December 31, Current Year"] := "AnnualVolumeSlot"( $ "California_CU_Schedules.MWD" );

    END
    UUID "{e46bc22b-0366-4b38-9701-e0f53fd53a09}";;

    RULE                 "Set LC Monthly Schedules";
    DESCRIPTION          "DESCRIPTION: This rule sets the consumptive use schedules for Nevada and California. -CE 9/17/13. Set the SNWP and MWD schedules based on the input consumptive use schedules for the various entities listed.  For SNWP this includes all groups with schedules for which the SNWP diversion delivers water.  For MWD, the return flow schedule is assumed to be constant at 8.5 acre-feet per day.  The MWDDiversion slot is input and so the returns schedule and the MWD (consumptive use portion) is set by this rule. <br><br>SLOTS SET: Nevada_CU_Schedules.SNWP; California_CU_Schedules.MWDReturns; California_CU_Schedules.MWD<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>GCAA, 20181030: Removed statement solving for California_CU_Schedules.MWDReturns and removed the part of the statement solving for MWDReturns from the California_CU_Schedules.MWD calculation.";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO "Dec31ofYear"( @"Finish Timestep" ) COMMENTED_BY "This is for testing purposes, this should be Finish timestep<br>when the model is actually moved forward and all input<br>is taken care of") DO
            $ "Nevada_CU_Schedules.SNWP" [date] := $ "Nevada_CU_Schedules.SNWADiversion" [date] + $ "Nevada_CU_Schedules.BasicManagement" [date] + $ "Nevada_CU_Schedules.LMNRA Mead" [date] + $ "Nevada_CU_Schedules.BoulderCanyonProject" [date] + $ "Nevada_CU_Schedules.NvDeptFishGame" [date] + $ "Nevada_CU_Schedules.PacificCoastBuilding" [date] + $ "Nevada_CU_Schedules.City of Henderson" [date] - $ "Nevada_CU_Schedules.LVWashReturns" [date];

            $ "California_CU_Schedules.MWD" [date] := $ "California_CU_Schedules.MWDDiversion" [date] - $ "California_CU_Schedules.MWDReturns" [date];

      ENDFOREACH;

    END
    UUID "{1432441c-7bab-4e5b-8630-93f0d9be2401}";;

  END
  UUID "{e86929fe-c622-4b77-8e9b-20396a580527}";;

  POLICY_GROUP   "Data Setup";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set 242 Well Field";
    DESCRIPTION          "";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"Finish Timestep") DO
            $ "BelowImperialDam:242WellExpansion.Local Inflow" [date] := IF ( date <= @"24:00:00 September Max DayOfMonth, 2020" )
 THEN
  0.00000000 "acre-ft/month"
 ELSE
  "VolumeToFlow"( $ "ForecastUse.242WellContribution" [] / 12.00000000, date )
 ENDIF;

      ENDFOREACH;

    END
    UUID "{fd225bc0-304b-4b5c-95ea-ed4e9ebc0f02}";;

    RULE                 "Compute Upper Basin Gains";
    DESCRIPTION          "DESCRIPTION: This rule calculates the local gains for each reservoir and local inflow in the upper basin from the relevent RFC forecasts. - CE 9/17/13 Assign each one of the reach simulation Local Inlow slots in the Upper basin based on the input <br>CBRFC forecast values that are input to the model on data objects.  The CBRFC forecasts for the headwater reservoirs (Taylor Park, Fontenelle and Vallecito) are input directly to the simulation reservoir object.  For the reach objects, consideration needs to be made to any upstream forecasts and the appropriate intervening flow for the reach needs to be determined.  This rule makes that calculation.<br><br>SLOTS SET: ColoradoAbovePowell:InterveningAbovePowell.Local Inflow; UpperSanJuan.Inflow; GreenBelowFlamingGorge:YampaRiver.Local Inflow; SanJuanBelowNavajo:AnimasRiver.Local Inflow; GunnisonBelowCrystal:GunnisonNrGJ_Whitewater.Local Inflow; GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow; GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow; GunnisonAboveBlueMesa:InterveningAboveBlueMesa.Local Inflow; Azotea Tunnel.Fractional Return Flow; GreenAboveFlamingGorge:InterveningAboveFlamingGorge.Local Inflow; GReenAboveFlamingGorge.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME index IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "ColoradoAbovePowell:InterveningAbovePowell.Local Inflow" [index] := $ "PowellInflow.Unregulated" [index] + ( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [index] + $ "Azotea Tunnel.Diversion Requested" [index] + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [index] ) - ( ( $ "CrystalInflow.Unregulated" [index] + $ "FlamingGorgeInflow.Unregulated" [index] + $ "NavajoInflow.ModUnregulated" [index] + NaNToZero ( $ "GainsCrystalToGJ.GainsCrystalToGJ" [index] ) + NaNToZero ( $ "AnimasRiverInflow.Animas_at_Durango" [index] ) ) + NaNToZero ( $ "YampaRiverInflow.Yampa_at_Deerlodge" [index] ) );

            $ "UpperSanJuan.Inflow" [index] := $ "NavajoInflow.ModUnregulated" [index] - $ "Vallecito.Inflow" [index];

            $ "GreenBelowFlamingGorge:YampaRiver.Local Inflow" [index] := NaNToZero ( $ "YampaRiverInflow.Yampa_at_Deerlodge" [index] );

            $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" [index] := NaNToZero ( $ "AnimasRiverInflow.Animas_at_Durango" [index] );

            $ "GunnisonBelowCrystal:GunnisonNrGJ_Whitewater.Local Inflow" [index] := NaNToZero ( $ "GainsCrystalToGJ.GainsCrystalToGJ" [index] );

            $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [index] := $ "MorrowPointInflow.Unregulated" [index] - $ "BlueMesaInflow.Unregulated" [index];

            $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [index] := $ "CrystalInflow.Unregulated" [index] - $ "MorrowPointInflow.Unregulated" [index];

            $ "GunnisonAboveBlueMesa:InterveningAboveBlueMesa.Local Inflow" [index] := $ "BlueMesaInflow.Unregulated" [index] - $ "TaylorPark.Inflow" [index];

          DESCRIPTION          "This assignment is necessary for RW 6.6. Per instruction from BoR this value is set to 0 for all <br>timesteps. LJ 03/19/2015.";
      $ "Azotea Tunnel.Fractional Return Flow" [index] := 0.00000000;

          INACTIVE    DESCRIPTION          "This is added because these local inflows need to be assigned and the previous rule &quot;Forecast <br>Test&quot; has been removed. The Local Inflow at the Gila River is set to 0 AF/Month. TP 6/12/2015<br><br>LBDV.GilaRiverLocalInflow and BID:Gila River.Local Inflow share the name &quot;GilaRiver&quot; in the OutToMTPO name map used in the Excel Input DMI. LBDV.GilaRiverLocalInflow is set by DMI for the period (Start-12) to (Dec, Finish Year), <br>but BID:Gila River.Local Inflow is set here with LBDV.GilaRiverLocalInflow. Can BID.Gila River be set by DMI or does it need to be set by rule? MC 20161101<br>";
      $ "BelowImperialDam:Gila River.Local Inflow" [index] := $ "LowerBasinDemandVariability.GilaRiverLocalInflow" [index];

      ENDFOREACH;

      FOREACH (DATETIME index IN "OffsetDate"( "RunStartDate"(  ), - 12.00000000, "1 months" ) TO "OffsetDate"( "RunEndDate"(  ), 12.00000000, "1 months" )) DO
            $ "GreenAboveFlamingGorge:InterveningAboveFlamingGorge.Local Inflow" [index] := $ "FlamingGorgeInflow.Unregulated" [index] - $ "Fontenelle.Inflow" [index];

      ENDFOREACH;

      FOREACH (DATETIME index IN "OffsetDate"( "RunStartDate"(  ), - 12.00000000, "1 months" ) TO "OffsetDate"( "RunStartDate"(  ), - 1.00000000, "1 months" )) DO
            $ "GreenAboveFlamingGorge.Outflow" [index] := $ "FlamingGorgeInflow.Unregulated" [index] - $ "Fontenelle.Inflow" [index] + $ "Fontenelle.Outflow" [index];

      ENDFOREACH;

    END
    UUID "{001f202f-f095-4afe-b9f2-c277efc600ec}";;

    RULE                 "SetCaliforniaPreliminaryStateAdjustedApportionment";
    DESCRIPTION          "DESCRIPTION: For any out year, the California State Apportionment needs to be adjusted based on the estimated Payback and estimated EC ICS Creation for IID that is input to the model. This preliminary adjustment to the CA State Apportionment allows for a calculation of MWD Diversion that takes the estimated parameters into consideration. This is a more realistic calculation than using the standard CA State Apportionment. The payback and ICS Creation can be adjusted in later logic and the MWD can be adjusted again.<br><br>SLOTS SET: AnnualWaterUse.California_PreliminaryAdjustedApportionment[Current Year]";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January 31, Current Year" AND ( ( "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "ThisRule" ) ) OR ( "GetRunCycleIndex"(  ) == 3.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 ) );
    NOTES                "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 AND Shortage is in effect and the alternate calculation in the rule if that is the case.  In the case of shortage, EC ICS Creation is not allowed and the value (Input to the model) is not used in the calculation of apportionment.  Subsequent rules (Reset MWD Annual Forecast Use - Force to CA Apportionment, Reset Monthly Forecast Use MWD - All Months Outyears, Reset Monthly Forecast Use MWD - Nov and Dec, Cur Year, and Redistribute MWD Nov & Dec Div Request) that depend on the value calculated in this rule were also modified to allow execution in Run Cycle 3 if Shortage is in effect.";
    BEGIN

      $ "AnnualWaterUse.California_PreliminaryAdjustedApportionment" ["Dec31ofYear"( @"t" )] := IF ( "IsMRM"(  ) )
 THEN
  IF ( @"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" )
  THEN
   $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
  ELSE
   IF ( NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
   THEN
    $ "AnnualWaterUse.CA_BasicApportionment" [] - $ "ICSProjectionData.California_EstimatedPayback" ["Dec31ofYear"( @"t" )] - $ "ICSProjectionData.CA_SystemConservation" ["Dec31ofYear"( @"t" )]
   ELSE
    $ "AnnualWaterUse.CA_BasicApportionment" [] - $ "ICSProjectionData.California_EstimatedPayback" ["Dec31ofYear"( @"t" )] - ( $ "ICSProjectionData.AnnualCreationEC_IID_Default" ["Dec31ofYear"( @"t" )] - $ "ICSProjectionData.AnnualDeliveryEC_IID_Default" ["Dec31ofYear"( @"t" )] ) - $ "ICSProjectionData.CA_SystemConservation" ["Dec31ofYear"( @"t" )]
   ENDIF
  ENDIF
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF;

    END
    UUID "{9d7435c8-fc52-4f9d-bfd6-a5933c24f626}";;

    RULE                 "INPUT MISSING NOTIFICATION";
    DESCRIPTION          "DESCRIPTION: This rule checks if the necessary RFC inflow information has been entered. This includes inflow information for all upper basin reserviors. -CE 9/17/13<br><br>SLOTS SET: <br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE, 9/17/13 ";
    BEGIN

    DESCRIPTION          "This rule executes if there is missing input data and if this rule. If this rule does execute and <br>give an error, make sure the input data sheet is set up correctly (CBRFC_EnsembleForecast) <br>and that the run period is correct for the current model run.  ";
      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "BlueMesaInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: BlueMesaInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "TaylorPark.Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: TaylorPark.Inflow Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "MorrowPointInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: MorrowPointInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "CrystalInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: CrystalInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "FlamingGorgeInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: FlamingGorgeInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Fontenelle.Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: Fontenelle.Inflow Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "NavajoInflow.ModUnregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: NavajoInflow.ModUnregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Vallecito.Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: Vallecito.Inflow Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "PowellInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: PowellInflow.Unregulated Missing"
 ENDIF;

    INACTIVE      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: NavajoIndianIrrigationProjectNIIP.Diversion Requested Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Azotea Tunnel.Diversion Requested" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: AzoteaTunnel.Diversion Requested Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: TunnelDiversionBelowCrystalForAg.Diversion Requested Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: SanJuanBelowNavajo:AnimasRiver.Local Inflow Missing"
 ENDIF;

    END
    UUID "{cebce44c-342d-4896-a053-e159c76e91f6}";;

    RULE                 "Set Extended Forecasts to Historic Average Hydrology";
    DESCRIPTION          "DESCRIPTION: This rule sets the inflow above Fontenelle and the unregulated inflow to Flaming Gorge for the 12 months beyond the run end date. Note that the rule actually will set all unpopulated (NaN) timesteps from the run start to 12 months after the finish with historic average values. However, the DMI Excel_InputFrom24MS populates the run period values as Inputs. The DMI is set to import values until Finish Timestep + 12 timesteps, but only those values until the end of the run are currently provided by the spreadsheet.<br><br>SLOTS SET: Fontenelle.Inflow; FlamingGorgeInflow.Unregulated";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>SC, 20111201: This rule set the inflows above Fontenelle, the unregulated inflow to Flaming Gorge, and the Yampa River Inflow for the 12 months beyond the run end date.  These values are needed by the operations rules for Flaming Gorge and Fontenelle as written by CADSWES.  Would be nice to review these rules and see if this is absolutely necessary. - sc 12/1/11<br>MC, 20160913: The comment in the body suggests the forecasts will be extended beyond the Finish Timestep by historic values, but actually all timesteps are being set with those values. Are the values being used?";
    BEGIN

    DESCRIPTION          "This rule will extend the forecasts for the locations specified beyond the RFC forecast period.  <br>The values in the extended forecast are set to historic input values for the specific location.";
      FOREACH (DATETIME index IN @"Start Timestep" TO @"Finish Timestep + 12") DO
            $ "Fontenelle.Inflow" [index] := IF ( IsNaN $ "Fontenelle.Inflow" [index] )
 THEN
  $ "HistoricData.HistoricAverageMonthlyInflows" [index, "FontenelleMonthlyAveInflow"]
 ENDIF;

            $ "FlamingGorgeInflow.Unregulated" [index] := IF ( IsNaN $ "FlamingGorgeInflow.Unregulated" [index] )
 THEN
  $ "HistoricData.HistoricAverageMonthlyInflows" [index, "FlamingGorgeMonthlyAveUnregInflow"]
 ENDIF;

      ENDFOREACH;

    END
    UUID "{6c55642c-b4a5-452d-be93-1e20bfa2c106}";;

    RULE                 "Run Cycle Counter Print Message";
    DESCRIPTION          "DESCRIPTION: This rule records the run cycle in the diagnostic output window for debugging purposes. -CE 9/17/13<br><br>SLOTS SET: <NONE><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE, 9/17/13";
    BEGIN

      PRINT "******************************************************";

      PRINT "Begin Run Cycle # " CONCAT "GetRunCycleIndex"(  );

      PRINT "******************************************************";

    END
    UUID "{7755fda4-4ed6-406a-84f3-eaefeea61c6c}";;

    RULE                 "Set LB Demand Variability Triggers Below Parker";
    DESCRIPTION          "DESCRIPTION: This rule fires in the beginning timestep but sets the trigger values for the whole run. Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request based on side inflow hydrology between certain locations.  The below Parker variability takes into considerations the side inflows below Parker Dam and sets a slot value (trigger) that will be used when compared to a historic statistically derived volume to determine the variability thresholds. This rule only sets the volumes and those will be used in subsequent rules when compared to historic threshold inflow values. <br><br>SLOTS SET: LowerBasinDemandVariability.LocalInflowBelowParkerTrigger<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "ThisRule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request based on side inflow hydrology between certain locations.  The <br>below Parker variability takes into considerations the side inflows below Parker Dam and sets a slot value (trigger) that will be used when compared to a historic statistically derived <br>volume to determine the variability thresholds. This rule only sets the volumes and those will be used in subsequent rules when compared to historic threshold inflow values. ";
      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (date == @"Start Timestep" OR "GetMonth"( date ) == 9.00000000 AND "OffsetDate"( date, 4.00000000, "1 Months" ) <= @"Finish Timestep") THEN
            IF_STATEMENT (date == @"Start Timestep") THEN
            IF_STATEMENT ("GetMonth"( date ) < 10.00000000) THEN
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVolYr2 = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowBelowParkerVolYr2;

      END_WITH_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END
    UUID "{87d31299-5bb7-4e8c-8067-4285400d2ee4}";;

    RULE                 "Set LB Demand Variability Triggers Above Hoover";
    DESCRIPTION          "DESCRIPTION: This rule fires in the beginning timestep but sets the trigger values for the whole run.  Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request based on side inflow hydrology between certain locations.  <br>The above Mead variability takes into considerations the side inflows below Glen Canyon Dam and above Hoover Dam and sets a slot value (trigger) that will be used when compared to a historic statistically-derived volume to determine the variability thresholds. <br>This rule only determines the side inflow volume that will be used later for the comparison.<br><br>SLOTS SET: LowerBasinDemandVariability.LocalInflowAboveHooverTrigger; LowerBasinDemandVariability.PowellUnregulatedInflowTrigger<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "ThisRule" );
    NOTES                "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request <br>based on side inflow hydrology between certain locations.  <br>The above Mead variability takes into considerations the side inflows below Glen Canyon Dam and above Hoover Dam <br>and sets a slot value (trigger) that will be used when compared to a historic statistically-derived volume to determine the <br>variability thresholds. <br>This rule only determines the side inflow volume that will be used later for the comparison.";
      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (( date == @"Start Timestep" OR "GetMonth"( date ) == 9.00000000 AND "OffsetDate"( date, 4.00000000, "1 Months" ) <= @"Finish Timestep" ) COMMENTED_BY "Note that the following expression evaluates as &quot;(A OR B) AND C&quot;, not as &quot;A OR (B AND C)&quot; - mc, <br>1/4/2016") THEN
            IF_STATEMENT (date == @"Start Timestep") THEN
            IF_STATEMENT ("GetMonth"( date ) < 10.00000000) THEN
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVolYr2 = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowAboveHooverVolYr2;

      END_WITH_STATEMENT;

          INACTIVE      WITH_STATEMENT (NUMERIC unregInflowPowellYr2 = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", @"24:00:00 October 31, Current Year", "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 2.00000000 ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := unregInflowPowellYr2;

      END_WITH_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVolYr2 = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowAboveHooverVolYr2;

      END_WITH_STATEMENT;

          INACTIVE      WITH_STATEMENT (NUMERIC unregInflowPowellYr2 = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", @"24:00:00 October 31, Current Year", "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )] := unregInflowPowellYr2;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

          INACTIVE      WITH_STATEMENT (NUMERIC waterYearNumber = "GetYear"( date ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF) DO
            WITH_STATEMENT (NUMERIC unregInflowPowell = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", "OffsetDate"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ), - 11.00000000, "1 Months" ), "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )] := unregInflowPowell;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END
    UUID "{9e206a82-d12b-4bd7-871f-9f0c14690a02}";;

  END
  UUID "{3e572fc2-ad4a-4512-8973-914bf72e2fef}";;

  UTILITY_GROUP "Powell Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "B1_Branch_UpperBalancingTierVolume" ( DATETIME eowyDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the Powell release volume when the tier has been designated as Upper Elevation Balancing, Branch B1. The release attempts to balance the Powell and Mead end of water year storages, within the release range of 8.23 MAF and 9.0 MAF, if the elevation criteria are met; otherwise, the release is set to 8.23 MAF<br><br>RETURNS: Annual release volume from Lake Powell<br><br>ARGUMENTS:<br>1. DATETIME eowyDate - the end of water year date at which to compare the Powell and Mead storages<br><br>CONSTRAINTS: Releases no less than 8.23 MAF and no more than 9.0 MAF<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT $ "PowellData.UpperTierB4MinAnnualRelease" [];
    MAX_CONSTRAINT $ "PowellData.UpperTierB4MaxAnnualRelease" [];
    NOTES          "DEVELOPMENT NOTES<br>MC, 20160801: Included consideration for possible untransferred carryover volume between Powell and Mead<br>MC, 20170501: Added Post-Execution Checks and removed unneeded call to user-defined function EnsureReleaseLimits, which applied the same constraints that are now in the Post-Execution Checks<br>SB, 20180925: Added function 'GetProjectedPoolElevation' instead of using Mead and Powell Pool Elevation. ";
    BEGIN

      WITH DATETIME eoyDate = "Dec31ofYear"( eowyDate ) DO
  WITH NUMERIC CarryoverVolume = NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [eoyDate] ) DO
   WITH NUMERIC PowellEffectivePool = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", "GetProjectedPoolElevation"( "Powell", eowyDate ) ) - CarryoverVolume ) DO
    WITH NUMERIC MeadEffectivePool = "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", eowyDate ) ) + CarryoverVolume ) DO
     IF ( MeadEffectivePool <= 1075.00000000 "ft" AND PowellEffectivePool > 3575.00000000 "ft" OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", eoyDate ) AND $ "PowellData.UpperElevBalBranch" [eoyDate] == 1.40000000 ) COMMENTED_BY "If the tier specification is user input for UEB, then release what is suggested for <br>that tier. This is placed so that if a specific Tier and balancing branch for any <br>year, but specifically WY1 has been made, then the logic will honor that and <br>estimate a balancing release instead of an 8.23 MAF release. TP 10/17/2017 <br>" )
     THEN
      "EqualizationReleaseWithCarryover"( eowyDate )
     ELSE
      $ "PowellData.BaseAnnualRelease" [] COMMENTED_BY "BaseAnnualRelease is 8.23 MAF"
     ENDIF
    ENDWITH
   ENDWITH
  ENDWITH COMMENTED_BY "Calculate effective pool elevations as if any carryover volume had been transferred for comparison to pool elevation trigger levels"
 ENDWITH COMMENTED_BY "If Mead's EOWY elevation is less than 1075' and Powell's EOWY elevation is greater than 3575' then release enough to balance <br>the storages up to 9.0 MAF and no less than 8.23 MAF annual release volume.  Otherwise just release 8.23 MAF.";

    END
    UUID "{7e791855-8808-430b-b105-c42fd45b445f}";;

    FUNCTION       "B2_Branch_UpperBalancingTierVolume" ( DATETIME eowyDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the Powell release volume when the tier has been designated as Upper Elevation Balancing, Branch B2. The release attempts to balance the Powell and Mead end of water year storages, within the release range of 7.0 MAF and 9.0 MAF<br><br>RETURNS: Annual release volume from Lake Powell<br><br>ARGUMENTS:<br>1. DATETIME eowyDate - the end of water year date at which to compare the Powell and Mead storages<br><br>CONSTRAINTS: Releases no less than 7.0 MAF and no more than 9.0 MAF<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>MC, 20160801: Included consideration for possible untransferred carryover volume between Powell and Mead";
    BEGIN

      "EnsureReleaseLimits"( "EqualizationReleaseWithCarryover"( eowyDate ), $ "PowellData.UpperTierB2MinAnnualRelease" [], $ "PowellData.UpperTierB2MaxAnnualRelease" [] );

    END
    UUID "{4317492b-9af3-4cbc-9483-47a9cf351e77}";;

    FUNCTION       "CalcReleaseForMaxPoolElevation" ( LIST waterYearDates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: this function calculates a minimum annual volume needed to be released from Powell in order to keep the reservoir from overfilling and crashing the run during the preliminary annual volume setting phase.  The preliminary volume will be 8.23 MAF in most cases, but if the inflows are high or the starting storage in Powell is high and 8.23 MAF is not enough to keep Powell from overfilling, then this function calculates the annual volume needing to be released in order to just prevent overfilling and crashing the model (does not currently include terms for evap and bankstorage).  An exact annual release volume will be calculated in subsequent rules. - sc 03/25/11<br><br>RETURNS: Water volume required to be released from Lake Powell to prevent overfilling [L^3]<br><br>ARGUMENTS:<br>1. LIST waterYearDates - list of the dates remaining in the water year<br><br>CONSTRAINTS: Value greater than or equal to 0 acre-feet<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT 0.00000000 "acre-ft";
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 03/25/2011";
    BEGIN

      WITH DATETIME firstTimestep = GET @INDEX 0.00000000 FROM waterYearDates DO
  WITH DATETIME lastTimestep = IF ( ( LENGTH waterYearDates ) >= 3.00000000 )
  THEN
   GET @INDEX ( LENGTH waterYearDates ) - 3.00000000 FROM waterYearDates
  ELSE
   GET @INDEX ( LENGTH waterYearDates ) - 1.00000000 FROM waterYearDates
  ENDIF DO
   ( ( $ "Powell.Storage" ["OffsetDate"( firstTimestep, - 1.00000000, " 1 months" )] + "SumFlowsToVolume"( $ "Powell.Inflow", firstTimestep, lastTimestep ) - "ElevationToStorage"( % "Powell", 3711.00000000 "feet" ) ) / ( ( ( lastTimestep - firstTimestep ) + 1.00000000 "month" ) * 0.90000000 ) ) COMMENTED_BY "The factor 0.9 in the denominator ensures the calculated volume is slightly greater than the volume that takes the pool elevation just to its maximum"
  ENDWITH COMMENTED_BY "lastTimestep date is July 31 unless firstTimestep is August or September, in which case lastTimestep is September 30"
 ENDWITH COMMENTED_BY "The period firstTimestep to lastTimestep is used to calculate an annualized volume to release from Powell to avoid overfilling." * 1.00000000 "year";

    END
    UUID "{af7f1ac0-1027-4da1-9c77-dc3f6ef8fe75}";;

    FUNCTION       "CurrentAnnualVolume" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and returns the annual release volume for Powell for the water year in which the passed-in date lies.<br><br>RETURNS: Target annual release volume in 1000 acre-feet<br><br>ARGUMENTS:<br>1. DATETIME date - a date within the run period<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: sc, 20110215";
    BEGIN

      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( date ) )];

    END
    UUID "{201aa2ce-bf55-497b-82f3-185c94ca607b}";;

    FUNCTION       "EqualizationRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function attempts to equalize the end of water year Powell and Mead storages by adding half the difference between the currently calculated end of water year storages to the target annual release from Powell<br><br>RETURNS: Annual release volume in 1000 kaf<br><br>ARGUMENTS:<br>1. DATETIME EOWYdate - the end of water year date for which the storages should be compared<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 2018/10/17: Remove carryover volume from Powell Storage and add to Mead storage when determining equalization volume. Equalization needs to know about carryover volume from the previous year in some functions in order to calculate the correct TARV, specifically when in equalization with a release of 8.23 MAF.  ";
    BEGIN

      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] + ( ( $ "Powell.Storage" [EOWYDate] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) - ( $ "Mead.Storage" [EOWYDate] + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) ) / ( 2.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] );

    END
    UUID "{c504226f-f71b-4e0f-a225-90e236233058}";;

    FUNCTION       "EqualizationTierCalculationForRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the target annual release volume and the controlling equalization condition (constraint) when Powell is operating in the Equalization tier; the controlling equalization condition represents the condition constraining the calculated release volume<br><br>RETURNS: List of the form &lcub;Annual release volume in 1000 kaf, Controlling Equalization Condition&rcub;<br><br>ARGUMENTS:<br>1. DATETIME EOWYdate - the end of water year date <br><br>CONSTRAINTS: The calculated release volume may be constrained by: the Powell equalization level for the water year; equalized storage in Powell and Mead; Mead pool elevation reaches 1,105 ft; Powell pool elevation reaches 20 ft less than the equalization level for the water year<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 2018/10/17: Equalization needs to know about carryover volume from the previous year in this function in order to calculate the correct TARV, specifically when in equalization with a release of 8.23 MAF. This occurs in multiple places in the ?EqualizationTierCalculationForRelease? function. ";
    BEGIN

      WITH NUMERIC PowellVolumeOverEqLevel = "Max"( ( $ "Powell.Storage" [EOWYDate] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) ), 0.00000000 "acre-ft" ) DO
  WITH NUMERIC EqualizationReleaseVolume = "EqualizationRelease"( EOWYDate ) DO
   WITH NUMERIC PreliminaryReleaseVolume = "Min"( PowellVolumeOverEqLevel / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )], EqualizationReleaseVolume ) DO
    WITH NUMERIC MeadElevationWithPrelimRelease = IF ( ( $ "Mead.Storage" [EOWYDate] + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) + ( PreliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) * ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) >= "ElevationToStorage"( % "Mead", 1229.00000000 "feet" ) )
    THEN
     1229.00000000 "feet"
    ELSE
     "StorageToElevation"( % "Mead", ( $ "Mead.Storage" [EOWYDate] + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) + ( PreliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) * ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) )
    ENDIF DO
     IF ( MeadElevationWithPrelimRelease < 1105.00000000 "ft" )
     THEN
      WITH NUMERIC totalVolumeToRaiseMeadTo1105 = "Max"( ( "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - ( $ "Mead.Storage" [EOWYDate] + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) ) / ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ), 0.00000000 "acre-ft" ) DO
       WITH NUMERIC PowellVolumeOverEqLevelLess20ft = "Max"( ( $ "Powell.Storage" [EOWYDate] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] ) ) - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" ), 0.00000000 "acre-ft" ) DO
        IF ( EqualizationReleaseVolume < totalVolumeToRaiseMeadTo1105 AND EqualizationReleaseVolume < PowellVolumeOverEqLevelLess20ft / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) )
        THEN
         { EqualizationReleaseVolume + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.30000000 }
        ELSE
         IF ( totalVolumeToRaiseMeadTo1105 < EqualizationReleaseVolume AND totalVolumeToRaiseMeadTo1105 < PowellVolumeOverEqLevelLess20ft )
         THEN
          { totalVolumeToRaiseMeadTo1105 + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.40000000 }
         ELSE
          { PowellVolumeOverEqLevelLess20ft / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.50000000 }
         ENDIF
        ENDIF COMMENTED_BY "Choose the minimum of the equalization release, the release to take Mead to 1105 and the release to take Powell down to the equalization level less 20'"
       ENDWITH COMMENTED_BY "Volume of Powell storage above the equalization level minus 20 feet"
      ENDWITH COMMENTED_BY "Volume needed to release from Powell to raise Mead elevation to 1105'"
     ELSE
      IF ( PreliminaryReleaseVolume == PowellVolumeOverEqLevel / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] )
      THEN
       { PreliminaryReleaseVolume , 0.10000000 }
      ELSE
       { PreliminaryReleaseVolume , 0.20000000 }
      ENDIF
     ENDIF COMMENTED_BY "Check if the preliminary release volume takes Mead above 1105'.  If so the preliminary volume is chosen, if not continue."
    ENDWITH COMMENTED_BY "EOWY Elevation of Mead with the preliminaryReleaseVolume release from Powell"
   ENDWITH COMMENTED_BY "Preliminary annual volume release before the Mead elevation check."
  ENDWITH COMMENTED_BY "Total volume that would need to be released to equalize storage"
 ENDWITH COMMENTED_BY "Total Volume in Powell above the Current Equalization Level";

    END
    UUID "{4ae12457-0e73-4438-9240-5d4adc10db15}";;

    FUNCTION       "FindReleaseUpperBoundColumn" ( NUMERIC release )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function finds the index corresponding to the first column in PowellData.PowellMonthlyReleaseTable with an annual total value greater than the release volume value provided as a parameter. <br><br>RETURNS: Column index value<br><br>ARGUMENTS:<br>1. NUMERIC release - annual release volume for Powell<br><br>CONSTRAINTS: Min - 0; Max - Number of columns in table - 1<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  WHILE ( release - releaseTable ["AnnualTotal", result] > 0.01000000 "1000 acre-ft" ) WITH NUMERIC result = 0.00000000 DO
   result + 1.00000000
  ENDWHILE
 ENDWITH COMMENTED_BY "While the annual total of the column with index &quot;result&quot; is less than the provided release volume, increment the value of &quot;result&quot;";

    END
    UUID "{bf341ebe-8f1e-447a-962b-02eeb4aea9cf}";;

    FUNCTION       "FindReleaseLowerBoundColumn" ( NUMERIC release, NUMERIC upperbound )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function finds the index corresponding to the first column in PowellData.PowellMonthlyReleaseTable with an annual total value less than the release volume value provided as a parameter. If the provided release volume is exactly equal to a column total, the lower bound index and upper bound index are equal. <br><br>RETURNS: Column index value<br><br>ARGUMENTS:<br>1. NUMERIC release - annual release volume for Powell<br>2. NUMERIC upperbound - index of the upper bound column in the table<br><br>CONSTRAINTS: Min - 0; Max - Number of columns in table - 1<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  IF ( releaseTable ["AnnualTotal", upperbound] - release < 0.10000000 "1000 acre-ft" )
  THEN
   upperbound
  ELSE
   upperbound - 1.00000000
  ENDIF
 ENDWITH;

    END
    UUID "{68a19f44-fe2e-4dfd-aee8-38f7dddb7056}";;

    FUNCTION       "GetPowellReleasesCorrectedForBypass" ( LIST InitialDateRelease )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list in the form of &lcub;Date, Release&rcub; and estimates a pool elevation for each month with those releases. The function creates a series of three item lists in the form &lcub;Date, Release, Pool elevation&rcub; where if the estimated pool elevation is too low a bypass release is calculated. The pool elevation that goes into the three item list is the calculated pool elevation from the lesser of the outflow that was passed in or the determined bypass outflow. This is passed into the rule Set Powell Outflow and the outflow for Powell is set with these values.<br><br>RETURNS: List of lists of the form &lcub;Date, Release, Pool elevation, Remaining Volume&rcub;<br><br>ARGUMENTS:<br>1. LIST initialDateRelease - list of lists of the form &lcub;Date, Release&rcub;<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "AUTHOR, DATE: TP, 20130701<br><br>SB, 20190711: The rule was not setting carryover when bypass constrained the outflow below TARV. The calculation of 'addCarryoverIfAny' was altered to add in any carryover created due to bypass constrained outflows.<br>MC, 20170501: Updated internal variable names and removed some internal variables for readability";
    BEGIN

      WITH LIST sortedInitDateRelease = "Sort"( InitialDateRelease ) DO
  WITH DATETIME InitialDate = "OffsetDate"( GET @INDEX 0.00000000 FROM GET @INDEX 0.00000000 FROM sortedInitDateRelease, - 1.00000000, "1 Months" ) DO
   WITH LIST listWithInitDate = FOR ( LIST index IN sortedInitDateRelease ) WITH LIST result = { { InitialDate , "null" , $ "Powell.Pool Elevation" [InitialDate] , GET @INDEX 2.00000000 FROM GET @INDEX 0.00000000 FROM InitialDateRelease } } DO
    WITH NUMERIC PreviousResultPE = GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
     WITH DATETIME PreviousDate = GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
      WITH DATETIME CurrentDate = "OffsetDate"( PreviousDate, 1.00000000, "1 Months" ) DO
       WITH NUMERIC PreviousCarryover = GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
        WITH NUMERIC CurrentEstRelease = GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM sortedInitDateRelease DO
         WITH NUMERIC MaxBypassRelease = IF ( PreviousResultPE <= 3500.00000000 "ft" )
         THEN
          "TableInterpolation"( $ "PowellMinObjRelData.Bypass Tube Capacity", 0.00000000, 1.00000000, PreviousResultPE, CurrentDate )
         ELSE
          CurrentEstRelease
         ENDIF DO
          WITH NUMERIC NextOutflow = "Min"( CurrentEstRelease, MaxBypassRelease ) DO
           WITH NUMERIC tempPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [CurrentDate], CurrentDate ) - "FlowToVolume"( NextOutflow, CurrentDate ) - NaNToZero ( $ "Powell.Change in Bank Storage" [CurrentDate] ) ) DO
            WITH NUMERIC NewPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [CurrentDate], CurrentDate ) - "PowellEvapEstimation"( CurrentDate, PreviousResultPE, tempPE ) - "FlowToVolume"( NextOutflow, CurrentDate ) - NaNToZero ( $ "Powell.Change in Bank Storage" [CurrentDate] ) ) DO
             WITH NUMERIC addCarryoverIfAny = IF ( ( ( LENGTH result ) == LENGTH InitialDateRelease ) AND PreviousCarryover < 0.05000000 "acre-ft" )
             THEN
              "Min"( PreviousCarryover, GET @INDEX 2.00000000 FROM index ) + GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH InitialDateRelease ) - 1.00000000 FROM InitialDateRelease
             ELSE
              "Min"( PreviousCarryover, GET @INDEX 2.00000000 FROM index ) + "FlowToVolume"( CurrentEstRelease - NextOutflow, CurrentDate )
             ENDIF COMMENTED_BY "Want to use the original InitialDateRelease because the sorted version does not <br>have any carryover that needs to be released next year. <br>" DO
              APPEND { CurrentDate , NextOutflow , NewPE , addCarryoverIfAny * "DebuggerStop"(  ) } ONTO result
             ENDWITH
            ENDWITH
           ENDWITH COMMENTED_BY "Calculate the PE for CurrentDate based on the updated outflow"
          ENDWITH COMMENTED_BY "Calculate the outflow as the minimum of the estimate passed in or the calculated maximum bypass"
         ENDWITH COMMENTED_BY "Calculate the maximum bypass possible based on the previous result PE value"
        ENDWITH COMMENTED_BY "Retrieve the release passed into the function for the current date"
       ENDWITH COMMENTED_BY "Retrieve the carryover created from the previous month <br>"
      ENDWITH COMMENTED_BY "Set current date"
     ENDWITH COMMENTED_BY "Retrieve previous result date"
    ENDWITH COMMENTED_BY "Retrieve previous result PE"
   ENDFOR DO
    ( REMOVE ITEM @INDEX 0.00000000 FROM listWithInitDate ) COMMENTED_BY "Remove the unneeded first element of the list of lists"
   ENDWITH COMMENTED_BY "Initialize the list with the timestep and pool elevation prior to the first date in the argument list"
  ENDWITH
 ENDWITH;

    END
    UUID "{9be1bf79-1934-4d5f-a4cd-8142ad37ca25}";;

    FUNCTION       "CalculatePowellMonthlyRelease" ( LIST datesToEOWY, NUMERIC UpperColumn, NUMERIC LowerColumn, NUMERIC RemainingAnnualVolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume does a linear interpolation on that table to find releases that sum up exactly to the annual volume set for Powell.  If the passed in set of dates is the first water year in the run, ie starts with the run's start timestep, then this function will make an adjustment to the releases that were calculated by doing the linear interpolation to account for what was released int he months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List of lists of the form &lcub;date, release, remaining volume over the lower bound to be released&rcub;<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates to the end of the water year<br>2. NUMERIC UpperColumn - index specifying the upper bound column in the table PowellData.PowellMontlhlyReleaseTable<br>3. NUMERIC LowerColumn - index specifying the lower bound column<br>4. NUMERIC RemainingAnnualVolume - the remaining annual volume to be released; <br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR/DATE: SC, 20110325<br>MC, 20170501: The original version of the model did not have RemainingAnnualVolume as an input, but calculated the remaining volume based on the target annual volume and the volume released prior to the model run; this version provides more flexibility to calculate releases for time periods different than those that begin with the current timestep<br>MC, 20170608: See note about necessity of check on volume in light of that type of check in calling function, GetPowellMonthlyReleases<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  WITH LIST UpperBoundList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
   WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
    APPEND releaseTable [monthsSinceEOWY + 1.00000000, UpperColumn] ONTO result
   ENDWITH
  ENDFOR DO
   WITH LIST LowerBoundList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
    WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
     APPEND releaseTable [monthsSinceEOWY + 1.00000000, LowerColumn] ONTO result
    ENDWITH
   ENDFOR DO
    WITH NUMERIC RemainingVolumeAboveLowerBounds = RemainingAnnualVolume - "Sum"( LowerBoundList ) DO
     WITH LIST differenceList = FOR ( NUMERIC index IN UpperBoundList ) WITH LIST result = {  } DO
      WITH NUMERIC diff = ( GET @INDEX LENGTH result FROM UpperBoundList ) - GET @INDEX LENGTH result FROM LowerBoundList DO
       APPEND diff ONTO result
      ENDWITH
     ENDFOR DO
      WITH LIST tempList = WHILE ( ( LENGTH result ) < LENGTH differenceList ) WITH LIST result = {  } DO
       APPEND { { GET @INDEX LENGTH result FROM datesToEOWY , GET @INDEX LENGTH result FROM differenceList , GET @INDEX LENGTH result FROM LowerBoundList } , GET @INDEX LENGTH result FROM differenceList } ONTO result
      ENDWHILE DO
       WITH LIST sortedList = "SortPairsDescending"( tempList ) DO
        WITH LIST AlteredReleaseFromTable = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = { { 0.00000000 , 0.00000000 , RemainingVolumeAboveLowerBounds } } DO
         WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
          WITH NUMERIC addedRelease = "Min"( GET @INDEX 1.00000000 FROM GET @INDEX index FROM sortedList, GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) DO
           WITH NUMERIC NewVolRemainAbvLB = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - addedRelease DO
            APPEND { GET @INDEX 0.00000000 FROM GET @INDEX index FROM sortedList , "VolumeToFlow"( "Min"( ( ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM sortedList ) + addedRelease ), RemainingAnnualVolume ) COMMENTED_BY "Do not release more than the total remaining annual volume (MC, 20160907)", GET @INDEX 0.00000000 FROM GET @INDEX index FROM sortedList ) , NewVolRemainAbvLB * "DebuggerStop"(  ) } ONTO result
           ENDWITH COMMENTED_BY "Update remaining total volume over LB to be released"
          ENDWITH COMMENTED_BY "Minimum of monthly capacity available over LB and remaining total volume over LB to be released"
         ENDWITH
        ENDFOR COMMENTED_BY "Initial list element is &lcub;0, 0, RemainingVolumeAboveLowerBounds&rcub;, subsequent elements are of the form: <br>&lcub;Month i, Flow rate for month i, Remaining vol over LB after month i release&rcub;" DO
         WITH NUMERIC RemainingVol = GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH AlteredReleaseFromTable ) - 1.00000000 FROM AlteredReleaseFromTable DO
          IF ( RemainingVol <= 1.00000000 "acre-feet" )
          THEN
           WITH LIST AdjMonthlyReleases = REMOVE ITEM @INDEX 0.00000000 FROM AlteredReleaseFromTable DO
            AdjMonthlyReleases
           ENDWITH
          ELSE
           WITH LIST AlteredReleases = REMOVE ITEM @INDEX 0.00000000 FROM AlteredReleaseFromTable DO
            WITH LIST NextLowerBoundList = UpperBoundList DO
             WITH NUMERIC NextUpperColumn = UpperColumn + 1.00000000 DO
              WITH LIST NextUpperBoundList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
               WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
                APPEND releaseTable [monthsSinceEOWY + 1.00000000, NextUpperColumn] ONTO result
               ENDWITH
              ENDFOR DO
               WITH LIST NextDifferenceList = FOR ( NUMERIC index IN NextUpperBoundList ) WITH LIST result = {  } DO
                WITH NUMERIC diff = ( GET @INDEX LENGTH result FROM NextUpperBoundList ) - GET @INDEX LENGTH result FROM NextLowerBoundList DO
                 APPEND diff ONTO result
                ENDWITH
               ENDFOR DO
                WITH LIST tempAlteredList = WHILE ( ( LENGTH result ) < LENGTH AlteredReleases ) WITH LIST result = {  } DO
                 APPEND { GET @INDEX LENGTH result FROM AlteredReleases , GET @INDEX 0.00000000 FROM GET @INDEX LENGTH result FROM AlteredReleases } ONTO result
                ENDWHILE DO
                 WITH LIST ResortedAlteredList = "SortPairsAscending"( tempAlteredList ) DO
                  WITH LIST NextTempList = WHILE ( ( LENGTH result ) < LENGTH NextDifferenceList ) WITH LIST result = {  } DO
                   APPEND { { GET @INDEX LENGTH result FROM datesToEOWY , GET @INDEX LENGTH result FROM NextDifferenceList , GET @INDEX 1.00000000 FROM GET @INDEX LENGTH result FROM ResortedAlteredList } , GET @INDEX LENGTH result FROM NextDifferenceList } ONTO result
                  ENDWHILE DO
                   WITH LIST NextSortedList = "SortPairsDescending"( NextTempList ) DO
                    WITH LIST NextAlteredReleaseFromTable = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = { { 0.00000000 , 0.00000000 , RemainingVol } } DO
                     WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                      WITH NUMERIC NextAddedRelease = "Min"( GET @INDEX 1.00000000 FROM GET @INDEX index FROM NextSortedList, GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) DO
                       WITH NUMERIC NextDiffInVol = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - NextAddedRelease DO
                        APPEND { GET @INDEX 0.00000000 FROM GET @INDEX index FROM NextSortedList , "VolumeToFlow"( ( NextAddedRelease + "FlowToVolume"( GET @INDEX 2.00000000 FROM GET @INDEX index FROM NextSortedList, GET @INDEX 0.00000000 FROM GET @INDEX index FROM NextSortedList ) ), GET @INDEX 0.00000000 FROM GET @INDEX index FROM NextSortedList ) , NextDiffInVol * "DebuggerStop"(  ) } ONTO result
                       ENDWITH
                      ENDWITH
                     ENDWITH
                    ENDFOR DO
                     WITH LIST AdjMonthlyReleases = REMOVE ITEM @INDEX 0.00000000 FROM NextAlteredReleaseFromTable DO
                      AdjMonthlyReleases
                     ENDWITH
                    ENDWITH
                   ENDWITH
                  ENDWITH
                 ENDWITH COMMENTED_BY "Need to re-sort the AlteredList by date in order to have indices consistent with <br>other lists used"
                ENDWITH COMMENTED_BY "Create a temporary altered list for resorting by month"
               ENDWITH COMMENTED_BY "Recalculate the differences between the upper and lower bounds"
              ENDWITH COMMENTED_BY "Create the new upper bound list for the months remaining in WY"
             ENDWITH COMMENTED_BY "Increase the upper bound index by one"
            ENDWITH COMMENTED_BY "Make previous upper bound list the new lower bound list"
           ENDWITH COMMENTED_BY "Not all remaining volume was released; can happen when not enough capacity in remainder of WY"
          ENDIF COMMENTED_BY "If total volume is within tolerance, use the calculated releases"
         ENDWITH COMMENTED_BY "Check to see if there is any remaining unreleased volume<br>MC, 20170608: Not sure if this is really necessary; seems like the check on volume in <br>  GetPowellMonthlyReleases should address the problem?"
        ENDWITH
       ENDWITH COMMENTED_BY "Create list of the form &lcub;Month i, UB(i)-LB(i), LB(i)&rcub;, sorted by UB(i)-LB(i)"
      ENDWITH COMMENTED_BY "Create list of the form: &lcub; &lcub;Remaining month i, UB(i)-LB(i), LB(month i)&rcub;, UB(i)-LB(i) &rcub;<br>The second occurrence of UB(i)-LB(i) is used to sort the first list"
     ENDWITH COMMENTED_BY "Calculate the difference between the UB and LB release for each remaining month"
    ENDWITH COMMENTED_BY "Calculate the remaining annual volume greater than the cumulative lower bound volume"
   ENDWITH COMMENTED_BY "Retrieve the release values for the lower bound column"
  ENDWITH
 ENDWITH COMMENTED_BY "Retrieve the release values for the upper bound column";

    END
    UUID "{3d3f891f-7e83-45ff-97ca-171f2e7e0c3b}";;

    FUNCTION       "CalculatePowellUEBToEqualizePowellMonRel" ( LIST datesToEOWY, NUMERIC UpperColumn, NUMERIC LowerColumn, NUMERIC RemainingAnnualVolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Takes a list of dates that go from the current timestep to the end of the water year. It returns a list of two items each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  If the Equalization outflow has been calculated by Branch 1.3 of the Upper Elevation Balancing Tier, then the outflows from the current date until April 1 have to follow a path of a 9.0 MAF release and then will be either the maximum power plant release (based on an estimation using engineering functions of RW) or the remaining amount of volume to meet the equalization volume determined by previous rules.  The post march releases will be estimated in this function and any carryover volume from not being able to release the water due to power plant capacity will need to be determined. <br><br>RETURNS: List of lists in the form &lcub;date, release, remaining volume over capacity to be released&rcub;<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates to the end of the water year<br>2. NUMERIC UpperColumn - index specifying the upper bound column in the table PowellData.PowellMontlhlyReleaseTable<br>3. NUMERIC LowerColumn - index specifying the lower bound column<br>4. NUMERIC RemainingAnnualVolume - the remaining annual volume to be released; <br><br>CONSTRAINTS: None<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR/DATE: TP, 20171013<br><br>TP, 20180226: startMonth is the month in which to increase releases to try to balance reservoirs. If the month is set to 4, it simulates the April Adjustment that this function is trying to accomplish. Carryover can be created in this scenario. By entering a 3 (March) the simulation is doing a March Adjustment instead, which may be necessary to not violate Power Plant Capacity and not create carryover.  If this operation is ever desired by the Powell Operator, this could be moved to a scalar slot in the model where it can be edited by the operator for a model simulation and not have to come into this function to make that change.<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.<br><br>S.Baker 2018/10/17: Removed hard coded column value and added function NumCol() - 1 <br><br>S.Baker 2018/11/26: It does not seem the function was tested in scenarios when the start date was April through September and there was an April adjustment (1.3 - Upper Elev Bal Tier, B3 branch). The changes to this function are meant to fix issues for start dates in this time frame. <br>- Add Boolean, ?startMonAprToSept?, to check if start month is April through September. In these specific months, the function breaks since part of the function is trying to calculate releases from October through March. The T/F value will be used to bypass calculations that would break the function. <br>- Edit the calculation of ?RelThruMar? to create an empty list if ?startMonAprToSept? is true. If false, the original calculation is performed. <br>- In calculation of ?scalVal?, add IF statement to check if sum(?baselist') is greater than 0 acre-ft (eg. list is not empty). Originally, model failed when ?baselist? was empty because it was trying to divide a number by zero. <br>- In calculation of ?TempList?, there was improper indexing of ?AdjustBaseList? when start date was April through September. An IF statement was added to index differently if ?startMonAprToSept? is true. <br>";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  WITH NUMERIC ColumnNoFor9MAF = "FindReleaseUpperBoundColumn"( 9000000.00000000 "acre-ft" ) DO
   WITH NUMERIC startMonth = 4.00000000 DO
    WITH BOOLEAN startMonAprToSept = IF ( "GetMonth"( GET @INDEX 0.00000000 FROM datesToEOWY ) >= startMonth AND "GetMonth"( GET @INDEX 0.00000000 FROM datesToEOWY ) <= 9.00000000 )
    THEN
     TRUE
    ELSE
     FALSE
    ENDIF DO
     WITH LIST RelThruMar = IF ( startMonAprToSept )
     THEN
      { 0.00000000 "acre-ft" }
     ELSE
      FOR ( DATETIME date IN datesToEOWY ) WITH LIST resultb = {  } DO
       WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
        IF ( "GetMonth"( date ) < startMonth OR "GetMonth"( date ) > 9.00000000 )
        THEN
         APPEND releaseTable [monthsSinceEOWY + 1.00000000, ColumnNoFor9MAF] ONTO resultb
        ELSE
         resultb
        ENDIF
       ENDWITH
      ENDFOR
     ENDIF COMMENTED_BY "Determine what the Release are necessary for the Oct through March pattern for a 9 MAF <br>release.  <br>" DO
      WITH NUMERIC TobeReleasedThruMar = "Sum"( RelThruMar ) COMMENTED_BY "Sum the October to March Release volume for 9.0 MAF release <br>" DO
       WITH NUMERIC remainingVolumeRelAprThruSep = ( RemainingAnnualVolume - TobeReleasedThruMar ) COMMENTED_BY "Determine the outflow that needs to be released between the Start Month and September to <br>meet the TARV <br>" DO
        WITH NUMERIC lowerColToReleaseRemaining = FOR ( NUMERIC col IN "GetNumbers"( LowerColumn, "NumColumns"( releaseTable ) - 1.00000000, 1.00000000 ) ) WITH NUMERIC newCol = LowerColumn DO
         WITH NUMERIC sumAprToSep = "SumTableColumn"( releaseTable, col, 7.00000000, 12.00000000 ) DO
          IF ( remainingVolumeRelAprThruSep > sumAprToSep )
          THEN
           newCol + 1.00000000
          ELSE
           newCol
          ENDIF
         ENDWITH
        ENDFOR COMMENTED_BY "Determine the column in the LTEMP Powell Release Table that contains the Start month to <br>September volume necessary to mee the TARV  <br>" DO
         WITH LIST LowerBoundListAprThruSep = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
          WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
           IF ( "GetMonth"( date ) < 10.00000000 AND "GetMonth"( date ) > startMonth - 1.00000000 )
           THEN
            APPEND releaseTable [monthsSinceEOWY + 1.00000000, lowerColToReleaseRemaining] ONTO result
           ELSE
            result
           ENDIF
          ENDWITH
         ENDFOR COMMENTED_BY "Determine the releases for the column determined in the previous step <br>" DO
          WITH LIST UpperBoundListAprThruSep = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
           WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
            IF ( "GetMonth"( date ) < 10.00000000 AND "GetMonth"( date ) > startMonth - 1.00000000 )
            THEN
             APPEND releaseTable [monthsSinceEOWY + 1.00000000, lowerColToReleaseRemaining + 1.00000000] ONTO result
            ELSE
             result
            ENDIF
           ENDWITH
          ENDFOR COMMENTED_BY "Determine the releases for the upper column of the determined lower column <br>" DO
           WITH NUMERIC LowersSum = "Sum"( LowerBoundListAprThruSep ) COMMENTED_BY "Sum the volumes for the Upper and lower columns <br>" DO
            WITH NUMERIC UpperSum = "Sum"( UpperBoundListAprThruSep ) DO
             WITH LIST baseList = IF ( remainingVolumeRelAprThruSep > UpperSum )
             THEN
              UpperBoundListAprThruSep
             ELSE
              LowerBoundListAprThruSep
             ENDIF COMMENTED_BY "Determine which pattern to use, lower column pattern or upper column pattern <br>" DO
              WITH NUMERIC scalVal = IF ( "Sum"( baseList ) > 0.00000000 "acre-ft" )
              THEN
               ( remainingVolumeRelAprThruSep / "Sum"( baseList ) )
              ELSE
               1.00000000
              ENDIF COMMENTED_BY "Determine a scale value that will increase or decrease a pattern to meet the remaining TARV <br>Volume <br>" DO
               WITH NUMERIC sumPowerPlantCapAprToSep = FOR ( DATETIME dateb IN datesToEOWY ) STAT_SUM
                IF ( "GetMonth"( dateb ) < startMonth OR "GetMonth"( dateb ) > 9.00000000 )
                THEN
                 0.00000000 "acre-ft"
                ELSE
                 "FlowToVolume"( $ "Powell.Peak Flow" [dateb], dateb )
                ENDIF
               ENDFOR COMMENTED_BY "Determine the volume of Power Plant Capacity between the start month and September <br>" DO
                WITH LIST AdjustedBaseList = FOR ( NUMERIC Rel IN baseList ) WITH LIST result = {  } DO
                 APPEND Rel * scalVal ONTO result
                ENDFOR COMMENTED_BY "Scale the base list to the TARV Volume <br>" DO
                 WITH LIST TempList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST resultb = {  } DO
                  IF ( startMonAprToSept )
                  THEN
                   WITH NUMERIC index = ( LENGTH resultb ) DO
                    APPEND { date , GET @INDEX index FROM AdjustedBaseList } ONTO resultb
                   ENDWITH
                  ELSE
                   WITH NUMERIC index = ( LENGTH resultb ) DO
                    IF ( "GetMonth"( date ) < startMonth OR "GetMonth"( date ) > 9.00000000 )
                    THEN
                     APPEND { date , GET @INDEX index FROM RelThruMar } ONTO resultb
                    ELSE
                     APPEND { date , GET @INDEX index - ( ( LENGTH datesToEOWY ) - ( 10.00000000 - startMonth ) ) FROM AdjustedBaseList } ONTO resultb
                    ENDIF
                   ENDWITH
                  ENDIF
                 ENDFOR COMMENTED_BY "Build a Water Year Release Pattern with 9.0 MAF pattern from Oct to the start month, and the <br>adjusted pattern from the start month to September to meet the TARV.  <br>" DO
                  WITH NUMERIC prevPoolElev = $ "Powell.Pool Elevation" ["OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 Months" )] COMMENTED_BY "Get the Previous Pool Elevation for the following List construction <br>" DO
                   WITH LIST ListWithMaxPowerRel = FOR ( LIST index IN TempList ) WITH LIST result = { { "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 Months" ) , "null" , prevPoolElev , RemainingAnnualVolume } COMMENTED_BY "Build the first list in the list of lists with information that will be used in the first iteration of the list <br>" } DO
                    WITH NUMERIC PreviousResultPE = GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
                     WITH DATETIME PreviousDate = GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
                      WITH DATETIME CurrentDate = "OffsetDate"( PreviousDate, 1.00000000, "1 Months" ) DO
                       WITH NUMERIC CurrentEstRelease = IF ( ( LENGTH result ) == ( LENGTH TempList ) )
                       THEN
                        "Max"( "VolumeToFlow"( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM TempList, CurrentDate ), "VolumeToFlow"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result, CurrentDate ) ) COMMENTED_BY "If in the last month, try to release all remaining volume <br>"
                       ELSE
                        "VolumeToFlow"( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM TempList, CurrentDate )
                       ENDIF DO
                        WITH NUMERIC PowerPlantHeadRow = "Min"( "Floor"( ( PreviousResultPE - $ "Powell.Minimum Power Elevation" [0.00000000, "Min Power Elev"] ), 1.00000000 "ft" ), 212.00000000 "feet" ) DO
                         WITH NUMERIC MaxGeneratorRelease = $ "Powell.Peak Flow" [CurrentDate] DO
                          WITH NUMERIC NextOutflow = IF ( "GetMonth"( CurrentDate ) > 9.00000000 OR "GetMonth"( CurrentDate ) < startMonth OR sumPowerPlantCapAprToSep > remainingVolumeRelAprThruSep )
                          THEN
                           "Min"( CurrentEstRelease, MaxGeneratorRelease )
                          ELSE
                           "Min"( "VolumeToFlow"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result, CurrentDate ) COMMENTED_BY "Remaining Volume<br>", MaxGeneratorRelease )
                          ENDIF DO
                           WITH NUMERIC tempPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [CurrentDate], CurrentDate ) - "FlowToVolume"( NextOutflow, CurrentDate ) - NaNToZero ( $ "Powell.Change in Bank Storage" [CurrentDate] ) ) DO
                            WITH NUMERIC NewPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [CurrentDate], CurrentDate ) - "PowellEvapEstimation"( CurrentDate, PreviousResultPE, tempPE ) - "FlowToVolume"( NextOutflow, CurrentDate ) - NaNToZero ( $ "Powell.Change in Bank Storage" [CurrentDate] ) ) COMMENTED_BY "Determine the Pool Elevation estimation with Evaporation  <br>" DO
                             WITH NUMERIC newRemVol = ( ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) - "FlowToVolume"( NextOutflow, CurrentDate ) ) COMMENTED_BY "Determine the remaining Volume that was not released from the TARV. At the end of the Water <br>Year, any value calculated here, will be considered Carryover.   <br>" DO
                              APPEND { CurrentDate , NextOutflow , NewPE , newRemVol } ONTO result
                             ENDWITH
                            ENDWITH
                           ENDWITH COMMENTED_BY "Calculate the PE for CurrentDate based on the updated outflow without Evap, for use in the <br>Evap function for Powell <br>"
                          ENDWITH COMMENTED_BY "Calculate the outflow as the minimum of the estimate passed in or the calculated maximum bypass"
                         ENDWITH COMMENTED_BY "Calculate the maximum bypass possible based on the previous result PE value"
                        ENDWITH COMMENTED_BY "Calculate the head value for the current PE <br>"
                       ENDWITH COMMENTED_BY "Retrieve the release passed into the function for the current date"
                      ENDWITH COMMENTED_BY "Set current date"
                     ENDWITH COMMENTED_BY "Retrieve previous result date"
                    ENDWITH COMMENTED_BY "Retrieve previous result PE"
                   ENDFOR COMMENTED_BY "Determine the outflows for the Water Year that meets the 9.0 MAF release pattern from October <br>to the start month, and the remaining releases limited to the release of the TARV or the Power <br>Plant Capacity. The result of the function will be a list of lists with the form &lcub;&lcub;Date, Outflow, Pool <br>Elevation, remaining TARV&rcub;,&lcub;Date, Outflow, Pool Eleavation, remaining TARV&rcub;,...&rcub; <br>" DO
                    WITH NUMERIC carryoverVol = ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH ListWithMaxPowerRel ) - 1.00000000 FROM ListWithMaxPowerRel ) COMMENTED_BY "If there is any carryover volume remaining, this could be due to months in the last months of the <br>Water Year where the TARV pattern in the &quot;Base List&quot; could not be met due to Power Plant <br>Capacity Restrictions. If the early months in the &quot;Base List&quot; after the Start Month, TARV <br>patterned release is not as high as the Power Plant Capacity for that month, the carryover <br>created in the later part of the Water Year, could be released in the earlier part, after the start <br>month.  <br>" DO
                     WITH LIST TryToReleaseAllCarryover = FOR ( LIST DRPEVol IN REMOVE ITEM @INDEX 0.00000000 FROM ListWithMaxPowerRel ) WITH LIST result = { { 1.00000000 , 1.00000000 , 1.00000000 , carryoverVol } } DO
                      WITH NUMERIC maxFlow = $ "Powell.Peak Flow" [GET @INDEX 0.00000000 FROM DRPEVol] COMMENTED_BY "Power Plant Capacity <br>" DO
                       WITH NUMERIC DiffCurFlowandMaxFlow = IF ( "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) > 9.00000000 OR "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) < startMonth )
                       THEN
                        0.00000000 "acre-ft/month"
                       ELSE
                        "Max"( maxFlow - GET @INDEX 1.00000000 FROM DRPEVol, 0.00000000 "acre-ft/month" )
                       ENDIF COMMENTED_BY "Determine the amount of possible space available for a given month <br>" DO
                        WITH NUMERIC CarryoverLeftToRelease = ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) COMMENTED_BY "amount of carryover that is needed to be released <br>" DO
                         WITH NUMERIC ChangeInRelease = ( ( GET @INDEX 1.00000000 FROM DRPEVol ) + "Min"( "VolumeToFlow"( CarryoverLeftToRelease, GET @INDEX 0.00000000 FROM DRPEVol ), DiffCurFlowandMaxFlow ) ) COMMENTED_BY "Determine new change in outflow <br>" DO
                          WITH NUMERIC CarryoverLeft = ( CarryoverLeftToRelease - "Min"( CarryoverLeftToRelease, "FlowToVolume"( DiffCurFlowandMaxFlow, GET @INDEX 0.00000000 FROM DRPEVol ) ) ) COMMENTED_BY "Determine if carryover is left to be released in the next months if possible.  <br>" DO
                           APPEND { GET @INDEX 0.00000000 FROM DRPEVol , ChangeInRelease , GET @INDEX 2.00000000 FROM DRPEVol , CarryoverLeft * "DebuggerStop"(  ) } ONTO result
                          ENDWITH
                         ENDWITH
                        ENDWITH
                       ENDWITH
                      ENDWITH
                     ENDFOR COMMENTED_BY "This List tries to insert the Carryover generated from the preivous list, into months where there <br>might be room below the Power Plant Capacity.  This loop could be removed if this operation is <br>not desired and the carryover is better for modeling purposes.  This list generations creates a list <br>of lists in the form &lcub;&lcub;Date, Outflow, Pool Elevation, CarryoverLeft&rcub;,...&rcub; <br>" DO
                      WITH LIST DateFlowVol = FOR ( LIST DFV IN TryToReleaseAllCarryover ) WITH LIST result = {  } DO
                       APPEND { GET @INDEX 0.00000000 FROM DFV , GET @INDEX 1.00000000 FROM DFV , GET @INDEX 3.00000000 FROM DFV } ONTO result
                      ENDFOR COMMENTED_BY "If the previous list is found to be undesirred, then insert &quot; ListWithMaxPowerRel&quot; into where <br>&quot;TryToReleaseAllCarryover&quot; exists.  Then remove the Pool Elevation element from that list. and <br>Return a list of lists in the form &lcub;&lcub;Date, Outflow, Carryover Remaining&rcub;,...&rcub; <br>" DO
                       WITH LIST AdjMonthlyReleases = ( REMOVE ITEM @INDEX 0.00000000 FROM DateFlowVol ) COMMENTED_BY "Remove the first element from the list in the form &lcub;1, 1, 1, Carryover Volume&rcub; <br>" DO
                        AdjMonthlyReleases
                       ENDWITH
                      ENDWITH
                     ENDWITH
                    ENDWITH
                   ENDWITH
                  ENDWITH
                 ENDWITH
                ENDWITH
               ENDWITH
              ENDWITH
             ENDWITH
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "Check start month for function execution to determine calculations based on month <br>"
   ENDWITH COMMENTED_BY "startMonth is the month in which to increase releases to try to balance reservoirs.  <br>"
  ENDWITH
 ENDWITH;

    END
    UUID "{0fa2f445-7915-4ecb-9d11-430351f1ba30}";;

    FUNCTION       "MonthsSinceEOWY" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the number of months since the end of the previous water year<br><br>RETURNS: The number of months since the end of the previous water year<br><br>ARGUMENTS:<br>1. DATETIME date - a date within the run period<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "PowellData.MonthsToFromEOWY" ["GetMonthAsString"( date ), "Since"];

    END
    UUID "{918e4906-0442-4d49-b817-8f6ad6ce60eb}";;

    FUNCTION       "MonthsUntilEOWY" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the number of months until the end of the water year<br><br>RETURNS: The number of months until the end of the water year<br><br>ARGUMENTS:<br>1. DATETIME date - a date within the run period<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "PowellData.MonthsToFromEOWY" ["GetMonthAsString"( date ), "Until"];

    END
    UUID "{3cce8abb-c3ad-4d9d-b7ee-48781cf266db}";;

    FUNCTION       "PowellEvapEstimation" ( DATETIME date, NUMERIC curPE, NUMERIC prevPE )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function follows the method Periodic Net Evaporation (Look up details in RiverWare Help). The function calculates the evaporation that is a function of the reservoir and removes the amount that would have evaporated if the resroivr had not been built. The evaporation is calculated as the Gross Evap from the reservoir less the river, streamside, terrace, and remaining evap that would have occured if the reservoir was not there. TP 2/20/2018<br><br>RETURNS: NUMERIC, Estimate of evaporation volume [L^3]<br><br>ARGUMENTS: <br>1.DATETIME date, The current date of interest<br>2. NUMERIC curPE, The pool elevation estimated without Evaporation for the date<br>3. NUMERIC prevPE, The pool elevation estiatmed in the previous version of the loop that uses this function.<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: TP, 20180220";
    BEGIN

      WITH NUMERIC AvgSurfaceArea = ( ( "ElevationToArea"( % "Powell", prevPE ) + "ElevationToArea"( % "Powell", curPE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average Surface area using an estimated Powell Pool Elevation without <br>Evaporation removed.  <br>" DO
  WITH NUMERIC GrosEvap = ( AvgSurfaceArea * $ "Powell.Gross Evaporation Coefficient" [date, 0.00000000] ) COMMENTED_BY "This is the Gross Evaporation for Powell <br>" DO
   WITH NUMERIC AvgRiverArea = ( ( "TableLookupDefaultTol"( $ "Powell.Elevation River Area", 0.00000000, 1.00000000, prevPE, date, TRUE ) + "TableLookupDefaultTol"( $ "Powell.Elevation River Area", 0.00000000, 1.00000000, curPE, date, TRUE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average River Area  <br>" DO
    WITH NUMERIC RiverEvap = ( AvgRiverArea * $ "Powell.River Evaporation Coefficient" [date, 0.00000000] ) COMMENTED_BY "Determine the amount of Evaporation from the River Area <br>" DO
     WITH NUMERIC AvgStreamsideArea = ( ( "TableLookupDefaultTol"( $ "Powell.Elevation Streamside Area", 0.00000000, 1.00000000, prevPE, date, TRUE ) + "TableLookupDefaultTol"( $ "Powell.Elevation Streamside Area", 0.00000000, 1.00000000, curPE, date, TRUE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average Streamside Area with no Reservor <br>" DO
      WITH NUMERIC StreamsideEvap = ( AvgStreamsideArea * $ "Powell.Streamside Coefficient" [date, 0.00000000] * $ "Powell.Average Air Temperature" [date, 0.00000000] ) COMMENTED_BY "Determine the amount of Evaporation from the Streamside Area, need to use the Average Air <br>Temperature to determine this value. <br>" DO
       WITH NUMERIC AvgTerraceArea = ( ( "TableLookupDefaultTol"( $ "Powell.Elevation Terrace Area", 0.00000000, 1.00000000, prevPE, date, TRUE ) + "TableLookupDefaultTol"( $ "Powell.Elevation Terrace Area", 0.00000000, 1.00000000, curPE, date, TRUE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average Terrace Area of the River with no reservoir <br>" DO
        WITH NUMERIC TerraceEvap = ( AvgTerraceArea * $ "Powell.Terrace Coefficient" [date, 0.00000000] * $ "Powell.Average Air Temperature" [date, 0.00000000] ) COMMENTED_BY "Determine the amount of Evaporation from the Terrace Area, need to use the Average Air <br>Temperature to determine this value. <br>" DO
         WITH NUMERIC RemainingArea = "Max"( AvgSurfaceArea - AvgRiverArea - AvgStreamsideArea - AvgTerraceArea, 0.00000000 "acre" ) COMMENTED_BY "Determine the Remaining area that would simulate the area outside of the river, streamside, or <br>terrace that is covered by the reservoir.  <br>" DO
          WITH NUMERIC RemainingEvap = ( RemainingArea * $ "Powell.Average Precipitation" [date, 0.00000000] ) COMMENTED_BY "Multiply that remaining area by the precipitation rate, it is assumed that any precipitation in the <br>remaining area is evaporated, so it is included in this estimation. See &quot;Periodic Net Evaporation&quot; in <br>section 17.1.18.7 in Objects of the RiverWare Help Documentation.  <br>" DO
           WITH NUMERIC SalvageEvap = ( RiverEvap + StreamsideEvap + TerraceEvap + RemainingEvap ) COMMENTED_BY "Determine the Salvage Evap (The amount of Evap that would occur if the reservoir were not <br>there) <br>" DO
            WITH NUMERIC Evap = "Max"( "FlowToVolume"( GrosEvap - SalvageEvap, date ), 0.00000000 "acre-ft" ) COMMENTED_BY "The Net Evap (Gross - Salvage) is the value that is returned from this function <br>" DO
             Evap
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{040aead3-3666-42f7-a71d-e4a3593dd3e4}";;

    FUNCTION       "PowellReleaseTier" ( NUMERIC Jan1Elev, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a numeric code designating the release tier for Powell based on the provided date and January 1 pool elevation<br><br>RETURNS: Numeric code associated with a release tier<br><br>ARGUMENTS:<br>1. NUMERIC Jan1Elev - pool elevation for January 1<br>2. DATETIME date - date used to specify the water year for calculating the equalization level pool elevation<br><br>CONSTRAINTS: Value is between 0 & 3<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( Jan1Elev >= "EqLevel"( date ) )
 THEN
  0.00000000 COMMENTED_BY "Equalization"
 ELSE
  IF ( Jan1Elev >= $ "PowellData.TierBreaks" ["UpperMid", 0.00000000] )
  THEN
   1.00000000 COMMENTED_BY "Upper Elevation Balancing"
  ELSE
   IF ( Jan1Elev >= $ "PowellData.TierBreaks" ["MidLower", 0.00000000] )
   THEN
    2.00000000 COMMENTED_BY "Mid-Elevation Release"
   ELSE
    3.00000000 COMMENTED_BY "Lower Elevation Balancing"
   ENDIF
  ENDIF
 ENDIF;

    END
    UUID "{fd54c24a-b992-44fc-b0da-597e0adecba3}";;

    FUNCTION       "DebuggerStop" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is a placeholder function that provdes a location for setting a breakpoint in the debugger and allows investigation of LIST of LISTs elements as they are created, instead of after the entire list is created<br><br>RETURNS: Value specified in body of function [NONE]<br><br>ARGUMENTS: NONE<br><br>CONSTRAINTS: NONE";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: Unknown";
    BEGIN

      1.00000000;

    END
    UUID "{d6afcf39-031f-43eb-9e35-d216212b3ad4}";;

    FUNCTION       "TierIs" ( STRING tier, DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns TRUE or FALSE signifying whether or not Powell is operating under the specified release tier in the water year containing the provided date<br><br>RETURNS: Boolean TRUE or FALSE<br><br>ARGUMENTS:<br>1. STRING tier - the name of the tier<br>2. DATETIME date - date used to determine the water year<br>3. BOOLEAN startYear - specifies whether or not the water year is the first water year (TRUE) in the model run or not (FALSE)<br><br>CONSTRAINTS: Returns FALSE if the release tier for the appropriate year is NaN<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( startYear AND date <= @"24:00:00 September 30" )
 THEN
  IF ( NOT IsNaN $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Current Year"] )
  THEN
   $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Current Year"] == $ "PowellData.TierNames" [tier, 0.00000000]
  ELSE
   FALSE
  ENDIF
 ELSE
  IF ( NOT IsNaN $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Next Year"] )
  THEN
   $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Next Year"] == $ "PowellData.TierNames" [tier, 0.00000000]
  ELSE
   FALSE
  ENDIF
 ENDIF;

    END
    UUID "{77f293b3-2180-4235-961e-c3af63b7bf87}";;

    FUNCTION       "UpperElevationBalancingBranchCalculation" ( DATETIME eowyDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates a code to specify which branch of the Upper Elevation Balancing Tier is used to calculate the release volume<br><br>RETURNS: Value representing the appropriate Upper Elevation Balancing tier branch<br><br>ARGUMENTS:<br>1. DATETIME eowyDate - the end of water year date for which the branch should be calculated<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 20120601<br><br>See the &quot;Interim Guidelines Flow Chart&quot; for reference.  This slot shows the branch within the Upper Elevation Balancing Tier that was taken for each year's calculation of Powell annual release volume.  It can take the following values for the following conditions:<br>1.1 - Upper Elev Bal Tier, B1 branch (8.23 MAF release)<br>1.2 - Upper Elev Bal Tier, B2 branch (release between 7 MAF and 9MAF)<br>1.3 - Upper Elev Bal Tier, B3 branch (Equalization Tier Calc)<br>1.4 - Upper Elev Bal Tier, B4 branch (release between 8.23 MAF and 9MAF)<br>999 - Any other Tier<br><br>MC, 20160908: Changed MeadProjectionDate to be dependent on input parameter eowyDate, instead of on @&quot;t&quot;; added Boolean input parameter 'startYear'  for determining which Mead PE to use; added MeadProjectedElevation variable<br><br>SB, 20180829: Changed how the 'MeadProjectedElevation' in calculated. If the projection date is within the current or previous water year, we need to look at the AugEOYMeadPEProjection value. This function is used in instances where the startYear input could be True/False depending on the controller timestep. The above change will allow the function to know where to look for the PE projection opposed to have it be input.  ";
    BEGIN

      WITH DATETIME MeadProjectionDate = "Dec31ofYear"( eowyDate - 1.00000000 "year" ) DO
  WITH NUMERIC MeadProjectedElevation = "GetProjectedPoolElevation"( "Mead", MeadProjectionDate ) DO
   IF ( $ "Powell.Pool Elevation" [eowyDate] > "EqLevel"( eowyDate ) )
   THEN
    1.30000000
   ELSE
    IF ( MeadProjectedElevation >= 1075.00000000 "ft" )
    THEN
     IF ( $ "Mead.Pool Elevation" [eowyDate] <= 1075.00000000 "ft" AND $ "Powell.Pool Elevation" [eowyDate] > 3575.00000000 "ft" )
     THEN
      1.40000000
     ELSE
      1.10000000
     ENDIF COMMENTED_BY "If Mead's EOWY elevation is less than 1075' and Powell's EOWY elevation is greater than 3575' then release enough to balance <br>the storages up to 9.0 MAF and no less than 8.23 MAF annual release volume (Branch 4).  Otherwise just release 8.23 MAF (Branch 1)"
    ELSE
     IF ( "EnsureReleaseLimits"( "EqualizationRelease"( eowyDate ), $ "PowellData.UpperTierB2MinAnnualRelease" [], $ "PowellData.UpperTierB2MaxAnnualRelease" [] ) > 8230.00000000 "1000 acre-ft" )
     THEN
      1.29000000
     ELSE
      1.27000000
     ENDIF COMMENTED_BY "Branch 2"
    ENDIF
   ENDIF COMMENTED_BY "If greater than the Equalization level, Branch 3"
  ENDWITH COMMENTED_BY "Retrieve the pool elevation for the projection date"
 ENDWITH COMMENTED_BY "Set the date on which to check the Mead pool elevation";

    END
    UUID "{a607f2d8-571a-4b39-a35f-a5c868426df7}";;

    FUNCTION       "UpperElevationBalancingBranchCalculation_old" ( DATETIME eowyDate, BOOLEAN startYear )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates a code to specify which branch of the Upper Elevation Balancing Tier is used to calculate the release volume<br><br>RETURNS: Value representing the appropriate Upper Elevation Balancing tier branch<br><br>ARGUMENTS:<br>1. DATETIME eowyDate - the end of water year date for which the branch should be calculated<br>2. BOOLEAN startYear - specifies whether the water year in question is the first water year (TRUE) or an out year (FALSE)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 20120601<br><br>See the &quot;Interim Guidelines Flow Chart&quot; for reference.  This slot shows the branch within the Upper Elevation Balancing Tier that was taken for each year's calculation of Powell annual release volume.  It can take the following values for the following conditions:<br>1.1 - Upper Elev Bal Tier, B1 branch (8.23 MAF release)<br>1.2 - Upper Elev Bal Tier, B2 branch (release between 7 MAF and 9MAF)<br>1.3 - Upper Elev Bal Tier, B3 branch (Equalization Tier Calc)<br>1.4 - Upper Elev Bal Tier, B4 branch (release between 8.23 MAF and 9MAF)<br>999 - Any other Tier<br><br>MC, 20160908: Changed MeadProjectionDate to be dependent on input parameter eowyDate, instead of on @&quot;t&quot;; added Boolean input parameter 'startYear'  for determining which Mead PE to use; added MeadProjectedElevation variable";
    BEGIN

      WITH DATETIME MeadProjectionDate = "Dec31ofYear"( eowyDate - 1.00000000 "year" ) DO
  WITH NUMERIC MeadProjectedElevation = IF ( startYear )
  THEN
   $ "PowellToMeadData.AugEOYMeadPEProjection" [MeadProjectionDate]
  ELSE
   $ "Mead.Pool Elevation" [MeadProjectionDate]
  ENDIF DO
   IF ( $ "Powell.Pool Elevation" [eowyDate] > "EqLevel"( eowyDate ) )
   THEN
    1.30000000
   ELSE
    IF ( MeadProjectedElevation >= 1075.00000000 "ft" )
    THEN
     IF ( $ "Mead.Pool Elevation" [eowyDate] <= 1075.00000000 "ft" AND $ "Powell.Pool Elevation" [eowyDate] > 3575.00000000 "ft" )
     THEN
      1.40000000
     ELSE
      1.10000000
     ENDIF COMMENTED_BY "If Mead's EOWY elevation is less than 1075' and Powell's EOWY elevation is greater than 3575' then release enough to balance <br>the storages up to 9.0 MAF and no less than 8.23 MAF annual release volume (Branch 4).  Otherwise just release 8.23 MAF (Branch 1)"
    ELSE
     IF ( "EnsureReleaseLimits"( "EqualizationRelease"( eowyDate ), $ "PowellData.UpperTierB2MinAnnualRelease" [], $ "PowellData.UpperTierB2MaxAnnualRelease" [] ) > 8230.00000000 "1000 acre-ft" )
     THEN
      1.29000000
     ELSE
      1.27000000
     ENDIF COMMENTED_BY "Branch 2"
    ENDIF
   ENDIF COMMENTED_BY "If greater than the Equalization level, Branch 3"
  ENDWITH COMMENTED_BY "Retrieve the pool elevation for the projection date"
 ENDWITH COMMENTED_BY "Set the date on which to check the Mead pool elevation";

    END
    UUID "{c895b415-eb94-40c0-9c8e-5f7e9eca8557}";;

    FUNCTION       "VolumeDeviationFromEOWYTarget" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the volume deviation of the end-of-water-year storage at Powell and Mead from their appropriate target levels according to the Equalization Tier logic.  The condition that is operative for setting the annual volume in a given year is stored in the PowellData.ControllingEqualizationCondition slot.  See the slot for further description of what the values actually mean.  This deviation volume is then added to the annual release volume to more precisely hit the end of water year (EOWY) target. Carryover created in the current and previous water year is accounted for each time a reservoir storage is used.<br><br>RETURNS: Difference between Powell storage volume and the desired end of water year storage volume [L^3]<br><br>ARGUMENTS:<br>1. DATETIME EOWYDate - end of water year date used to specify the appropriate water year<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>S.Baker, 2018/10/17: This function calculates a VolumeDeviation in the rule ?Refine Equalization Release Volume?.  This function needs to account for carryover volume that is created for the current year; without accounting for carryover, MTOM continuously increase the TARV and eventually aborts. Added two 'WITH' statements to use for current and previous year's carryover volume.<br>";
    BEGIN

      WITH NUMERIC carryoverCurrentWY = $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "OffsetDate"( EOWYDate, 12.00000000, "1 months" ) )] DO
  WITH NUMERIC carryoverPreviousWY = $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( EOWYDate )] DO
   IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.10000000 )
   THEN
    $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) ) - carryoverCurrentWY
   ELSE
    IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.20000000 OR NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.30000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWYDate )] ) == 1.27000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWYDate )] ) == 1.29000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWYDate )] ) == 1.40000000 )
    THEN
     ( ( $ "Powell.Storage" [EOWYDate] - carryoverCurrentWY - carryoverPreviousWY ) - ( $ "Mead.Storage" [EOWYDate] + carryoverCurrentWY + carryoverPreviousWY ) ) / 2.00000000
    ELSE
     IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.40000000 )
     THEN
      "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - ( $ "Mead.Storage" [EOWYDate] + carryoverCurrentWY + carryoverPreviousWY )
     ELSE
      IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.50000000 )
      THEN
       $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" ) - carryoverCurrentWY - carryoverPreviousWY
      ELSE
       0.00000000 "acre-ft"
      ENDIF COMMENTED_BY "Fourth possible condition is that Powell elevation needs to be at 20ft below the equalization level by the end-of-water-year"
     ENDIF COMMENTED_BY "Third possible condition is that Mead needs to be at elevation 1105 ft by the end-of-water-year"
    ENDIF COMMENTED_BY "Second possible condition is that the end-of-water-year storages need to be equal between Powell and Mead."
   ENDIF
  ENDWITH
 ENDWITH COMMENTED_BY "First condition is that Powell needs to be to its equalization level by end-of-water-year";

    END
    UUID "{4f23703c-2252-4729-b6be-28b01dfc099e}";;

    FUNCTION       "WaterYearDatesByGroup" ( NUMERIC inputGroupNumber )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a list of the dates in the same WY group (all dates in a water year have the same group number) &quot;inputGroupNumber&quot;. Note that for the initial water year, only the remaining months in the water year (beginning with that of the Start Timestep) are included in the output.<br><br>RETURNS: List of dates remaining in the water year specified by the input argument<br><br>ARGUMENTS:<br>1. NUMERIC inputGroupNumber - numeric value specifying the water year for which the dates are desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST prelimList = FOR ( DATETIME date IN @"Start Timestep + 1" TO @"Finish Timestep" ) WITH LIST result = { { @"Start Timestep" , 1.00000000 } } DO
  WITH NUMERIC groupNumber = GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
   IF ( "GetMonthAsString"( date ) == "October" )
   THEN
    APPEND { date , groupNumber + 1.00000000 } ONTO result
   ELSE
    APPEND { date , groupNumber } ONTO result
   ENDIF
  ENDWITH
 ENDFOR DO
  IF ( ( inputGroupNumber == 7.00000000 AND @"Start Timestep" == @"October 31" ) COMMENTED_BY "If the start month is October then there is no third water year in the run window.  Thus we need this function to be <br>non-empty and return a date that will definitely be outside of the run window. - sc 11/03/11" )
  THEN
   { @"24:00:00 December 31, 1900" }
  ELSE
   FOR ( LIST dateGroupNumber IN prelimList ) WITH LIST result = {  } DO
    IF ( ( GET @INDEX 1.00000000 FROM dateGroupNumber ) == inputGroupNumber )
    THEN
     APPEND GET @INDEX 0.00000000 FROM dateGroupNumber ONTO result
    ELSE
     result
    ENDIF
   ENDFOR COMMENTED_BY "Loop through prelimList and keep the &lcub;Date, Group Number&rcub; pairs for which Group Number matches inputGroupNumber"
  ENDIF
 ENDWITH COMMENTED_BY "prelimList contains all dates within the model run period and their associated water year numbers";

    END
    UUID "{f08863a4-fa24-4d07-9cc7-fe9637030bef}";;

    FUNCTION       "GetPowellMonthlyReleases_pre20171024" ( LIST datesToEOWY )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume calculates each month's release.  If the set of dates passed to the function is the first water year in the run (i.e., begins with the run's start timestep), then, if necessary, this function will make an adjustment to the calculated releases to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List with members of the form &lcub;date, release&rcub; where date is a member of the list of dates passed to the function<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates within the model run period<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 20110325<br><br>MC, 20160907: In calculation of AdjustedMonthlyReleases, moved subRelList<1> (and multiplied by 1 &quot;month&quot;) into call to VolumeToFlow to get desired volume; previous version was not giving correct desired volume (at least in some cases when UserInput_MinimumAnnualRelease sets the TARV) due to conversion associated with monthly flow and time scale (i.e., RW was making an unwanted conversion based on the number of days in a month); Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1><br>MC, 20170501: Renamed variables for better understanding";
    BEGIN

      WITH NUMERIC AnnualVolume = "CurrentAnnualVolume"( GET @INDEX 0.00000000 FROM datesToEOWY ) DO
  WITH BOOLEAN EqualizationbyAprAdjust = IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] ) == 1.30000000 )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF DO
   WITH NUMERIC VolumeReleasedPreRun = IF ( "GetMonthAsString"( GET @INDEX 0.00000000 FROM datesToEOWY ) == "October" )
   THEN
    0.00000000 "acre-feet"
   ELSE
    "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), @"Start Timestep - 1" ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] )
   ENDIF DO
    WITH NUMERIC RemainingWYReleaseVolume = AnnualVolume - VolumeReleasedPreRun DO
     WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( AnnualVolume ) DO
      WITH NUMERIC LowerColumnBound = "FindReleaseLowerBoundColumn"( AnnualVolume, UpperColumnBound ) DO
       WITH LIST RemainingMonthlyReleases = IF ( EqualizationbyAprAdjust )
       THEN
        "CalculatePowellUEBToEqualizePowellMonRel"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYReleaseVolume )
       ELSE
        "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYReleaseVolume )
       ENDIF DO
        IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" )
        THEN
         WITH NUMERIC MonthlyReleaseSum = FOR ( LIST monthlyReleaseVol IN RemainingMonthlyReleases ) STAT_SUM
          "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
         ENDFOR DO
          WITH NUMERIC Tolerance = 5.00000000 "acre-feet" DO
           WITH NUMERIC VolumeDifference = RemainingWYReleaseVolume - MonthlyReleaseSum DO
            IF ( "Abs"( VolumeDifference ) < Tolerance )
            THEN
             RemainingMonthlyReleases
            ELSE
             WITH NUMERIC MonthlyVolumeAdjustment = VolumeDifference / LENGTH RemainingMonthlyReleases DO
              WITH LIST AdjustedMonthlyReleases = FOR ( LIST subRelList IN RemainingMonthlyReleases ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
               WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - MonthlyVolumeAdjustment DO
                 ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( MonthlyVolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
                ENDWITH
               ENDWITH
              ENDFOR DO
               REMOVE ITEM @INDEX 0.00000000 FROM AdjustedMonthlyReleases
              ENDWITH
             ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170607: Why not adjust porportionately to monthly releases?<br>"
            ENDIF
           ENDWITH
          ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
         ENDWITH COMMENTED_BY "Calculate total remaining releases from RemainingMonthlyReleases"
        ELSE
         RemainingMonthlyReleases
        ENDIF
       ENDWITH COMMENTED_BY "Calculate list of the form &lcub;Month, Adjusted monthly release rate, Remaining volume above lower bound column&rcub;"
      ENDWITH COMMENTED_BY "Detemine index of first column in monthly release table with total annual volume <= annualVolume<br>(Same as UpperColumnBound if annualVolume is equal to a column total)"
     ENDWITH COMMENTED_BY "Calculate index of first column in monthly release table with total annual volume >= annualVolume"
    ENDWITH
   ENDWITH COMMENTED_BY "Determine volume released prior to model run start"
  ENDWITH
 ENDWITH COMMENTED_BY "Retrieve TargetAnnualReleaseVolume for water year containing datesToEOWY<0>";

    END
    UUID "{bab7bcd2-87ea-481f-b79a-33793faaf46a}";;

    FUNCTION       "GetPowellMonthlyReleases_v2" ( LIST datesToEOWY, NUMERIC TargetAnnualReleaseVolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume calculates each month's release.  If the set of dates passed to the function is the first water year in the run (i.e., begins with the run's start timestep), then, if necessary, this function will make an adjustment to the calculated releases to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List with members of the form &lcub;date, release&rcub; where date is a member of the list of dates passed to the function<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates within the model run period<br>2. NUMERIC TotalVolumeToRelease - the total volume of water to be released during a water year<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 20110325<br><br>MC, 20160728: This version of the function takes a second argument, TotalVolumeToRelease, instead of using an annual volume calculated by the user-defined function CurrentAnnualVolume; it was originally created for use in handling carryover years";
    BEGIN

      WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( TargetAnnualReleaseVolume ) DO
  WITH NUMERIC LowerColumnBound = "FindReleaseLowerBoundColumn"( TargetAnnualReleaseVolume, UpperColumnBound ) DO
   WITH NUMERIC VolumeReleasedPreRun = IF ( "GetMonthAsString"( ( GET @INDEX 0.00000000 FROM datesToEOWY ) ) == "October" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, 1.00000000, "-1 months" ) )
   ENDIF DO
    WITH NUMERIC CarryoverReleasedPreRun = "Min"( VolumeReleasedPreRun, $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] ) DO
     WITH NUMERIC TARVReleasedPreRun = VolumeReleasedPreRun - CarryoverReleasedPreRun DO
      WITH NUMERIC TARVRemaining = TargetAnnualReleaseVolume - TARVReleasedPreRun DO
       WITH LIST RemainingMonthlyReleases = "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, TARVRemaining ) DO
        IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" )
        THEN
         WITH NUMERIC SumRemainingReleases = FOR ( LIST monthlyReleaseVol IN RemainingMonthlyReleases ) STAT_SUM
          "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
         ENDFOR DO
          WITH NUMERIC VolumeDifference = TARVRemaining - SumRemainingReleases DO
           WITH NUMERIC Tolerance = 5.00000000 "acre-feet" DO
            IF ( "Abs"( VolumeDifference ) < Tolerance )
            THEN
             RemainingMonthlyReleases
            ELSE
             WITH NUMERIC MonthlyVolumeAdjustment = VolumeDifference / LENGTH RemainingMonthlyReleases DO
              WITH LIST AdjustedMonthlyReleases = FOR ( LIST subRelList IN RemainingMonthlyReleases ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
               WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - MonthlyVolumeAdjustment DO
                 ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( MonthlyVolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
                ENDWITH
               ENDWITH
              ENDFOR DO
               REMOVE ITEM @INDEX 0.00000000 FROM AdjustedMonthlyReleases
              ENDWITH
             ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170607: Why not distribute the difference proportionately to releases?"
            ENDIF
           ENDWITH
          ENDWITH
         ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
        ELSE
         RemainingMonthlyReleases
        ENDIF
       ENDWITH COMMENTED_BY "Calculate list of the form &lcub;Month, Monthly release rate, Remaining volume above lower bound column&rcub;"
      ENDWITH COMMENTED_BY "Calculate annual volume that remains to be released"
     ENDWITH COMMENTED_BY "Calculate annual volume previously released "
    ENDWITH COMMENTED_BY "Calculate carryover volume previously released"
   ENDWITH COMMENTED_BY "Calculate total volume previously released"
  ENDWITH
 ENDWITH COMMENTED_BY "Find upper and lower bound columns for annual release";

    END
    UUID "{e216fafe-b67f-4ec5-800a-43bc820a374f}";;

    FUNCTION       "GetPowellMonthlyReleases" ( LIST datesToEOWY )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume calculates each month's release.  If the set of dates passed to the function is the first water year in the run (i.e., begins with the run's start timestep), then, if necessary, this function will make an adjustment to the calculated releases to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List with members of the form &lcub;date, release, remaining volume&rcub; where date is a member of the list of dates passed to the function<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates within the model run period<br>2. NUMERIC TotalVolumeToRelease - the total volume of water to be released during a water year<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 20110325<br><br>MC, 20160728: This version of the function takes a second argument, TotalVolumeToRelease, instead of using an annual volume calculated by the user-defined function CurrentAnnualVolume; it was originally created for use in handling carryover years<br><br>MC, 20171024: Tried to combine all functions that develop release schedules into a single one here. Old version renamed GetPowellMonthlyReleases_pre20171024; this version finds bounding release schedule columns based on remaining volume, which Paul D. previously indicated should be okay<br><br>S.Baker, 2018/10/17: <br>(1) 'AnnualCarryoverVolume' - Function needs to know the carryover volume no matter the equalization tier. <br>(2) 'RemainingMonthlyReleases' - The ?CalculatePowellUEBToEqualizePowellMonRel? function uses ?Powell.Peak Flow? which isn?t solved for until Powell has successfully dispatched. Therefore, the statement setting the ?RemainingMonthlyRelease? checks to see of Powell.Outflow is NaN. This normally occurs when the TARV is initially set to 8.23 MAF. Once Powell resets the TARV, the function will re-execute and will enter the function ?CalculatePowellUEBToEqualizePowellMonRel? if Powell is equalizing with an April adjustment. <br>(3) IF statement for ?RemainingMonthlyReleases? - A new conditions was added to ensure the model didn?t enter this part of the function unless it was not an April Adjustment. Originally, the model would solve for carryover, but would spread the carryover out by spilling water out of Powell in this part of the function. <br><br>S.Baker, 2018/11/26: subracted VolumeReleasedPreRun from TARV in the calculation of RemaininWYRelease.";
    BEGIN

      WITH DATETIME WaterYear = "Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) ) DO
  WITH BOOLEAN EqualizationbyAprAdjust = IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" [WaterYear] ) == 1.30000000 )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF DO
   WITH NUMERIC VolumeReleasedPreRun = IF ( "GetMonthAsString"( ( GET @INDEX 0.00000000 FROM datesToEOWY ) ) == "October" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, 1.00000000, "-1 months" ) )
   ENDIF DO
    WITH NUMERIC TargetAnnualVolume = $ "PowellData.TargetAnnualReleaseVolume" [WaterYear] DO
     WITH NUMERIC AnnualCarryoverVolume = NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [WaterYear] ) DO
      WITH LIST TARVVolReleases = WITH NUMERIC RemainingWYRelease = IF ( VolumeReleasedPreRun >= AnnualCarryoverVolume )
      THEN
       TargetAnnualVolume + AnnualCarryoverVolume - VolumeReleasedPreRun
      ELSE
       TargetAnnualVolume - VolumeReleasedPreRun
      ENDIF COMMENTED_BY "If carryover still needs to be released, use TARV. Carryover will <br>be added in the CalculateCarryoverReleases function.  <br>" DO
       WITH NUMERIC UpperColumnBound = "FindRemainingReleaseUpperBoundColumn"( RemainingWYRelease, datesToEOWY ) COMMENTED_BY "If the dates end with a water year end, use remaining release to determine column bound<br>If run ends in Dec, using remaining release function leads to all annual volume being released in <br>Oct, Nov, Dec  <br>" DO
        WITH NUMERIC LowerColumnBound = "FindRemainingReleaseLowerBoundColumn"( RemainingWYRelease, datesToEOWY, UpperColumnBound ) DO
         WITH LIST RemainingMonthlyReleases = IF ( EqualizationbyAprAdjust AND NOT IsNaN $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM datesToEOWY] )
         THEN
          "CalculatePowellUEBToEqualizePowellMonRel"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYRelease )
         ELSE
          "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYRelease )
         ENDIF COMMENTED_BY "List of lists of form: &lcub;Date, Release, Remaining Volume&rcub; <br>" DO
          IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" AND NOT EqualizationbyAprAdjust )
          THEN
           WITH NUMERIC SumRemainingReleases = FOR ( LIST monthlyReleaseVol IN RemainingMonthlyReleases ) STAT_SUM
            "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
           ENDFOR DO
            WITH NUMERIC VolumeDifference = RemainingWYRelease - SumRemainingReleases DO
             WITH NUMERIC Tolerance = 5.00000000 "acre-feet" DO
              IF ( "Abs"( VolumeDifference ) < Tolerance )
              THEN
               RemainingMonthlyReleases
              ELSE
               WITH NUMERIC MonthlyVolumeAdjustment = VolumeDifference / LENGTH RemainingMonthlyReleases DO
                WITH LIST AdjustedMonthlyReleases = FOR ( LIST subRelList IN RemainingMonthlyReleases ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
                 WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                  WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - MonthlyVolumeAdjustment DO
                   ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( MonthlyVolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
                  ENDWITH
                 ENDWITH
                ENDFOR DO
                 REMOVE ITEM @INDEX 0.00000000 FROM AdjustedMonthlyReleases
                ENDWITH
               ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170607: Why not distribute the difference proportionately to releases?"
              ENDIF
             ENDWITH
            ENDWITH
           ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
          ELSE
           RemainingMonthlyReleases
          ENDIF
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH DO
       IF ( ( VolumeReleasedPreRun >= AnnualCarryoverVolume ) OR IF ( IsNaN $ "PowellData.ReleaseVolumeSetFlag" [WaterYear] )
       THEN
        ( LENGTH datesToEOWY ) < 11.00000000 AND IsNaN $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM datesToEOWY]
       ELSE
        ( $ "PowellData.ReleaseVolumeSetFlag" [WaterYear] == 0.00000000 )
       ENDIF COMMENTED_BY "Carryover will not be added until annual release volume is finalized <br>" )
       THEN
        TARVVolReleases COMMENTED_BY "Schedule remaining volume normally <br>"
       ELSE
        "CalculateCarryoverReleases"( datesToEOWY, AnnualCarryoverVolume, TARVVolReleases ) COMMENTED_BY "Add the Carryover that was created in the previous year to the schedule that is passed into the <br>function, &quot;TARVVolReleases&quot; <br>"
       ENDIF
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{54e8e1fd-8449-40e7-8454-d97f29e0be3b}";;

    FUNCTION       "CalculateCarryoverReleases" ( LIST datesToEOWY, NUMERIC InitialCarryoverVolume, LIST TARVVolReleases )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the maximum powerplant capacity release for the case when there is remaining carryover volume between Powell and Mead from one water year to the next. It assumes the monthly releases for the remainder of the year based on the annual release volume have already been calculated<br><br>RETURNS: List of the form &lcub;Date, Release, Carryover Remaining&rcub;. The third (CarryoverRemaining) element in the list are needed internally by the function to track which water is being released through the loop.<br><br>ARGUMENTS: <br>1. LIST datesToEOWY, a list of the months remaining in the current water year<br>2. NUMERIC InitialCarryoverVolume, the carryover volume remaining that was not released prior to the start date of the current model run<br>3. LIST TARVVolReleases, a list of outflows that should sum to the current setting of the TARV.  <br><br>CONSTRAINTS:<br><br> <br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20160711<br>MC, 20160711: The GetMaxReleaseGivenInflow predefined function for future months is dependent on the operating head from pool elevation, which will not be strictly accurate because each month's value is calculated from the previously set typical outflow<br>MC, 20170503: Rewrote function using initial element of list, which allowed condensing code by removing separate sections for first element of list and subsequent elements<br>TP, 2017 11/16/2017: The function needs to know the current setting of the TARV in order to release on top of what needs to be released for the WY.  The function now estimates an upated Pool Elevation and Power Plant Capacity within the function.";
    BEGIN

      WITH DATETIME InitialDate = "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 months" ) DO
  WITH LIST sortedTARVRel = "Sort"( TARVVolReleases ) DO
   WITH NUMERIC TargetAnnualReleaseVolume = $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] DO
    WITH LIST ListWithInit = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = { { InitialDate , "null" , InitialCarryoverVolume , $ "Powell.Pool Elevation" ["OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 Months" )] } } COMMENTED_BY "Build the beginning structure of the list that contains the month prior to when the releases will be <br>start, in an out year, this date will be September of the previous Water Year. Then a &quot;null&quot; value <br>where the outflow that will be calculated will be entered in subsequent sub lists, the initial <br>carryover volume that is to be released (ideally, this will be reduced throughout the construction <br>of the loop), and the initial pool elevation that will help simulate Powell.  <br>" DO
     WITH NUMERIC index = ( FIND date WITHIN datesToEOWY ) + 1.00000000 DO
      WITH NUMERIC TARVOut = ( GET @INDEX 1.00000000 FROM GET @INDEX index - 1.00000000 FROM sortedTARVRel ) COMMENTED_BY "Get the current release, for the current iteration <br>" DO
       WITH NUMERIC PreviousCarryoverRemaining = ( GET @INDEX 2.00000000 FROM GET @INDEX index - 1.00000000 FROM result ) COMMENTED_BY "Get the current carryover volume that still needs to be released <br>" DO
        WITH NUMERIC PreviousResultPE = ( GET @INDEX 3.00000000 FROM GET @INDEX index - 1.00000000 FROM result ) COMMENTED_BY "Get the Previous Pool Elevation, as the loop grows, the simulated Pool Elevation from the <br>previous iteration will be used here. <br>" DO
         WITH NUMERIC Qmax = $ "Powell.Peak Flow" [date] COMMENTED_BY "Use the current Peak Flow value, this value will change as new outflows are set, but as iterations <br>occur with the structure of this logic, this method works. If it is found that the Peak Release is <br>not correct, a different determination of potential Power Plant Capacity should be entered here.  <br>" DO
          WITH NUMERIC Release = "Min"( Qmax, "VolumeToFlow"( PreviousCarryoverRemaining, date ) + TARVOut ) COMMENTED_BY "Determine the new release for the month <br>" DO
           WITH NUMERIC CarryoverRemaining = IF ( ( LENGTH result ) == LENGTH TARVVolReleases )
           THEN
            "Max"( PreviousCarryoverRemaining - "FlowToVolume"( Release - TARVOut, date ), 0.00000000 "acre-ft" ) + GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH TARVVolReleases ) - 1.00000000 FROM TARVVolReleases
           ELSE
            "Max"( PreviousCarryoverRemaining - "FlowToVolume"( Release - TARVOut, date ), 0.00000000 "acre-ft" )
           ENDIF DO
            WITH NUMERIC TempPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [date], date ) - "FlowToVolume"( Release, date ) - NaNToZero ( $ "Powell.Change in Bank Storage" [date] ) ) DO
             WITH NUMERIC NewPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [date], date ) - "PowellEvapEstimation"( date, PreviousResultPE, TempPE ) - "FlowToVolume"( Release, date ) - NaNToZero ( $ "Powell.Change in Bank Storage" [date] ) ) COMMENTED_BY "Determine the new Pool Elevation with the estimated Powell Evaporation <br>" DO
              APPEND { date , Release , CarryoverRemaining , NewPE * "DebuggerStop"(  ) } ONTO result
             ENDWITH
            ENDWITH COMMENTED_BY "Estimate the new Pool Eleavtion without Evaporation, which is necessary to determine the <br>Evaporation estimate in the next function.  <br>"
           ENDWITH COMMENTED_BY "Determine if Carryover was all released or if some is still needed to be released <br>"
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "Get the current index in the list that is being created <br>"
    ENDFOR DO
     WITH NUMERIC carryoverVol = ( GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH ListWithInit ) - 1.00000000 FROM ListWithInit ) DO
      WITH LIST getAllCarryoverOut = FOR ( LIST DRPEVol IN REMOVE ITEM @INDEX 0.00000000 FROM ListWithInit ) WITH LIST result = { { 1.00000000 , 1.00000000 , 1.00000000 , carryoverVol } } DO
       WITH NUMERIC maxFlow = $ "Powell.Peak Flow" [GET @INDEX 0.00000000 FROM DRPEVol] DO
        WITH NUMERIC DiffCurFlowandMaxFlow = IF ( "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) > 9.00000000 OR "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) < 4.00000000 )
        THEN
         0.00000000 "acre-ft/month"
        ELSE
         "Max"( maxFlow - GET @INDEX 1.00000000 FROM DRPEVol, 0.00000000 "acre-ft/month" )
        ENDIF DO
         WITH NUMERIC CarryoverLeftToRelease = ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) DO
          WITH NUMERIC ChangeInRelease = ( GET @INDEX 1.00000000 FROM DRPEVol ) + "Min"( "VolumeToFlow"( CarryoverLeftToRelease, GET @INDEX 0.00000000 FROM DRPEVol ), DiffCurFlowandMaxFlow ) DO
           WITH NUMERIC CarryoverLeft = CarryoverLeftToRelease - "Min"( CarryoverLeftToRelease, "FlowToVolume"( DiffCurFlowandMaxFlow, GET @INDEX 0.00000000 FROM DRPEVol ) ) DO
            APPEND { GET @INDEX 0.00000000 FROM DRPEVol , ChangeInRelease , GET @INDEX 3.00000000 FROM DRPEVol , CarryoverLeft * "DebuggerStop"(  ) } ONTO result
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDFOR DO
       WITH LIST DateFlowVol = FOR ( LIST DFV IN getAllCarryoverOut ) WITH LIST result = {  } DO
        APPEND { GET @INDEX 0.00000000 FROM DFV , GET @INDEX 1.00000000 FROM DFV , GET @INDEX 3.00000000 FROM DFV } ONTO result
       ENDFOR DO
        ( REMOVE ITEM @INDEX 0.00000000 FROM DateFlowVol )
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "Remove unneeded first element in list of lists"
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{021913fb-8e2b-46de-84a7-6bda7b717ac0}";;

    FUNCTION       "EqualizationReleaseWithCarryover" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: Created this function to account for the effects of carryover volume in the equalization calculation, which are not needed in the original EqualizationRelease function. If there is carryover volume for the water year, in order to calculate the correct annual volume to release, the calculation needs to 'virtually' move the carryover water from Powell to Mead<br><br>RETURNS: Powell release volume<br><br>ARGUMENTS:<br>1. DATETIME EOWYdate - the end of water year date used to specify the water year of interest<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20160801<br>";
    BEGIN

      ( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] + ( $ "Powell.Storage" [EOWYDate] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["OffsetDate"( "Dec31ofYear"( EOWYDate ), 12.00000000, "1 months" )] ) - ( $ "Mead.Storage" [EOWYDate] + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["OffsetDate"( "Dec31ofYear"( EOWYDate ), 12.00000000, "1 months" )] ) ) ) / ( 2.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) ) COMMENTED_BY "Add half of the storage difference that would be present if the carryover volume had been moved from Powell to Mead to the annual release volume";

    END
    UUID "{22d86c2e-089c-4dcd-9a1b-63f26ec5440b}";;

    FUNCTION       "GetWaterYearNumber" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the water year number (relative water year within the model run) of the water year containing the argument &quot;date&quot;<br><br>RETURNS: Numeric index of the water year<br><br>ARGUMENTS<br>1. DATETIME date<br><br>CONSTRAINTS:<br><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170209";
    BEGIN

      "GetYear"( date ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 AND "GetMonth"( date ) <= 9.00000000 )
 THEN
  0.00000000
 ELSE
  IF ( "GetMonth"( @"Start Timestep" ) <= 9.00000000 AND "GetMonth"( date ) > 9.00000000 )
  THEN
   2.00000000
  ELSE
   1.00000000
  ENDIF COMMENTED_BY "Start<Oct & date>=Oct, add 2"
 ENDIF COMMENTED_BY "If Start>= Oct & date<Oct, then difference in water years is the same as between <br>calendar years";

    END
    UUID "{1c0a64f4-b119-4610-bdae-8e581aa2cbc7}";;

    FUNCTION       "FindRemainingReleaseUpperBoundColumn" ( NUMERIC RemainingRelease, LIST datesToEOWY )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the column index for the column in PowellData.PowellMonthlyReleaseTable with the smallest capacity for the remainder of the water year that is greater than the remaining required water year release (Least Upper Bound).<br><br>RETURNS: Numeric index for column [No units]<br><br>ARGUMENTS: <br>1. NUMERIC RemainingRelease - volume of water remaining to be released in the water year of interest<br>2. LIST datesToEOWY - list of dates remaining in the water year of interest<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: MC, 20170627 (previously developed for Sarah Baker's research model)<br><br>MC, 20180116: Added second condition to IF statement regarding last element in datesToEOWY being equal to September. In the January run, the Finish Timestep is Dec resulting in the final outyear selecting a Powell release schedule that allowed the total annual volume to be released during Oct-Dec. Adding the condition allows that case to select the release schedule based on the annual volume, which results in an appropriate release schedule for Oct-Dec<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  IF ( ( LENGTH datesToEOWY ) < 3.00000000 OR "GetMonth"( GET @INDEX ( LENGTH datesToEOWY ) - 1.00000000 FROM datesToEOWY ) != 9.00000000 )
  THEN
   WHILE ( RemainingRelease - releaseTable ["AnnualTotal", result] > 0.01000000 "1000 acre-ft" ) WITH NUMERIC result = 0.00000000 DO
    result + 1.00000000
   ENDWHILE
  ELSE
   WHILE ( RemainingRelease - FOR ( DATETIME date IN ( GET @INDEX 0.00000000 FROM datesToEOWY ) TO GET @INDEX ( LENGTH datesToEOWY ) - 1.00000000 FROM datesToEOWY ) STAT_SUM
    releaseTable ["GetMonthAsString"( date ), result]
   ENDFOR > 1.00000000 "acre-feet" AND result < "NumColumns"( releaseTable ) ) WITH NUMERIC result = 1.00000000 DO
    result + 1.00000000
   ENDWHILE
  ENDIF
 ENDWITH COMMENTED_BY "If difference between remaining volume and remaining UB capacity > 1 acre-foot, increment UB column index";

    END
    UUID "{5ef9441d-d0a5-42f4-bedc-5fea0ffef920}";;

    FUNCTION       "FindRemainingReleaseLowerBoundColumn" ( NUMERIC RemainingRelease, LIST datesToEOWY, NUMERIC upperbound )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the column index for the column in PowellData.PowellMonthlyReleaseTable with the greatest capacity for the remainder of the water year that is less than the remaining required water year release (Greatest Lower Bound).<br><br>RETURNS: Numeric index for column [No units]<br><br>ARGUMENTS: <br>1. NUMERIC RemainingRelease - volume of water remaining to be released in the water year of interest<br>2. LIST datesToEOWY - list of dates remaining in the water year of interest<br>3. NUMERIC upperbound - the index of the previously-determined upper bound column<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170627 (previously developed for Sarah Baker's research model)<br><br>S.Baker, 20180620: Time constraint on release table added to allow hindcast runs.";
    BEGIN

      WITH SLOT releaseTable = IF ( "GetYear"( @"Start Timestep" ) >= 2017.00000000 )
 THEN
  $ "PowellData.PowellMonthlyReleaseTable"
 ELSE
  $ "PowellData.PowellMonthlyReleaseTable_preJan2017"
 ENDIF DO
  WITH NUMERIC UBSum = FOR ( DATETIME date IN ( GET @INDEX 0.00000000 FROM datesToEOWY ) TO GET @INDEX ( LENGTH datesToEOWY ) - 1.00000000 FROM datesToEOWY ) STAT_SUM
   releaseTable ["GetMonthAsString"( date ), upperbound]
  ENDFOR DO
   IF ( ( UBSum - RemainingRelease < 1.00000000 "acre-feet" ) OR ( upperbound == 1.00000000 "acre-feet" ) COMMENTED_BY "Upper bound is first populated column <br>" )
   THEN
    upperbound
   ELSE
    upperbound - 1.00000000
   ENDIF
  ENDWITH
 ENDWITH COMMENTED_BY "If the remaining release volume is within 1 acre-foot of the previously determined upper bound sum, use it as <br>the lower bound also; otherwise, decrease the lower bound index";

    END
    UUID "{069ee7fb-5d26-462a-8b96-91fc757d936c}";;

    FUNCTION       "ReleaseAdjustment" ( NUMERIC VolumeDeviation, DATETIME EOWY )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the adjustment to the Powell release required to meet the condition specified by the ControllingEqualizationCondition, incorporating Mead and Powell bank storage estimates where necessary.<br><br>RETURNS: Adjustment to the Powell release necessary to correct the VolumeDeviation [L^3]<br><br>ARGUMENTS:<br>1. VolumeDeviation - the volume by which Powell and/or Mead deviate from their respective storages that would satisfy the controlling condition<br>2. EOWY - the end of water year date for the water year under consideration<br><br>CONSTRAINTS: NONE";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: MC, 201801";
    BEGIN

      IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.10000000 )
 THEN
  VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] )
 ELSE
  IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.20000000 OR NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.30000000 )
  THEN
   VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] )
  ELSE
   IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.40000000 )
   THEN
    VolumeDeviation / ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] )
   ELSE
    IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.50000000 )
    THEN
     VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] )
    ELSE
     IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWY )] ) == 1.27000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWY )] ) == 1.29000000 )
     THEN
      IF ( VolumeDeviation < 0.00000000 "acre-feet" )
      THEN
       "Max"( $ "PowellData.UpperTierB2MinAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )], VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) )
      ELSE
       "Min"( VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ), $ "PowellData.UpperTierB2MaxAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )] )
      ENDIF
     ELSE
      IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWY )] ) == 1.40000000 )
      THEN
       "Min"( "Max"( $ "PowellData.UpperTierB4MinAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )], VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) ), $ "PowellData.UpperTierB4MaxAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )] )
      ELSE
       0.00000000 "acre-ft"
      ENDIF
     ENDIF COMMENTED_BY "If refining a UEB volume, have to restrict adjustment to keep total annual release within allowable bounds   <br>"
    ENDIF COMMENTED_BY "Fourth possible condition is that Powell elevation needs to be at 20ft below the equalization level by the end-of-water-year"
   ENDIF COMMENTED_BY "Third possible condition is that Mead needs to be at elevation 1105 ft by the end-of-water-year"
  ENDIF COMMENTED_BY "Second possible condition is that the end-of-water-year storages need to be equal between Powell and Mead."
 ENDIF;

    END
    UUID "{c5193736-68cb-48c8-b8a8-8b51289afaa4}";;

    FUNCTION       "GetMeadProjectedPoolElevation" ( DATETIME MeadProjectionDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines which Mead pool elevation projection to use based on the start timestep and MeadProjectionDate. If start timestep is Jan-July, use only previous years' AugEOYMeadPEProjection. If Aug-Dec, use the previous and current year's AugEOYMeadPEProjection.<br><br>RETURNS: Pool elevation value from either the Aug 24MS projection or from MTOM's projection<br><br>ARGUMENTS:<br>1. DATETIME MeadProjectionDate - the EOCY date which Mead pool elevation is desired<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "Author, Date: SB, 20180917";
    BEGIN

      IF ( IF ( "GetMonth"( @"Start Timestep" ) < "GetMonth"( @"August" ) )
 THEN
  MeadProjectionDate == "Dec31ofYear"( @"Start Timestep" - 1.00000000 "year" )
 ELSE
  MeadProjectionDate == "Dec31ofYear"( @"Start Timestep" ) OR MeadProjectionDate == "Dec31ofYear"( @"Start Timestep" - 1.00000000 "year" )
 ENDIF )
 THEN
  $ "PowellToMeadData.AugEOYMeadPEProjection" [MeadProjectionDate]
 ELSE
  $ "Mead.Pool Elevation" [MeadProjectionDate]
 ENDIF COMMENTED_BY "Look at the Start Timestep to determine which Mead PE projection to use <br>";

    END
    UUID "{7a8bd6b0-635f-4559-94ec-4ae1684707c6}";;

    FUNCTION       "GetProjectedPoolElevation" ( STRING Reservoir, DATETIME ProjectionDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines which Mead or Powell pool elevation projection to use based on the start timestep and ProjectionDate. If start timestep is Jan-July, use only previous years' AugEOYPEProjection. If Aug-Dec, use the previous and current year's AugEOYPEProjection.<br><br>RETURNS: Pool elevation value from either the Aug 24MS projection or from MTOM's projection<br><br>ARGUMENTS:<br>1. STRING Reservoir - &quot;Powell&quot; or &quot;Mead&quot; the reservoir pool elevation is desired<br>2. DATETIME ProjectionDate - the EOCY date which pool elevation is desired<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "Author, Date: SB, 20180917";
    BEGIN

      IF ( IF ( "GetMonth"( @"Start Timestep" ) < "GetMonth"( @"August" ) )
 THEN
  ProjectionDate == "Dec31ofYear"( @"Start Timestep" - 1.00000000 "year" )
 ELSE
  ProjectionDate == "Dec31ofYear"( @"Start Timestep" ) OR ProjectionDate == "Dec31ofYear"( @"Start Timestep" - 1.00000000 "year" )
 ENDIF )
 THEN
  "GetSlot"( "PowellToMeadData.AugEOY" CONCAT Reservoir CONCAT "PEProjection" ) [ProjectionDate]
 ELSE
  "GetSlot"( Reservoir CONCAT ".Pool Elevation" ) [ProjectionDate]
 ENDIF COMMENTED_BY "Look at the Start Timestep to determine which PE projection to use  <br>";

    END
    UUID "{080db095-e752-440c-a59f-1a860c152bb4}";;

  END
  UUID "{267a21f3-36f2-4491-b419-b55c628ab94c}";;

  UTILITY_GROUP "Powell Steady Flow Experiment Functions";
  DESCRIPTION   "";
  ACTIVE        FALSE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetSeptemberSteadyFlowRelease" ( NUMERIC AnnualReleaseVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "PowellData.SteadyFlowExperimentRelease" ["SteadyFlowTableRow"( AnnualReleaseVolume ), 1.00000000];

    END
    UUID "{4994050c-ecae-4e0a-9116-0866a2abe1ff}";;

    FUNCTION       "GetOctoberSteadyFlowRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns the october release volume of the current water year under steady flow experiment conditions. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "MonthIs"( { "October" , "November" , "December" } ) )
 THEN
  $ "Powell.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"]
 ELSE
  $ "Powell.Outflow" [@"24:00:00 September Max DayOfMonth, Previous Year"]
 ENDIF;

    END
    UUID "{488b3c34-c78d-447c-aa97-b512ef5a0f04}";;

    FUNCTION       "GetInitialPowellMonthlyVolumes" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function is invalide due to function input GetSeptemberSteadFlowRelease()";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      APPEND "FlowToVolume"( "GetSeptemberSteadyFlowRelease"( $ "PowellData.TargetAnnualReleaseVolume" [] ), @"24:00:00 September Max DayOfMonth, Current Year" ) ONTO INSERT "FlowToVolume"( "GetOctoberSteadyFlowRelease"(  ), @"24:00:00 October Max DayOfMonth, Current Year" ) INTO FOR ( NUMERIC i IN "GetNumbers"( 2.00000000, 11.00000000, 1.00000000 ) ) WITH LIST result = {  } DO
  APPEND "Interpolate"( "CurrentAnnualVolume"( @"t" ), $ "PowellData.PowellMonthlyReleaseTable" [0.00000000, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) )], $ "PowellData.PowellMonthlyReleaseTable" [0.00000000, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) ) + 1.00000000], $ "PowellData.PowellMonthlyReleaseTable" [i, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) )], $ "PowellData.PowellMonthlyReleaseTable" [i, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) ) + 1.00000000] ) ONTO result
 ENDFOR;

    END
    UUID "{38636fd6-f1b2-479e-996e-8942f8ada50c}";;

    FUNCTION       "SteadyFlowTableRow" ( NUMERIC AnnualReleaseVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WHILE ( AnnualReleaseVolume >= $ "PowellData.SteadyFlowExperimentRelease" [i, 0.00000000] ) WITH NUMERIC i = 0.00000000 DO
  i + 1.00000000
 ENDWHILE;

    END
    UUID "{bc254638-8834-4b52-adbb-36d7e5c93071}";;

    FUNCTION       "SteadyFlowReduce_1_July" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  IF ( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] >= 0.00000000 "acre-ft" )
  THEN
   "Min"( "GetElement"( monthlyRelease, 2.00000000 ) - 800.00000000 "1000 acre-ft", "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] ) COMMENTED_BY "Return either the amount of reduction in july down to 800 kaf <br>or the total reduction (if it all occurs in July)"
  ELSE
   "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" []
  ENDIF COMMENTED_BY "If the monthly releases exceed the annual release volume, then decrease july first"
 ENDWITH;

    END
    UUID "{ae62f1ac-a1ea-451f-b621-df30a580306c}";;

    FUNCTION       "SteadyFlowReduce_2_August" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 1.00000000 ) COMMENTED_BY "1 in reverse order is august" - 800.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in August down to 800 kaf <br>or the total reduction (if it all occurs in August)"
 ENDWITH;

    END
    UUID "{8c8bec06-a173-486b-8ca9-925a6086971c}";;

    FUNCTION       "SteadyFlowReduce_3_June1" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 3.00000000 ) - 800.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 800 kaf <br>or the total reduction (if it all occurs in June), In both cases negatives <br>can occur, so zero these out "
 ENDWITH;

    END
    UUID "{4b972d2b-f2f1-4aff-90a1-1703d94933e6}";;

    FUNCTION       "SteadyFlowReduce_4_June2" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 3.00000000 ) COMMENTED_BY "3 in reverse order is june" - 600.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 600 kaf <br>or the total reduction (if it all occurs in June)"
 ENDWITH;

    END
    UUID "{f782029f-8998-422d-bcf9-52ad52e24aad}";;

    FUNCTION       "SteadyFlowReduce_5_April" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 5.00000000 ) COMMENTED_BY "5 in reverse order is april" - 500.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ) - "SteadyFlowReduce_4_June2"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in April down to 500 kaf<br>or the total reduction (if it all occurs in June)"
 ENDWITH;

    END
    UUID "{27e62804-9b38-44f9-aa69-77a89b45c073}";;

    FUNCTION       "SteadyFlowReduce_6_May" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 4.00000000 ) COMMENTED_BY "4 in reverse order is may" - 500.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ) - "SteadyFlowReduce_4_June2"(  ) - "SteadyFlowReduce_5_April"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 600 kaf <br>or the total reduction (if it all occurs in June)"
 ENDWITH;

    END
    UUID "{9b51a539-9b3a-43a6-9fb3-5f5d948e6398}";;

    FUNCTION       "DepletionToDiversionRatio" ( STRING depletionSlot, STRING diversionSlot, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( depletionSlot [date] == 0.00000000 "cms" )
 THEN
  0.00000000
 ELSE
  diversionSlot [date] / depletionSlot [date]
 ENDIF;

    END
    UUID "{eedbc123-91eb-4933-b188-38702f653964}";;

    FUNCTION       "SubbasinShortage" ( STRING subbasin, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( OBJECT obj IN "ListSubbasin"( subbasin ) SET_INTERSECTION ( "ListSubbasin"( "AggDiversionSite" ) COMMENTED_BY "Can eliminate after bug 4914 is fixed.  Have to do this now because we are <br>expecting only aggregate diversion sites not individual water users" ) ) WITH NUMERIC totalShortage = 0.00000000 "acre-ft" DO
  FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC userShortage = 0.00000000 "acre-ft" DO
   userShortage + ( "FlowToVolume"( % "SanJuanNewMexicoDiversionSchedules" & ( ( STRINGIFY obj ) CONCAT "_" CONCAT "Depletion" ) [date], date ) - "FlowToVolume"( obj & "Total Depletion Requested" [date], date ) ) COMMENTED_BY "Subtract off depletion requested because this slot <br>has already been reduced by the WSA rule"
  ENDFOR + totalShortage
 ENDFOR;

    END
    UUID "{569b9fcf-44da-4528-9547-d02032e6aa9b}";;

  END
  UUID "{cb59d52f-1f58-4997-b3b0-06ccd064bf4a}";;

  UTILITY_GROUP "NavajoFunctions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "DebugDailyNavajoFunction" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is used to debug the parent function, this should not have an impact on the result of the parent function and can be edited using the boolean function that allows this function to execute. <br><br>RETURN TYPE: Flow rate of 0.00 cfs<br><br>ARGUMENTS:<none><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/4/2015<br>";
    BEGIN

      0.00000000 "cfs";

    END
    UUID "{6191fdc1-aedd-4259-a8b0-511ca94eb60e}";;

    FUNCTION       "DetermineNavajoEoWYReleaseLevel" ( DATETIME date )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: <br>This Function returns the value of the release level for the Navajo Release<br>0 = No Release<br>1 = Release of 114,000 AF<br>2 = Relase greater of 166,000 or SpillAF<br>3 = Release of > 344,000 AF to get the reservoir back to full<br><br>The policy is based on the decision Tree used by the Navajo Dam Operator and is within the Flow Recomendations For the San Juan River published by the San Juan River Basin Recovery Implementation Program *1999 <br><br>RETURNS: List of the form &lcub;Water required for EOWY target pool elevation, Release level, Nose level, Nose volume, Excess release&rcub;<br><br>ARGUMENTS<br>1. DATETIME date - date used to determine calendar year of release level<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170502: Unclear to me whether Navajo operates on water year or calendar year at this point; a date is passed into the function as an argument, but the current timestep @&quot;t&quot; is also used in the function";
    BEGIN

      WITH NUMERIC waterRqdForEOWYTPE = "Max"( IF ( @"t" == @"Start Timestep" )
 THEN
  IF ( "GetMonth"( @"t" ) <= 2.00000000 OR "GetMonth"( @"t" ) >= 10.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   "WaterToAchieveEOYTPE"( "GetWaterYearEndDate"( @"t" ) )
  ENDIF
 ELSE
  "WaterToAchieveEOYTPE"( "GetWaterYearEndDate"( @"t" ) ) COMMENTED_BY "If the timestep is not the start timestep, it has to be March"
 ENDIF, 0.00000000 "acre-ft" ) + IF ( $ "NavajoData.Add6050SPRToAvailWater" ["Dec31ofYear"( @"t" )] == 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "ElevationToStorage"( % "Navajo", 6063.00000000 ) - "ElevationToStorage"( % "Navajo", 6050.00000000 )
 ENDIF COMMENTED_BY "In the event that an additional Spring Peak Release of water available to 6,050 ft. on Navajo is <br>requested, the flag NavajoData.Add6050SPRToAvailWater = 1, then the volume of water <br>between 6,063 and 6,050 is added to the Spring Peak Release. The approximate volume of that <br>water is 160.87 KAF. TP 8/4/2014" DO
  WITH NUMERIC releaseLevel = IF ( "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( date ) ) )
  THEN
   $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( date )]
  ELSE
   FOR ( NUMERIC iter IN "GetNumbers"( 1.00000000, 4.00000000, 1.00000000 ) ) WITH NUMERIC result = 0.00000000 DO
    IF ( waterRqdForEOWYTPE >= $ "NavajoData.SpringPeakReleaseLevels" ["Volume", iter - 1.00000000] )
    THEN
     iter
    ELSE
     result
    ENDIF
   ENDFOR
  ENDIF DO
   WITH NUMERIC noseLevel = IF ( releaseLevel == 4.00000000 )
   THEN
    FOR ( NUMERIC iter IN "GetNumbers"( 0.00000000, 10.00000000, 1.00000000 ) ) WITH NUMERIC result = 0.00000000 DO
     IF ( waterRqdForEOWYTPE - $ "NavajoData.SpringPeakReleaseLevels" ["Volume", 3.00000000] >= $ "NavajoData.SpringNoseLevels" ["Volume", iter] )
     THEN
      iter
     ELSE
      result
     ENDIF
    ENDFOR
   ELSE
    0.00000000
   ENDIF DO
    WITH NUMERIC noseVolume = IF ( releaseLevel == 4.00000000 )
    THEN
     waterRqdForEOWYTPE - $ "NavajoData.SpringPeakReleaseLevels" ["Volume", 3.00000000]
    ELSE
     0.00000000 "acre-ft"
    ENDIF DO
     WITH NUMERIC excessOfRelease = IF ( releaseLevel == 4.00000000 )
     THEN
      noseVolume - $ "NavajoData.SpringNoseLevels" ["Volume", noseLevel]
     ELSE
      IF ( NOT releaseLevel == 0.00000000 )
      THEN
       "Max"( waterRqdForEOWYTPE - $ "NavajoData.SpringPeakReleaseLevels" ["Volume", releaseLevel - 1.00000000], 0.00000000 "acre-ft" )
      ELSE
       "Max"( "WaterToAchieveEOYTPE"( "GetWaterYearEndDate"( @"t" ) ), 0.00000000 "acre-ft" )
      ENDIF
     ENDIF DO
      { waterRqdForEOWYTPE , releaseLevel , noseLevel , noseVolume , excessOfRelease }
     ENDWITH
    ENDWITH COMMENTED_BY "Calculate nose volume"
   ENDWITH COMMENTED_BY "Calculate the nose level"
  ENDWITH COMMENTED_BY "Calculate the release level"
 ENDWITH COMMENTED_BY "Water required to reach EOWY target pool elevation";

    END
    UUID "{496bde67-ac15-427a-9bef-f1f0f4608aa5}";;

    FUNCTION       "DetermineNavajoMonthlyFlowVolumeNew" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Sums flows for each month using the NavajoData.NavajoOuflowWithScale Slot.  These values will be returned as volume per month in Acre-ft and will become the Navajo.Outflow monthly values. <br><br>RETURNS: Monthly outflow as a sum of daily flows [L^3]<br><br>ARGUMENTS<br>1. DATETIME date - timestep date (end of month) specifying the month for which to calculate the outflow<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 8/7/2012";
    BEGIN

      "SumFlowsToVolume"( $ "NavajoData.MarchThruJulyDaily", "OffsetDate"( date, ( "GetDaysInMonth"( date ) / 1.00000000 "day" - 1.00000000 ) * - 1.00000000, "1 days" ), date );

    END
    UUID "{79e249a9-cc37-4d58-be6e-4c91191c552a}";;

    FUNCTION       "DailyOutflowsForNavajo" ( DATETIME date, NUMERIC releaseLevel, NUMERIC noseLevel, NUMERIC excessOfRelease )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is called by the rule &quot;March through July Daily Release&quot; to calculate the daily release value from Navajo based on the date, release and nose levels for the year, and excess water available<br><br>RETURNS: Daily release rate<br><br>ARGUMENTS<br>1. DATETIME date - date on which to calculate the release rate<br>2. NUMERIC releaseLevel - annual release level for the reservoir<br>3. NUMERIC noseLevel - annual nose level for the reservoir<br>4. NUMERIC excessOfRelease - excess water available over base flow<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC peakReleaseValue = $ "NavajoData.SpringPeakReleaseByLevel" [date, releaseLevel] DO
  WITH NUMERIC noseReleaseValue = $ "NavajoData.SpringPeakNoseByLevel" [date, noseLevel] DO
   WITH NUMERIC peakAndNoseValue = peakReleaseValue + noseReleaseValue DO
    WITH LIST baseFlowDate = { 0.00000000 "day" , 6.00000000 "day" , 9.00000000 "day" , 13.00000000 "day" , 25.00000000 "day" } DO
     WITH NUMERIC baseFlowDays = "GetDayOfYear"( @"24:00:00 October 1, Current Year" ) - ( 155.00000000 "day" + GET @INDEX releaseLevel FROM baseFlowDate ) DO
      WITH NUMERIC baseFlowChange = excessOfRelease / baseFlowDays DO
       WITH NUMERIC flowValue = IF ( peakAndNoseValue > 0.00000000 "cfs" )
       THEN
        peakAndNoseValue
       ELSE
        IF ( "GetDayOfYear"( date ) < 155.00000000 "day" OR date > @"24:00:00 September 30, Current Year" )
        THEN
         $ "NavajoData.BaseRelease" []
        ELSE
         "Max"( $ "NavajoData.BaseRelease" [] + baseFlowChange, $ "NavajoData.BaseRelease" [] ) COMMENTED_BY "Release at least base flow, but more if available"
        ENDIF COMMENTED_BY "Release base flow prior to June 5 (June 4 in leap year) and after September 30"
       ENDIF DO
        flowValue + IF ( date > @"24:00:00 June 28, Current Year" )
        THEN
         "DebugDailyNavajoFunction"(  )
        ELSE
         0.00000000 "cfs"
        ENDIF
       ENDWITH
      ENDWITH COMMENTED_BY "Calculate amount by which to change base flow"
     ENDWITH COMMENTED_BY "Calculate the number of days at base flow based on the release level"
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{6833eac2-71db-4234-83de-3985ef3163c4}";;

    FUNCTION       "DetermineLowFlowsatNavajo" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: If the spring peak operations cause Navajo to go below 5,990 ft. determine the shortage sharing reduction in outflow and NIIP Diversion to keep Navajo from going below 5,990 ft.  5,990 ft is elevation for which NIIP can no longer divert water from Navajo Reservoir.<br><br>RETURN TYPE: List of lists of the form &lcub;Date, Navajo outflow, Navajo diversion&rcub;<br><br>ARGUMENTS: <none><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH DATETIME EndDate = "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12", @"Finish Timestep" ) DO
  FOR ( DATETIME date IN "GetDates"( @"t", EndDate, "1 months" ) ) WITH LIST result = {  } DO
   WITH LIST DateAndDiffStor = FOR ( DATETIME dateb IN "GetDates"( @"t", EndDate, "1 months" ) ) WITH LIST DateAndDiffStor = {  } DO
    APPEND { dateb , "Max"( "ElevationToStorage"( % "Navajo", $ "NavajoData.MinDesiredPoolElevation" [] ) - $ "Navajo.Storage" [dateb], 0.00000000 "acre-ft" ) } ONTO DateAndDiffStor
   ENDFOR DO
    WITH LIST DiffList = MAPLIST ( LIST DiffListCheck IN DateAndDiffStor ) DO
     GET @INDEX 1.00000000 FROM DiffListCheck
    ENDMAPLIST DO
     WITH NUMERIC MaxDiff = "MaxItem"( DiffList ) DO
      WITH NUMERIC MaxIndex = FIND MaxDiff WITHIN DiffList DO
       WITH NUMERIC MaxDiffWithEvap = MaxDiff + "SumSlot"( $ "Navajo.Evaporation", @"t", EndDate ) DO
        WITH LIST MaxDateLists = GET @INDEX MaxIndex FROM DateAndDiffStor DO
         WITH DATETIME MaxDate = "DateMin"( GET @INDEX 0.00000000 FROM MaxDateLists, @"Finish Timestep" ) DO
          WITH NUMERIC SummedOutflowValuesFromNavajo = "SumFlowsToVolume"( $ "Navajo.Outflow", @"t", MaxDate ) DO
           WITH NUMERIC SummedNIIPDiversions = "SumFlowsToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Depletion Requested", @"t", MaxDate ) DO
            WITH NUMERIC ReductionFactor = "Max"( ( SummedOutflowValuesFromNavajo + SummedNIIPDiversions - MaxDiffWithEvap ) / ( SummedOutflowValuesFromNavajo + SummedNIIPDiversions ), 0.00000000 ) DO
             IF ( date > MaxDate )
             THEN
              ( APPEND { date , $ "Navajo.Outflow" [date] , $ "Navajo.Diversion" [date] } ONTO result ) COMMENTED_BY "No reduction necessary"
             ELSE
              ( APPEND { date , "Max"( $ "Navajo.Outflow" [date] * ReductionFactor, "Min"( $ "NavajoData.MinimumOutflow" [], $ "Navajo.Inflow" [] ) ) , "Max"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [date] * ReductionFactor, 0.00000000 "cfs" ) } ONTO result ) COMMENTED_BY "Reduced outflows and diversions"
             ENDIF COMMENTED_BY "Append appropriate result to list"
            ENDWITH COMMENTED_BY "Calculate factor by which to reduce outflows and diversions"
           ENDWITH COMMENTED_BY "Calculate cumulative NIIP diversions"
          ENDWITH COMMENTED_BY "Calculate cumulative outflows"
         ENDWITH COMMENTED_BY "Find the earlier of MaxDate or the end of the model run"
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "Remove the dates from the prior list of lists and just keep the shortage values"
   ENDWITH COMMENTED_BY "Create list of lists with the form &lcub;Date, Storage shortage on the date&rcub;"
  ENDFOR
 ENDWITH COMMENTED_BY "Loop through dates between current timestep and the earlier of the finish timestep or the end of February of the next year";

    END
    UUID "{5aeea7c1-b321-415a-b7f7-be2e5d80fe8c}";;

    FUNCTION       "EstimateEvaporationNavajo" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This Function estimates the evaporation from March to July for the available water calculation.  The evaporation is calculated based on the total inflow to the reservoir and  a release of only the base flow.  An error was occuring where the area volume table was limiting the solving of the reservoir because taking an inflow and releasing only the base flow can result in higher storage levels than the table implies.  So the Min function with the equation and the 1,976,849 acre-ft is used right now because 1,977,850.0000999999 acre-ft is the maximum storage in the area volume table.  This limits the evaporation to be calculated based on the largest area in the table.  If the area volume curve is extended, then this min function can be removed. <br><br>RETURN TYPE: Estimate of the evaporation volume<br><br>ARGUMENTS<br>1. DATETIME startDate - beginning of the estimation period<br>2. DATETIME endDate - end of the estimation period<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/14/2012";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC evapCalc = 0.00000000 "acre-ft" DO
  evapCalc + "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( $ "Navajo.Storage" [@"t - 1"] + "SumFlowsToVolume"( $ "Navajo.Inflow", startDate, date ) - "SumNavajoBaseRelease"( startDate, date ) - FOR ( DATETIME niipDate IN startDate TO date ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
   "FlowToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [niipDate], niipDate ) + result
  ENDFOR, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000], date ) COMMENTED_BY "Estimated evaporation for &quot;date&quot;"
 ENDFOR COMMENTED_BY "Calculate estimate by adding the evaporation estimate for each date to a running total";

    END
    UUID "{b5ab81d9-cd8b-4cfe-876c-a0f8ad34d67d}";;

    FUNCTION       "IsLowFlowAdjustmentNecessary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a TRUE value if for any month between the current timestep and the earlier of the next February or the model Finish Timestep, the pool elevation drops below the MinDesiredPoolElevation value; otherwise, the function returns FALSE<br><br>RETURNS: TRUE (low flow adjustment necessary) or FALSE (no adjustment necessary)<br><br>ARGUMENTS:<none><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN "GetDates"( @"t", "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12", @"Finish Timestep" ), "1 months" ) ) WITH BOOLEAN result = FALSE DO
  IF ( $ "Navajo.Pool Elevation" [date] < $ "NavajoData.MinDesiredPoolElevation" [] )
  THEN
   TRUE
  ELSE
   result
  ENDIF
 ENDFOR;

    END
    UUID "{49e66a77-8e30-4633-9889-85593f4331a2}";;

    FUNCTION       "MaxDayOfMonth_pre201707" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the date for the end of the month containing the input argument &quot;date&quot;, including consideration for leap years.<br><br>RETURNS: Datetime representing the end of the month date [Datetime]<br><br>ARGUMENTS<br>1. DATETIME date<br><br>CONSTRAINTS: <NONE><br><br>.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Rewrite this function as MaxDayOfMonth = OffsetDate(date, [GetDaysInMonth(date)-GetDayOfMonth(date)]/1 ?day?, ?1 days?), and use it to replace calls to GetEndDayOfMonth also? Similar for MinDayOfMonth & GetStartDayOfMonth";
    BEGIN

      WITH NUMERIC MoNum = "GetMonth"( date ) DO
  IF ( MoNum == 1.00000000 )
  THEN
   "OffsetDate"( date, "Units NONE"( 31.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
  ELSE
   IF ( MoNum == 2.00000000 )
   THEN
    IF ( "LeapYear"( date ) )
    THEN
     "OffsetDate"( date, "Units NONE"( 60.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
    ELSE
     "OffsetDate"( date, "Units NONE"( 59.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
    ENDIF
   ELSE
    IF ( MoNum == 3.00000000 )
    THEN
     IF ( "LeapYear"( date ) )
     THEN
      "OffsetDate"( date, "Units NONE"( 91.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
     ELSE
      "OffsetDate"( date, "Units NONE"( 90.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
     ENDIF
    ELSE
     IF ( MoNum == 4.00000000 )
     THEN
      IF ( "LeapYear"( date ) )
      THEN
       "OffsetDate"( date, "Units NONE"( 121.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
      ELSE
       "OffsetDate"( date, "Units NONE"( 120.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
      ENDIF
     ELSE
      IF ( MoNum == 5.00000000 )
      THEN
       IF ( "LeapYear"( date ) )
       THEN
        "OffsetDate"( date, "Units NONE"( 152.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
       ELSE
        "OffsetDate"( date, "Units NONE"( 151.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
       ENDIF
      ELSE
       IF ( MoNum == 6.00000000 )
       THEN
        IF ( "LeapYear"( date ) )
        THEN
         "OffsetDate"( date, "Units NONE"( 182.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
        ELSE
         "OffsetDate"( date, "Units NONE"( 181.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
        ENDIF
       ELSE
        IF ( MoNum == 7.00000000 )
        THEN
         IF ( "LeapYear"( date ) )
         THEN
          "OffsetDate"( date, "Units NONE"( 213.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
         ELSE
          "OffsetDate"( date, "Units NONE"( 212.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
         ENDIF
        ELSE
         IF ( MoNum == 8.00000000 )
         THEN
          IF ( "LeapYear"( date ) )
          THEN
           "OffsetDate"( date, "Units NONE"( 244.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
          ELSE
           "OffsetDate"( date, "Units NONE"( 243.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
          ENDIF
         ELSE
          IF ( MoNum == 9.00000000 )
          THEN
           IF ( "LeapYear"( date ) )
           THEN
            "OffsetDate"( date, "Units NONE"( 274.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
           ELSE
            "OffsetDate"( date, "Units NONE"( 273.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
           ENDIF
          ELSE
           IF ( MoNum == 10.00000000 )
           THEN
            IF ( "LeapYear"( date ) )
            THEN
             "OffsetDate"( date, "Units NONE"( 305.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
            ELSE
             "OffsetDate"( date, "Units NONE"( 304.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
            ENDIF
           ELSE
            IF ( MoNum == 11.00000000 )
            THEN
             IF ( "LeapYear"( date ) )
             THEN
              "OffsetDate"( date, "Units NONE"( 335.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ELSE
              "OffsetDate"( date, "Units NONE"( 334.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ENDIF
            ELSE
             IF ( "LeapYear"( date ) )
             THEN
              "OffsetDate"( date, "Units NONE"( 366.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ELSE
              "OffsetDate"( date, "Units NONE"( 365.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ENDIF
            ENDIF
           ENDIF
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END
    UUID "{6a819919-03ca-4846-8ab9-8ef361312e2f}";;

    FUNCTION       "MaxDayOfMonth" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the date for the end of the month containing the input argument &quot;date&quot;, including consideration for leap years.<br><br>RETURNS: Datetime representing the end of the month date [Datetime]<br><br>ARGUMENTS<br>1. DATETIME date<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Rewrite this function as MaxDayOfMonth = OffsetDate(date, [GetDaysInMonth(date)-GetDayOfMonth(date)]/1 ?day?, ?1 days?), and use it to replace calls to GetEndDayOfMonth also? Similar for MinDayOfMonth & GetStartDayOfMonth.";
    BEGIN

      "OffsetDate"( date, ( "GetDaysInMonth"( date ) - "GetDayOfMonth"( date ) ) / 1.00000000 "day", "1 days" );

    END
    UUID "{041cc47f-b813-4bf9-bf49-868a544cfb19}";;

    FUNCTION       "MinDayOfMonth" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date for the beginning of the month containing the input argument &quot;date&quot;. The function assumes that &quot;date&quot; represents the last day of a month.<br><br>RETURNS: Beginning date of month [Datetime]<br><br>ARGUMENTS<br>1. DATETIME date - end date of the month for which the beginning date is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Rewrite this function as MinDayOfMonth = OffsetDate(date, GetDayOfMonth(date)]/1 ?day? - 1, ?-1 days?), and use it to replace calls to GetStartDayOfMonth also? Similar for MaxDayOfMonth & GetEndDayOfMonth.";
    BEGIN

      WITH NUMERIC MoNum = "GetMonth"( date ) DO
  IF ( MoNum == 1.00000000 )
  THEN
   "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
  ELSE
   IF ( MoNum == 2.00000000 )
   THEN
    IF ( "LeapYear"( date ) )
    THEN
     "OffsetDate"( date, "Units NONE"( - 28.00000000 "day" ), "1 days" )
    ELSE
     "OffsetDate"( date, "Units NONE"( - 27.00000000 "day" ), "1 days" )
    ENDIF
   ELSE
    IF ( MoNum == 3.00000000 )
    THEN
     "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
    ELSE
     IF ( MoNum == 4.00000000 )
     THEN
      "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
     ELSE
      IF ( MoNum == 5.00000000 )
      THEN
       "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
      ELSE
       IF ( MoNum == 6.00000000 )
       THEN
        "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
       ELSE
        IF ( MoNum == 7.00000000 )
        THEN
         "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
        ELSE
         IF ( MoNum == 8.00000000 )
         THEN
          "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
         ELSE
          IF ( MoNum == 9.00000000 )
          THEN
           "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
          ELSE
           IF ( MoNum == 10.00000000 )
           THEN
            "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
           ELSE
            IF ( MoNum == 11.00000000 )
            THEN
             "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
            ELSE
             "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
            ENDIF
           ENDIF
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END
    UUID "{fa5192c7-6284-4f04-ad38-b700b0554834}";;

    FUNCTION       "NavajoAboveMaxPEOperations" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: If the Navajo pool elevation is above the maximum then release water to reduce the pool elevation. Return the new outflow for Navajo, the ouflow change as a volume and the volume that needed to be released in order to get to the Dam Protection pool elevation.<br><br>RETURNS: List of form &lcub;Modified Outflow, Outflow volume change, Volume released&rcub;<br><br>ARGUMENTS:<none><br><br>CONSTRAINTS: Maximum release of 5,000 cfs based on Max Release table<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/4/2015";
    BEGIN

      WITH NUMERIC navajoMonthlyOutflow = "Min"( $ "Navajo.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] ), @"t" ), 5000.00000000 "cfs" ) DO
  WITH NUMERIC navajoMonthlyVolumeChange = "FlowToVolume"( navajoMonthlyOutflow - $ "Navajo.Outflow" [], @"t" ) DO
   WITH NUMERIC volReleasedForDamProtection = "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] ) DO
    { navajoMonthlyOutflow , navajoMonthlyVolumeChange , volReleasedForDamProtection }
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Find outflow <=5,000 cfs that will reduce pool elevation to dam protection level; <br>5,000 cfs is the approximate maximum release (at interpolated pool elevation of 6,103 ft)";

    END
    UUID "{e4f4f145-ab8a-4a47-b51e-fefe6e844a59}";;

    FUNCTION       "SumNavajoBaseRelease" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the sum of outflows from &quot;startDate&quot; to &quot;endDate&quot;<br><br>RETURNS: Volume released between startDate and endDate<br><br>ARGUMENTS:<br>1. DATETIME startDate - date on which to begin sum<br>2. DATETIME endDate - date on which to end sum<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
  result + "FlowToVolume"( $ "Navajo.Outflow" [], date )
 ENDFOR;

    END
    UUID "{d6ec78a9-2d26-4401-9524-ee8d5eb1a556}";;

    FUNCTION       "WaterToAchieveEOYTPE" ( DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses a water balance to calculate the water available (over base releases) between the current time and the date in the argument &quot;endDate&quot;, in order to achieve the end-of-water-year pool elevation target for the year containing &quot;endDate&quot;.<br><br>RETURNS: Water volume available for release<br><br>ARGUMENTS<br>1. DATETIME endDate - date that specifies the end of the period for which to calculate available water<br><br>CONSTRAINTS<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC AvailableWater = $ "Navajo.Storage" [@"t - 1"] COMMENTED_BY "Beginning storage" + "SumFlowsToVolume"( $ "Navajo.Inflow", @"t", endDate ) COMMENTED_BY "Inflow volume" - "SumNavajoBaseRelease"( @"t", endDate ) COMMENTED_BY "Base flow release volume" - "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" ["Dec31ofYear"( endDate )] ) COMMENTED_BY "Storage at target PE" - FOR ( DATETIME niipDate IN @"t" TO endDate ) WITH NUMERIC niipVol = 0.00000000 "acre-ft" DO
  "FlowToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [niipDate], niipDate ) + niipVol
 ENDFOR COMMENTED_BY "NIIP diversion volume requested" - "EstimateEvaporationNavajo"( @"t", endDate ) COMMENTED_BY "Evaporation volume" DO
  AvailableWater
 ENDWITH;

    END
    UUID "{d133f581-6804-4d86-833d-eb2380e91832}";;

  END
  UUID "{35cc74a6-b00a-43ae-a87a-4f0dbc4a9094}";;

  UTILITY_GROUP "Flaming Gorge Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "DaysToDownramp" ( NUMERIC PPC, NUMERIC Baseflow, NUMERIC Rate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the number of days required to downramp from powerplant capacity to baseflow. Baseflow is set by the current hydrologic classification. The unit business is because Riverware cannot currently do calculations with the FlowPerTime unit. <br><br>RETURNS: Number of days [NONE]<br><br>ARGUMENTS<br>1. NUMERIC PPC - beginning flow rate (assuming powerplant capacity)<br>2. NUMERIC Baseflow - ending flow rate (baseflow rate based on current hydrologic classification)<br>3. NUMERIC Rate - daily flow rate reduction value<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      ( ( PPC - Baseflow ) / ( Rate / 1.00000000 "day" ) ) COMMENTED_BY "Assuming we are downramping from power plant capacity, divide required reduction in flow rate by the daily reduction in rate";

    END
    UUID "{78759d68-59dc-4d82-8630-7e85ca6ee382}";;

    FUNCTION       "DaysToRampUp" ( NUMERIC PPC, NUMERIC Baseflow, NUMERIC Rate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: The number of days to ramp up are determined by either the powerplant capacity minus the baseflow divided by the ramp up rate, or 0, whichever is greater<br><br>RETURNS: Number of days [NONE]<br><br>ARGUMENTS<br>1. NUMERIC PPC - beginning flow rate (assuming powerplant capacity)<br>2. NUMERIC Baseflow -ending flow rate  (baseflow rate based on current hydrologic classification)<br>3. NUMERIC Rate - daily flow rate reduction value<br><br>CONSTRAINTS<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: CE 6/12/13";
    BEGIN

      "Max"( ( PPC - Baseflow ) / ( Rate / 1.00000000 "day" ), 0.00000000 "day" );

    END
    UUID "{33bf34b1-47e6-4c7e-9d1a-3d415ec67169}";;

    FUNCTION       "ForecastComputeOutflowAtRuleCurveStorage" ( OBJECT reservoir, DATETIME month, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function performs a simple water balance for the reservoir and month specified as inputs. The water balance is based on the previous storage passed to the function, the rule curve storage for the month passed as input, the reservoir inflows, and an evaporation estimate.<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS<br>1. OBJECT reservoir - reservoir for which outflow forecast is needed<br>2. DATETIME month - timestep for which outflow forecast is needed<br>3. NUMERIC previousStorage - reservoir storage volume at beginning of month<br><br>CONSTRAINTS: Minimum and Maximum release rates for the specified reservoir<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    MIN_CONSTRAINT "GetMinRelease"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      ( previousStorage - "RuleCurveStorage"( reservoir, month ) ) / 1.00000000 "month" + reservoir & "Inflow" [month] - "VolumeToFlow"( "EstimateEvaporation"( reservoir, previousStorage, previousStorage, month, month ), month );

    END
    UUID "{08d36834-bcde-43ee-8829-62f5eac11f81}";;

    FUNCTION       "ForecastComputeStorageAtGivenOutflow" ( OBJECT reservoir, NUMERIC outflow, DATETIME month, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Based on a simple water balance and the given input arguments, this function returns either the Inactive Capacity of the reservoir or a projection of the storage taking into account the outflow and estimated evaporation<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which outflow forecast is needed<br>2. NUMERIC outflow - outflow rate to use in forecast<br>3. DATETIME month - timestep for which outflow forecast is needed<br>4. NUMERIC previousStorage - reservoir storage volume at beginning of month<br><br>CONSTRAINTS: Inactive storage capacity; Live storage capacity (from slot UBRuleCurveData.ReservoirData)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT "GetInactiveCapacity"( reservoir );
    MAX_CONSTRAINT "GetLiveCapacity"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170503: Previous version of function was written so that it returned either the InactiveCapacity or the LiveCapacity (fixed value), but could not return a value between those; rewrote the function to return the computed water balance value constrained by the Inactive or Live capacity";
    BEGIN

      WITH NUMERIC ForecastStorage = previousStorage + "FlowToVolume"( reservoir & "Inflow" [month], month ) - ( "FlowToVolume"( outflow, month ) + "EstimateEvaporation"( reservoir, previousStorage, previousStorage, month, month ) ) DO
  "Max"( "Min"( ForecastStorage, "GetLiveCapacity"( reservoir ) ), "GetInactiveCapacity"( reservoir ) )
 ENDWITH;

    END
    UUID "{edee65c3-f67e-4b56-a622-b61a2a83de43}";;

    FUNCTION       "ForecastFontenelleRelease" ( DATETIME startMonth, DATETIME endMonth )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function forecasts the releases and associated storage volumes for Fontenelle for the period startMonth to endMonth.<br><br>RETURNS: List of lists of the form &lcub;&lcub;Storage volumes&rcub;, &lcub;Outflow rates&rcub;&rcub;<br><br>ARGUMENTS:<br>1. DATETIME startMonth - first month in the period of calculation<br>2. DATETIME endMonth - last month in the period of calculation<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC totalMonths = IF ( "GetMonth"( endMonth ) - "GetMonth"( startMonth ) < 0.00000000 )
 THEN
  12.00000000 - "Abs"( "GetMonth"( endMonth ) - "GetMonth"( startMonth ) )
 ELSE
  "GetMonth"( endMonth ) - "GetMonth"( startMonth )
 ENDIF DO
  FOR ( NUMERIC month IN "GetNumbers"( 0.00000000, totalMonths, 1.00000000 ) ) WITH LIST result = { { $ "Fontenelle.Storage" ["OffsetDate"( startMonth, - 1.00000000, "1 MONTHS" )] } COMMENTED_BY "Previous storage" , {  } COMMENTED_BY "New outflow " } DO
   WITH DATETIME currentDate = "OffsetDate"( startMonth, month, "1 MONTHS" ) DO
    WITH NUMERIC newStorage = "ForecastComputeStorageAtGivenOutflow"( % "Fontenelle", "ForecastComputeOutflowAtRuleCurveStorage"( % "Fontenelle", currentDate, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ), currentDate, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ) DO
     { APPEND newStorage COMMENTED_BY "New, compute StorageAtGivenOutflow which takes time and previous storage as a parameter" ONTO GET @INDEX 0.00000000 FROM result , APPEND ( ( ( GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ) - newStorage ) / 1.00000000 "month" + % "Fontenelle" & "Inflow" [currentDate] - "VolumeToFlow"( "EstimateEvaporation"( % "Fontenelle", GET @INDEX month FROM GET @INDEX 0.00000000 FROM result, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result, currentDate, currentDate ), currentDate ) ) COMMENTED_BY "MC, 20170503: Does this give the same flow rate as ForecastComputeOutflowAtRuleCurveStorage in the computation of newStorage?" ONTO GET @INDEX 1.00000000 FROM result }
    ENDWITH
   ENDWITH
  ENDFOR
 ENDWITH;

    END
    UUID "{11035a5f-eb7f-4499-af91-01c67167adcc}";;

    FUNCTION       "GetDaysAtBypass_old" ( NUMERIC HClass )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Determines the number of days at bypass capacity. For mod dry, average and mod wet years, if the number of days that the Yampa is greater than 14000 cfs is greater than the threshold then the standard days at bypass capacity are used. If the days greater than 14000 cfs is less than the threshold then the days at bypass is zero.  For dry years the days at bypass is always zero and for wet years always bypass. -CE 6/12/13<br><br>RETURNS: Number of days [NONE]<br><br>ARGUMENTS:<br>1. NUMERIC HClass - hydrologic class indicator<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( HClass < 4.00000000 AND HClass > 0.00000000 )
 THEN
  IF ( "YampaDaysAbove14000"(  ) > $ "FlamingGorgeData.YampaDaysAbove14000ForBypass" [HClass, 0.00000000] )
  THEN
   $ "FlamingGorgeData.DaysAtBypassCapacity" [HClass, 0.00000000]
  ELSE
   0.00000000 "day"
  ENDIF COMMENTED_BY "If the Yampa is very wet then bypass to meet peaks otherwise no bypass"
 ELSE
  IF ( HClass == 0.00000000 )
  THEN
   0.00000000 "day" COMMENTED_BY "In Dry years never bypass"
  ELSE
   $ "FlamingGorgeData.DaysAtBypassCapacity" [HClass, 0.00000000] COMMENTED_BY "In wet years always bypass"
  ENDIF
 ENDIF COMMENTED_BY "Are we in Mod Dry, Ave, or Mod Wet?";

    END
    UUID "{c7342ffe-dd00-4869-8e24-992825e302ab}";;

    FUNCTION       "GetFGBaseFlowMagnitude" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft/month";
    DESCRIPTION    "DESCRIPTION: Returns the steady base flow magnitude necessary to meet the May 1 ULDE.  The magnitude is first projected as if there are no base flow limits. If the necessary base flow is outside of the limits, then the returned flow is within the limits set by the current hydrologic classification. <br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF, 20190128: Removed Min Constraint SolveOutflow(MaxPE) to since it is not being applied as part of a Max() check along with MinFlow at the rule level to match CRSS.  <br><br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "GetFGBaseFlowMagnitudeUnconstrained"(  ) < $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 0.00000000] )
 THEN
  $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 0.00000000] COMMENTED_BY "Use Lower Limit of Base Flow Range"
 ELSE
  IF ( "GetFGBaseFlowMagnitudeUnconstrained"(  ) > $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 1.00000000] )
  THEN
   $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 1.00000000] COMMENTED_BY "Use Upper Limit of Base Flow Range"
  ELSE
   "GetFGBaseFlowMagnitudeUnconstrained"(  ) COMMENTED_BY "Somewhere in between, use calculated value"
  ENDIF
 ENDIF;

    END
    UUID "{038a3f53-27d1-4a78-9f2b-538e58c4e3b5}";;

    FUNCTION       "GetFGBaseFlowMagnitudeUnconstrained" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    ".acre-ft/month";
    DESCRIPTION    "Arguements: None<br><br>DESCRIPTION: Uses a simple water balance with predicted inflows to calculate a steady outflow rate from the current timestep to the next April to meet the May 1 ULDE regardless of base flow restrictions. Additional provisions ensure FG baseflow will be sufficent to meet the lower baseflow limit set for the Green at Jensen by the EIS during baseflow operation months. <br><br>- Jan-April: Use current inflow forecast to calculate the baseflow needed to achieve the Target May 1 UDLE (based on precent exceedence/current hydrologic year classification).<br>- May-Dec: Use predicted inflow between t and next April to calculate the baseflow needed to achieve the March 1 drawdown level of 6027ft from the EIS. <br><br>Returns: The unconstrained baseflow [L^3/T]";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF 20190125: Updated to use TargetHWGivenInflowOneMonth<br><br>CF,20190109: TargetHWGivenInflow now take Inflow - EstEvap to account for evaporation. Jan-Feb now uses GetMay1TargetElevation() according to direction from HP about use of % exceedance to calculate PE target. Mar-April do not use BF targets at Jensen. <br><br>CF,20181010: for FG update adding in baseflow targets for Jensen to GetFGBaseFlowMagnitudeUnconstrained<br><br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "MonthIs"( { "January" , "February" } ) )
 THEN
  "Max"( "TargetHWGivenInflow"( % "FlamingGorge", @"t", @"24:00:00 April Max DayOfMonth, Current Year", "GetMay1TargetElevation"(  ) COMMENTED_BY "CF: This has been changed to a hydrologic year classification calculated target as per HP. <br>Previously was a static target. <br>", "PredictedFGInflow"( @"t", @"24:00:00 April Max DayOfMonth, Current Year" ) COMMENTED_BY "CF: MTOM's unregulated inflow accounts for the evaporation and upstream delta storage <br>therefore it does not need to include EstimateEvaporation like CRSS. <br>", $ "FlamingGorge.Storage" [@"t - 1"] ) COMMENTED_BY "CF, 20190107: Changed to use Evap. <br>", "Max"( ( $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 2.00000000] - $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"t"] COMMENTED_BY "CF: PredictedYampaFlow() not needed since its just a call of this slot @t   <br>" ) COMMENTED_BY "CF: This ensures FG baseflow will be sufficient to meet the lower baseflow limit set for the Green <br>at Jensen by the EIS. The flow at Jensen is the FG baseflow plus the predicted Yampa flow. <br>", $ "FlamingGorgeData.MinFlow" [] ) )
 ELSE
  IF ( "MonthIs"( { "March" } ) )
  THEN
   "Max"( "TargetHWGivenInflow"( % "FlamingGorge", @"t", @"24:00:00 April Max DayOfMonth, Current Year", "GetMay1TargetElevation"(  ) COMMENTED_BY "CF: This has been changed to a hydrologic year classification calculated target as per HP. <br>Previously was a static target. <br>", "PredictedFGInflow"( @"t", @"24:00:00 April Max DayOfMonth, Current Year" ) COMMENTED_BY "CF: MTOM's unregulated inflow accounts for the evaporation and upstream delta storage <br>therefore it does not need to include EstimateEvaporation like CRSS. <br>", $ "FlamingGorge.Storage" [@"t - 1"] ) COMMENTED_BY "CF, 20190107: Changed to use Evap. <br>", $ "FlamingGorgeData.MinFlow" [] )
  ELSE
   IF ( "MonthIs"( { "April" } ) COMMENTED_BY "CF:April, this include Evap in fct. The EIS has no Jensen targets in March and April, in these <br>months release are used to meet the UDLE.   <br>" )
   THEN
    "Max"( "TargetHWGivenInflowOneMonth"( % "FlamingGorge", @"t", @"24:00:00 April Max DayOfMonth, Current Year", "GetMay1TargetElevation"(  ) COMMENTED_BY "CF: This has been changed to a hydrologic year classification calculated target as per HP. <br>Previously was a static target. <br>", "PredictedFGInflow"( @"t", @"24:00:00 April Max DayOfMonth, Current Year" ), $ "FlamingGorge.Storage" [@"t - 1"] ) COMMENTED_BY "CF, 20190107: Changed to use Evap. <br>", $ "FlamingGorgeData.MinFlow" [] )
   ELSE
    "Max"( "TargetHWGivenInflow"( % "FlamingGorge", @"t", @"24:00:00 April Max DayOfMonth, Next Year", $ "FlamingGorgeData.May1TargetElevation" [3.00000000, 2.00000000] COMMENTED_BY "CF: This is the May 1 drawdown level of 6027ft. In Aug - Dec this the the target elevation from <br>the to EIS. This is the target until Jan when the hydrologic year classification can be calculated.   <br>", "PredictedFGInflow"( @"t", @"24:00:00 April Max DayOfMonth, Next Year" ), $ "FlamingGorge.Storage" [@"t - 1"] ), "Max"( ( $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 2.00000000] - $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"t"] COMMENTED_BY "CF: PredictedYampaFlow() not needed since its just a call of this slot @t   <br>" ) COMMENTED_BY "CF: This ensures FG baseflow will be sufficient to meet the lower baseflow limit set for the Green <br>at Jensen by the EIS. The flow at Jensen is the FG baseflow plus the predicted Yampa flow.  <br>", $ "FlamingGorgeData.MinFlow" [] ) ) COMMENTED_BY "CF: May-Dec assume static target of 6027 for May 1, Next Year.  <br>"
   ENDIF
  ENDIF COMMENTED_BY "CF: The EIS has no Jensen targets in March and April, in these months release are used to meet <br>the UDLE.  <br>"
 ENDIF COMMENTED_BY "CF: Jan-Feb use GetMay1Target based on exceedance.   <br>";

    END
    UUID "{6f2b32c3-90d7-4ce0-9071-5d0f1efde20e}";;

    FUNCTION       "GetMay1TargetElevation" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns the May 1 target pool elevation based on the percent exceedance value of the Apr-Jul inflow forecast<br><br>RETURNS: Target May 1 pool elevation for Flaming Gorge [L]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      $ "FlamingGorgeData.May1TargetElevation" [IF ( ( WHILE ( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] * 100.00000000 < $ "FlamingGorgeData.May1TargetElevation" [result, 1.00000000] AND result <= 2.00000000 ) WITH NUMERIC result = 0.00000000 DO
  result + 1.00000000
 ENDWHILE == 0.00000000 ) COMMENTED_BY "Cycle through indices and if exceedance percentage is greater than all in table, return index of 0; target elevation will be 6,027 ft" )
 THEN
  0.00000000
 ELSE
  WHILE ( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] * 100.00000000 < $ "FlamingGorgeData.May1TargetElevation" [result, 1.00000000] AND result <= 2.00000000 ) WITH NUMERIC result = 0.00000000 DO
   result + 1.00000000
  ENDWHILE COMMENTED_BY "Cycle through indices and return index for which exceedance percentage is between lower and upper limit" - 1.00000000
 ENDIF COMMENTED_BY "Find index in May1TargetElevation corresponding to appropriate exceedance level of forecast", 2.00000000];

    END
    UUID "{feedee48-9aeb-4d64-8cb9-be26add46c0c}";;

    FUNCTION       "GetNumberOfDaysAtPPC" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function bounds the days at power plant capacity to within the limts for the current hydrologic classification<br><br>RETURNS: Number of days to release at power plant capacity [T]<br><br>ARGUMENTS<br>1. NUMERIC Class<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: CE 6/12/13";
    BEGIN

      WITH NUMERIC DaysAtPPC = "GetNumberOfDaysAtPPCUnconstrained"( Class ) DO
  IF ( DaysAtPPC < $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000] )
  THEN
   $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000]
  ELSE
   IF ( DaysAtPPC > $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000] )
   THEN
    $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000]
   ELSE
    DaysAtPPC
   ENDIF
  ENDIF
 ENDWITH COMMENTED_BY "Ensure that the days at power plant capacity fall within the limits of the current hydrologic classification";

    END
    UUID "{21eb232d-9177-47b3-a484-01d665af02f5}";;

    FUNCTION       "GetNumberOfDaysAtPPCUnconstrained" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Interpolates the number of days to have the powerplant at capacity for the current hydrologic classification based on the current exceedance percentile for the Yampa April through July volume<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS<br>1. NUMERIC Class - Annual hydrologic class<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      "Interpolate"( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 0.00000000], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000] );

    END
    UUID "{bdc0a049-8ffd-445b-bf51-d0cfc7ef7d7b}";;

    FUNCTION       "NumberOfMonthsUntilMay" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the number of months remaining to make releases to meet the May 1 Upper Limit Drawdown Elevation (ULDE) on Flaming Gorge reservoir. This is called by the Flaming Gorge baseflow operations. -HG 9/12/12<br><br>RETURNS: Number of months until next May [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: HG, 9/12/12";
    BEGIN

      IF ( "GetMonth"( @"t" ) >= 5.00000000 )
 THEN
  ( 12.00000000 - "GetMonth"( @"t - 1" ) + 4.00000000 ) COMMENTED_BY "For May through December.<br>Calculate the remaining months of current year (current month - Dec.)<br>Add the first four months of next year (Jan.- Apr.).<br>"
 ELSE
  ( 5.00000000 - "GetMonth"( @"t" ) ) COMMENTED_BY "For January through April.<br>Calculate the remaining months to make releases before May 1, <br>includes the current month."
 ENDIF;

    END
    UUID "{522bddc7-b363-4587-80a9-b8141665e8dd}";;

    FUNCTION       "PredictedFGInflow" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total inflow volume between the dates specified as arguments<br><br>RETURNS: Inflow volume to Flaming Gorge [L^3]<br><br>CF: ForecastData.FlamingGorgeInflow is set by Fontenelle rule ForecastFutureFGInflow-total average. This is the 50% Exceedance.  <br><br>ARGUMENTS<br>1. DATETIME startDate - beginning date of period for sum<br>2. DATETIME endDate - ending date of period for sum<br><br>CONSTRAINTS<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      IF ( endDate > @"Finish Timestep" )
 THEN
  "SumFlowsToVolume"( $ "FlamingGorge.Inflow", startDate, @"Finish Timestep" ) + "SumFlowsToVolume"( $ "FlamingGorgeData.ProjectedInflow", @"Finish Timestep + 1", endDate )
 ELSE
  "SumFlowsToVolume"( $ "FlamingGorge.Inflow", startDate, endDate )
 ENDIF;

    END
    UUID "{75bcf33a-a62f-4808-844a-f985f8f9762c}";;

    FUNCTION       "PredictedYampaFlow" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total inflow volume between the dates specified as arguments<br><br>RETURNS: Inflow volume to Yampa at Deerlodge [L^3]<br><br>ARGUMENTS<br>1. DATETIME startDate - beginning date of period for sum<br>2. DATETIME endDate - ending date of period for sum<br><br>CONSTRAINTS<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF,20181012: Else statement added to deal with when at the end of a run and no yampa data<br><br>AUTHOR, DATE: CF,20181010 for FG update adding in baseflow targets for Jensen to GetFGBaseFlowMagnitudeUnconstrained<br>";
    BEGIN

      IF ( endDate < "RunEndDate"(  ) )
 THEN
  "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", startDate, endDate )
 ELSE
  "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Previous Year", @"24:00:00 April Max DayOfMonth, Current Year" ) COMMENTED_BY "CF: This could be improved to take what is between @t - run end date + portion of previous <br>years spring but I don't know how to impliment the time so it finds what month the run end date is <br>and looks back for the previous years that month (would sometimes be current year).  <br>"
 ENDIF;

    END
    UUID "{1aa73f2c-5690-4ea5-89d9-6877a6e64bd5}";;

    FUNCTION       "FGSpringReleaseStartDate" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguments: None<br><br>Description: This function determines FG spring release date based on Yampa peak magnitude and historic julian day larval razorback sucker emergence. <br><br>Formula Ax^2+Bx+C where x = $ FlamingGorgeEIS.YampaPeakDailyFlow.<br><br>Returns: Date";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF, 20181010: Use reference to new LTSPRegressionCoefficients table slot. <br><br>HP, 20170714<br><br>";
    BEGIN

      @"24:00:00 January 1, Current Year" + ( $ "FlamingGorgeData.LTSPRegressionCoefficients" [0.00000000, "A"] * ( $ "KNN_MTOM.YampaPeakDailyFlow" [@"24:00:00 December 31, Current Year"] ^ 2.00000000 / 1.00000000 "cfs^2" ) - $ "FlamingGorgeData.LTSPRegressionCoefficients" [0.00000000, "B"] * ( $ "KNN_MTOM.YampaPeakDailyFlow" [@"24:00:00 December 31, Current Year"] / 1.00000000 "cfs" ) + $ "FlamingGorgeData.LTSPRegressionCoefficients" [0.00000000, "C"] ) * 1.00000000 "day";

    END
    UUID "{8ca2784d-46cd-457b-8938-96b8aaff208b}";;

    FUNCTION       "RoundToNearestDay" ( NUMERIC numDays )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the rounded value of the specified argument &quot;numDays&quot;. If the fractional part of numDays is < 0.5 the value is rounded down; otherwise, the value is rounded up.<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS:<br>1. NUMERIC numDays<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "Fraction"( numDays, 1.00000000 "day" ) >= 0.50000000 "day" )
 THEN
  "Ceiling"( numDays, 1.00000000 "day" )
 ELSE
  "Floor"( numDays, 1.00000000 "day" )
 ENDIF;

    END
    UUID "{406f541c-6ba5-4fc4-9484-8969737f3baf}";;

    FUNCTION       "YampaDaysAbove14000" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Determines the number of days that the Yampa River will be above 14000 cfs. If the Yampa April to July volume is greater than the bypass threshold then the number of days above 14000 cfs is determined with a linear regression equation based on data for the historical period 1923-2006. For volumes less than the bypass threshold the number of days above 14000 cfs is zero. -CE 6/12/13<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS:<NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170315 - The description on this function is the same as the one for the function YampaDaysAbove14000Old, which uses regression; however, this version does not use regression";
    BEGIN

      "CountDaysAboveThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ), 14000.00000000 "cfs" );

    END
    UUID "{ebe528f9-34e4-450e-9fd9-c8493c7436d9}";;

    FUNCTION       "FindYampaPeakDateForYear" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function finds the date of the Yampa peak flow within the period April through July of the current year<br><br>RETURNS: Date of the Yampa April-July peak flow [DATETIME]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170503: Function simplified by removing 3 unused local variable WITH statements";
    BEGIN

      WITH NUMERIC yampaPeak = "MaxItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) ) DO
  GET @INDEX FIND yampaPeak WITHIN "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) FROM "GetDates"( @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year", "1 days" )
 ENDWITH;

    END
    UUID "{f8e4c1db-17aa-4f9e-b322-b270dc71f42c}";;

    FUNCTION       "FindYampa10kcfsBypassDateForYear" ( DATETIME YampaPeakDate )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the date to bypass if the Yampa River flows are at 10,000 cfs for the length of time necessary to meet flow targets.<br><br>RETURNS: Date to begin ramp up to bypass [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME YampaPeakDate - date of the Yampa peak flow (from function FindYampaPeakDateForYear)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170503: Numeric input argument BypassDays removed because it was not used";
    BEGIN

      WITH LIST flowList = "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) DO
  WITH NUMERIC DaysAbv10k = "CountDaysAboveThreshold"( flowList, 10000.00000000 "cfs" ) DO
   WITH NUMERIC DaysToRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.BypassCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" ) ) / 1.00000000 "day" + 2.00000000 DO
    WITH NUMERIC DaysToPeak = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
     IF ( $ "KNN_MTOM.SpringHClass" [] < 4.00000000 AND $ "KNN_MTOM.SpringHClass" [] > 0.00000000 )
     THEN
      IF ( ( DaysAbv10k >= $ "KNN_MTOM.YampaDaysAbove10000ForBypass" [$ "KNN_MTOM.SpringHClass" [], 0.00000000] OR ( $ "KNN_MTOM.SpringHClass" [] == 2.00000000 AND DaysAbv10k > 3.00000000 "day" ) ) COMMENTED_BY "Will bypass if Yampa River flows are above 10,000 cfs for days necessary to meet flow targets in all hydrologic classifications or<br>in average years if Yampa River above 10,000 cfs for 3 days in order to meet 18,600 cfs target 50% of the time." )
      THEN
       WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
        IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( DaysToPeak - length - 1.00000000 == - 1.00000000 )
        THEN
         0.00000000
        ELSE
         DaysToPeak - length - 1.00000000
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
        THEN
         DaysToPeak - length
        ELSE
         result
        ENDIF
       ENDFOR COMMENTED_BY "If the Yampa River is above 10,000 cfs for enough days to meet flow targets then this calculation determines the peak date of the Yampa River <br>and returns the first date that the Yampa River reaches 10,000 cfs before the peak date." DO
        GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
        THEN
         0.00000000
        ELSE
         DateIndex - DaysToRamp
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
       ENDWITH
      ELSE
       WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
        IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( DaysToPeak - length - 1.00000000 == - 1.00000000 )
        THEN
         0.00000000
        ELSE
         DaysToPeak - length - 1.00000000
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
        THEN
         DaysToPeak - length
        ELSE
         result
        ENDIF
       ENDFOR DO
        GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
        THEN
         0.00000000
        ELSE
         DateIndex - DaysToRamp
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
       ENDWITH
      ENDIF
     ELSE
      "DateMax"( WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
       IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( DaysToPeak - length - 1.00000000 == - 1.00000000 )
       THEN
        0.00000000
       ELSE
        DaysToPeak - length - 1.00000000
       ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
       THEN
        DaysToPeak - length
       ELSE
        result
       ENDIF
      ENDFOR DO
       GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
       THEN
        0.00000000
       ELSE
        DateIndex - DaysToRamp
       ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
      ENDWITH, @"24:00:00 April 2, Current Year" ) COMMENTED_BY "Returns the maximum of April 2 or the first day that the Yampa River is above 10,000 cfs so the April-July function works."
     ENDIF
    ENDWITH
   ENDWITH
  ENDWITH COMMENTED_BY "Counts Yampa River flow days above 10,000 cfs to determine if flow targets can be met."
 ENDWITH COMMENTED_BY "Determines the date to bypass if the Yampa River flows are at 10,000 cfs for the length of time necessary to meet flow targets. ";

    END
    UUID "{d92401c9-eb1a-4816-893e-2dd2372dd6d9}";;

    FUNCTION       "DaysAboveThreshold" ( LIST dailyFlows, NUMERIC flowThreshold )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function counts the number of flow values in the argument list &quot;dailyFlows&quot; that exceed the value of the argument &quot;flowThreshold&quot;<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS:<br>1. LIST dailyFlows - list of daily flow rates<br>2. NUMERIC flowThreshold - threshold flow rate<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC flow IN dailyFlows ) WITH NUMERIC result = 0.00000000 "day" DO
  IF ( flow > flowThreshold )
  THEN
   1.00000000 "day"
  ELSE
   0.00000000 "day"
  ENDIF + result
 ENDFOR;

    END
    UUID "{4e18f5a6-6aca-43d9-9a09-f514e07b392c}";;

    FUNCTION       "FindYampa14kcfsPPCDateForYear" ( NUMERIC PPCDays, DATETIME YampaPeakDate )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the date to increase the Flaming Gorge release to the powerplant capacity (PPC) if the Yampa River flows are at 14,000 cfs for the length of time necessary to meet flow targets.<br><br>RETURNS: Date to increase release rate [DATETIME]<br><br>ARGUMENTS:<br>1. NUMERIC PPCDays - the number of days that Flaming Gorge will release at powerplant capacity<br>2. DATETIME YampaPeakDate - date of the Yampa peak flow (from function FindYampaPeakDateForYear)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST flowList = "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) DO
  WITH NUMERIC DaysAbv14k = "DaysAboveThreshold"( flowList, 14000.00000000 "cfs" ) COMMENTED_BY "Counts Yampa River flows above 14,000 cfs to determine if flow targets can be met." DO
   WITH NUMERIC DaysToRamp = "RoundToNearestDay"( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" ) ) / 1.00000000 "day" + 1.00000000 DO
    WITH NUMERIC DaysToPeak = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
     IF ( $ "KNN_MTOM.SpringHClass" [] < 4.00000000 AND $ "KNN_MTOM.SpringHClass" [] > 0.00000000 )
     THEN
      IF ( DaysAbv14k >= $ "KNN_MTOM.YampaDaysAbove14000ForPPC" [$ "KNN_MTOM.SpringHClass" [], 0.00000000] )
      THEN
       WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
        IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 14000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX DaysToPeak - length - 1.00000000 FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 14000.00000000 "cfs" ) < 1.00000000 "day" )
        THEN
         DaysToPeak - length
        ELSE
         result
        ENDIF
       ENDFOR DO
        GET @INDEX DateIndex - DaysToRamp FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
       ENDWITH COMMENTED_BY "Finds the date closest to the Yampa River peak flow date that flows are 14,000 cfs in order to begin ramp up to PPC."
      ELSE
       ( YampaPeakDate - PPCDays / 2.00000000 ) COMMENTED_BY "FG has a spring peak every year and flow targets below 18,600 cfs.  This returns the date closest to the Yampa River peak <br>with half of the PPC days determined for flow targets being met in all hydrologic classifications. "
      ENDIF
     ELSE
      ( YampaPeakDate - PPCDays * 0.75000000 ) COMMENTED_BY "FG has a spring peak every year and flow targets below 18,600 cfs.  This returns the date closest to the Yampa River peak with the PPC days determined<br>for flow targets being met in all hydrologic classifications. This returns 75% of the PPC days so that ramping to PPC occurs closer to the Yampa River peak in dry years.  <br>The wet year hydrologic classification is usually targeted using the bypass functions."
     ENDIF
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Determines the date to increase to PPC if the Yampa River flows are at 14,000 cfs for the length of time necessary to meet flow targets.";

    END
    UUID "{ddfc86b8-1353-4676-bd90-246bb1ee873c}";;

    FUNCTION       "CountDaysAboveThreshold" ( LIST Flows, NUMERIC MinFlow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a count of the number of values in the list &quot;Flows&quot; that are greater than the value of &quot;MinFlow&quot;<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS<br>1. LIST Flows - list of flow rates<br>2. NUMERIC MinFlow - threshold flow rate<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC flow IN Flows ) WITH NUMERIC result = 0.00000000 "day" DO
  IF ( flow >= MinFlow )
  THEN
   result + 1.00000000 "day"
  ELSE
   result
  ENDIF
 ENDFOR;

    END
    UUID "{c5bb171f-5cee-4f80-8aa8-fecb203365b7}";;

    FUNCTION       "CountDaysBelowThreshold" ( LIST Flows, NUMERIC MinFlow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a count of the number of values in the input argument list &quot;Flows&quot; that are less than the value of the input argument &quot;MinFlow&quot;<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS<br>1. LIST Flows - list of flow rates<br>2. NUMERIC MinFlow - threshold flow rate<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC flow IN Flows ) WITH NUMERIC result = 0.00000000 "day" DO
  IF ( MinFlow >= flow )
  THEN
   result + 1.00000000 "day"
  ELSE
   result
  ENDIF
 ENDFOR;

    END
    UUID "{1dc07d49-51ee-46ae-996d-038455ea581a}";;

    FUNCTION       "AugustDownRamp" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguements: None<br><br>Description: Create a list for August flows whether downramping from bypass flows or not. When bypass releases extend through the entire A-J period to July 31st, this function downramps to base flows in August.<br><br>Returns: List of August flows. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF 20190125: Updated to use TargetHWGivenInflowOneMonth";
    BEGIN

      WITH NUMERIC RampRate = $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"24:00:00 April Max DayOfMonth, Current Year"], 0.00000000] * 1.00000000 "cfs" DO
  WITH NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] - $ "FlamingGorge.Outflow" [] ) / RampRate * 1.00000000 "day" ) COMMENTED_BY "Number of days needed to downramp from July 31st bypass release to August base flow." DO
   WITH LIST DateList = "GetDates"( @"24:00:00 August 1, Current Year", @"24:00:00 August 31, Current Year", "1 days" ) DO
    WITH LIST FlowList = FOR ( DATETIME date IN DateList ) WITH LIST Augflows = {  } DO
     WITH NUMERIC i = ( date - @"24:00:00 August 1, Current Year" ) / 1.00000000 "day" DO
      APPEND IF ( date == @"24:00:00 August 1, Current Year" )
      THEN
       ( $ "KNN_MTOM.FlamingGorgeDaily" COMMENTED_BY "CF: CRSS slot $ &quot;DailyFlows.FlamingGorgeDaily&quot;  <br>" [@"24:00:00 July Max DayOfMonth, Current Year"] - RampRate )
      ELSE
       IF ( date <= @"24:00:00 August 1, Current Year" + DaysToDownRamp )
       THEN
        "Max"( ( GET @INDEX i - 1.00000000 FROM Augflows ) - "KNN_MTOM.BaseFlowDownrampRateNoUnits" COMMENTED_BY "CF: CRSS slot ForecastData.FlamingGorgeInflow <br>" [$ "KNN_MTOM.BaseFlowHClass" COMMENTED_BY "CF: CRSS slot different <br>" [@"24:00:00 April 30, Current Year"], 0.00000000] * 1.00000000 "cfs", "GetFGBaseFlowMagnitude"(  ) ) COMMENTED_BY "Downramping."
       ELSE
        "Max"( "Max"( ( GET @INDEX i - 1.00000000 FROM Augflows ), "GetFGBaseFlowMagnitude"(  ) ), "TargetHWGivenInflowOneMonth"( % "FlamingGorge", @"t - 1", @"t", $ "FlamingGorgeData.MaxPE" [] COMMENTED_BY "CF: Prv fct (TargetHWGivenInflowforOneMonth) just took in Elevation but this matches <br>TargetHW arguements and is more explicit.   <br>", "FlowToVolume"( $ "FlamingGorge.Inflow" COMMENTED_BY "CF: CRSS slot ForecastData.FlamingGorgeInflow <br>" [], @"t" ) COMMENTED_BY "CF: MTOM's unregulated inflow accounts for the evaporation and upstream delta storage <br>therefore it does not need to include EstimateEvaporation like CRSS. <br>", $ "FlamingGorge.Storage" [@"t - 1"] ) ) COMMENTED_BY "No downramping needed, the list generates August base flows or flows<br>necessary to maintain max PE.<br>CF: Added logic to maintain max PE here. "
       ENDIF
      ENDIF ONTO Augflows
     ENDWITH
    ENDFOR COMMENTED_BY "Create a list for August flows whether downramping from bypass flows or not." DO
     FOR ( DATETIME date IN DateList ) WITH LIST DateFlowList = {  } DO
      APPEND { date , GET @INDEX ( date - @"24:00:00 August 1, Current Year" ) / 1.00000000 "day" FROM FlowList } ONTO DateFlowList
     ENDFOR
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{2a691ba0-1d22-4888-a1a2-22c854c18a03}";;

    FUNCTION       "SpringFlowA-JVolumeUpdate" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the April through July unregulated inflow volume for Flaming Gorge<br><br>RETURNS: Unregulated inflow volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "MonthIs"( { "January" , "February" , "March" } ) )
 THEN
  ( ( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) / "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) * "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Before April, the April-July volume forecast is calculated as the average volume for that period multiplied by the ratio of the current year's forecast volume <br>from the current month through April to the average for the same period."
 ELSE
  "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) COMMENTED_BY "Otherwise, use the April through July forecast and/or actual flows"
 ENDIF;

    END
    UUID "{a2adea20-7d12-45a9-a08e-4e43104dd205}";;

    FUNCTION       "BaseFlowA-JVolumeUpdate" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates an estimated or actual unregulated inflow volume for the period April through July at Flaming Gorge<br><br>RETURNS: Unregulated inflow volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20160913: I don't see how March or May targets are reflected in this function, are they considered elsewhere? That inline comment precedes this documentation.<br>MC, 20170503: August used the same calculation as April-July so I removed its separate IF conditional and just let it calculate under the final ELSE; changed the position of the denominators in the calculations to better reflect how the factor is being calculated as a ratio of average unregulated flows for different periods (not sure it's any clearer, though)";
    BEGIN

      IF ( "MonthIs"( { "January" , "February" , "March" } ) )
 THEN
  ( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) * ( "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) / "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) ) COMMENTED_BY "January through April flows change depending on actual inflow, the forecasted unreg inflow and meeting March or May 1 elevation target.<br>Forecast volume is calculated as the sum of the current year's monthly forecast flows from the current month through April multiplied by the <br>ratio of the average April-July flow to the average flow for the current period."
 ELSE
  IF ( "MonthIs"( { "September" , "October" , "November" , "December" } ) )
  THEN
   "Max"( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"t - 1", @"t - 1" ) * ( "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Next Year", @"24:00:00 July Max DayOfMonth, Next Year" ) / $ "KNN_MTOM.FGAverageUnregInflow" [@"t - 1"] ), 0.00000000 "acre-ft" )
  ELSE
   "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) COMMENTED_BY "April, May, June, July, August"
  ENDIF COMMENTED_BY "The months of September through December look at actual flows coming into the system and react if necessary to meet the March 1 elevation target."
 ENDIF;

    END
    UUID "{67627ffd-9dfc-427c-8af2-9fcdeca2403f}";;

    FUNCTION       "MakeDailyFlamingGorgeReleaseDateandFlowList_LTSP" ( DATETIME startdate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "HP, 20170714<br><br>Arguments: <br>     Startdate between April-July<br>     2nd Disagg Yampa Flows<br>     FG Spring Release Start Date<br><br>Description:<br>    This function is the powerhouse for FG daily disaggregation and calculates the ramp rates, number of days at powerplant capacity, number of days at bypass, and timing of the spring peak. The LTSP timing uses a function that estimates larval razorback sucker based on Yampa peak magnitude and historic julian days to larval presence. The ramp down takes into account Reach 2 Jensen flows and calculates target flows accordingly. <br><br>Returns:<br>     Daily FG hydrograph in cfs for the April-July period.<br>     	";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF 20190125: Updated to use TargetHWGivenInflowOneMonth<br><br>HP, 20170714";
    BEGIN

      WITH LIST DateList = "GetDates"( @"24:00:00 April 1, Current Year", @"t" COMMENTED_BY "Only calculates daily schedule to the end of the current month for computation efficiency.", "1 days" ) DO
  WITH LIST FlowList = WITH DATETIME YampaPeakDate = IF ( TRUE )
  THEN
   "FindYampaPeakDateForYear"(  )
  ELSE
   @"24:00:00 May 27, Current Year"
  ENDIF COMMENTED_BY "Finds the Yampa peak flow date for this year, change if to FALSE to use May 27 which matches it with the dates that the expression slot was using..." DO
   WITH NUMERIC DaysAtPPC = "Max"( "RoundToNearestDay"( "GetNumberOfDaysAtPPC"( $ "KNN_MTOM.SpringHClass" COMMENTED_BY "CF: CRSS slot $ &quot;DailyFlows.FlamingGorgeDaily&quot; <br>" [@"t"] ) ), 1.00000000 "day" ) COMMENTED_BY "Calculate number of days that Flaming Gorge will release Power Plant Capacity (PPC), with a minimum of 1 day at PPC to meet flow recommendation, I am unsure about the minimum days in really dry years, but am using 1 for now..." DO
    WITH NUMERIC RampUpDaysToPPC = "RoundToNearestDay"( "Max"( IF ( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) <= $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" )
    THEN
     0.00000000 "day"
    ELSE
     ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" )
    ENDIF, 0.00000000 "day" ) ) COMMENTED_BY "Calculate the number of days that the flow will have to ramp to reach the PPC, or sets it to 0 if it can reach it in one jump." DO
     WITH NUMERIC RampUpToPPCRate = ( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( ( RampUpDaysToPPC / 1.00000000 "day" ) + 1.00000000 ) ) COMMENTED_BY "Calculate the up ramping rate depending on the number of days so that it evenly ramps up to PPC over those days. Will not exceed the up ramp rate limit (2000 cfs)." DO
      WITH NUMERIC RampUpDaysToBypass = "RoundToNearestDay"( "Max"( IF ( ( $ "KNN_MTOM.BypassCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) <= $ "KNN_MTOM.RampUpRateNoUnits" COMMENTED_BY "CF: CRSS slot $ &quot;FlamingGorgeData.RampUpRateNoUnits&quot; <br>" [] * 1.00000000 "cfs" )
      THEN
       0.00000000 "day"
      ELSE
       ( $ "KNN_MTOM.BypassCapacity" COMMENTED_BY "CF: CRSS slot $ &quot;FlamingGorgeData.BypassCapacity&quot; <br>" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" )
      ENDIF, 0.00000000 "day" ) ) DO
       WITH NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - 2700.00000000 "cfs" ) / ( $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs" ) * 1.00000000 "day" ) DO
        WITH NUMERIC DaysAtBypass = "RoundToNearestDay"( "GetDaysAtBypass"( $ "KNN_MTOM.SpringHClass" [] ) ) DO
         WITH DATETIME FGSpringReleaseStartDate = "DateMax"( "DateMin"( "FGSpringReleaseStartDate"(  ), @"24:00:00 August 2, Current Year" - ( DaysAtPPC + RampUpDaysToPPC + DaysToDownRamp + DaysAtBypass / 2.00000000 ) COMMENTED_BY "Estimate total spring flow days...<br>" ), @"24:00:00 April 2, Current Year" ) COMMENTED_BY "Start ramping up using LTSP polynomial, but Apr 2 as a minimum to avoid breaking, and start early <br>enough to end by July 31" DO
          FOR ( DATETIME date IN DateList ) WITH LIST flows = {  } DO
           WITH NUMERIC i = ( date - @"24:00:00 April 1, Current Year" ) / 1.00000000 "day" DO
            APPEND IF ( date < startdate )
            THEN
             IF ( IsNaN $ "KNN_MTOM.FlamingGorgeDaily" [date] )
             THEN
              $ "FlamingGorge.Outflow" [@"t - 1"]
             ELSE
              $ "KNN_MTOM.FlamingGorgeDaily" [date]
             ENDIF COMMENTED_BY "CF: Change to use Outflow @ t-1 if Flaming Gorge Daily has not been calculated.   <br>"
            ELSE
             IF ( ( date < FGSpringReleaseStartDate ) COMMENTED_BY "Before Spring Releases start continue at base flows for the ULDE in March and April that will meet ULDE on May 1" )
             THEN
              $ "FlamingGorge.Outflow" [@"t - 1"] COMMENTED_BY "CF: Change from a IF April use Outflow[@March&rcub; Else Outflow[@April]  <br>"
             ELSE
              IF ( ( date < FGSpringReleaseStartDate + RampUpDaysToPPC ) COMMENTED_BY "Ramping period up to Flaming Gorge PPC Release (or max release if below PPC)" )
              THEN
               "Min"( ( GET @INDEX i - 1.00000000 FROM flows ) + RampUpToPPCRate, "MaxItem"( { $ "FlamingGorgeData.PowerPlantCapacity" [] , "CheckJensen"(  ) , "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) } ) COMMENTED_BY "Release PPC or volume necessary to stay below max PE. Also Check Jensen. <br>" )
              ELSE
               IF ( "CountDaysAboveThreshold"( flows, $ "KNN_MTOM.BypassCapacity" [] ) < DaysAtBypass )
               THEN
                "Min"( ( GET @INDEX i - 1.00000000 FROM flows ) + $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs", "MaxItem"( { $ "KNN_MTOM.BypassCapacity" [] , "CheckJensen"(  ) , "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) } ) COMMENTED_BY "Release bypass capacity or volume necessary to stay below max PE. Also check Jensen. <br>" ) COMMENTED_BY "Ramps up and continues at Bypass Cap until it has been at Bypass Cap for enough days"
               ELSE
                IF ( "CountDaysAboveThreshold"( flows, $ "FlamingGorgeData.PowerPlantCapacity" [] ) < DaysAtPPC )
                THEN
                 "Max"( ( GET @INDEX i - 1.00000000 FROM flows ) - $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs", "Max"( $ "FlamingGorgeData.PowerPlantCapacity" [], "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) ) COMMENTED_BY "Downramps to base flows unless inflows will increase FG above max PE.<br>Releases volume necessary to stay below max PE." ) COMMENTED_BY "Ramps down from bypass (if it was there) then continues at PPC until it has been above PPC for enough days"
                ELSE
                 "Max"( ( GET @INDEX i - 1.00000000 FROM flows ) - $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" COMMENTED_BY "CF: CRSS slot $ &quot;FlamingGorgeData.BaseFlowMagnitudeLimits&quot; <br>" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs", "MaxItem"( { "GetFGBaseFlowMagnitude"(  ) COMMENTED_BY "CF: GetFGBaseFlowMagnitude() was missing from IF after downramp statement. Fixed.    <br>" , "CheckJensen"(  ) , "FGTargetHWGivenInflowOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) } ) COMMENTED_BY "Releases base flows or volume necessary to stay below max PE.Also check Jensen. <br>" ) COMMENTED_BY "Ramps down from PPC and then continues at the new base flow which is newly calculated each month"
                ENDIF
               ENDIF
              ENDIF
             ENDIF
            ENDIF ONTO flows
           ENDWITH
          ENDFOR
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH DO
   FOR ( DATETIME date IN DateList ) WITH LIST DateFlowList = {  } DO
    APPEND { date , GET @INDEX ( date - @"24:00:00 April 1, Current Year" ) / 1.00000000 "day" FROM FlowList } ONTO DateFlowList
   ENDFOR COMMENTED_BY "This links together the date and flow in a list of 2 item lists..... e.g., &lcub;...,(5/1/12, 1200 cfs), (5/2/12, 1300 cfs), etc...&rcub;"
  ENDWITH
 ENDWITH;

    END
    UUID "{1a13f595-2959-4baf-8537-ab64e450a548}";;

    FUNCTION       "FGConstrainedOutflow" ( NUMERIC UnconstrainedOutflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguements: NUMERIC UnconstrainedOutflow<br><br>Description: Applys a Max Constraint to any Outflow supplied in the arguement of all the water FG can release.  <br><br>Returns: The constrained outflow.  ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MAX_CONSTRAINT "SolveOutflow"( % "FlamingGorge", $ "FlamingGorge.Inflow" [@"t"], $ "UBRuleCurveData.ReservoirData" ["FlamingGorge", "inactiveCapacityStorage"], $ "FlamingGorge.Storage" [@"t - 1"], @"t" );
    NOTES          "CF, 20181212: Added to allow running VIC hydrology.";
    BEGIN

      UnconstrainedOutflow;

    END
    UUID "{2f0fc7ca-dfc1-4967-8d65-1a2805b6c7da}";;

    FUNCTION       "TargetHWGivenInflowOneMonth" ( OBJECT Res, DATETIME TargetBeginDate, DATETIME TargetEndDate, NUMERIC TargetPE, NUMERIC TotalInflow, NUMERIC PrvStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "ARGUMENTS<br>1. OBJECT Res<br>2. DATETIME TargetBeginDate, first timestep for flow calculation<br>3.DATETIME TargetEndDate, last timestep<br>3.NUMERIC TargetPE, PE to achieve at TargetEndDate<br>5. NUMERIC TotalInflow - Total inflow occuring between TargetBeginDate and TargetEndDate. Passed as argument to allow use of functions rather than Slot.Inflow<br><br>DESCRIPTION: This function returns the release for the current month to attain the specified pool elevation value, &quot;TargetPE&quot;, at &quot;TargetEndDate&quot; based on a water balance using &quot;TotalInflow&quot; and evaporation. Can handle one timestep periods (Begin = End) or longer. This is meant to be a generic version of the predefined function targetHWgiveninflow.<br><br>RETURNS: Monthly outflow rate [L^3/T]<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF,20190109: New mass balance function called by GetFGBaseFlowMagnitudeUnconstrained which accounts for evaporation. Replaces old ...forOneMonth() function. This is more generic.<br><br>AUTHOR, DATE:  CF,20190109";
    BEGIN

      "VolumeToFlow"( ( PrvStorage - "ElevationToStorage"( Res, TargetPE ) + TotalInflow ), TargetEndDate );

    END
    UUID "{f0d15fdd-8da5-4654-ac7a-30810f6926b5}";;

    FUNCTION       "FGTargetHWGivenInflowOneMonth" ( NUMERIC TargetPE )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "ARGUMENTS<br>NUMERIC TargetPE, PE to achieve at TargetEndDate<br><br>DESCRIPTION: This function returns the release for the current month to attain the specified pool elevation value, &quot;TargetPE&quot;. New fct FGTargetHWGivenInflowOneMonth() w/ only 1 PE arguement now calls generic TargetHWGivenInflowOneMonth() to improve readability   <br><br>RETURNS: Monthly outflow rate [L^3/T]<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF,20190109: New mass balance function called by GetFGBaseFlowMagnitudeUnconstrained which accounts for evaporation. Replaces old ...forOneMonth() function. This is more generic.<br><br>AUTHOR, DATE:  CF,20190109";
    BEGIN

      "TargetHWGivenInflowOneMonth"( % "FlamingGorge", @"t - 1", @"t", TargetPE COMMENTED_BY "CF: Prv fct (TargetHWGivenInflowforOneMonth) just took in Elevation but this matches <br>TargetHW arguements and is more explicit.   <br>", "FlowToVolume"( $ "FlamingGorge.Inflow" COMMENTED_BY "CF: CRSS slot ForecastData.FlamingGorgeInflow <br>" [], @"t" ) COMMENTED_BY "CF: MTOM's unregulated inflow accounts for the evaporation and upstream delta storage <br>therefore it does not need to include EstimateEvaporation like CRSS. <br>", $ "FlamingGorge.Storage" [@"t - 1"] );

    END
    UUID "{391323d4-033d-4a07-8efa-8347e14cbd9d}";;

    FUNCTION       "GetDaysAtBypass" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguments: None<br><br>Description: The function determines the number of days Flaming Gorge will bypass based on hydrologic class. <br><br>-In wet years Flaming Gorge will always bypass.  <br>-In dry years Flaming Gorge will never bypass.  <br>-In the other three year types, Flaming Gorge will bypass if conditions on the Yampa River warrant bypassing water to try and meet the wetter targets at Jensen (18600 cfs).   <br> <br>Yampa must be above 10000 (calculated by DaysAboveThreshold) for a length of time greater than or equal to the values in YampaDaysAbove10000ForBypass for Flaming Gorge to bypass water. If this is the case then GetNumberOfDaysAtBypass is used to determine the number of days at bypass. This is a function of both the year type on the Yampa and the year type on the Green/at Flaming Gorge as determined by the Compute Percent Exceedance rule.  <br><br>In previous versions of CRSS, Flaming Gorge would only bypass when the Yampa was flowing at 14000 cfs for enough days to meet the 22600 flow target at Jensen. The 22600 cfs flow target has a shorter duration than the 18600 cfs target, therefore under certain hydrologies this updated version will function differently than previous versions of CRSS. <br><br>Returns: the number of days Flaming Gorge will bypass.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF,20190204: Imported from CRSS. <br>";
    BEGIN

      WITH NUMERIC MaxBypassDays = "Max"( "RoundToNearestDay"( ( $ "FlamingGorge.Storage" [@"t - 1"] - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ) + "PredictedFGInflow"( @"t", @"24:00:00 August Max DayOfMonth, Next Year" ) ) / "GetMaxOutflowGivenHW"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [], @"t" ) ), 0.00000000 "day" ) DO
  IF ( $ "KNN_MTOM.SpringHClass" [] < 4.00000000 AND $ "KNN_MTOM.SpringHClass" [] > 0.00000000 )
  THEN
   IF ( "DaysAboveThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ), 10000.00000000 "cfs" ) >= $ "FlamingGorgeData.YampaDaysAbove10000ForBypass" [$ "KNN_MTOM.SpringHClass" [], 0.00000000] )
   THEN
    "GetNumberOfDaysAtBypass"( $ "KNN_MTOM.SpringHClass" [] )
   ELSE
    0.00000000 "day"
   ENDIF
  ELSE
   IF ( $ "KNN_MTOM.SpringHClass" [] == 0.00000000 )
   THEN
    0.00000000 "day" COMMENTED_BY "In Dry years never bypass"
   ELSE
    "Max"( "GetNumberOfDaysAtBypass"( $ "KNN_MTOM.SpringHClass" [] ), MaxBypassDays ) COMMENTED_BY "In wet years always bypass."
   ENDIF
  ENDIF
 ENDWITH COMMENTED_BY "Are we in Mod Dry, Ave, or Mod Wet?";

    END
    UUID "{2ce190d2-8209-4dd5-a6a6-b95e86c5cb2c}";;

    FUNCTION       "GetNumberOfDaysAtBypass" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguements: Current hydrologic year classification <br><br>Description: Funciton ensures that the days at power plant capacity calculated by GetNumberOfDaysAtBypassUnconstrained fall within the limits of the current hydrolocic classification<br><br>Returns: Number of days ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF,20190204: Imported from CRSS. <br>";
    BEGIN

      IF ( "GetNumberOfDaysAtBypassUnconstrained"( Class ) < $ "FlamingGorgeData.DaysAtBypass" [Class, 0.00000000] )
 THEN
  $ "FlamingGorgeData.DaysAtBypass" [Class, 0.00000000]
 ELSE
  IF ( "GetNumberOfDaysAtBypassUnconstrained"( Class ) > $ "FlamingGorgeData.DaysAtBypass" [Class, 1.00000000] )
  THEN
   $ "FlamingGorgeData.DaysAtBypass" [Class, 1.00000000]
  ELSE
   "GetNumberOfDaysAtBypassUnconstrained"( Class )
  ENDIF
 ENDIF COMMENTED_BY "Ensure that the days at power plant capacity fall within the <br>limits ofthe current hydrolocic classification";

    END
    UUID "{67cda824-64ee-4ef3-b6ef-781afcdf0869}";;

    FUNCTION       "GetNumberOfDaysAtBypassUnconstrained" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguements: Current hydrologic year classification <br><br>Description: Funciton interpolates to find the number of days at by pass capacity based on the spring flow percentage exceedence and the EIS mandated limits for the current hydrolocic classification<br><br>Returns: Number of days ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CF,20190204: Imported from CRSS. ";
    BEGIN

      "Interpolate"( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 0.00000000], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtBypass" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtBypass" [Class, 0.00000000] );

    END
    UUID "{bcdfcd21-30e7-44ed-9d2d-efd60ac222c2}";;

    FUNCTION       "CheckJensen" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "ARGUMENTS<br>None<br><br>DESCRIPTION: New fct CheckJensen() replaces Max(FG.BaseFlowMagLimits-Minitem(YampaDepleted)),MinFlow) to improve readability.<br><br>RETURNS: Monthly outflow rate [L^3/T]";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( ( $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 2.00000000] - "MinItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"t", @"24:00:00 July 31, Current Year" ) ) ), $ "FlamingGorgeData.MinFlow" [] );

    END
    UUID "{aff436d3-f110-40ec-849d-fe86cdec218b}";;

  END
  UUID "{415c2fa2-80ea-4bcc-a815-430c9b53df93}";;

  UTILITY_GROUP "KNNFunctions";
  DESCRIPTION   "The groups supports daily modeling of FG operations. ";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "ChooseIndexYearRatio" ( NUMERIC aprRatio, NUMERIC mayRatio, NUMERIC junRatio, NUMERIC julRatio )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function selects an index year from the K nearest neighbors in the historical record. The distance calculation between years is based on the monthly volume ratios to the seasonal volume<br><br>RETURNS: Historical year as a number, not a date [NONE]<br><br>ARGUMENTS:<br>1. NUMERIC aprRatio - the April proportion of the seasonal (April-July) volume<br>2. NUMERIC mayRatio - the May proportion of the seasonal volume<br>3. NUMERIC junRatio - the June proportion of the seasonal volume<br>4. NUMERIC julRatio - the July proportion of the seasonal volume<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      GET @INDEX WHILE ( NOT $ "KNN_MTOM.randomNum" [@"24:00:00 December Max DayOfMonth, Current Year"] <= $ "KNN_MTOM.CumulativeSumW" [i, 0.00000000] ) WITH NUMERIC i = 0.00000000 DO
  i + 1.00000000
 ENDWHILE COMMENTED_BY "Select the index year based on the current year's random number" FROM "FindKNNFromRatios"( aprRatio, mayRatio, junRatio, julRatio );

    END
    UUID "{99792043-0230-4c96-9904-0139bbac36cf}";;

    FUNCTION       "FindKNNFromRatios" ( NUMERIC aprRatio, NUMERIC mayRatio, NUMERIC junRatio, NUMERIC julRatio )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function creates a list of the K historical years that are nearest to the year with the monthly ratios specified by the input arguments<br><br>RETURNS: List of lists of the form &lcub;&lcub;Year, Distance&rcub;&rcub;<br><br>ARGUMENTS:<br>1. NUMERIC aprRatio - the April proportion of the seasonal (April-July) volume<br>2. NUMERIC mayRatio - the May proportion of the seasonal volume<br>3. NUMERIC junRatio - the June proportion of the seasonal volume<br>4. NUMERIC julRatio - the July proportion of the seasonal volume<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST sortedYears = "SortPairsAscending"( FOR ( LIST yrVol IN "GetYearsAndRatios"(  ) ) WITH LIST result = {  } DO
  ( APPEND { GET @INDEX 0.00000000 FROM yrVol , "Exp"( ( aprRatio - GET @INDEX 1.00000000 FROM yrVol ) ^ 2.00000000 + ( mayRatio - GET @INDEX 2.00000000 FROM yrVol ) ^ 2.00000000 + ( junRatio - GET @INDEX 3.00000000 FROM yrVol ) ^ 2.00000000 + ( julRatio - GET @INDEX 4.00000000 FROM yrVol ) ^ 2.00000000, 0.50000000 ) } ONTO result ) COMMENTED_BY "Create the list element &lcub;Year, Distance measure&rcub;"
 ENDFOR ) COMMENTED_BY "Create a list with elements &lcub;Year, Distance measure&rcub; for each historic year that is sorted from the smallest to largest distance" DO
  FOR ( NUMERIC val IN "GetNumbers"( 0.00000000, $ "KNN_MTOM.K" [] - 1.00000000, 1.00000000 ) ) WITH LIST result = {  } DO
   APPEND GET @INDEX val FROM sortedYears ONTO result
  ENDFOR COMMENTED_BY "Create a new list with only the K nearest historical years"
 ENDWITH;

    END
    UUID "{7bd300ba-e160-482c-a19c-b7595333ab48}";;

    FUNCTION       "GetCurrentMonthlyNaturalInflow" ( DATETIME month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the monthly flow volume for the month specified in the input argument of the current year (when this function is called from the rule Set Yampa Daily Natural - Second Stage Disagg, the input argument is actually a date, not a month)<br><br>RETURNS: Flow volume for month [L^3]<br><br>ARGUMENTS:<br>1. DATETIME month<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH DATETIME currentMonth = "GetDate"( "GetMonthAsString"( month ) CONCAT ",current year" ) DO
  "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [currentMonth], currentMonth )
 ENDWITH;

    END
    UUID "{6ef7c824-38ad-4899-812e-62d8efe18629}";;

    FUNCTION       "GetCurrentYearDailyList" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function generates a list of the dates within the KNN StartMonth to EndMonth period (currently April-July) for the current year<br><br>RETURNS: List of dates<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170714: Implemented Heather P.'s changes that use predefined functions to streamline the code and remove older CONCAT statements for constructing dates";
    BEGIN

      "GetDates"( "CompletePartialDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ), "CompletePartialDate"( @"Min DayOfMonth", @"t" ) ), "CompletePartialDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ), "CompletePartialDate"( @"Max DayOfMonth", @"t" ) ), "1 days" );

    END
    UUID "{dc5da988-06d5-4c46-8ef6-fb7a181eb304}";;

    FUNCTION       "GetIndexYearDailyList" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function generates a list of the dates within the KNN StartMonth to EndMonth period (currently April-July) for the KNN index year<br><br>RETURNS: List of dates (days) <br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170714: Implemented Heather P.'s changes that use predefined functions to streamline the code and remove some older CONCAT statements for constructing dates";
    BEGIN

      "GetDates"( "CompletePartialDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ), "CompletePartialDate"( "NumberToYear"( $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"] ), @"24:00:00 December 31" COMMENTED_BY "The month doesn't matter here, it just needs a month to be valid <br>" ) ), "CompletePartialDate"( "NumberToYear"( $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"] ), "GetDate"( "24:00:00" CONCAT ( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT " Max DayOfMonth" ) ) ), "1 days" );

    END
    UUID "{7882d699-3853-4cc0-aa2c-fa9afd807abd}";;

    FUNCTION       "GetMonthlyProportionVector" ( DATETIME month )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates each day's volume proportion of the monthly volume (for the month passed as an input argument) for the historical index year<br><br>RETURNS: List of proportion values [NONE]<br><br>ARGUMENTS:<br>1. DATETIME month - month for which the proportions are needed<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST days = "GetDates"( "GetDate"( "GetMonthAsString"( month ) CONCAT "1, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"], "." ) ), "GetDate"( ( "GetMonthAsString"( month ) CONCAT " " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( month ), "." ) ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"], "." ) ), "1 DAYS" ) COMMENTED_BY "Generate list of days in month for historical index year" DO
  WITH NUMERIC monthlyVolume = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeDaily", GET @INDEX 0.00000000 FROM days, GET @INDEX ( LENGTH days ) - 1.00000000 FROM days ) DO
   FOR ( DATETIME day IN days ) WITH LIST propVec = {  } DO
    ( APPEND ( $ "KNN_MTOM.DeerlodgeDaily" [day] * 24.00000000 "hour" ) / monthlyVolume ONTO propVec ) COMMENTED_BY "Calculate each day's volume proportion and append to result list"
   ENDFOR
  ENDWITH
 ENDWITH;

    END
    UUID "{24ebe7b8-3e0b-43db-aad9-f671f078ea33}";;

    FUNCTION       "GetProportionVector" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates each day's volume proportion of the total spring volume for the historical index year<br><br>RETURNS: List of proportion values [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC sprVol = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeDaily", GET @INDEX 0.00000000 FROM "GetIndexYearDailyList"(  ), GET @INDEX ( LENGTH "GetIndexYearDailyList"(  ) ) - 1.00000000 FROM "GetIndexYearDailyList"(  ) ) COMMENTED_BY "Calculate the spring period volume for the historical index year" DO
  FOR ( DATETIME day IN "GetIndexYearDailyList"(  ) ) WITH LIST propVec = {  } DO
   APPEND "FlowToVolume"( $ "KNN_MTOM.DeerlodgeDaily" [day], day ) / sprVol ONTO propVec
  ENDFOR COMMENTED_BY "Calculate each day's proportion of the spring volume"
 ENDWITH;

    END
    UUID "{0074f1bc-4aab-45a7-888c-676c48a3fe89}";;

    FUNCTION       "GetRandSeed" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns a seed for use by the Random or RandomNormal function. The seed is incremented by the trace number, as stored in the first timestep of the Hydrology Increment slot. The trace number could be available as a RPL function, but would not be enough to fulfill our requirements.<br><br>In the current setup, all MRM runs will have the same set of random numbers at the same trace, but all traces will have different sets, as controlled by the Hydrology Increment slot, which is rotated with the MRM runs.<br>This also allows single trace runs to have identical random numbers generated as well, which is not possible with a RPL function.<br><br>Probably should rename the Hydrology Increment slot to Trace Number.<br><br>With Random Seed = 1, is equivalent to just using the Trace Number as the seed for each trace.<br><br>RETURNS: Number used as seed for Random or RandomNormal function [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170504: The above description predates the use of this uniform documentation format.";
    BEGIN

      ( $ "KNN_MTOM.Random Seed" [] + ( $ "KNN_MTOM.hydrologyIncrement" [@"Start Timestep"] - 1.00000000 ) );

    END
    UUID "{b82a2262-4926-4732-9ad7-60bb9238a592}";;

    FUNCTION       "GetSecondStageProportionVector" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates each day's volume as a proportion of its respective month's volume, based on the same proportions from the historical index year, for the April-July period of the current year<br><br>RETURNS: List of numeric proportions [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME month IN "GetDates"( @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year", "1 MONTHS" ) ) WITH LIST propVec = {  } DO
  WITH LIST monthlyProp = "GetMonthlyProportionVector"( month ) COMMENTED_BY "Calculate the month's daily proportion vector" DO
   FOR ( NUMERIC dayProp IN monthlyProp ) WITH LIST result = propVec DO
    APPEND dayProp ONTO result
   ENDFOR COMMENTED_BY "Loop through the month's vector and append elements to final result list"
  ENDWITH
 ENDFOR COMMENTED_BY "Loop through each month in the April-July period";

    END
    UUID "{bc275580-8670-4b81-b1a4-1e1fe19ba1df}";;

    FUNCTION       "GetSpringVolume" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculate the total volume of Yampa_at_Deerlodge for the KNN StartMonth to EndMonth (currently April-July) period<br><br>RETURNS: Flow volume for Yampa_at_Deerlodge [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", "GetDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ) CONCAT ",current year" ), "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ",current year" ) );

    END
    UUID "{d9baf231-40c8-4a0f-bcd3-316090ffe94c}";;

    FUNCTION       "GetYearsAndRatios" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: For each year in the historical record, this function calclulates each month's proportion of the total April-July Yampa flow volume<br><br>RETURNS: List of lists of the form &lcub;&lcub;Year, Apr proportion, May proportion, June proportion, July proportion&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC year IN "GetNumbers"( "GetYear"( "NumberToDate"( $ "KNN_MTOM.HistoricalStartYear" [] ) ), "GetYear"( "NumberToDate"( $ "KNN_MTOM.HistoricalEndYear" [] ) ), 1.00000000 ) ) WITH LIST result = {  } DO
  WITH NUMERIC seasonalVol = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeMonthly", "GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ), "GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) DO
   APPEND { year , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "May, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "May, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "June, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "June, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol } ONTO result
  ENDWITH COMMENTED_BY "Calculate the year's April-July volume"
 ENDFOR COMMENTED_BY "Loop over list of historical years";

    END
    UUID "{3421e235-5589-41ee-82aa-aaf502c408c0}";;

  END
  UUID "{d46ce5a8-519b-4a78-bc44-3592bab88f5a}";;

  UTILITY_GROUP "Fontenelle Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "FontenelleMonthlyOutflow" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION:This function returns a monthly outflow for Fontenelle reservoir based on the monthly logic that has always been in the MTOM model.  There are various constraints for some months where the logic is specified for that month and for those months that are not specified, the outflow is set to the outflow of the month before.  All of the monthly flows are constrained to the Min and Max constraints that are conditioned into the function and can be viewed when the &quot;Post-Exec. Checks&quot; box is checked.  <br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Minimum monthly release; release to reach maximum pool elevation; safe channel capacity; release to reach minimum pool elevation";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT "MaxItem"( { $ "FontenelleData.PeriodicMinFlow" [] , "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) } ) COMMENTED_BY "Must release at least the monthly minimum rate and enough to ensure pool elevation does not exceed maximum";
    MAX_CONSTRAINT IF ( ( "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) < 0.00000000 "acre-ft/month" ) COMMENTED_BY "Reservoir can accept all inflow without exceeding maximum capacity" )
 THEN
  "Min"( $ "FontenelleData.SafeChannelCapacity" [], "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MinElevation_FullRecord" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) ) COMMENTED_BY "Maximum is either the SafeChannelCapacity or outflow to reach the minimum elevation"
 ELSE
  "Max"( $ "FontenelleData.SafeChannelCapacity" [], "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) ) COMMENTED_BY "Maximum is either the SafeChannelCapacity or outflow to reach the maximum elevation"
 ENDIF;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 5/11/2015<br><br>TP, 5/11/2015: This rule replaces a series of 11 other rules that made similar checks.<br><br>MC, 20160816: Corrected the date of the beginning pool elevations in the ElevationToStorage functions for April, September, and December from @&quot;t&quot; to @&quot;t-1&quot;, and changed the time periods in the denominators of those months' calculations from a number of months to a difference of dates, which more accurately calculates the periods in question since &quot;month&quot; in RW is 31 days. Other possible modifications discussed with Lee T. before she left are: 1) changing the recalculation of winter flows from December to October to better reflect actual operations; 2) changing the minimum elevation to 6,465 feet because 6,468 feet is not a hard boundary (leaving the target at 6,468 ft but changing the min elevation to 6,465 ft allows some flexibility in the model that reflects actual operations); 3) adding an estimate of evaporation to the above months' flow calculations (doesn't make much difference); 4) making the minimum flow values periodic and variable throughout the year<br><br>MC, 20170508: All of the changes discussed in the above comment were in place by the April 2017 MTOM run<br><br>S.Baker, 2018/11/26: There was a lower minimum elevation in Fontenelle from 1985-1989. To enable the testbed to simulate Fontenelle's operations closer to the historical operations, a new expression slot was added to account for a lower minimum elevation during this period. The expression slot would check the date to see if it falls in the 1985-1989 time frame and use the lower minimum elevation if it does. This would cause no changes to the current operation of Fontenelle.  Change - Replaced &quot;FontenelleData.MinElevation&quot; in the Max Constraint of the Post-Execution Checks to use the scalar slot ?FontenelleData.MinElevation_FullRecord?.  This new slot sets a lower minimum elevation for 1985-1989 when Fontenelle was drawn down. ";
    BEGIN

      WITH NUMERIC June1Target = 6480.00000000 "feet" DO
  IF ( "MonthIs"( { "July" } ) )
  THEN
   "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] ) COMMENTED_BY "Set the July Outflow to be such that the August 1 Pool Elevation target is met"
  ELSE
   IF ( "MonthIs"( { "June" } ) )
   THEN
    IF ( $ "Fontenelle.Pool Elevation" [] > $ "FontenelleData.July1Target" [] )
    THEN
     "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] )
    ELSE
     "FontenelleTargetFlow"( $ "FontenelleData.July1Target" [] )
    ENDIF COMMENTED_BY "Release flows such that the July target is met unless the current pool elevation<br>is currently above the July pool elevation target, then release for the August 1<br>target"
   ELSE
    IF ( "MonthIs"( { "April" } ) )
    THEN
     "Min"( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.July1Target" [] ) + ( "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 2" ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.July1Target" [] ), @"t - 1", @"t + 2" ) ) ) / ( @"24:00:00 June Max DayOfMonth, Current Year" - @"24:00:00 March Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Steady release over April, May and June to meet July1 Target", "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ) COMMENTED_BY "Power Plant Capacity" )
    ELSE
     IF ( "MonthIs"( { "August" } ) )
     THEN
      "Min"( "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ), $ "Fontenelle.Outflow" [@"t - 1"] )
     ELSE
      IF ( "MonthIs"( { "October" } ) )
      THEN
       ( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 5" ) ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ), @"t - 1", @"t + 5" ) ) / ( @"24:00:00 March Max DayOfMonth, Next Year" - @"24:00:00 September Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Compute the steady flow over December to March necsessary to meet Apr 1 target. Change in storage plus forecasted volume divided by 4 months. The next 3 months will look back at this value."
      ELSE
       IF ( "MonthIs"( { "September" } ) )
       THEN
        ( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 6" ) ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ), @"t - 1", @"t + 6" ) ) / ( @"24:00:00 March Max DayOfMonth, Next Year" - @"24:00:00 August Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Compute the steady flow over September to March necsessary to meet Apr 1 target. Change in storage plus forecasted volume divided by 3 months.  The next two months will look back at this value."
       ELSE
        IF ( "MonthIs"( { "May" } ) )
        THEN
         "Max"( $ "Fontenelle.Outflow" [@"t - 1"], "SolveOutflow"( % "Fontenelle", % "Fontenelle" & "Inflow" [@"t"], "ElevationToStorage"( % "Fontenelle", June1Target ), "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ), @"t" ) )
        ELSE
         $ "Fontenelle.Outflow" [@"t - 1"]
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END
    UUID "{953a1967-db48-452c-a7c7-879b2acd5339}";;

    FUNCTION       "FontenelleTargetFlow" ( NUMERIC Elevation )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Determines the target outflow for Frontenelle. The outflow is either the maximum possible outflow given the inflow, or the release needed to meet the target elevation, whichever is less assuming the flow meets the power plant capacity. - ce 6/6/13<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS:<br>1. NUMERIC Elevation - the target pool elevation to reach with the outflow<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT $ "FontenelleData.MinFlow" [];
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170609: Could the maximum possible release be moved to the Post-Excecution Checks?";
    BEGIN

      "Min"( "GetMaxOutflowGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ) COMMENTED_BY "Maximum possible release from the res", "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", Elevation ), "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "Release to meet target elevation" );

    END
    UUID "{9ec34bd6-716d-4ab2-9171-8318cee7af98}";;

  END
  UUID "{982d8054-08ce-417f-b3ec-e0f02ef86827}";;

  UTILITY_GROUP "DCP and ICS Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "DCP Users" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      { "AZ" , "NV" , "CA" , "MWD" , "Coachella" , "MX" };

    END
    UUID "{6d8a55e4-b48e-4374-a4a6-6472c2f18ce9}";;

    FUNCTION       "TaxedECICS" ( NUMERIC annualCreation, NUMERIC previousDelivery )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Max"( annualCreation - previousDelivery, 0.00000000 "acre-feet" ) COMMENTED_BY "Per Section IV.A.3, Replenishment Incentive, there shall be no assement made upon the creation <br>of ECICS to the extent of the volume of EC ICS delivered to the same contractor in the preceding <br>year<br><br>AP 7/11/19  <br>";

    END
    UUID "{a6e83404-f9a3-4083-86af-ff1e3a6d9d3a}";;

    FUNCTION       "NonTaxedECICS" ( NUMERIC annualCreation, NUMERIC previousDelivery )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "Min"( annualCreation, previousDelivery ) COMMENTED_BY "Per Section IV.A.3, Replenishment Incentive, there shall be no assement made upon the creation <br>of ECICS to the extent of the volume of EC ICS delivered to the same contractor in the preceding <br>year<br><br>AP 7/11/19  <br>";

    END
    UUID "{692236dd-d545-45fb-968d-b35496cae6db}";;

    FUNCTION       "Current Year EC ICS Creation" ( NUMERIC AnnualCreation, NUMERIC PreviousDelivery, STRING State )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( "TaxedECICS"( AnnualCreation, PreviousDelivery ) * "SystemTaxAdjustment_DCP"(  ) + "NonTaxedECICS"( AnnualCreation, PreviousDelivery ) ) + IF ( State == "Nevada" )
 THEN
  $ "ICS Credits.ImportedICS_NV" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.TributaryICS_NV" [@"24:00:00 December 31, Previous Year"]
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

    END
    UUID "{eac40aed-9d69-40d5-bf49-2974b9138165}";;

    FUNCTION       "CAWCD Requested ICS" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( $ "ICS Credits.AnnualICSDelivery_CAWCD" [@"24:00:00 December 31, Current Year"] + "CAWCD Mitigation Water"(  ) + "CAWCD DCP ICS Delivery"(  ) + "CAWCD Post 2026 ICS Delivery"(  ) ) COMMENTED_BY "Not used in MTOM but in 24 MS. Should this be deleted? <br>";

    END
    UUID "{33f11602-8300-4c10-8ade-5bf2495fc704}";;

    FUNCTION       "CAWCD Mitigation Water" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] <= 2.00000000 AND $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] >= 1.00000000 )
 THEN
  $ "ICS Credits.CAWCD Mitigation Water" []
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

    END
    UUID "{44cfadd3-ed14-4deb-9489-7c52ef05b70f}";;

    FUNCTION       "CAWCD DCP ICS Delivery" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "DCP.RecoveryElevation" [] )
 THEN
  $ "ICS Credits.DCPICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"]
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

    END
    UUID "{22ddeac4-2ef3-4f80-b754-68ec2aa9b6bb}";;

    FUNCTION       "CAWCD Available Canal Space" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "AnnualWaterUse.CAPCanal_AnnualCapacity" [] - "Annual Volume"( $ "CAPDiversion.Total Diversion Requested" );

    END
    UUID "{7478f1a7-9e89-4d19-8daa-6825b3214a40}";;

    FUNCTION       "DeliveryAndCreationMWDICS" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the volumes of ICS delivered and EC ICS created for California, taking into account Lower Basin Demand Variability <br><br>RETURNS: List of lists of the form &lcub;&lcub;ICS delivered, EC ICS created&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20180125: Removed SystemTaxAdjustment from Annual Max in MinItem for creationOfCACEICS local variable based on USBR changes to ruleset<br>CH, 4/27/18: Changed totaldeliveryofCAICS assignment so that the available ICS water was was referencing total CA ICS, not just CA EC ICS<br>CH, 5/8/18: In MWD EC ICS creation assignment, maximum creation of MWD EC ICS edited to be CA max put - IID EC creation; in MWD ICS delivery assignment, available ICS water edited to be min of (MWD max take - IID total ICS) and (total MWD ICS + creation EC ICS*system tax) in order to separate MWD ICS creation and delivery from IID ICS creation and delivery <br>CH, 5/10/18: renamed function and internal variables to refer to MWD ICS instead of CA ICS to avoid confusion<br>AP, 4/11/19: Added constraint to make sure the deterministic run uses the default 24 MS inputs";
    BEGIN

      IF ( @"t" >= @"24:00:00 April 30, Start Year" AND @"t" <= @"24:00:00 December 31, Start Year" OR NOT "IsMRM"(  ) )
 THEN
  { $ "ICSProjectionData.AnnualDeliveryBiNat_MWD_Default" ["Dec31ofYear"( @"t" )] + $ "ICSProjectionData.AnnualDeliverySysEff_MWD_Default" ["Dec31ofYear"( @"t" )] + $ "ICSProjectionData.AnnualDeliveryEC_MWD_Default" ["Dec31ofYear"( @"t" )] + $ "ICSProjectionData.AnnualDeliveryDCPICS_MWD_Default" ["Dec31ofYear"( @"t" )] , $ "ICSProjectionData.AnnualCreationEC_MWD_Default" ["Dec31ofYear"( @"t" )] }
 ELSE
  WITH NUMERIC creationOfMWDECICS = IF ( ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR NOT "IsMRM"(  ) ) COMMENTED_BY "If a Quantified Surplus Year, a Flood Control Year, or if the run is a deterministic Min, Max or <br>Most run, do not Create any ICS TP 12/18/2017, updated for DCP AP 10/21/19<br>" )
  THEN
   0.00000000 "acre-ft"
  ELSE
   "MinItem"( { $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Put Step 1"] COMMENTED_BY "Annual Max <br>" , "Max"( ( $ "ICS Credits.MeadBankParameters" ["MWD", "Max Capacity"] - ( $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.BiNationalICS_MWD" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December 31, Previous Year"] ) ), 0.00000000 "acre-ft" ) COMMENTED_BY "Account Space <br>" , ( $ "ICS Credits.MeadBankParameters" ["California", "Max Creation"] - $ "ICSProjectionData.AnnualCreationEC_IID_Default" [@"24:00:00 December 31, Current Year"] ) COMMENTED_BY "Maximum Creation of MWD ICS <br>" , "Max"( "SumFlowsToVolume"( $ "MWDDiversion:MWD.Diversion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) - $ "AnnualWaterUse.MWDMinimumAnnualDelivery" [], 0.00000000 "acre-ft" ) COMMENTED_BY "Difference between Diversion Requests and Minimum Required MWD Delivery <br>" } )
  ENDIF DO
   WITH NUMERIC totalDeliveryOfMWDICS = "ICSDeliveryReduction_DCP"( "MinItem"( { IF ( NOT "IsMRM"(  ) )
   THEN
    0.00000000 "acre-ft"
   ELSE
    IF ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) COMMENTED_BY "If the year has domestic surplus, reduce the ICS Delivery by the amount of <br>Domestic surplus entitlement for MWD. TP 12/18/2017 <br>" )
    THEN
     "Max"( ( $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] - $ "Surplus Volume Entitlements.MWD Domestic" ["Dec31ofYear"( @"t" )] ), 0.00000000 "acre-ft" )
    ELSE
     $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] COMMENTED_BY "Not Surplus or Shortage <br>"
    ENDIF COMMENTED_BY "flood control <br>"
   ENDIF , ( $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - "SumFlowsToVolume"( $ "MWDDiversion:MWD.Depletion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) ) COMMENTED_BY "MWD at full ditch (Conveyance Capacity)<br>" , "Min"( $ "ICS Credits.MeadBankParameters" ["California", "Max Take"] - ( $ "ICSProjectionData.AnnualDeliveryBiNat_IID_Default" [@"24:00:00 December 31, Current Year"] + $ "ICSProjectionData.AnnualDeliveryEC_IID_Default" [@"24:00:00 December 31, Current Year"] ), $ "ICS Credits.TotalICS_MWD" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "Make sure the amount of Delivery taken is within the MWD ICS bank or below <br>the Maximum Take that MWD can have. TP 12/18/2017  <br>" + creationOfMWDECICS * "SystemTaxAdjustment_DCP"(  ) ) COMMENTED_BY "Available ICS Water <br>" } ), "California", "Max Delivery", $ "ICS Credits.AnnualConversionECtoDCP_MWD" [@"24:00:00 December 31, Current Year"] ) DO
    { totalDeliveryOfMWDICS , creationOfMWDECICS }
   ENDWITH
  ENDWITH
 ENDIF;

    END
    UUID "{7041b37d-1172-484e-aec6-cf16887c9756}";;

    FUNCTION       "FloodControlECICSBalance" ( NUMERIC fcvolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes the passed in flood control volume and uses the resulting EC ICS volumes for each state to determine the balance for each state. Then determines a reduction ratio which is the flood control volume divided by the total EC ICS volume.  If this value is greater than 1, the flood control volume is greater than the total EC ICS volume and the resulting EC Volumes need to be set to 0 AF. If the ratio is less than one, then the EC ICS volumes need to be reduced by the ratio proportional to the volume for each state.  The function returns the volumes for each state in AF. - TP 11/4/2014<br><br>RETURNS: List of lists of the form &lcub;&lcub;CA EC balance, NV EC balance, AZ EC balance, CA Total ICS, NV Total ICS, AZ Total ICS&rcub;&rcub;<br><br>ARGUMENTS:<br>1. NUMERIC fcvolume - Flood control release rate<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 11/4/2014<br><br>12/11/18, AP: edited to include MWD / IID ICS CA split, edited to more accurately reflect ICS  flood control in interim guidlines (% ICS change)";
    BEGIN

      WITH NUMERIC mwdECICS = $ "ICS Credits.ExtraordinaryConservationICS_MWD" ["Dec31ofYear"( @"t" )] DO
  WITH NUMERIC iidECICS = $ "ICS Credits.ExtraordinaryConservationICS_IID" ["Dec31ofYear"( @"t" )] DO
   WITH NUMERIC nvECICS = $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] DO
    WITH NUMERIC cawcdECICS = $ "ICS Credits.ExtraordinaryConservationICS_CAWCD" ["Dec31ofYear"( @"t" )] DO
     WITH NUMERIC critECICS = $ "ICS Credits.ExtraordinaryConservationICS_CRIT" ["Dec31ofYear"( @"t" )] DO
      WITH NUMERIC gricECICS = $ "ICS Credits.ExtraordinaryConservationICS_GRIC" ["Dec31ofYear"( @"t" )] DO
       WITH NUMERIC mviddECICS = $ "ICS Credits.ExtraordinaryConservationICS_MVIDD" ["Dec31ofYear"( @"t" )] DO
        WITH NUMERIC wmECICS = $ "ICS Credits.ExtraordinaryConservationICS_WM" ["Dec31ofYear"( @"t" )] DO
         WITH NUMERIC totalECICS = mwdECICS + iidECICS + nvECICS + cawcdECICS + critECICS + gricECICS + mviddECICS + wmECICS DO
          WITH NUMERIC mwdOtherICS = $ "ICS Credits.TotalICS_MWD" ["Dec31ofYear"( @"t" )] - mwdECICS DO
           WITH NUMERIC iidOtherICS = $ "ICS Credits.TotalICS_IID" ["Dec31ofYear"( @"t" )] - iidECICS DO
            WITH NUMERIC nvOtherICS = $ "ICS Credits.TotalICS_NV" ["Dec31ofYear"( @"t" )] - nvECICS DO
             WITH NUMERIC cawcdOtherICS = $ "ICS Credits.TotalICS_CAWCD" ["Dec31ofYear"( @"t" )] - cawcdECICS DO
              IF ( fcvolume < totalECICS )
              THEN
               WITH LIST stateECBalLista = { mwdECICS - ( mwdECICS / totalECICS ) * fcvolume , iidECICS - ( iidECICS / totalECICS ) * fcvolume , nvECICS - ( nvECICS / totalECICS ) * fcvolume , cawcdECICS - ( cawcdECICS / totalECICS ) * fcvolume , critECICS - ( critECICS / totalECICS ) * fcvolume , gricECICS - ( gricECICS / totalECICS ) * fcvolume , mviddECICS - ( mviddECICS / totalECICS ) * fcvolume , wmECICS - ( wmECICS / totalECICS ) * fcvolume } DO
                WITH LIST totalECBalList = { mwdOtherICS + GET @INDEX 0.00000000 FROM stateECBalLista , iidOtherICS + GET @INDEX 1.00000000 FROM stateECBalLista , nvOtherICS + GET @INDEX 2.00000000 FROM stateECBalLista , cawcdECICS + GET @INDEX 3.00000000 FROM stateECBalLista } DO
                 { 0.00000000 "acre-ft" , GET @INDEX 0.00000000 FROM stateECBalLista , GET @INDEX 1.00000000 FROM stateECBalLista , GET @INDEX 2.00000000 FROM stateECBalLista , GET @INDEX 3.00000000 FROM stateECBalLista , GET @INDEX 4.00000000 FROM stateECBalLista , GET @INDEX 5.00000000 FROM stateECBalLista , GET @INDEX 6.00000000 FROM stateECBalLista , GET @INDEX 7.00000000 FROM stateECBalLista , GET @INDEX 0.00000000 FROM totalECBalList , GET @INDEX 1.00000000 FROM totalECBalList , GET @INDEX 2.00000000 FROM totalECBalList , GET @INDEX 3.00000000 FROM totalECBalList }
                ENDWITH
               ENDWITH
              ELSE
               { 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , mwdOtherICS , iidOtherICS , nvOtherICS , cawcdOtherICS } COMMENTED_BY "if the FC volume is greater than the EC ICS total delivery volume and EC ICS volume, then reduce the state values for delivery and volume to 0 AF and the total ICS volume for each state <br>will be equal to the other ICS Volumes in the system. "
              ENDIF COMMENTED_BY "If the Flood Control is greater than the delivery volume, but less than the total EC ICS volume plus the EC ICS Delivery, reduce the state EC ICS volume by the amount<br>of the Flood Control volume less the EC ICS total delivery volume. Reduce the current EC ICS volumes for each state by the ratio derived and reduce the Total ICS Volume <br>for each state by the difference each state volume of EC ICS "
             ENDWITH
            ENDWITH
           ENDWITH
          ENDWITH COMMENTED_BY "Get the Total ICS Volume for each stat minuse the EC water"
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Get the EC ICS Volumes for each state and compute <br>the total volume. ";

    END
    UUID "{7232ee59-42ea-44fa-804c-baab7f95b193}";;

    FUNCTION       "ICSAccountingForAZ" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation of the ICS categories Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat) and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total Arizona ICS Volume. <br>The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>For the delivery of AZ ICS: <br>If the projected January Lake Mead elevation is 1,100 ft or higher, then set the ICS delivery to the Total ICS Created / 10. <br> In the case that the Lower Basin is in Surplus, CAP would take delivery of 1/10 ICS Created in addition to any Surplus entitlement. <br> In cases where the projected January Lake Mead elevation is under 1,100 ft, set the delivery volume to 0 af, regardless of Normal or Shortage condition. <br><br>RETURNS: List of lists of the form &lcub;&lcub;Delivery charged to EC, Delivery charged to SE, Delivery charged to Binational, AZ EC ICS, AZ SE ICS, Binational AZ ICS, Total AZ ICS, Total AZ ICS delivery, Total AZ ICS creation&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 9/10/2014<br>CH, 4/27/18: Deleted if else statements in creation of SE and Binat ICS so that AZ is allowed to created these types of ICS even in Shortage condition (only EC ICS cannot be created during a shortage). Cleaned up list the function returns and unused with statments: only 7 out of the 9 that were included are being used. <br><br>S.Baker, 09/25/2018: Changed the Mead.Pool Elevation input to function GetProjectedPoolElevation() function instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation).<br><br>AP, 11/30/18: Changed all evap tax references  from *0.97 to the EvapTaxAdjustment function, changed all system tax references  from *0.95 to the SystemTaxAdjustment function,";
    BEGIN

      WITH NUMERIC AnnualCreationEC_CRIT = IF ( ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "Min"( $ "ICSProjectionData.AnnualCreationEC_CRIT_Default" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"], ( ( $ "ICS Credits.MeadBankParameters" ["Arizona", "Max Capacity"] - $ "ICS Credits.Bank_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) - $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) / IF ( $ "ICSProjectionData.AnnualCreationEC_CRIT_Default" [@"24:00:00 December Max DayOfMonth, Current Year"] > $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"] )
  THEN
   "SystemTaxAdjustment_DCP"(  )
  ELSE
   1.00000000
  ENDIF ) + $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"]
 ENDIF DO
  WITH NUMERIC AnnualCreationEC_GRIC = IF ( ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) )
  THEN
   0.00000000 "acre-ft"
  ELSE
   "Min"( $ "ICSProjectionData.AnnualCreationEC_GRIC_Default" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"], ( ( $ "ICS Credits.MeadBankParameters" ["Arizona", "Max Capacity"] - $ "ICS Credits.Bank_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) - $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year EC ICS Creation"( AnnualCreationEC_CRIT, $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) ) / IF ( $ "ICSProjectionData.AnnualCreationEC_GRIC_Default" [@"24:00:00 December Max DayOfMonth, Current Year"] > $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"] )
   THEN
    "SystemTaxAdjustment_DCP"(  )
   ELSE
    1.00000000
   ENDIF ) + $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"]
  ENDIF DO
   WITH NUMERIC AnnualCreationEC_CAWCD = IF ( ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "Min"( $ "ICSProjectionData.AnnualCreationEC_CAWCD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"], ( ( $ "ICS Credits.MeadBankParameters" ["Arizona", "Max Capacity"] - $ "ICS Credits.Bank_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) - $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"] + ( "Current Year EC ICS Creation"( AnnualCreationEC_CRIT, $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) + "Current Year EC ICS Creation"( AnnualCreationEC_GRIC, $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) ) ) / IF ( $ "ICSProjectionData.AnnualCreationEC_CAWCD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"] > $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] )
    THEN
     "SystemTaxAdjustment_DCP"(  )
    ELSE
     1.00000000
    ENDIF ) + $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"]
   ENDIF DO
    WITH NUMERIC AnnualCreationEC_MVIDD = IF ( ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) )
    THEN
     0.00000000 "acre-ft"
    ELSE
     $ "ICSProjectionData.AnnualCreationEC_MVIDD_Default" [@"24:00:00 December Max DayOfMonth, Current Year"]
    ENDIF DO
     WITH NUMERIC AnnualCreationEC_WM = IF ( ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) )
     THEN
      0.00000000 "acre-ft"
     ELSE
      $ "ICSProjectionData.AnnualCreationEC_WM_Default" [@"24:00:00 December Max DayOfMonth, Current Year"]
     ENDIF DO
      WITH NUMERIC AnnualCreationSysEff_AZ = $ "ICS Credits.AnnualCreationSysEff_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
       WITH NUMERIC AnnualCreationEC_AZ = ( AnnualCreationEC_CAWCD + AnnualCreationEC_CRIT + AnnualCreationEC_GRIC + AnnualCreationEC_MVIDD + AnnualCreationEC_WM ) DO
        WITH NUMERIC AnnualCreationBiNat_AZ = $ "ICS Credits.AnnualCreationBiNat_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
         WITH NUMERIC AnnualDeliverySysEff_AZ = $ "ICS Credits.AnnualDeliverySysEff_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
          WITH NUMERIC AnnualDeliveryEC_AZ = ( $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] + $ "ICS Credits.AnnualDeliveryEC_WM" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
           WITH NUMERIC AnnualDeliveryBiNat_AZ = $ "ICS Credits.AnnualDeliveryBiNat_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
            WITH NUMERIC AnnualDeliveryDCP_AZ = $ "ICS Credits.AnnualDeliveryDCP_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
             WITH NUMERIC ECICS_CRIT = ( $ "ICS Credits.ExtraordinaryConservationICS_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year EC ICS Creation"( AnnualCreationEC_CRIT, $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) - $ "ICS Credits.AnnualDeliveryEC_CRIT" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
              WITH LIST AZFiming = "AZ Firming Agreement"(  ) DO
               WITH NUMERIC FirmingBalanceAZ = $ "ICS Credits.FirmingAgreementBalance_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] - GET @INDEX 1.00000000 FROM AZFiming DO
                WITH NUMERIC FirmingBalanceUS = $ "ICS Credits.FirmingAgreementBalance_US" [@"24:00:00 December Max DayOfMonth, Previous Year"] - GET @INDEX 2.00000000 FROM AZFiming DO
                 WITH NUMERIC ECICS_GRIC = ( $ "ICS Credits.ExtraordinaryConservationICS_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year EC ICS Creation"( AnnualCreationEC_GRIC, $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) - $ "ICS Credits.AnnualDeliveryEC_GRIC" [@"24:00:00 December 31, Current Year"] ) - GET @INDEX 0.00000000 FROM AZFiming DO
                  WITH NUMERIC ECICS_CAWCD = ( $ "ICS Credits.ExtraordinaryConservationICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year EC ICS Creation"( AnnualCreationEC_CAWCD, $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) - $ "ICS Credits.AnnualDeliveryEC_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
                   WITH NUMERIC ECICS_MVIID = ( $ "ICS Credits.ExtraordinaryConservationICS_MVIDD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year EC ICS Creation"( AnnualCreationEC_MVIDD, $ "ICS Credits.AnnualDeliveryEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) - $ "ICS Credits.AnnualDeliveryEC_MVIDD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
                    WITH NUMERIC ECICS_WM = ( $ "ICS Credits.ExtraordinaryConservationICS_WM" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year EC ICS Creation"( AnnualCreationEC_WM, $ "ICS Credits.AnnualDeliveryEC_WM" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Arizona" ) - $ "ICS Credits.AnnualDeliveryEC_WM" [@"24:00:00 December 31, Current Year"] ) DO
                     WITH NUMERIC ECICS_AZ = ECICS_CRIT + ECICS_GRIC + ECICS_CAWCD + ECICS_MVIID + ECICS_WM DO
                      WITH NUMERIC BiNat_CAWCD = ( $ "ICS Credits.BiNationalICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryBiNat_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
                       WITH NUMERIC BiNat_AZ = BiNat_CAWCD DO
                        WITH NUMERIC SysEff_CAWCD = ( $ "ICS Credits.SystemEfficiencyICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationSysEff_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliverySysEff_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
                         WITH NUMERIC SysEff_AZ = SysEff_CAWCD DO
                          WITH NUMERIC CAWCDremainingDCPcontribution = $ "ICS Credits.AnnualDesiredDCPICSCreation_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
                           WITH NUMERIC DCP_CAWCD_preliminary = $ "ICS Credits.DCPICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.AnnualDeliveryDCP_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
                            WITH NUMERIC MeadBankPrelminary = DCP_CAWCD_preliminary + ECICS_AZ + BiNat_AZ DO
                             WITH NUMERIC RemainingBankSpace = $ "ICS Credits.MeadBankParameters" ["Arizona", "Max Capacity"] - MeadBankPrelminary DO
                              WITH NUMERIC AnnualSimultaneousCreationDCP_CAWCD = "Max"( "Min"( CAWCDremainingDCPcontribution, RemainingBankSpace ), 0.00000000 "acre-ft" ) DO
                               WITH NUMERIC AnnualSysWaterDCPcontribution_CAWCD = $ "ICS Credits.AnnualDCPContribution_AZ" [@"24:00:00 December Max DayOfMonth, Current Year"] - AnnualSimultaneousCreationDCP_CAWCD DO
                                WITH NUMERIC AnnualCreationDCP_CAWCD = AnnualSimultaneousCreationDCP_CAWCD DO
                                 WITH NUMERIC AnnualCreationDCP_AZ = AnnualSimultaneousCreationDCP_CAWCD DO
                                  WITH NUMERIC AnnualCreationSysWater_AZ = AnnualSysWaterDCPcontribution_CAWCD DO
                                   WITH NUMERIC DCP_CAWCD = ( $ "ICS Credits.DCPICS_CAWCD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + AnnualSimultaneousCreationDCP_CAWCD - $ "ICS Credits.AnnualDeliveryDCP_CAWCD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
                                    WITH NUMERIC TotalCAWCD = ECICS_CAWCD + BiNat_CAWCD + SysEff_CAWCD + DCP_CAWCD DO
                                     WITH NUMERIC DCP_AZ = DCP_CAWCD DO
                                      WITH NUMERIC AZBank = ECICS_AZ + BiNat_AZ + DCP_CAWCD DO
                                       WITH NUMERIC TotalICS = SysEff_AZ + ECICS_AZ + BiNat_AZ + DCP_AZ DO
                                        { AnnualCreationSysEff_AZ , AnnualCreationEC_AZ , AnnualCreationBiNat_AZ , AnnualDeliverySysEff_AZ , AnnualDeliveryEC_AZ , AnnualDeliveryBiNat_AZ , AnnualDeliveryDCP_AZ , ECICS_CRIT , ECICS_GRIC , ECICS_CAWCD , ECICS_MVIID , ECICS_WM , ECICS_AZ , BiNat_CAWCD , BiNat_AZ , SysEff_CAWCD , SysEff_AZ , AnnualSimultaneousCreationDCP_CAWCD , AnnualSysWaterDCPcontribution_CAWCD , AnnualCreationDCP_CAWCD , AnnualCreationDCP_AZ , AnnualCreationSysWater_AZ , DCP_CAWCD , TotalCAWCD , DCP_AZ , AZBank , TotalICS , FirmingBalanceAZ , FirmingBalanceUS , AnnualCreationEC_CRIT , AnnualCreationEC_GRIC , AnnualCreationEC_CAWCD , AnnualCreationEC_MVIDD , AnnualCreationEC_WM }
                                       ENDWITH
                                      ENDWITH
                                     ENDWITH COMMENTED_BY "Remaining AZ State Balances <br>"
                                    ENDWITH COMMENTED_BY "CAWCD Total   <br>"
                                   ENDWITH
                                  ENDWITH
                                 ENDWITH
                                ENDWITH
                               ENDWITH
                              ENDWITH
                             ENDWITH
                            ENDWITH
                           ENDWITH
                          ENDWITH COMMENTED_BY "DCP and Balance Check <br>"
                         ENDWITH COMMENTED_BY "AZ State SysEff Balance <br>"
                        ENDWITH COMMENTED_BY "AZ User SysEff Balances <br>"
                       ENDWITH COMMENTED_BY "AZ State BiNat Balance <br>"
                      ENDWITH COMMENTED_BY "AZ User BiNat Balances   <br>"
                     ENDWITH COMMENTED_BY "AZ State EC Balance  <br>"
                    ENDWITH
                   ENDWITH
                  ENDWITH
                 ENDWITH
                ENDWITH
               ENDWITH
              ENDWITH
             ENDWITH COMMENTED_BY "AZ User EC ICS Balances  <br>"
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH COMMENTED_BY "Annual Delivery for AZ slots <br>"
        ENDWITH
       ENDWITH
      ENDWITH COMMENTED_BY "Annual Creation for AZ slots <br>"
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{e0e3d1dc-285e-4568-aff5-33d074d303a5}";;

    FUNCTION       "ICSAccountingForMWD" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation of the MWD ICS categories Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat) and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total MWD ICS Volume. The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>RETURNS: List of lists of the form &lcub;&lcub;EC delivery, SE delivery, BiNat delivery, EC ICS created, CA EC ICS, CA SE ICS, CA BiNat ICS, Total CA ICS, MWD diversion reduction&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 9/10/2014<br>CH, 5/10/18: Renamed function from ICSAccountingForCA to ICSAccountingForMWD and renamed internal variables to refer to MWD ICS instead of CA ICS";
    BEGIN

      WITH NUMERIC MWD_SysEffICS = $ "ICS Credits.SystemEfficiencyICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationSysEff_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliverySysEff_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
  WITH NUMERIC MWD_BiNatICS = $ "ICS Credits.BiNationalICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryBiNat_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
   WITH NUMERIC MWDcurrentECICStoDCPconversion = "Min"( $ "ICS Credits.AnnualRemainingDCPContribution_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"], "Max"( 0.00000000 "acre-ft", ( $ "ICS Credits.MeadBankParameters" ["MWD", "Max Capacity"] - ( MWD_BiNatICS + ( $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] - ( $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) COMMENTED_BY "No need to take into account DCP delivery since it wont happen if Lower basin is operating under <br>DCP, no need to take into account any conversion from previous EC to DCP ICS because it is just <br>a paper transfer, the water is already accounted for in the EC ICS balance from the previous <br>year. <br><br>AP 11/19/19    <br>" ) ) COMMENTED_BY "Calculation of bank space for additional ICS creation to meet DCP calculation <br>" ) ) DO
    WITH NUMERIC MWDsyswaterDCPcontribution = "Max"( 0.00000000 "acre-ft", ( $ "ICS Credits.AnnualDCPContribution_CA" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] - MWDcurrentECICStoDCPconversion ) ) COMMENTED_BY "This is the state of CA system water requirement. MWD meets CA DCP requirement <br>" DO
     WITH NUMERIC CVWDDCPContribution = $ "ICS Credits.AnnualDCPContribution_Coachella" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
      WITH NUMERIC MWDannualECICScreation = "Max"( 0.00000000 "acre-ft", $ "ICSProjectionData.AnnualCreationEC_MWD_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] - MWDcurrentECICStoDCPconversion / "SystemTaxAdjustment_DCP"(  ) ) DO
       WITH NUMERIC MWD_ECICS = $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year EC ICS Creation"( MWDannualECICScreation, $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"], "California" ) - $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
        WITH NUMERIC MWD_DCPICS = $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + ( $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] + MWDcurrentECICStoDCPconversion ) - $ "ICS Credits.AnnualDeliveryDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
         WITH NUMERIC CVWDDCPICS_creation = "Max"( 0.00000000 "acre-ft", ( $ "ICS Credits.AnnualConversionPreviousECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] + MWDcurrentECICStoDCPconversion ) - $ "ICS Credits.AnnualDCPContribution_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) DO
          WITH NUMERIC CVWDsyswaterDCPcontribution = CVWDDCPContribution - CVWDDCPICS_creation DO
           WITH NUMERIC MWD_TotalICS = MWD_ECICS + MWD_SysEffICS + MWD_BiNatICS + MWD_DCPICS DO
            WITH NUMERIC MWD_ICSBank = MWD_ECICS + MWD_BiNatICS + MWD_DCPICS DO
             { MWD_SysEffICS , MWD_BiNatICS , MWDcurrentECICStoDCPconversion , MWDannualECICScreation , MWD_DCPICS , MWDsyswaterDCPcontribution , CVWDDCPICS_creation , CVWDsyswaterDCPcontribution , MWD_ECICS , MWD_TotalICS , MWD_ICSBank }
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH COMMENTED_BY "CVWD is a sub account of the MWD DCP contribution since MWD covers the state of CA. <br>MWD DCP conversion from previous ICS and simultaneous creation has already been checked <br>against the bank space. This way, per discussion, MWD covers any tax needed to meet the <br>CA DCP contribution. MWD creates DCP ICS then CVWD can create if there is bank space. <br>MWD can create EC ICS after CVWD creates DCP ICS. <br><br>MWD covers as much as they can using conversion from previous DCP ICS and simultaneous <br>creation. If the sum of the DCP ICS creation is more than MWD's 93% contribution, the <br>remaining DCP ICS goes to CVWD. If system water is used to meet <7% of the state DCP <br>cntribution then it will get charged to CVWD. If there is system water >7%, all of CVWD's <br>DCP contribution will be system water. <br>"
        ENDWITH
       ENDWITH
      ENDWITH COMMENTED_BY "If there is any ICS left over after meeting the DCP requirement it can be created my MWD.  <br>"
     ENDWITH
    ENDWITH
   ENDWITH COMMENTED_BY "Since MWD's DCP contribution is meeting the state of CA full amount, this covers MWD and <br>CVWD's DCP contribution.<br><br>DCP Contributions will be made by converting EC ICS, then simultaneous creation, then system <br>water  <br>"
  ENDWITH COMMENTED_BY "BiNat Calculation <br>"
 ENDWITH COMMENTED_BY "CVWD DCP ICS accounting takes place under ICS Accounting for MWD. This is because CVWD is <br>storing their ICS under MWD's account. MWD meets the state of CA contribution<br><br>AP 11/19/19<br><br>Sys Eff Calculation   <br>";

    END
    UUID "{fb667623-0553-452e-af24-8afa189a5714}";;

    FUNCTION       "ICSAccountingForNV" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation of the ICS categories Tributary, Imported, Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat), Tributary DSS (Developed Shortage Supply), Imported DSS and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total Nevada ICS Volume. The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>For the delivery of NV ICS: <br>The delivery values of NV ICS are all input and if logic is needed to determine the delivery of NV ICS, then the logic would go into this function. <br><br>RETURNS: List of lists of the form &lcub;&lcub;Creation Trib ICS, Creation Trib DSS, SE ICS, EC ICS, NV Trib DSS ICS, NV Imp DSS ICS, NV BiNat ICS, NV Total ICS, Delivery of NV Trib DSS, Delivery of NV Imp DSS, Creation NV Imp ICS, Creation NV Imp DSS, NV Imp ICS, NV Trib ICS, Delivery of Trib ICS, Delivery of Imp ICS&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 9/10/2014<br><br>AP, 11/29/18: Updated deliveryofImpICS/deliveryofTribICS logic. Changed all system tax references  from *0.95 to the SystemTaxAdjustment function<br><br>AP, 11/30/18: Changed all evap tax references  from *0.97 to the EvapTaxAdjustment function<br>";
    BEGIN

      WITH NUMERIC SysEff = $ "ICS Credits.SystemEfficiencyICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationSysEff_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliverySysEff_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
  WITH NUMERIC BiNat = $ "ICS Credits.BiNationalICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryBiNat_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
   WITH NUMERIC Imported = $ "ICS Credits.AnnualCreationImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  ) - $ "ICS Credits.AnnualDeliveryImp_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
    WITH NUMERIC Tributary = $ "ICS Credits.AnnualCreationTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] * "SystemTaxAdjustment_DCP"(  ) - $ "ICS Credits.AnnualDeliveryTrib_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
     WITH NUMERIC currentECICStoDCPconversion = "Min"( $ "ICS Credits.AnnualRemainingDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"], "Max"( 0.00000000 "acre-ft", ( $ "ICS Credits.MeadBankParameters" ["Nevada", "Max Capacity"] - ( BiNat + ( $ "ICS Credits.DCPICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + ( $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December 31, Previous Year"] - $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] ) ) COMMENTED_BY "No need to take into account DCP delivery since it wont happen if Lower basin is operating under <br>DCP, no need to take into account any conversion from EC to DCP ICS because it is just a paper <br>transfer, the water is already accounted for in the EC ICS balance from the previous year. <br><br>AP 11/19/19   <br>" ) ) COMMENTED_BY "Calculation of bank space for additional ICS creation to meet DCP calculation. could possibly be <br>negative depending on tributary conservation ICS and available space <br>" ) ) DO
      WITH NUMERIC syswaterDCPcontribution = $ "ICS Credits.AnnualDCPContribution_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - currentECICStoDCPconversion DO
       WITH NUMERIC SNWPannualECICScreation = "Max"( 0.00000000 "acre-ft", $ "ICSProjectionData.AnnualCreationEC_SNWP_Preliminary" [@"24:00:00 December Max DayOfMonth, Current Year"] - currentECICStoDCPconversion / "SystemTaxAdjustment_DCP"(  ) ) DO
        WITH NUMERIC ECpreliminary = $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year EC ICS Creation"( SNWPannualECICScreation, $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"], "Nevada" ) - $ "ICS Credits.AnnualDeliveryEC_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] DO
         WITH NUMERIC DCPICS = $ "ICS Credits.DCPICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualConversionPreviousECtoDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "ICS Credits.AnnualDeliveryDCP_NV" [@"24:00:00 December Max DayOfMonth, Current Year"] + currentECICStoDCPconversion DO
          WITH NUMERIC MeadBankPreliminary = BiNat + ECpreliminary + DCPICS DO
           WITH NUMERIC RemainingBankSpace = $ "ICS Credits.MeadBankParameters" ["Nevada", "Max Capacity"] - MeadBankPreliminary DO
            WITH NUMERIC ECbankReduction = IF ( RemainingBankSpace < 0.00000000 "acre-ft" )
            THEN
             RemainingBankSpace
            ELSE
             0.00000000 "acre-ft"
            ENDIF DO
             WITH NUMERIC ECfinal = ECpreliminary + ECbankReduction DO
              WITH NUMERIC MeadBankFinal = MeadBankPreliminary + ECbankReduction DO
               WITH NUMERIC TotalICS = MeadBankFinal + ( SysEff + Imported + Tributary ) DO
                { SysEff , BiNat , Imported , Tributary , currentECICStoDCPconversion , SNWPannualECICScreation , syswaterDCPcontribution , ECfinal , DCPICS , MeadBankFinal , TotalICS }
               ENDWITH
              ENDWITH
             ENDWITH
            ENDWITH
           ENDWITH
          ENDWITH COMMENTED_BY "Start of bank logic <br>"
         ENDWITH COMMENTED_BY "BiNational ICS Calculation <br>"
        ENDWITH
       ENDWITH COMMENTED_BY "EC ICS Calculations<br>"
      ENDWITH COMMENTED_BY "Calculates remaining DCP contribution needed if it is not covered through conversion of previous <br>balance or from any simultaneous conversions. This will be made as sys water<br>"
     ENDWITH COMMENTED_BY "Information for DCP and EC ICS calculations <br><br>Calculates how much of the current year's EC ICS creation will be used to create DCP ICS <br>"
    ENDWITH
   ENDWITH COMMENTED_BY "Imported and Tributary ICS is not carried over from the previous year so the equation format is <br>just: [EOY ICS] =  [ICS created this year] - [ICS delivered this year]<br><br>EOY ICS becomes ECICS the following year.  <br><br><br>Imported and Tributary ICS Balance Calculation  <br>"
  ENDWITH COMMENTED_BY "BiNat ICS Calculation <br>"
 ENDWITH COMMENTED_BY "System Eff Calculation <br>";

    END
    UUID "{76f7c0fe-0981-49aa-8181-fe2aa2636d54}";;

    FUNCTION       "ICSAccountingForIID" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation and delivery of the IID Extraordinary Conservation (EC) and Bi-National (BiNat) ICS to determine the annual balance of each category of ICS and the resulting total of IID ICS storage volume. The function returns a list of each of these values for the Rule to assign to the appropriate slots.  CH 5/10/18<br><br>RETURNS: List of lists of the form &lcub;&lcub;IID EC ICS, IID BiNat ICS, Total IID ICS&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: CH, 5/10/18";
    BEGIN

      WITH NUMERIC AnnualDeliveryBiNat = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  $ "ICSProjectionData.AnnualDeliveryBiNat_IID_Default" [@"24:00:00 December 31, Current Year"]
 ENDIF DO
  WITH NUMERIC AnnualDeliveryEC = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   $ "ICSProjectionData.AnnualDeliveryEC_IID_Default" [@"24:00:00 December 31, Current Year"]
  ENDIF DO
   WITH NUMERIC AnnualCreationEC = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR NaNToZero ( $ "FloodControlOutput.Flood Control Flag" [] ) > 0.00000000 OR NaNToZero ( $ "FloodControlOutput.Exclusive Space Flag" [] ) > 0.00000000 ) )
   THEN
    0.00000000 "acre-ft"
   ELSE
    IF ( $ "ICSProjectionData.AnnualDeliveryEC_IID_Default" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-ft" )
    THEN
     "Max"( ( $ "ICS Credits.MeadBankParameters" ["IID", "Max Capacity"] - $ "ICS Credits.ExtraordinaryConservationICS_IID" [@"24:00:00 December 31, Previous Year"] * "EvapTaxAdjustment"(  ) ) / "SystemTaxAdjustment"(  ) - $ "ICSProjectionData.AnnualDeliveryEC_IID_Default" [@"24:00:00 December 31, Current Year"], 0.00000000 "acre-ft" )
    ELSE
     ( $ "ICS Credits.MeadBankParameters" ["IID", "Max Capacity"] - $ "ICS Credits.ExtraordinaryConservationICS_IID" [@"24:00:00 December 31, Previous Year"] * "EvapTaxAdjustment"(  ) ) / "SystemTaxAdjustment"(  )
    ENDIF
   ENDIF DO
    WITH NUMERIC ECICSIID = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
    THEN
     $ "ICS Credits.ExtraordinaryConservationICS_IID" [@"24:00:00 December Max DayOfMonth, Previous Year"] + AnnualCreationEC * "SystemTaxAdjustment"(  )
    ELSE
     ( $ "ICS Credits.ExtraordinaryConservationICS_IID" [@"24:00:00 December Max DayOfMonth, Previous Year"] - AnnualDeliveryEC ) * "EvapTaxAdjustment"(  ) + AnnualCreationEC * "SystemTaxAdjustment"(  )
    ENDIF COMMENTED_BY "Current year's EC ICS balance - no delivery in shortage condition <br>" DO
     WITH NUMERIC BiNatICSIID = ( $ "ICS Credits.BiNationalICS_IID" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_IID" [@"24:00:00 December Max DayOfMonth, Current Year"] - AnnualDeliveryBiNat ) COMMENTED_BY "Current year's BiNat ICS balance <br>" DO
      WITH NUMERIC totalICSIID = ECICSIID + BiNatICSIID DO
       { AnnualDeliveryBiNat , AnnualDeliveryEC , AnnualCreationEC , ECICSIID , BiNatICSIID , totalICSIID }
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{8a8100cf-a319-4039-8a3f-0b6fdeabd7ef}";;

    FUNCTION       "ICSDeliveryReduction_DCP" ( NUMERIC AnnualDelivery, STRING State, STRING Volume, NUMERIC ECtoDCP )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] < $ "DCP.IGMinTakeElevation" [] AND $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] >= $ "DCP.ReducedTakeElevation" [] )
 THEN
  "Min"( AnnualDelivery, $ "ICS Credits.MeadBankParameters" [State, Volume] )
 ELSE
  AnnualDelivery
 ENDIF
 ELSEIF_COND ( $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] < $ "DCP.ReducedTakeElevation" [] AND $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] >= $ "DCP.MinTakeElevation" [] )
 ELSEIF_CLAUSE ( "Min"( AnnualDelivery, $ "ICS Credits.MeadBankParameters" [State, Volume] - ECtoDCP ) )
 END_ELSEIF
 ELSEIF_COND ( $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] < $ "DCP.MinTakeElevation" [] )
 ELSEIF_CLAUSE ( 0.00000000 "acre-ft" )
 END_ELSEIF COMMENTED_BY "Section IV.D.1-3 of the LB OPs section of the DCP limits the amount of ICS that can be delivered <br>to each state based on meads elevation and the max annual delivery allowed for each state.<br>";

    END
    UUID "{10b946b7-c450-49b2-a03b-8c9e1969ab58}";;

    FUNCTION       "SumAnnualCAPDivRequest" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total annual CAP diversion requested for the current calendar year<br><br>RETURNS: Total annual diversion volume requested [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  "FlowToVolume"( $ "CAPDiversion.Total Diversion Requested" [date], date )
 ENDFOR;

    END
    UUID "{f554f75a-9bf0-4233-ba05-a2dc987c6c5d}";;

    FUNCTION       "SumAnnualSNWADivRequest" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Sums the annual diversion request for SNWP Pumping from Lake Mead TP 7/27/2015<br><br>RETURNS: Diversion requested volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/27/2015";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  "FlowToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date], date )
 ENDFOR;

    END
    UUID "{8a3b7f0e-1fe4-4bd2-917a-e096d488e98f}";;

    FUNCTION       "SumAnnualMWDDivRequest" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total volume of the MWDDiversion:MWD.Diversion Requested slot for the current model year<br><br>RETURNS: Diversion volume requested for current year<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  ( "FlowToVolume"( $ "MWDDiversion:MWD.Diversion Requested" [date], date ) - $ "California_CU_Schedules.MWDReturns" [date] )
 ENDFOR;

    END
    UUID "{346c57d6-0f42-4c6f-a0e4-8c8c102b9029}";;

    FUNCTION       "SystemTaxAdjustment" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Used to calculate the &quot;tax&quot; charged to ICS water<br><br>RETURNS: Coefficient to multiply ICS volume by to assess tax [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: MC, 20171204<br><br>MC, 20171204: Copied from Aug2017 CRSS model during modifications to switch CA ICS creation and delivery from Powell inflow basis to Sacramento Water Year basis";
    BEGIN

      1.00000000 - $ "ICS Credits.SystemTaxPercent" [];

    END
    UUID "{38272efc-f8cb-4edd-ab61-31919244d66c}";;

    FUNCTION       "SystemTaxAdjustment_DCP" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Used to calculate the &quot;tax&quot; charged to ICS water<br><br>RETURNS: Coefficient to multiply ICS volume by to assess tax [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: MC, 20171204<br><br>MC, 20171204: Copied from Aug2017 CRSS model during modifications to switch CA ICS creation and delivery from Powell inflow basis to Sacramento Water Year basis";
    BEGIN

      1.00000000 - $ "ICS Credits.SystemTaxPercent_DCP" [];

    END
    UUID "{7365bf1d-7ddb-4f36-ad1d-4e37235a7996}";;

    FUNCTION       "EvapTaxAdjustment" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Used to calculate the &quot;evap tax&quot; charged to ICS water<br><br>RETURNS: Coefficient to multiply ICS volume by to assess tax [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: AP 20181130<br><br>Created to get rid of hardcoded evap tax percent in ruleset. Similar to SystemTaxAdjustment Function";
    BEGIN

      1.00000000 - $ "ICS Credits.EvapTaxPercent" [];

    END
    UUID "{e8ee2616-dae9-48dd-bb6d-11a94fb7a144}";;

    FUNCTION       "MWD_ICSDeliveryCharged" ( NUMERIC totalDeliveryOfMWDICS, NUMERIC creationOfMWDECICS )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC AnnualDelivery = totalDeliveryOfMWDICS DO
  WITH LIST DeliveryChargedList = FOR ( NUMERIC CategoryBalance IN { $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December 31, Previous Year"] , "Min"( $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December 31, Previous Year"] - NaNToZero ( $ "ICS Credits.AnnualConversionECtoDCP_MWD" [@"24:00:00 December Max DayOfMonth, Current Year"] ) + "Current Year EC ICS Creation"( creationOfMWDECICS + $ "ICS Credits.AnnualSysWaterforDCP_Coachella" [@"24:00:00 December 31, Current Year"], $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December 31, Previous Year"], "California" ), $ "ICS Credits.MeadBankParameters" ["California", "Max Delivery"] ) , $ "ICS Credits.SystemEfficiencyICS_MWD" [@"24:00:00 December 31, Previous Year"] , $ "ICS Credits.BiNationalICS_MWD" [@"24:00:00 December 31, Previous Year"] } ) WITH LIST result = {  } DO
   WITH NUMERIC RemainingBalance = IF ( ( LENGTH result ) == 0.00000000 )
   THEN
    AnnualDelivery
   ELSE
    AnnualDelivery - "Sum"( result )
   ENDIF DO
    WITH NUMERIC DeliveryAmount = IF ( ( LENGTH result ) == 0.00000000 AND $ "Mead.Pool Elevation" [@"24:00:00 December Max DayOfMonth, Previous Year"] < $ "DCP.RecoveryElevation" [] )
    THEN
     0.00000000 "acre-ft"
    ELSE
     "Min"( RemainingBalance, CategoryBalance )
    ENDIF DO
     APPEND DeliveryAmount ONTO result
    ENDWITH
   ENDWITH
  ENDFOR DO
   { GET @INDEX 0.00000000 FROM DeliveryChargedList , GET @INDEX 1.00000000 FROM DeliveryChargedList , GET @INDEX 2.00000000 FROM DeliveryChargedList , GET @INDEX 3.00000000 FROM DeliveryChargedList } COMMENTED_BY "0 = DCP, 1 = EC, 2 = SysEff, 3 = BiNat<br>"
  ENDWITH
 ENDWITH;

    END
    UUID "{3755aaf4-0c63-41bf-8b7a-1ada5368c65b}";;

    FUNCTION       "MWD_ICS_Balances" ( NUMERIC creationOfMWDECICS, NUMERIC deliveryChargedToEC, NUMERIC creationMWDSE, NUMERIC deliveryChargedToSE, NUMERIC creationMWDBiNat, NUMERIC deliveryChargedToBiNat, NUMERIC creationMWDDCPICS, NUMERIC deliveryChargedToDCPICS )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC DCPICSMWD = $ "ICS Credits.DCPICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationMWDDCPICS - deliveryChargedToDCPICS DO
  WITH NUMERIC ECICSMWD = ( $ "ICS Credits.ExtraordinaryConservationICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + "Current Year EC ICS Creation"( creationOfMWDECICS, $ "ICS Credits.AnnualDeliveryEC_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"], "California" ) - deliveryChargedToEC ) COMMENTED_BY "Resulting ExtraOrdinaryConservation ICS " DO
   WITH NUMERIC SEICSMWD = ( $ "ICS Credits.SystemEfficiencyICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationMWDSE - deliveryChargedToSE ) COMMENTED_BY "Resulting System Efficiency ICS " DO
    WITH NUMERIC BiNatICSMWD = ( $ "ICS Credits.BiNationalICS_MWD" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationMWDBiNat - deliveryChargedToBiNat ) COMMENTED_BY "Resulting Bi National ICS " DO
     WITH NUMERIC totalICSMWD = ( DCPICSMWD + ECICSMWD + SEICSMWD + BiNatICSMWD ) COMMENTED_BY "Total ICS" DO
      { ECICSMWD , SEICSMWD , BiNatICSMWD , totalICSMWD , DCPICSMWD }
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{7c3ee56a-3c8c-43d2-8f3f-01a1e85f16ab}";;

    FUNCTION       "AZ Firming Agreement" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC FirmingDeliveryAZ = "Min"( $ "ICS Credits.FirmingAgreementDelivery_AZ" [], $ "ICS Credits.FirmingAgreementBalance_AZ" [@"24:00:00 December 31, Previous Year"] ) DO
  WITH NUMERIC FirmingDeliveryUS = "Min"( $ "ICS Credits.FirmingAgreementDelivery_US" [], $ "ICS Credits.FirmingAgreementBalance_US" [@"24:00:00 December 31, Previous Year"] ) DO
   WITH NUMERIC TotalFirmingDelivery = FirmingDeliveryAZ + FirmingDeliveryUS DO
    IF ( "GetYear"( @"t" ) >= 2026.00000000 )
    THEN
     IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) <= $ "DCP.AZFirmingAgreementElevation" [] )
     THEN
      { TotalFirmingDelivery , FirmingDeliveryAZ , FirmingDeliveryUS }
     ELSE
      { 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" }
     ENDIF
    ELSE
     { 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" }
    ENDIF
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{479cfcd2-8edb-46b2-a0fc-51c02a170b6d}";;

    FUNCTION       "CAWCD Post 2026 ICS Delivery" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "GetYear"( @"t" ) >= 2026.00000000 )
 THEN
  IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) > $ "DCP.MinTakeElevation" [] )
  THEN
   $ "ICS Credits.TotalICS_CAWCD" [@"24:00:00 December 31, Previous Year"] / ( 2036.00000000 - "GetYear"( @"t" ) )
  ELSE
   0.00000000 "acre-ft"
  ENDIF
 ELSE
  0.00000000 "acre-ft"
 ENDIF;

    END
    UUID "{7127bed7-0e2a-4fe7-9eeb-889a754cbf33}";;

  END
  UUID "{dfbd709e-fde0-42ae-a9cd-6ba134319bf4}";;

  UTILITY_GROUP "Midterm Model General Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "CurrentYear" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the date that represents the current year for annual slots<br><br>RETURNS: Dec 31, Current Year [DATETIME]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      @"24:00:00 December Max DayOfMonth, Current Year";

    END
    UUID "{791b3125-6f27-4a19-95c5-d10417435538}";;

    FUNCTION       "DateToCheckEOWYElevation" ( DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the appropriate end of water year date on which to check the pool elevation<br><br>RETURNS: 24:00:00 September 30 of appropriate year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies which water year to check<br>2. BOOLEAN startYear - logical argument that specifies whether &quot;date&quot; is in the Start Year [TRUE] or an out year [FALSE]<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( date >= @"October 31" OR ( date == @"August 31" AND NOT startYear ) OR ( date == @"September 30" AND NOT startYear ) )
 THEN
  @"24:00:00 September 30, Next Year"
 ELSE
  @"24:00:00 September 30, Current Year"
 ENDIF;

    END
    UUID "{553411db-6b0b-451d-a658-af2bcce308c4}";;

    FUNCTION       "DateToCheckJan1Elevation" ( DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date of Dec 31 for the appropriate calendar year to represent a Jan 1 pool elevation (i.e., the Dec 31 pool elevation represents the Jan 1 pool elevation). The function assumes if &quot;date&quot; is October or later, or is August and not in the first year of the model run, that Jan 1 of the calendar year following the one containing &quot;date&quot; is desired; otherwise, Jan 1 of the current calendar year is desired. <br><br>RETURNS: Dec 31 of the year containing &quot;date&quot; [DATETIME]<br><br>ARGUMENTS: <br>1. DATETIME date - date for which the Jan 1 elevation should be checked<br>2. BOOLEAN startYear - Boolean variable designating if the year is the first year of the model run (TRUE) or not (FALSE)<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: I think the assumptions made in the function may be unnecessary and complicating. It might be easier to make adjustments in the &quot;date&quot; argument rather than sending in the additional Boolean argument; that is, if in August and want Jan 1 of next year, just pass @&quot;t+2&quot; instead of requiring the separate Boolean argument";
    BEGIN

      IF ( date >= @"October 31" OR ( date == @"August 31" AND NOT startYear ) )
 THEN
  "Dec31ofYear"( date )
 ELSE
  "Dec31ofYear"( date - 1.00000000 "year" )
 ENDIF;

    END
    UUID "{bd0d490c-8439-4cc8-9ffb-b577e30046ac}";;

    FUNCTION       "EnsureReleaseLimits" ( NUMERIC release, NUMERIC lowerLimit, NUMERIC upperLimit )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function ensures the release volume specified as an argument lies between the minimum and maximum values specifed as arguments<br><br>RETURNS: Release volume [L^3]<br><br>ARGUMENTS:<br>1. NUMERIC release - release volume to check<br>2. NUMERIC lowerLimit - minimum release volume<br>3. NUMERIC upperLimit - maximum release volume<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT lowerLimit;
    MAX_CONSTRAINT upperLimit;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      release;

    END
    UUID "{4664d315-d8eb-4da7-b54a-4f31e76989fc}";;

    FUNCTION       "EqLevel" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "DESCRIPTION: This function returns the value for the year containing &quot;date&quot; from the slot PowellData.EqualizationElevationTable (i.e., the Equalization pool elevation specified for the year)<br><br>RETURNS: Pool elevation [L]<br><br>ARGUMENTS: <br>1. DATETIME date - date that specifies the water year to check<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH STRING waterYear = IF ( date >= @"October 31" )
 THEN
  "GetYearAsString"( "OffsetDate"( date, 1.00000000, "1 years" ) )
 ELSE
  "GetYearAsString"( date )
 ENDIF DO
  $ "PowellData.EqualizationElevationTable" [waterYear, 0.00000000]
 ENDWITH;

    END
    UUID "{55df81ce-c902-4c9b-a1f4-ecda0f77b399}";;

    FUNCTION       "EstimateEvaporation" ( OBJECT reservoir, NUMERIC startStorage, NUMERIC endStorage, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns an estimate of the evaporation volume occurring on the specified reservoir between the specified dates and storages<br><br>RETURNS: Evaporation volume [L^3]<br><br>ARGUMENTS<br>1. OBJECT reservoir - reservoir for which evaporation volume is desired<br>2. NUMERIC startStorage - beginning storage volume<br>3. NUMERIC endStorage - ending storage volume<br>4. DATETIME startDate - date of beginning storage volume<br>5. DATETIME endDate - date of ending storage volume<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "FlowToVolume"( ( "StorageToArea"( reservoir, startStorage ) + "StorageToArea"( reservoir, endStorage ) ) / 2.00000000 * "SumEvapCoeffCRSS"( reservoir, "GetMonth"( startDate ) - 1.00000000, "GetMonth"( endDate ) - 1.00000000 ), endDate );

    END
    UUID "{e9e36ad9-f7b0-40eb-830f-b397db47e796}";;

    FUNCTION       "GetElement" ( LIST list, NUMERIC i )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the value (numeric) of the list item at index i<br><br>RETURNS: Numeric value [Variable]<br><br>ARGUMENTS:<br>1. LIST list - list of items<br>2. NUMERIC i - index value into list<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      GET @INDEX i FROM list;

    END
    UUID "{7afa3e2d-b200-4355-9f2d-6648421c1357}";;

    FUNCTION       "HasAnyRuleFired" ( LIST rules )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines if any rule in the input list &quot;rules&quot; has fired successfully<br><br>RETURNS: TRUE if any rule in the list has fired successfully; otherwise FALSE [BOOLEAN]<br><br>ARGUMENTS:<br>1. LIST rules - a list of rule names<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( STRING rule IN rules ) WITH BOOLEAN fired = FALSE DO
  IF ( "HasRuleFiredSuccessfully"( rule ) AND NOT fired )
  THEN
   TRUE
  ELSE
   fired
  ENDIF
 ENDFOR;

    END
    UUID "{e3c9b5c7-d8c3-4fb9-90b8-11cdec853030}";;

    FUNCTION       "Interpolate" ( NUMERIC x, NUMERIC x0, NUMERIC x1, NUMERIC y0, NUMERIC y1 )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function does a linear interpolation of values in a table<br><br>RETURNS: Interpolated value of y [Units of y]<br><br>ARGUMENTS<br>1. NUMERIC x - value of X variable whose corresponding value in Y column of table is desired<br>2. NUMERIC x0 - highest value in X column that is less than x<br>3. NUMERIC x1 - lowest value in X column that is greater than x<br>4. NUMERIC y0 - value in Y vector corresponding to x0 value in X column<br>5. NUMERIC y1 - value in Y vector corresponding to x1 value in X column<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE 6/12/13";
    BEGIN

      y0 + ( x - x0 ) / ( x1 - x0 ) * ( y1 - y0 );

    END
    UUID "{c20f1089-d128-47d6-b5b8-0c89f82a30f7}";;

    FUNCTION       "IsYearDemandVariabilityAndRunCycle4" ( DATETIME date )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This rule returns a Boolean value of TRUE if lower basin demand variability is active and the run is in Run Cycle 4 and a value of FALSE otherwise<br><br>RETURNS: Boolean [BOOLEAN]<br><br>ARGUMENTS:<br>1. DATETIME date - date which specifies the year in question<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20180125: Added LBDV.BlwParkerTriggerSet and ICS Credits.SacWYType conditions to function based on USBR changes to function";
    BEGIN

      IF ( "GetRunCycleIndex"(  ) == 4.00000000 AND ( ( NaNToZero ( $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == 1.00000000 OR NaNToZero ( $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == - 1.00000000 ) OR ( ( NaNToZero ( $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == 1.00000000 OR NaNToZero ( $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == - 1.00000000 ) OR $ "ICS Credits.SacWYType" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] != 3.00000000 ) ) )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END
    UUID "{d3daf197-3d7e-4b27-9346-f328cad080f3}";;

    FUNCTION       "MeadPumpingDemandVariabilityFactor" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function checks the lower basin demand threshhold for the Local Inflows above Hoover and applies the changes to Mead pumping where necessary.  If the local inflows above Hoover Dam are greater than the 90% historic local inflow volume then the pumping is reduced by 5%.  In the case that the local inflows are less than the 10% exceedence historic local inflow volume then the pumping is increased by 5%. The function returns a factor which is applied to the monthly pumping requests and set by the rule that calls this function (Reset Monthly Forecast SNWP LC Demand Variability).  TP 3/12/2013<br><br>RETURNS: Number representing the current pumping rate relative to a normal year [NONE]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies the year for which the pumping factor is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 3/12/2013";
    BEGIN

      IF ( "IsMRM"(  ) AND NOT "IsSurplusOrShortage"(  ) )
 THEN
  IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) < $ "DCP.DCP_StartElevation" [] )
  THEN
   1.00000000
  ELSE
   IF ( ( $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowAboveHoover90"] ) COMMENTED_BY "For high inflow year, pumping reduced" )
   THEN
    0.95000000
   ELSE
    IF ( ( $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowAboveHoover10"] ) COMMENTED_BY "For low inflow year, pumping increased" )
    THEN
     1.05000000
    ELSE
     1.00000000
    ENDIF
   ENDIF
  ENDIF COMMENTED_BY "If DCP contributions needs to be made, no NV demand variability AP 12/5/19  <br>"
 ELSE
  1.00000000
 ENDIF;

    END
    UUID "{213ce28c-0155-4f78-8bc6-b1de573582a4}";;

    FUNCTION       "AgUsersBelowParkerDemandVariabilityFactor" ( DATETIME date, STRING AgUser )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function checks the lower basin demand threshhold for the Local Inflows below Parker and applies the changes to Mead pumping where necessary.  The function takes a date and checks the conditions for the year of that date then returns a factor for increased or decreased pumping from Mead.<br><br>RETURNS: Demand variability factor [NONE]<br><br>ARGUMENTS:<br>1. DATETIME date - date that determines the year to check<br>2. STRING AgUser - user for who the factor is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 3/12/13";
    BEGIN

      IF ( "IsMRM"(  ) )
 THEN
  IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker90"] )
  THEN
   0.90000000
  ELSE
   IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker10"] )
   THEN
    IF ( AgUser == "IID" OR AgUser == "CVWD" OR AgUser == "YMIDD" OR AgUser == "WMIDD" )
    THEN
     1.00000000
    ELSE
     1.05000000
    ENDIF
   ELSE
    1.00000000
   ENDIF
  ENDIF
 ELSE
  1.00000000
 ENDIF;

    END
    UUID "{eaf21901-76a3-4f73-804c-152a96ab974f}";;

    FUNCTION       "CAPDemandVariabilityFactor" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function checks the lower basin demand threshhold for the Local Inflows above Hoover and applies the changes to Mead pumping where necessary.  The function takes a date and checks the conditions for the year of that date then returns a factor for increased or decreased pumping from Mead. If local inflows to the system below Parker Dam are greater than the 90% exceedence of historic local inflows a factor of 90% is returned.  If the local inflows are below the 10% exceedence of the historic local inflows, then the diversion requested can be increased in the amount the is equal to the difference in the State Apportionment for the year and the volume of Senior Prority user diversion requests.  This value is added to any ICS delivery if Lake Mead is above 1,100 Ft.  The sum of the remaining state apportionment and the ICS Delivery is what CAP is allowed to divert.  A ratio of the new diversion amount to the old diversion amount is returned and applied to the diversion request slot in the rule calling this function (Reset Monthly Forecast CAP LC Demand Variability). TP 7/27/2015<br><br>RETURNS: Factor to apply to diversion requests [NONE]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies the year considered<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 3/12/2013";
    BEGIN

      IF ( "IsMRM"(  ) AND NOT "IsSurplusOrShortage"(  ) )
 THEN
  IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) < $ "DCP.DCP_StartElevation" [] )
  THEN
   1.00000000
  ELSE
   IF ( ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker90"] ) COMMENTED_BY "High local inflows" )
   THEN
    0.90000000
   ELSE
    IF ( ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker10"] ) COMMENTED_BY "Low local inflows" )
    THEN
     WITH NUMERIC volOfAZAgScheduled = FOR ( DATETIME dateSum IN "GetDates"( "OffsetDate"( "Dec31ofYear"( date ), - 11.00000000, "1 Months" ), "Dec31ofYear"( date ), "1 Months" ) ) STAT_SUM
      FOR ( OBJECT azNonCapWaterUser IN "ListSubbasin"( "ArizonaNonCAPWaterUsers" ) ) STAT_SUM
       "FlowToVolume"( azNonCapWaterUser & "Diversion Requested" [dateSum], dateSum )
      ENDFOR
     ENDFOR DO
      WITH NUMERIC diffVolAgDivAZ = $ "AnnualWaterUse.Arizona_Apportionment" ["Dec31ofYear"( date )] - volOfAZAgScheduled DO
       WITH NUMERIC volOfScheduledCAPDiv = "SumAnnualCAPDivRequest"(  ) DO
        WITH NUMERIC ratioFullAllocToAgDiv = ( diffVolAgDivAZ / volOfScheduledCAPDiv ) COMMENTED_BY "Add the difference in the volume available for CAP to divert to the ICS<br> diversion that is available if Lake Mead is above 1,100 Ft." DO
         ratioFullAllocToAgDiv
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "This needs to be changed to take into account All ofthe Ag Diversions for Arizona below Parker Dam so that the total <br>diversion does not exceede 2.8 MAF for the given year. All of the ag diversions are not included here. TP 3/12/2013<br>Added a new Sub Basin called ArizonaNonCAPWaterUsers and now this issue is resolved TP 1/28/2015"
    ELSE
     1.00000000
    ENDIF
   ENDIF
  ENDIF COMMENTED_BY "If DCP contributions needs to be made, no CAP demand variability AP 11/6/19<br>"
 ELSE
  1.00000000
 ENDIF;

    END
    UUID "{37045e06-5853-45e6-906d-20f1838e6831}";;

    FUNCTION       "IsMRM" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This Function will determine if the model is in a deterministic mode or an MRM mode.  Right now, the deterministic run is as high as 32 months and the MRM is as short as 60 months. so anything over 3 years difference between the year of the finish timestep and the year of the start timestep will be an MRM run. The function returns True if the model is in an MRM run and False if the model is not. If the MRM is only run for the deterministic period, this function does not apply. Other methods of determining an MRM run should be implemented here if they are known. TP 3/13/2013<br><br>RETURNS: FALSE if slot LowerBasinDemandVariability.DetermCheck has value of NaN or 1.0; TRUE otherwise [BOOLEAN]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 3/13/2013<br>MC, 20170515: The function is called from several rules in the current ruleset, but the slot used in this function doesn't appear to be set anywhere in the rules. It is currently set as input through Sep 2022 in the model but I can't determine how it was set as it shows up on the MRM DMI but is not in the EnsembleForecasts spreadsheet. I looked at the SEP15 model and spreadsheets and it does not appear in the spreadsheet there either, but is in the model?<br>MC, 20180309: The slot is set from values in the DONOTCHANGE worksheet of the EnsembleForecasts spreadsheet";
    BEGIN

      IF ( IsNaN $ "LowerBasinDemandVariability.DetermCheck" [@"Start Timestep"] OR $ "LowerBasinDemandVariability.DetermCheck" [@"Start Timestep"] == 1.00000000 )
 THEN
  FALSE
 ELSE
  TRUE
 ENDIF;

    END
    UUID "{77c6cb47-3924-443d-80b2-7e8f9c14ffcc}";;

    FUNCTION       "IsSurplusOrShortage" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This Function checks the two limits of Shortage or Surplus and returns a boolean statement saying if the water year is in surplus or shortage. This is being used in the LC Demand Variability Logic. TP 4/18/2013<br><br>RETURNS: TRUE if Mead is in Shortage or Surplus; FALSE otherwise [BOOLEAN]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 4/18/2013<br><br>S.Baker, 20180925: Changed IF statements to use function 'GetProjectedPoolElevation' instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). ";
    BEGIN

      IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
 THEN
  TRUE
 ELSE
  IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Surplus.Domestic Surplus Trigger Elevation" [] )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF
 ENDIF;

    END
    UUID "{43700a2b-b93e-4abd-93d1-439824e212a9}";;

    FUNCTION       "MonthIs" ( LIST months )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns True if the current timestep is in the list months and False if it is not. - CE 6/11/13<br><br>RETURNS: Boolean [BOOLEAN]<br><br>ARGUMENTS: <br>1. LIST months - list of months as strings to check for current month<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "GetMonthAsString"( @"t" ) IN months;

    END
    UUID "{1edc6029-2b61-46d4-8335-b9931553680d}";;

    FUNCTION       "RelativeEOWYDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns the datetime at the end of the water year relative the the current timestep. e.g. if the month is June, the function would return @&quot;t+3&quot;<br><br>RETURNS: Date of the end of the water year containing the input argument &quot;date&quot; [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the end of water year is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20161201: Replace use of this function by WaterYearEndDate, which does not rely on the MonthsUntilEOWY user-defined function?";
    BEGIN

      "OffsetDate"( date, "MonthsUntilEOWY"( date ), "1 months" );

    END
    UUID "{ed47b064-324c-4625-9d8f-1d84c44179d7}";;

    FUNCTION       "RuleCurveStorage" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the storage volume target from the UBRuleCurveData.BaseRuleCurves slot for the reservoir and date passed as input<br><br>RETURNS: Storage volume target [L^3]<br><br>ARGUMENTS<br>1. OBJECT res - reservoir for which storage volume is desired<br>2. DATETIME date - timestep for which storage volume is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.BaseRuleCurves" [STRINGIFY res, "GetMonthAsString"( date )];

    END
    UUID "{e508d36d-b205-4515-8f63-52bec548a36c}";;

    FUNCTION       "StartMonthIsSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns TRUE if the timestep is the Start Timestep and the month is September, and returns FALSE otherwise<br><br>RETURNS: Boolean [BOOLEAN]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170511: Function name is somewhat misleading? I thought it meant the Start Timestep occurred in September, regardless of whether the current timestep was the Start Timestep";
    BEGIN

      @"t" == @"Start Timestep" AND "MonthIs"( { "September" } );

    END
    UUID "{41bde287-9ec3-4974-8011-5a3c44fc7ce4}";;

    FUNCTION       "SumEvapCoeffCRSS" ( OBJECT res, NUMERIC startRow, NUMERIC endRow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function sums the values in the Evaporation Coefficients slot of the reservoir specified as an argument for the row specified as arguments<br><br>RETURNS: total evaporation rate for the period determined by the rows specified [L/T]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir for which the total evaporation rate is desired<br>2. NUMERIC startRow - index representing the beginning month of the period desired in the Evaporation Coefficients slot<br>3. NUMERIC endRow - index representing the ending month of the period desired in the Evaporation Coefficients slot<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumTableColumn"( res & "Evaporation Coefficients", 0.00000000, startRow, endRow );

    END
    UUID "{6582072f-82a0-4ed3-9e5c-aac2bc183b19}";;

    FUNCTION       "GetWaterYearEndDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date of the end of the water year containing the date passed as an argument; if the month of the date is September or earlier, use Sep 30 of the same calendar year; otherwise, use Sep 30 of the following calendar year<br><br>RETURNS: 24:00:00 September 30 for the appropriate water year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - datetime for which the end of water year date is desired<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "GetMonth"( date ) <= 9.00000000 )
 THEN
  "CompletePartialDate"( @"24:00:00 September 30", date )
 ELSE
  "CompletePartialDate"( @"24:00:00 September 30", "NumberToYear"( "GetYear"( date ) + 1.00000000 ) )
 ENDIF;

    END
    UUID "{a0e9d994-9204-4e77-86ce-607342560529}";;

    FUNCTION       "GetWaterYearBeginDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date of the beginning of the water year containing the date passed as an argument. Note that the datetime returned represents October 31, not October 1, since the model uses a monthly timestep and timesteps are represented by their end, not beginning.<br><br>RETURNS: 24:00:00 October 31 for the appropriate water year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME tInput - datetime for which the beginning of water year date is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "GetMonth"( date ) <= 9.00000000 )
 THEN
  "CompletePartialDate"( @"24:00:00 October 31", "NumberToYear"( "GetYear"( date ) - 1.00000000 ) )
 ELSE
  "CompletePartialDate"( @"24:00:00 October 31", date )
 ENDIF;

    END
    UUID "{15f3e30b-7f69-4423-857e-f57665a32d49}";;

    FUNCTION       "CheckAndAdjustToCapacity" ( SLOT divSlot, NUMERIC divCap )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function redistributes flows in divSlot that exceed the capacity value divCap<br><br>RETURNS: List of flow rates [L^3/T]<br><br>ARGUMENTS:<br>1. SLOT divSlot - slot with units of flow rate [L^3/T] to check for values meeting capacity provided<br>2. NUMERIC divCap - maximum value to allow for values in divSlot<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: John Roca, Unknown<br>MC, 20170609: This function was written in response to a situation that occurred whereby MWD would take extra available water near the end of a year, but doing so too late in the year resulted in diversions that exceeded the canal capacity";
    BEGIN

      WITH LIST divPairs = FOR ( DATETIME ithDate IN "GetDates"( @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) WITH LIST result = {  } DO
  APPEND { ithDate , "FlowToVolume"( divSlot [ithDate], ithDate ) } ONTO result
 ENDFOR DO
  WITH NUMERIC overCapVol = FOR ( LIST ithVal IN divPairs ) WITH NUMERIC result = 0.00000000 "acre-feet" DO
   result + "Max"( 0.00000000 "acre-feet", ( GET @INDEX 1.00000000 FROM ithVal ) - "FlowToVolume"( divCap, GET @INDEX 0.00000000 FROM ithVal ) )
  ENDFOR DO
   WITH LIST spaceAvailable = FOR ( LIST ithVal IN divPairs ) WITH LIST result = {  } DO
    APPEND "FlowToVolume"( divCap, GET @INDEX 0.00000000 FROM ithVal ) - GET @INDEX 1.00000000 FROM ithVal ONTO result
   ENDFOR DO
    FOR ( LIST ithPair IN "Reverse"( divPairs ) ) WITH LIST output = {  } DO
     INSERT WITH NUMERIC cumulativeSpaceAvailable = FOR ( DATETIME jthT IN "GetDates"( ( GET @INDEX 0.00000000 FROM ithPair ), @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) WITH NUMERIC result = 0.00000000 "acre-feet" DO
      result + "Max"( GET @INDEX "GetMonth"( jthT ) - 1.00000000 FROM spaceAvailable, 0.00000000 "acre-feet" )
     ENDFOR COMMENTED_BY "Get the cumulative space available for the given month" DO
      "VolumeToFlow"( ( ( GET @INDEX 1.00000000 FROM ithPair ) + "MinItem"( { overCapVol , GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable , IF ( cumulativeSpaceAvailable < overCapVol )
      THEN
       GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable
      ELSE
       IF ( cumulativeSpaceAvailable - overCapVol >= GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable )
       THEN
        0.00000000 "acre-ft"
       ELSE
        ( GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable ) - ( cumulativeSpaceAvailable - overCapVol )
       ENDIF
      ENDIF COMMENTED_BY "This logic detemines the incremental change required without going over the annual volume" } ) ) COMMENTED_BY "Add or subtract the required adjustment value to meet the required annual volume or to prevent <br>going over the monthly capacity", GET @INDEX 0.00000000 FROM ithPair )
     ENDWITH INTO output
    ENDFOR COMMENTED_BY "Iterate through the dates from December backwards to January while <br>distributing the over-capacity total volume to months that have space"
   ENDWITH COMMENTED_BY "Figure out the monthly values by which diversions are over or under the capacity"
  ENDWITH COMMENTED_BY "Figure out the total volume that needs to be redistibuted given the monthly diversion values that <br>go over the capacity"
 ENDWITH COMMENTED_BY "Get a list of date and value pairs for the calendar year";

    END
    UUID "{d2f3bb85-1c2a-4100-9b0e-e454d4f6cfa9}";;

    FUNCTION       "IsUEBEqualizingBranchAndRunCycle4" ( DATETIME eoyDate )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns TRUE if the current Run Cycle is 4 and the Powell upper elevation balancing branch is > 1.20 (1.27, 1.29, 1.3, or 1.4), and FALSE otherwise.<br><br>RETURNS: Boolean TRUE or FALSE<br><br>ARGUMENTS:<br>1. DATETIME eoyDate - the end of year date specifying the water year for which the UEB Branch is checked<br><br>CONSTRAINTS: NONE";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: TP, 201801";
    BEGIN

      ( "GetRunCycleIndex"(  ) == 4.00000000 AND $ "PowellData.UpperElevBalBranch" [eoyDate] > 1.20000000 );

    END
    UUID "{9931bbae-5872-4b0d-8b90-9a893d240eb8}";;

  END
  UUID "{164b480b-be20-42c2-ae67-52b9db261109}";;

  UTILITY_GROUP "Headwater Reservoir Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetEOMTargetElevation" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object and a date, and then returns the end of month target elevation for that reservoir on that date.  This function requires that the reservoirs data object be named &quot;[reservoir]Data&quot; and that the guide slot that holds the target elevations be named &quot;[reservoir]Guide&quot;.  - sc 12/16/10<br><br>RETURNS: Pool elevation [L]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir for which target elevation is desired<br>2. DATETIME date - date for which target is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/16/2010";
    BEGIN

      WITH OBJECT resDataObj = "GetObject"( ( STRINGIFY res ) CONCAT "Data" ) DO
  WITH STRING guideSlotName = ( STRINGIFY res ) CONCAT "Guide" DO
   resDataObj & guideSlotName [date, "Target Elevation"]
  ENDWITH
 ENDWITH;

    END
    UUID "{133fd05a-5f04-4108-9cbb-6c3291556205}";;

    FUNCTION       "GetReservoirMinConstraint" ( OBJECT reservoir, DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir and a date and returns the minimum constraint to the outflow allowed from that reservoir on that date. - sc 12/16/10<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which minimum outflow is desired (Taylor Park or Vallecito)<br>2. DATETIME date - date for which minimum is desired<br>3. NUMERIC prevElev - pool elevation at the end of the previous timestep<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/16/2010<br>TV, 8/1/2012: Added additional argument necessary for Taylor Park";
    BEGIN

      IF ( reservoir == % "TaylorPark" )
 THEN
  "Min"( $ "TaylorParkData.MinFlow" [date] COMMENTED_BY "Minimum flow requirements", "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [date], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.MinElevation" [] ), "ElevationToStorage"( % "TaylorPark", prevElev ), date ) COMMENTED_BY "Maximum possible release from reservoir to dead pool. -tv 8.1.12" )
 ELSE
  IF ( reservoir == % "Vallecito" )
  THEN
   $ "VallecitoData.MinFlow" []
  ELSE
   STOP_RUN "No such Reservoir"
  ENDIF
 ENDIF;

    END
    UUID "{44e04b3a-bb3c-4ddf-b530-b5f467d84e82}";;

    FUNCTION       "MonthlyEvapVolume" ( OBJECT reservoir, DATETIME date, NUMERIC previousPoolElevation, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object, a datetime, a pool elevation and storage at the end of the timestep previous to the passed-in date.  It returns the volume of water evaporated from the passed-in reservoir during the passed-in date timestep. - sc 12/19/10<br><br>RETURNS: Evaporation volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which evaporation estimate is desired<br>2. DATETIME date - date the specifies the timestep for which evaporation is desired<br>3. NUMERIC previousPoolElevation - pool elevation at the end of the timestep prior to &quot;date&quot;<br>4. NUMERIC previousStorage - storage volume at the end of the timestep prior to &quot;date&quot;<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/19/2010";
    BEGIN

      WITH NUMERIC evapHeight = reservoir & "Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000] * "GetDaysInMonth"( date ) DO
  WITH NUMERIC elevationAfterEvap = previousPoolElevation - evapHeight DO
   WITH NUMERIC storageAfterEvap = "TableInterpolation"( reservoir & "Elevation Volume Table", 0.00000000, 1.00000000, elevationAfterEvap, date ) DO
    previousStorage - storageAfterEvap
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{95e070e9-407f-4d75-88bb-2e435212c932}";;

    FUNCTION       "GetReservoirMaxConstraint" ( OBJECT reservoir, DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir and a date and returns the maximum constraint to the outflow allowed from that reservoir on that date. - sc 12/16/10<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which maximum outflow is desired (Taylor Park or Vallecito)<br>2. DATETIME date - date for which maximum is desired<br>3. NUMERIC prevElev - pool elevation at the end of the previous timestep<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/16/2010";
    BEGIN

      IF ( reservoir == % "TaylorPark" OR reservoir == % "Vallecito" )
 THEN
  "TableInterpolation"( reservoir & "Max Release", 0.00000000, 1.00000000, prevElev, @"t" )
 ELSE
  STOP_RUN "No such Reservoir"
 ENDIF;

    END
    UUID "{49a1ce5c-6e8c-4ed2-94aa-f7f0d74401cd}";;

    FUNCTION       "SolveConstrainedOutflow" ( OBJECT reservoir, NUMERIC elevationTarget, NUMERIC previousPoolElev, NUMERIC minConstraint, NUMERIC maxConstraint, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object, an end-of-timestep elevation target, a previous timestep elevation, a minimum release constraint, a maximum release constraint, and a datetime.  It returns a release value for the passed in reservoir on the passed in date that hits the elevation target, or gets as close as possible within the passed in constraints.  Note the min and max constraints are imposed in the Post-Execution checks and do not appear in the body of the function. - sc 12/14/10<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which outflow is desired<br>2. NUMERIC elevationTarget - target pool elevation<br>3. NUMERIC previousPoolElev - pool elevation at end of previous timestep<br>4. NUMERIC minConstraint - minimum flow rate possible<br>5. NUMERIC maxConstraint - maximum flow rate possible<br>6. DATETIME date - date for which pool elevation should meet target<br><br>CONSTRAINTS: minConstraint & maxConstraint (passed arguments)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    MAX_CONSTRAINT maxConstraint;
    MIN_CONSTRAINT minConstraint;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/14/2010<br>MC, 20170531: Remove WITH statement?";
    BEGIN

      "SolveOutflow"( reservoir, reservoir & "Inflow" [date], "ElevationToStorage"( reservoir, elevationTarget ), "ElevationToStorage"( reservoir, previousPoolElev ), date );

    END
    UUID "{5a9087bc-e584-4bbd-9615-98cce35b252f}";;

    FUNCTION       "SimulateHeadwaterRes" ( OBJECT reservoir )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object and returns a list of three-item lists, each sub-list of the form &lcub;date, outflow, end-of-month pool elevation&rcub;. There is one sublist for each timestep in the run.<br>The function operates the passed-in reservoir basically according to a guide curve specified on the reservoirs data object.  A minimum constraint and maximum constraint to the outflow are calculated for each timestep that provides a floor and ceiling to the outflow that can be initiated to hit the elevation target prescribed by the guide curve.  A water balance calculation is performed at each timestep to determine the pool elevation at the end of the timestep. Then it steps forward one timestep does another water balance calculation, and continues doing this until it reaches the last timestep of the run.  The water balance equation used here is:<br><br>[Previous End of Month Storage] + [Reservoir Inflow] - [Reservoir Outflow] - [Reservoir Evaporation] = [End of Month Storage].  - sc 12/20/10<br><br>RETURNS: List of lists of the form &lcub;&lcub;date, outflow, End of month pool elevation&rcub;&rcub;<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which outflows are desired<br><br>CONSTRAINTS: minConstraint and maxConstraint outflows calculated by user-defined functions<br><br><br><br>TV, 20120801: Added additional argument (previous pool elevation) required by changes to the function GetReservoirMinConstraint";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/20/2010";
    BEGIN

      FOR ( DATETIME date IN @"Start Timestep" TO @"Finish Timestep" ) WITH LIST result = {  } DO
  WITH NUMERIC previousPoolElevation = IF ( date == @"Start Timestep" )
  THEN
   reservoir & "Pool Elevation" [@"t - 1"]
  ELSE
   GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result
  ENDIF DO
   WITH NUMERIC resOutflow = WITH NUMERIC elevationTarget = "GetEOMTargetElevation"( reservoir, date ) DO
    WITH NUMERIC minConstraint = "GetReservoirMinConstraint"( reservoir, date, previousPoolElevation ) DO
     WITH NUMERIC maxConstraint = "GetReservoirMaxConstraint"( reservoir, date, previousPoolElevation ) DO
      "SolveConstrainedOutflow"( reservoir, elevationTarget, previousPoolElevation, minConstraint, maxConstraint, date )
     ENDWITH
    ENDWITH
   ENDWITH COMMENTED_BY "Calculate outflow from previous pool elevation to target subject to constraints" DO
    WITH NUMERIC PreviousStorage = "TableInterpolation"( reservoir & "Elevation Volume Table", 0.00000000, 1.00000000, previousPoolElevation, date ) DO
     WITH NUMERIC releaseVolume = resOutflow * "GetDaysInMonth"( date ) DO
      WITH NUMERIC inflowVolume = reservoir & "Inflow" [date] * "GetDaysInMonth"( date ) DO
       WITH NUMERIC evapVolume = "MonthlyEvapVolume"( reservoir, date, previousPoolElevation, PreviousStorage ) DO
        WITH NUMERIC newStorage = PreviousStorage + inflowVolume - releaseVolume - evapVolume DO
         WITH NUMERIC EOMPoolElevation = "TableInterpolation"( reservoir & "Elevation Volume Table", 1.00000000, 0.00000000, newStorage, date ) DO
          APPEND { date , resOutflow , EOMPoolElevation } ONTO result
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDFOR;

    END
    UUID "{f70cfce2-dd89-4470-b370-8a8104785219}";;

  END
  UUID "{cc0cf129-e6a2-4321-9a65-96d06f919462}";;

  UTILITY_GROUP "Aspinall Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "BlueMesaOutflowCalc" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the outflow to be released from Blue Mesa by considering the following constraints: 1.) Release the greater of the flows necessary to meet the Whitewater Target Flow, the Black Canyon Target Flow, and the target pool elevation for Blue Mesa; 2.) Prevent an overflow at Crystal; 3.) If above minimum power pool elevation (7,393 ft), then maintain the pool above that value; 4.) Release no more than the maximum possible outflow; 5.) Maintain the pool elevation above the top of the dead pool (7,358 ft); 6.) Prevent the pool elevation from exceeding the maximum pool elevation.<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Release not less than 0 cfs";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Some of the limiting constraints could be moved to Post-Execution Checks (i.e., max possible outflow, release to max PE, release to dead pool); update local variable names; replace hard-coded values with slot values as possible";
    BEGIN

      WITH NUMERIC MonthlyWhitewaterTarget = IF ( ( "GetMonth"( @"t" ) == 5.00000000 OR "GetMonth"( @"t" ) == 6.00000000 ) AND ( $ "BlueMesa.Storage" [@"t - 1"] + "FlowToVolume"( $ "BlueMesa.Inflow" [@"t"], @"t" ) > "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.SpillwayElevation" [] ) OR $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] < 3.00000000 ) )
 THEN
  FOR ( DATETIME date IN "GetDates"( "GetStartDayOfMonth"(  ), "GetEndDayOfMonth"(  ), "1 days" ) ) STAT_AVE
   $ "BlueMesaData.TargetDailyWhitewaterFlows" [date]
  ENDFOR
 ELSE
  $ "BlueMesaData.BaseFlowTarget" [@"t", $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"]] COMMENTED_BY "CF: This was corrected so it takes in H Class to find correct baseflow.  <br>"
 ENDIF COMMENTED_BY "Computes the average flow for the month at the Whitewater Gage, which is calculated and then <br>referenced on the BlueMesaData.MayThruJulyDaily slot. TP 9/22/2015" DO
  WITH NUMERIC MonthlyCanyonFlows = IF ( $ "BlueMesaData.MeetCanyonDecreeFlows" [] == 1.00000000 )
  THEN
   FOR ( DATETIME date IN "GetDates"( "GetStartDayOfMonth"(  ), "GetEndDayOfMonth"(  ), "1 days" ) ) STAT_AVE
    $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date]
   ENDFOR
  ELSE
   0.00000000 "acre-ft/month"
  ENDIF DO
   WITH NUMERIC MeetDownstreamFlowTargets = "SolveBlueMesaReleaseForDownstreamTargets"( MonthlyWhitewaterTarget, @"t", MonthlyCanyonFlows ) COMMENTED_BY "Maximum release to meet the Whitewater Gage and the Black Canyon Target Flows" DO
    WITH NUMERIC ReleaseToMeetBMMaxPE = "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MaximumPoolElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "Outflow to bring the reservoir to the maximum reservoir pool" DO
     WITH NUMERIC ReleaseToMeetBMTargetPE = "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), 0.00000000 "cfs" COMMENTED_BY "CF: If the inflow + storage[t-1] is not equal to the guide storage[t] then will calculate a negative <br>outflow, setting to 0 prevents that from being included in solving the Blue Mesa Outflow <br>" ) COMMENTED_BY "Outflow to meet the target pool elevation" DO
      WITH NUMERIC MaxReleaseToAvoidMinPE = WITH NUMERIC tunnelDiv = $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [@"t"] DO
       WITH NUMERIC WaterAvailToCanyon = "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPowerElevation" [] COMMENTED_BY "Input Minimum Pool Elevation on the Blue Mesa Data Object" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), % "BlueMesa" & "Inflow" [@"t"] ) DO
        WITH NUMERIC GainsAbvCrystal = $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [@"t"] + $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [@"t"] DO
         WITH NUMERIC GainsBMToGJ = GainsAbvCrystal + $ "GunnisonBelowCrystal:GunnisonNrGJ_Whitewater.Local Inflow" [@"t"] DO
          WITH NUMERIC flowLevel = $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] DO
           WITH NUMERIC WaterRigtsAtWW = $ "BlueMesaData.BaseFlowTarget" [@"t", flowLevel] DO
            "Max"( tunnelDiv + "MinItem"( { WaterAvailToCanyon , "MaxItem"( { WaterRigtsAtWW - GainsBMToGJ , $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"] - GainsAbvCrystal , 0.00000000 "cfs" } ) , IF ( $ "BlueMesa.Pool Elevation" [@"t - 1"] <= $ "BlueMesaData.MinimumPowerElevation" [] )
            THEN
             "Max"( 300.00000000 "cfs" - GainsAbvCrystal, 0.00000000 "cfs" )
            ELSE
             "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPowerElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) - tunnelDiv, 0.00000000 "cfs" )
            ENDIF } ), "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPowerElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), 0.00000000 "cfs" ) )
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH COMMENTED_BY "This determines the outflow from the reservoir as the reservoir approaches and goes below the spillway.  <br>If the Blue Mesa is above min power pool (7,393 ft) in the previous time step, then release the amount <br>necessary to meet the downstream demands, including the Gunnison Tunnel and the Whitewater and Black <br>Canyon Target Flows but not more than what would lower Blue Mesa to Min Power Pool. If the Blue Mesa Pool <br>Elevation is below Min Power Pool then only release enough to meet the Gunnison Tunnel flow and base target <br>flows at Whitewater and the Canyon. " DO
       WITH NUMERIC MaxReleaseToPreventCrystalOverflow = "SolveBlueMesaReleaseForCrystalReleaseTarget"( $ "BlueMesaData.CrystalMaxOutflow" [@"t"], @"t" ) COMMENTED_BY "If Possible do not release over the maximum monthly target flow for Crystal. <br>Aug - Apr: 2,100 cfs; June - July: 4,150 cfs; no limit in May. " DO
        WITH NUMERIC BMPoolElevWithNoRelease = "TableInterpolation"( $ "BlueMesa.Elevation Volume Table", 1.00000000, 0.00000000, $ "BlueMesa.Storage" [@"t - 1"] + "FlowToVolume"( $ "BlueMesa.Inflow" [@"t"], @"t" ), @"t" ) DO
         WITH NUMERIC NoReleaseStorage = "ElevationToStorage"( % "BlueMesa", BMPoolElevWithNoRelease ) COMMENTED_BY "Calculate storage without release <br>" DO
          WITH NUMERIC SpillwayStorage = "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.SpillwayElevation" [] ) COMMENTED_BY "Calculate storage at the spillway invert <br>" DO
           WITH NUMERIC VolumeAboveSpillway = NoReleaseStorage - SpillwayStorage DO
            WITH NUMERIC ReleaseableVolumeRate = VolumeAboveSpillway / 1.00000000 "month" + $ "BlueMesa.Maximum Controlled Release" [0.00000000, 0.00000000] COMMENTED_BY "Here, this value represents only the max outlet works instead of also including <br>the Regulated Spill, which is how the RiverWare documentation considers it. <br>" DO
             WITH NUMERIC maxPossibleOutflow = "TableInterpolation"( $ "BlueMesaData.BlueMesa_MaxOutflowTable", 0.00000000, 1.00000000, BMPoolElevWithNoRelease, @"t" ) COMMENTED_BY "Mathematically derived max possible outflow based on the Max Release table <br>on the Blue Mesa data object. " DO
              WITH NUMERIC maxOutflowToBottom = "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MaxDeadPoolElevation" [] + 0.10000000 "feet" ) COMMENTED_BY "The minimum elevation is a tenth of a foot high to prevent the reservoir from failing from the <br>mass balance for the reservoir. TP 9/28/2015", "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "Max release to the top of the dead pool (7,358 ft.)" DO
               WITH NUMERIC TargetReleaseFromBM = "Max"( "MinItem"( { "MaxItem"( { MeetDownstreamFlowTargets , ReleaseToMeetBMTargetPE } ) , MaxReleaseToPreventCrystalOverflow , MaxReleaseToAvoidMinPE , ReleaseableVolumeRate COMMENTED_BY "MC, 20170808: for testing, replaced maxPossibleOutflow <br>with ReleaseableVolumeRate  <br>" , maxOutflowToBottom } ), ReleaseToMeetBMMaxPE COMMENTED_BY "Release necessary to prevent Flood Control" ) DO
                "Max"( TargetReleaseFromBM, 0.00000000 "cfs" )
               ENDWITH
              ENDWITH
             ENDWITH
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH COMMENTED_BY "Calculate flows needed in Black Canyon"
 ENDWITH COMMENTED_BY "Calculate flows needed at Whitewater gage";

    END
    UUID "{2cd969d6-480e-44aa-b936-83d2c0808fc2}";;

    FUNCTION       "TaylorParkMinReleaseConstraint" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and returns the minimum release permitted on that date from Taylor Park Reservoir.  Currently it is just the &quot;MinFlow&quot; slot on the &quot;TaylorParkData&quot; object.  It is expected that this function will get more detailed as the development of the model continues and may have unique calculations for each month of the year. - sc 12/16/10<br><br>RETURNS: Minimum flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the minimum flow is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: Replace calls to this function with references to the slot?";
    BEGIN

      $ "TaylorParkData.MinFlow" [date];

    END
    UUID "{e99577dd-57fe-4e16-b295-2386f4d84497}";;

    FUNCTION       "CalcCanyonPeakFlowTarget" ( NUMERIC currentForecast )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function returns the one-day peak flow target for the Black Canyon portion of the Gunnison River that will meet the Federal Reserve Water Right. Data for the linear calculation is stored in BlueMesaData.PeakFlowCalcData. Peak flow levels are from Appendix G, Sect 31 of Decree, Case No. 01CW05.<br><br>ARGUMENTS: Current Unregulated Inflow Forecast<br><br>RETURNS: One-day peak flow target for the Black Canyon portion of the Gunnison River.<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/22/2010<br><br>CF, 20170505: The function was modified to take currentForecast as an argument. Data for the linear calculation has been stored in BlueMesaData.PeakFlowCalcData rather than the function's body. - CF 5/5/17<br><br>SC, 20101222: The calculation is taken from Paul Davidson's &quot;Black Canyon Logic&quot; spreadsheet which references the relevant section of the Decree. The peak flow is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir. There are six regions, each having its own linear calculation for the peak flow. First the function determines which region, or level, the forecast fits into, and then calculates using the linear equation associated with that region, the appropriate peak flow target for May of the current year. - sc 12/22/10";
    BEGIN

      WITH STRING forecastLevel = FOR ( STRING level IN { "Level 6" , "Level 5" , "Level 4" , "Level 3" , "Level 2" , "Level 1" } ) WITH STRING result = "Level 6" DO
  IF ( $ "BlueMesaData.CanyonFlowCalcData" [level, "Upper Limit"] > currentForecast )
  THEN
   level
  ELSE
   result
  ENDIF
 ENDFOR DO
  ( $ "BlueMesaData.CanyonFlowCalcData" [forecastLevel, "Parameter A"] * ( currentForecast / 1000.00000000 "acre-feet" ) + $ "BlueMesaData.CanyonFlowCalcData" [forecastLevel, "Parameter B"] ) * 1.00000000 "cfs"
 ENDWITH;

    END
    UUID "{2d731052-366c-4aac-a2d7-cc9398889761}";;

    FUNCTION       "CalcGunnisonWWPeakFlowTarget" ( NUMERIC HClass, NUMERIC currentForecast )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: The one-day peak flow target at the Whitewater gage is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir BlueMesaInflow.Unregulated. The target is determine based a linear equation divided into six regions corresponding to the different hydrologic year types. The coefficients are stored in BlueMesaData.PeakFlowCalcData and come from the 2012 ROD Figure 1 and Table 1.<br><br>RETURNS: One-day peak flow target for the Whitewater gage.<br><br>ARGUMENTS: <br>1. NUMERIC HClass - current hydrologic year classification based on the current Apr-Jul forecast for Blue Mesa unregulated inflow<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/22/2010<br><br>CF, 20170505: The function was modified to take currentForecast and HClass as arguments. - CF 5/5/17<br><br>MC, 20161103: I think this calculation is actually for the Whitewater Gage, not the Black Canyon. The parameters in BlueMesaData.PeakFlowCalcData are consistent with those from the ROD referenced in the document BlueMesaOpsOutline_2015.docx<br><br>This function returns the one-day peak flow target for the Black Canyon portion of the Gunnison River.  The calculation is taken from Paul Davidson's &quot;Black Canyon Logic&quot; spreadsheet which references the releavant section of the Decree.  The peak flow is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir.  There are six regions, each having its own linear calculation for the peak flow.  First the function determines which region, or level, the forecast fits into, and then calculates using the linear equation associated with that region, the appropriate peak flow target for May of the current year. - sc 12/22/10";
    BEGIN

      $ "BlueMesaData.PeakFlowCalcData" [HClass, "Parameter A"] * ( currentForecast / 1000.00000000 "acre-feet" ) + $ "BlueMesaData.PeakFlowCalcData" [HClass, "Parameter B"];

    END
    UUID "{03ceb0c5-f624-4594-b192-a5dc9ad285c3}";;

    FUNCTION       "CalcGunnisonHClass" ( NUMERIC currentForecast )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: Calculates the Hydrologic Year classification which is a value between 0 (Dry) and 5 (Wet) that is based on Figure 1 and Table 1 of the 2012 ROD for the Aspinall Unit.  Values are stored in BlueMesaData.PeakFlowCalcData. <br><br>RETURNS: Numeric peak flow level 0-5/hydrologic year type [No Units]<br><br>ARGUMENTS:<br>1. NUMERIC currentForecast - current Blue Mesa forecasted unregulated inflow<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: CF, 20170505<br><br>CF, 20170505: The function was modified to take currentForecast as an argument. The name of this function was updated. - CF 5/5/17";
    BEGIN

      FOR ( NUMERIC HClass IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 , 5.00000000 } ) WITH NUMERIC result = 0.00000000 DO
  IF ( currentForecast > $ "BlueMesaData.PeakFlowCalcData" [HClass, "Lower Limit"] )
  THEN
   HClass
  ELSE
   result
  ENDIF
 ENDFOR;

    END
    UUID "{06502e35-1f8a-442e-855d-b5bd3a54a0ed}";;

    FUNCTION       "UBConstrainedOutflow" ( OBJECT reservoir, NUMERIC UnconstrainedOutflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Arguements: None <br>  <br>Description: <br>  <br>Returns: Constrainted Outflow rate [L^3/T]";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT 0.00000000 "acre-ft/month";
    MAX_CONSTRAINT "Min"( "SolveOutflow"( reservoir, reservoir & "Inflow" [@"t"], 0.00000000 "acre-ft", reservoir & "Storage" [@"t - 1"], @"t" ), $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "maxRelease"] );
    NOTES          "CF,20190405: Created to apply to Aspinall Rules";
    BEGIN

      UnconstrainedOutflow;

    END
    UUID "{e52fff83-59b6-491c-9f14-a3ad2494fce7}";;

    FUNCTION       "SolveBlueMesaReleaseForDownstreamTargets" ( NUMERIC TargetWhitewaterFlow, DATETIME date, NUMERIC TargetCanyonFlow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "Arguements: <br>1. NUMERIC TargetWhitewaterFlow - flow rate required at the Whitewater gage<br>2. DATETIME date - date for which the release is desired<br>3. NUMERIC TargetCanyonFlow - flow rate required through Black Canyon<br>  <br>Description: This function takes a numeric flow target and a date. It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in flow target for the Whitewater gage and the Black Canyon section of the Gunnison River which is the &quot;Tunnel Return Flow&quot; object on the workspace. The function does this by doing a water balance in the reach of the river between Blue Mesa and the Black Canyon and solving for the release from Blue Mesa.<br><br>Since MTOM now includes evaporation additional releases are nessisary to maintain Morrow Point and Crystal storage. Blue Mesa also releases to achieve a target Morrow Point storage which was given by Rick Clayton. At this time releases to achieve a Crystal target storage have not been included in Blue Mesa operations and are just withheld by Crystal in the first timestep, see rule Crystal Outflow.   <br>  <br>Returns: Blue Mesa release [L^3/T] - release from Blue Mesa Reservoir that is necessary to hit the flow targets ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF,20190403: Moved in from Apr 2019 Offc CRSS. Add accounting for Evap of DS res. Add release needed to get MP to target storage. <br><br>MC, 20170705: Added adjustment to local inflows for dates in May because local inflow value includes changes in Paonia and Ridgway storages that are not available to meet downstream targets (i.e., the local inflows are unregulated but regulated flows are what actually contribute to target flows). The value added is the average difference between regulated and unregulated flows for 1980-2017 based on data received from Rick C. <br>MC, 20161123: This function receives target Whitewater and Black Canyon flows, as well as a date. It returns the Blue Mesa Reservoir release value necessary to achieve both of the passed-in flow targets by calculating a water balance between the reservoir and each target location, and setting the release to the maximum needed to attain the targets.  (used in updated BlueMesaOpsOutline_November2016.docx)";
    BEGIN

      "Max"( "Max"( ( ( TargetWhitewaterFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] - ( $ "GainsCrystalToGJ.GainsCrystalToGJ" [date] - IF ( "GetMonth"( date ) == 5.00000000 )
 THEN
  $ "BlueMesaData.CrystalToGJ_MayAdjustment" []
 ELSE
  0.00000000 "acre-feet/month"
 ENDIF COMMENTED_BY "In May, adjust local inflows for reservoir storages" ) ) + "VolumeToFlow"( ( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ), @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ) ) COMMENTED_BY "Need to account for Evap to maintain constant storage in DS res. <br>" + ( "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) - $ "MorrowPoint.Storage" [@"t - 1"] ) COMMENTED_BY "Additional Release needed to get MP to Target <br>", @"t" ) ) COMMENTED_BY "-Would set a Blue Mesa Release enough to meet the Whitewater Target and the Gunnison Tunnel <br>Diversion while leveraging the gains between Blue Mesa and Grand Junction  <br>", ( ( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] ) + "VolumeToFlow"( ( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ), @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ) ) COMMENTED_BY "Need to account for Evap to maintain constant storage in DS res. <br>" + ( "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) - $ "MorrowPoint.Storage" [@"t - 1"] ) COMMENTED_BY "Additional Release needed to get MP to Target <br>", @"t" ) ) COMMENTED_BY "This would set a Blue Mesa Release enough to meet the minimum Black Canyon Flows and the <br>Gunnison Tunnel Diversion while leveraging the gains between BM and the Tunnel. " ), "VolumeToFlow"( ( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ), @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ) ) COMMENTED_BY "Need to account for Evap to maintain constant storage in DS res. <br>" + ( "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) - $ "MorrowPoint.Storage" [@"t - 1"] ) COMMENTED_BY "Additional Release needed to get MP to Target <br>", @"t" ) COMMENTED_BY "If Gains Meet DS Targets: <br>" );

    END
    UUID "{d7a77937-f5fa-426c-804f-53b982617b8c}";;

    FUNCTION       "SolveBlueMesaReleaseForCrystalReleaseTarget" ( NUMERIC TargetCrystalRelease, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "ARGUMENTS:<br>1. NUMERIC TargetCrystalRelease - release rate desired from Crystal<br>2. DATETIME date - date on which the release is desired<br><br>DESCRIPTION: This function takes a numeric release target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in release target for Crystal Reservoir  The function does this by doing a water balance in the reach of the river between Blue Mesa and Crystal Res and solving for the release from Crystal Res. <br><br>Since MTOM now includes evaporation additional releases are nessisary to maintain Morrow Point and Crystal storage.<br><br>RETURNS: Release rate [L^3/T]<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "CF,20190403: Moved in from Apr 2019 Offc CRSS. Add accounting for Evap of DS res. <br><br>AUTHOR, DATE: sc 12/28/10";
    BEGIN

      "Max"( TargetCrystalRelease - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] - "VolumeToFlow"( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) COMMENTED_BY "CF: MP should reach target by end of timestep. <br>", @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ), @"t" ), "VolumeToFlow"( "EstimateEvaporation"( % "MorrowPoint", $ "MorrowPoint.Storage" [@"t - 1"], "ElevationToStorage"( % "MorrowPoint", $ "BlueMesaData.StorageTargetMorrowPoint" [] ) COMMENTED_BY "CF: MP should reach target by end of timestep. <br>", @"t", @"t" ) + "EstimateEvaporation"( % "Crystal", $ "Crystal.Storage" [@"t - 1"], "ElevationToStorage"( % "Crystal", $ "BlueMesaData.StorageTargetCrystal" [] ), @"t", @"t" ), @"t" ) COMMENTED_BY "CF: Only release to cover evap. <br>" );

    END
    UUID "{8cd450d2-0f34-4930-bce0-e062d67f3778}";;

  END
  UUID "{6139a25f-0d0c-41dc-95f6-3a33d125e116}";;

  UTILITY_GROUP "Vallecito Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "VallecitoMinReleaseConstraint" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and returns the minimum release permitted on that date from Vallecito Reservoir.  Currently it is just the &quot;MinFlow&quot; slot on the VallecitoData object.  It is expected that this function will get more detail as the development of the model continues and may have unique calculations for each month of the year. - sc 12/16/10<br><br>RETURNS: Minimum release rate [L^3/T]<br><br>ARGUMENTS:<br>1. DATETIME date - date which is currently irrelevant to function<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: Remove function as unnecessary?";
    BEGIN

      $ "VallecitoData.MinFlow" [];

    END
    UUID "{1b023353-c615-4f5b-95a1-679d04334678}";;

    FUNCTION       "VallecitoMaxReleaseConstraint" ( DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and a previous elevation value and returns the maximum allowable release from Vallecito Reservoir on that date.  Currently it is calculated as the appropriate value on the &quot;Max Release&quot; table of the reservoir.  It is expected that this function will get more detailed as the model is developed and will likely have unique calculations for each month of the year.  - sc 12/17/10<br><br>RETURNS: Maximum release rate [L^3/T]<br><br>ARGUMENTS: <br>1. DATETIME date - date specifying timestep for which max release is desired<br>2. NUMERIC  prevElev - pool elevation at end of previous timestep<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "TableInterpolation"( $ "Vallecito.Max Release", 0.00000000, 1.00000000, prevElev, @"t" );

    END
    UUID "{53e87b31-912f-4c3d-b87a-84852b2c5ef0}";;

  END
  UUID "{90ae13a1-e8de-4a14-94b3-b82e4142dbed}";;

  UTILITY_GROUP "Flood Control Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AvailableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the available storage in a reservoir as the difference between the live capacity of the reservoir and the storage value at the end of the previous timestep<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the available space is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: The upstream UC reservoirs use this same calculation in the rule Set Forecast Data, but do not call the function";
    BEGIN

      "GetLiveCapacity"( reservoir ) - reservoir & "Storage" [@"t - 1"];

    END
    UUID "{8392acfd-323b-4cc2-8d6d-ad5f1b91ee3e}";;

    FUNCTION       "ComputeMinimumSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the space available in &quot;reservoir&quot; given the minimum required space<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the space is desired (see Development Notes)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170518: As of now, the only reservoir with data in the MeadFloodControlData.MinSpace slot (which is referenced by the GetMinimumSpace function) is Mead, so the only successful call to this function will be with reservoir as &quot;Mead&quot;";
    BEGIN

      "GetLiveCapacity"( reservoir ) - "GetMininumSpace"( reservoir );

    END
    UUID "{eacdb4a8-8555-4340-a092-7b88c7394d98}";;

    FUNCTION       "ComputeTargetStorageRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "DESCRIPTION: This function calculates the outflow required to reach the target elevation specified by the SpaceBuilding function with an upper bound of the maximum space building release (28,000 cfs).<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: 0 acre-feet/month (minimum), MeadFloodControlData.MaxRelease (maximum)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170518: The function ComputeOutflowAtGivenStorageForSpaceBuilding uses the SolveOutflow function, which includes both Release and Spill; however, the first condition restricts the outflow to the maximum release value; also, the ComputeOutflowAtGivenStorageForSpaceBuilding function does not constrain releases to a MinRelease and MaxRelease like ComputeOutflowAtGivenStorage does<br>MC, 20170518: Instead of using the IF conditional, could add Post-Exec Checks that limit outflow to [0 acre-feet/month, MaxRelease]; or, should the 0 acre-feet actually be a MinRelease value (UBRuleCurveData.ReservoirData slot has a min release value of 3,000 cfs for Mead)";
    BEGIN

      IF ( ( "ComputeOutflowAtGivenStorageForSpaceBuilding"( % "Mead", "SpaceBuilding"(  ) ) > $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000] ) COMMENTED_BY "Outflow to reach target > Max flood control release, use Max flood control release" )
 THEN
  $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000]
 ELSE
  "Max"( "ComputeOutflowAtGivenStorageForSpaceBuilding"( % "Mead", "SpaceBuilding"(  ) ), 0.00000000 "acre-feet/month" ) COMMENTED_BY "Use non-negative release to reach target"
 ENDIF;

    END
    UUID "{4c43ee10-592a-4ce6-ba52-32458ac876a9}";;

    FUNCTION       "ComputeTargetStorage" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates a target storage volume for Mead based on either the volume calculated by the SpaceBuilding function, or the volume achievable by the MaxRelease outflow<br><br>RETURNS: Storage Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "ComputeOutflowAtGivenStorage"( % "Mead", "SpaceBuilding"(  ) ) > $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000] )
 THEN
  "ComputeStorageWithGivenOutflow"( % "Mead", $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000] )
 ELSE
  "SpaceBuilding"(  )
 ENDIF COMMENTED_BY "If the outflow to reach the SpaceBuilding storage target exceeds the MaxRelease outflow, <br>calculate the storage achieved at the MaxRelease; otherwise use the SpaceBuilding storage";

    END
    UUID "{b7650f1a-0b1f-4962-ace8-302fcdff2ce1}";;

    FUNCTION       "CurrentAvailableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the storage space available at the current timestep for the specified reservoir<br><br>RETURNS: Available volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the available space is desired<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "GetLiveCapacity"( reservoir ) - reservoir & "Storage" [];

    END
    UUID "{d1dfab7a-fbac-40ec-97e4-dd5bf45e0edd}";;

    FUNCTION       "FloodControlEvap" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the evaporation incurred during flood control operations using a storage value halfway between the storage at the previous timestep and the live capacity of the reservoir<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the evaporation is calculated<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "StorageToArea"( reservoir, "GetLiveCapacity"( reservoir ) - "AvailableSpace"( reservoir ) / 2.00000000 ) * "SumEvapCoeff"( reservoir );

    END
    UUID "{b41e7153-5833-416c-b40d-d8e767e7af98}";;

    FUNCTION       "DeltaBankStorage" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the total change in bank storage of Mead and Powell that occurs by using the space available in each<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] * ( "AvailableSpace"( % "Mead" ) - $ "MeadFloodControlData.MinSpace" [0.00000000, 0.00000000] ) + $ "Powell.Bank Storage Coefficient" [0.00000000, 0.00000000] * "AvailableSpace"( % "Powell" );

    END
    UUID "{76445aa9-2a10-4245-a431-4f3e7ad1819d}";;

    FUNCTION       "ForecastMeadInflow" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function computes the inflow forecast through July for Mead for use in the flood control release determination.<br><br>RETURNS: Forecast inflow volume to Mead [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumSlotVolume"( $ "PowellInflow.Unregulated", "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) ) + "SumAllGainsBelowVolume"( % "Powell", @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) + $ "MeadFloodControlData.Forcmax" ["Forcmax", "GetMonthAsString"( @"t" )] - $ "FloodControlOutput.UBEffective" [];

    END
    UUID "{d6f1568e-8fe1-4743-8858-c3c7d8038340}";;

    FUNCTION       "SouthernNevConsumed" ( LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the total diversion volume requested by SNWP over the date range passed as an argument<br><br>RETURNS: Diversion volume requested [L^3]<br><br>ARGUMENTS:<br>1. LIST dates - a list of dates over which the diversion is summed<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: This function is unnecessary since its functionality can be replaced by using the predefined function SumFlowsToVolume";
    BEGIN

      "SumSlotVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested", dates );

    END
    UUID "{33e33e65-22d3-4c7c-a532-348da4c0b5ed}";;

    FUNCTION       "ForecastRunoffSeason " (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the release level required to pass excess inflow from Mead. This level corresponds to the flood control release steps in Table 1 in Exhibit A of the Flood Control Manual and is used in determining Mead flood control releases January 1 - July 31.<br><br>RETURNS: List of lists of the form &lcub;&lcub;Flow, Release level index&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Non-negative minimum release flow<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170906: Changed ?<=? to ?<? in the Boolean ?(results<1>) < 5.00000? in the WHILE conditional statement";
    BEGIN

      WHILE ( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) ), @"t" ) COMMENTED_BY "Remaining excess volume at current release level as flow rate" > $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] COMMENTED_BY "Currently considered release level" AND ( GET @INDEX 1.00000000 FROM results ) < 5.00000000 ) WITH LIST results = { "Max"( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( 0.00000000 ), @"t" ) COMMENTED_BY "Volume at lowest release level", 0.00000000 "acre-feet/month" ) , 0.00000000 } DO
  IF ( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 ), @"t" ) COMMENTED_BY "Remaining excess volume at next higher release level as flow rate" <= $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] COMMENTED_BY "Currently considered release level" )
  THEN
   INSERT $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] INTO INSERT ( ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 ) * "DebuggerStop"(  ) INTO results
  ELSE
   INSERT "Max"( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 ), @"t" ), 0.00000000 "acre-feet/month" ) INTO INSERT ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 INTO results
  ENDIF
 ENDWHILE;

    END
    UUID "{a73142e2-f397-47a5-8ff3-78d860d5ea98}";;

    FUNCTION       "ComputeMinMeadFloodRelease" ( NUMERIC index )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the difference between the Mead inflow volume in excess of the available space in Mead and Powell and the volume released between the next timestep and the end of July of the current year at the release level specified by the input argument &quot;index&quot;<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. NUMERIC index - index that specifies a release level for Mead<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "FloodControlOutput.Withoutrel" [] - "FloodControlLevelVolume"( "GetMonthlyDatelist"( @"t + 1", @"24:00:00 July Max DayOfMonth, Current Year" ), index );

    END
    UUID "{e99d3911-925a-43a6-aafb-83e981897363}";;

    FUNCTION       "FloodControlLevelVolume" ( LIST dateList, NUMERIC index )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the volume released from Mead at the release level specified by the input argument &quot;index&quot;<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. LIST dateList - list of dates over which the release volume should be calculated<br>2. NUMERIC index - index specifying a release level<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN dateList ) WITH NUMERIC result = 0.00000000 "acre-feet" DO
  result + "FlowToVolume"( $ "MeadFloodControlData.Levels" [0.00000000, index], date )
 ENDFOR;

    END
    UUID "{64924c39-a663-49a4-b33e-7048741ccb38}";;

    FUNCTION       "ComputeDeltaTargetStorage" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function computes the difference between the previous timestep's storage and the target storage at the current timestep for the Lower Basin reservoir specified as an input argument<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - LB reservoir for which storage difference is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "GetTargetStorage"( reservoir, @"t" ) - reservoir & "Storage" [@"t - 1"];

    END
    UUID "{18d439a9-307f-4489-bc1f-314ecf69a6d1}";;

    FUNCTION       "UBCreditableSpace" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function sums the space available in upper basin reservoirs for flood control, up to the maximum creditable space, for Powell, Flaming Gorge (including Fontenelle), Navajo, and Blue Mesa. The maximum creditable space for each reservoir is specified in the Hoover Flood Control Manual for the space building months of August through December.<br><br>RETURNS: Available UB storage [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( OBJECT reservoir IN "ListSubbasin"( "UBFloodControlReservoirs" ) ) WITH NUMERIC sum = 0.00000000 "acre-feet" DO
  IF ( ( STRINGIFY reservoir ) == "FlamingGorge" )
  THEN
   sum + "Min"( "CurrentAvailableSpace"( % "FlamingGorge" ) + "CurrentAvailableSpace"( % "Fontenelle" ), "GetMaxCreditableSpace"( % "FlamingGorge" ) )
  ELSE
   sum + "Min"( "CurrentAvailableSpace"( reservoir ), "GetMaxCreditableSpace"( reservoir ) )
  ENDIF
 ENDFOR;

    END
    UUID "{2dcc52d2-d29c-48c2-a870-d845185aa9e8}";;

    FUNCTION       "SpaceBuilding" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function is used to determine if space building releases from Hoover are necessary. It compares the minimum required available flood control storage space at a given month (using the SystemSpace function and the MeadFloodControlData.Space table) to the available space in Mead plus the creditable space in upper basin reservoirs. If there is not sufficient flood control space available, it computes the target storage required to create the minimum flood control space in Mead, and returns that storage target.<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( ( "CurrentAvailableSpace"( % "Mead" ) + "UBCreditableSpace"(  ) > "SystemSpace"(  ) ) COMMENTED_BY "Current Mead space + UB space > Required space for current month" )
 THEN
  "ComputeMinimumSpace"( % "Mead" ) COMMENTED_BY "Calculate max space available in Mead"
 ELSE
  ( "GetLiveCapacity"( % "Mead" ) - "SystemSpace"(  ) + "UBCreditableSpace"(  ) ) COMMENTED_BY "Calculate max space available in Mead + UB"
 ENDIF;

    END
    UUID "{7b3a042a-3720-4427-86ba-449c8e2809fa}";;

    FUNCTION       "SumEvapCoeff" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the sum of all the evaporation coefficients for the specified reservoir until July. During the sum, the coefficient values are adjusted to deal with the unit conversion issue between the current month and the months for which the values were entered, and converted into 31 day months. <br><br>RETURNS: Evaporation depth [L]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir whose coefficients are to be summed<br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: Powell uses the Periodic Net evaporation method, and does not have a slot named &quot;Evaporation Coefficients&quot;.  For that reason, I'm doubtful this function has been called since that method has been in use, as it seems likely the function would fail.";
    BEGIN

      FOR ( DATETIME date IN "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) ) WITH NUMERIC result = 0.00000000 "ft" DO
  result + reservoir & "Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000] * 1.00000000 "month"
 ENDFOR;

    END
    UUID "{24a88c69-bb2a-44d1-9642-18cf4a9d0db3}";;

  END
  UUID "{5606f0cd-858b-449a-b01e-b44c7bcb931e}";;

  UTILITY_GROUP "24 Month General Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AcreFeetPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170504: Disabled this function because there are no calls to it in the current rule set";
    BEGIN

      value;

    END
    UUID "{04888093-06e6-439b-91c8-6193df7d88c3}";;

    FUNCTION       "SlotToString" ( OBJECT obj )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function retrieves a list of slots from a data object by using the GetSeriesSlots predefined function and then converts the list of slots into a list of strings of the slot names.<br><br>RETURNS: List of strings<br><br>ARGUMENTS:<br>1. OBJECT obj - object for which the slot names are desired<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      MAPLIST ( SLOT slotname IN "GetSeriesSlots"( obj ) ) DO
  "GetSlotName"( slotname )
 ENDMAPLIST;

    END
    UUID "{a2809567-4d10-4e4c-a3ef-af5781592197}";;

    FUNCTION       "AcreFeetPerMonthPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet/month]";
    DESCRIPTION    "<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170504: This function is only used in DebuggingRule, which I turned off, so I turned this function off also";
    BEGIN

      value;

    END
    UUID "{8c438d77-4b00-4aab-9d1a-e4a7fa048f75}";;

    FUNCTION       "CFSPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170504: No calls to this function so I turned it off";
    BEGIN

      value;

    END
    UUID "{2c763fb3-e875-44b7-b86a-e01de03b3535}";;

    FUNCTION       "CheckResPhysicalConstraint" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total water available as a flow rate by converting the previous storage volume into a flow rate, adding the inflows for the date specified, and subtracting a fixed flow rate (50,000 acre-ft/month)<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir to check<br>2. DATETIME date - date on which to check the reservoir<br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: Is there a basis for the fixed 50,000 acre-ft/month, and if so, what is it? Move this value to a slot?";
    BEGIN

      WITH DATETIME dateBefore = "OffsetDate"( date, - 1.00000000, "1 months" ) DO
  "VolumeToFlow"( res & "Storage" [dateBefore], date ) + res & "Inflow" [date] - 50000.00000000 "acre-ft/month"
 ENDWITH;

    END
    UUID "{c8f770cc-24ba-4359-b8f5-ea7ab2754ea7}";;

    FUNCTION       "GetMonthlyDatelist" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: makes a monthly datelist from the startDate month to the endDate month.<br><br>RETURNS: List of form &lcub;Month&rcub; [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME startDate - beginning period for which to generate list<br>2. DATETIME endDate - ending of period for which to generate list<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170504: Calls to this function use current or next timestep and end of July in current year as startDate and endDate, so implicit assumption those arguments are end of month dates? I think all of the calls to the function use t or t+1 as startDate and July 31, Current Year as endDate, so okay now but not robust.";
    BEGIN

      IF ( startDate >= endDate )
 THEN
  { endDate }
 ELSE
  WHILE ( ( GET @INDEX 0.00000000 FROM dateList ) > startDate ) WITH LIST dateList = { endDate } DO
   INSERT ( GET @INDEX 0.00000000 FROM dateList ) - "GetDaysInMonth"( ( GET @INDEX 0.00000000 FROM dateList ) - 1.00000000 "day" ) INTO dateList
  ENDWHILE
 ENDIF;

    END
    UUID "{42fc95ad-a250-4249-8b02-a07fc6b15e47}";;

    FUNCTION       "SumGainsBelow" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170530: This function has no calls to it in the current ruleset, so I turned it off. Note this version differs from SumGainsBelowVolume and SumAllGainsBelowVolume because it only sums slots with Input values.";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "INPUT", FALSE, @"t", @"t" );

    END
    UUID "{3e1304b7-a5ed-44cf-ada9-368fd3f74f6e}";;

    FUNCTION       "SumGainsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumObjectsAggregatedOverTime to calculate the sum of the local inflows downstream of the reservoir specified as an input argument between the dates specified as input arguments<br><br>RETURNS: Volume of local inflows (the TRUE option in the call to SumObjectsAggregatedOverTime converts FLOW to VOLUME)<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir object for which local inflow total is desired<br>2. DATETIME startDate - beginning date for sum<br>3. DATETIME endDate - end date for sum<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: This function is the same as SumAllGainsBelowVolume, so I changed all references to this function to call that function, and turned this function off.";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "ALL", TRUE, startDate, endDate );

    END
    UUID "{3288054e-9a4f-4154-b39d-3468518bce05}";;

    FUNCTION       "SumAllGainsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumObjectsAggregatedOverTime to calculate the sum of the local inflows downstream of the reservoir specified as an input argument between the dates specified as input arguments<br><br>RETURNS: Volume of local inflows (the TRUE option in the call to SumObjectsAggregatedOverTime converts FLOW to VOLUME) [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir object for which local inflow total is desired<br>2. DATETIME startDate - beginning date for sum<br>3. DATETIME endDate - end date for sum<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: This function is the same as the user-defined function SumGainsBelowVolume. I changed all calls to that function to call thist function and turned that one off.";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "ALL", TRUE, startDate, endDate );

    END
    UUID "{3e8873fd-0acb-4909-a3d3-6c5dfafe3cb7}";;

    FUNCTION       "SumDiversionsBelow" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "MC, 20170530: This function is the same as SumDiversionsBelowVolume except that this version does not convert the aggregated flow rates to Volume; there are no calls to this function in the current ruleset, so I turned it off.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "INPUT", FALSE, @"t", @"t" );

    END
    UUID "{55c70a47-88a5-4942-ba86-b63413e5af89}";;

    FUNCTION       "SumDiversionsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "MC, 20170530: This function is the same as SumAllDiversionsBelowVolume except this version aggregates only slots with Input values. There are no calls to this function in the current ruleset, so I turned it off.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "INPUT", TRUE, startDate, endDate );

    END
    UUID "{b700ec62-2366-4a95-b129-1f6b86889497}";;

    FUNCTION       "SumAllDiversionsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumObjectsAggregatedOverTime to calculate the sum of the diversion requests downstream of the reservoir specified as an input argument between the dates specified as input arguments<br><br>RETURNS: Volume of diversion requests (the TRUE option in the call to SumObjectsAggregatedOverTime converts FLOW to VOLUME) [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir object for which diversion total is desired<br>2. DATETIME startDate - beginning date for sum<br>3. DATETIME endDate - end date for sum<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "ALL", TRUE, startDate, endDate );

    END
    UUID "{122aa2a3-ad2d-46aa-92f8-b013124c3fda}";;

    FUNCTION       "SumSlotVolume" ( SLOT slot, LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: Given a slot (FLOW units) and a list of dates as arguments, returns the volume sum of the slot over the dates<br><br>RETURNS: Volume sum of slots flow values for dates specified [L^3]<br><br>ARGUMENTS:<br>1. SLOT slot - the slot whose values are to be summed<br>2. LIST dates - the dates to be included in the sum<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: Replace calls to this function with the predefined function SumFlowsToVolume?";
    BEGIN

      FOR ( DATETIME date IN dates ) WITH NUMERIC sum = 0.00000000 "acre-feet" DO
  sum + "FlowToVolume"( slot [date], date )
 ENDFOR;

    END
    UUID "{09067f31-7ebd-4161-8c13-bbd7cc81a2aa}";;

    FUNCTION       "Compute Head as a Function of Turbine Release" ( NUMERIC turbineRelease )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the Mohave power head for the current timestep as the difference between the tailwater elevation, as calculated from the tailwater table using the turbineRelease argument, and the average pool elevation over the current timestep, calculated as the sum of the current pool elevation and the previous pool elevation divided by 2<br><br>RETURNS: Turbine head [L]<br><br>ARGUMENTS:<br>1. NUMERIC turbineRelease - dam release through the turbines<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      ( $ "Mohave.Pool Elevation" [] + $ "Mohave.Pool Elevation" [@"t - 1"] ) / 2.00000000 - "TableInterpolation"( $ "Mohave.Tailwater Table", 0.00000000, 1.00000000, turbineRelease, @"t" );

    END
    UUID "{ecc4d28e-9e95-44bc-8879-5115b3350168}";;

    FUNCTION       "Annual Volume" ( SLOT slot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumFlowsToVolume to calculate the sum of a given slot over the current calendar year<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. SLOT slot - the slot for which the annual volume is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Remove this function and simply call SumFlowsToVolume instead?";
    BEGIN

      "SumFlowsToVolume"( slot, @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" );

    END
    UUID "{6fc6c106-26b9-4cda-8ce9-53630fcf70e3}";;

    FUNCTION       "AnnualVolumeSlot" ( SLOT slot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculate the sum of a given slot over the current calendar year<br><br>RETURNS: Sum of slot values [Slot units]<br><br>ARGUMENTS:<br>1. SLOT slot - the slot to sum<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      "SumSlot"( slot, @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" );

    END
    UUID "{ef99f9d7-352c-4e3c-b0b3-3b95d52e63b4}";;

    FUNCTION       "SumSlotList" ( OBJECT obj )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This functions starts out with a data object. It gets a list of slots in the object by using the GetSeriesSlots predefined function. It then sums the values of all the slots in the object over the current timestep.<br><br>MC, 20170530: There are no calls to this function in the current ruleset, so I turned it off.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( SLOT slotname IN "GetSeriesSlots"( obj ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
  result + slotname []
 ENDFOR;

    END
    UUID "{b01d3868-6495-4b5c-a921-da3e0bc26308}";;

    FUNCTION       "SumSlotListDates" ( OBJECT obj, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This functions sums the values of all the slots on the object passed as an argument for the timestep passed as an argument<br><br>RETURNS: Sum of slot values [L^3]<br><br>ARGUMENTS:<br>1. OBJECT obj - object whose slots are to be summed<br>2. DATETIME date - date on which to calculate the slot sum<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( SLOT slotname IN "GetSeriesSlots"( obj ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
  result + slotname [date]
 ENDFOR;

    END
    UUID "{c7382fda-6200-4b42-a304-36458572752b}";;

    FUNCTION       "GetLastDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the last day of the year of the model run's last timestep, regardless of the date passed to the function.<br><br>RETURNS: Last day of the year for last year in run [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date that is irrelevant since the function returns the same value regardless of this date<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: This function returns the same value no matter what date is passed; replace it with the Dec31ofYear(@&quot;Finish Timestep&quot;) wherever it occurs";
    BEGIN

      IF ( "GetMonth"( date ) > 1.00000000 )
 THEN
  "Dec31ofYear"( @"Finish Timestep" )
 ELSE
  "Dec31ofYear"( @"Finish Timestep" )
 ENDIF;

    END
    UUID "{2b3cfbc7-6652-49fb-8520-a5dc0d0f335b}";;

    FUNCTION       "GetFirstDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is used in rules that set monthly values in outyears. If the start timestep is December, we want the rule to skip the 1st 2 timesteps and set values Feb - Dec (11 total), otherwise set values Jan-Dec (12 total). <br><br>RETURNS: Last date in January or February of the current year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date used to determine whether the returned date represents January or February<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( date == @"Start Timestep + 1" )
 THEN
  @"24:00:00 February Max DayOfMonth, Current Year"
 ELSE
  @"24:00:00 January Max DayOfMonth, Current Year"
 ENDIF;

    END
    UUID "{1f6d0c57-c47a-4cbf-8369-982c2e9d15f5}";;

    FUNCTION       "GetDaysBasedOnFirstDate" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is used in rules that set monthly values in outyears. If the start timestep is December, we want the rule to skip the 1st two timesteps and set values Feb - Dec (11 total), otherwise set values Jan-Dec (12 total). <br><br>RETURNS: the number of months to divide an annual volume into [NONE]<br><br>ARGUMENTS: <br>1. DATETIME date - date used to determine the number of months<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown <br>MC, 20170530: 1.) Replaced @&quot;t&quot; by date because both rules calling this function pass @&quot;t&quot; as date; 2.) Changed the original misleading name GetDaysBasedOnFirstDate to current name because the function is actually calculating a number of months, not days (reverted back for consistency with CRSS?)<br><br>ST, 20181231: updated logic to match 24 MS";
    BEGIN

      IF ( date == @"Start Timestep + 1" )
 THEN
  11.00000000
 ELSE
  12.00000000
 ENDIF;

    END
    UUID "{53ba7e28-21b0-4aeb-aa31-af8e6af1227d}";;

    FUNCTION       "Dec31ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Determines the day of the year for December 31 making corrections for leap years if necessary. -CE 6/11/13<br><br>RETURNS: December 31 of the year of the date specified [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies the year for which Dec 31 is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170531: (Possible rewrite) CompletePartialDate(@&quot;December 31&quot;, date)";
    BEGIN

      IF ( "LeapYear"( date ) )
 THEN
  "OffsetDate"( date, "Units NONE"( 366.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ELSE
  "OffsetDate"( date, "Units NONE"( 365.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ENDIF;

    END
    UUID "{360542aa-f153-42db-9736-a6b91d6252c6}";;

    FUNCTION       "PartialToFull" ( DATETIME MonthDay )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns a fully-specified datetime in the current year of the partially-specified datetime in the input parameter MonthDay<br><br>RETURNS: A full datetime expression [DATETIME]<br><br>ARGUMENTS: <br>1. DATETIME MonthDay - a partially-specified datetime representing a month and day<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown <br>MC, 20160915: Replace calls with calls to predefined function CompletePartialDate (cf. Annual Daily Black Canyon Flow Determination)? ";
    BEGIN

      WHILE ( result < MonthDay ) WITH DATETIME result = @"24:00:00 January 1, Current Year" DO
  result + 1.00000000 "day"
 ENDWHILE;

    END
    UUID "{576c3b51-b941-4fe7-bde4-80f7b2443213}";;

    FUNCTION       "Units NONE" ( NUMERIC number )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Removes the &quot;day&quot; units from a value. - CE 6/11/13<br><br>RETURNS: Number without units [NONE]<br><br>ARGUMENTS:<br>1. NUMERIC number - a number with units of &quot;days&quot;<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      number / 1.00000000 "day";

    END
    UUID "{826d2d51-596a-4334-bd77-3791fc1dd03c}";;

  END
  UUID "{94f89e7e-e6e0-4d92-912b-bfe7746f9da4}";;

  UTILITY_GROUP "Rule Curve Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "ComputeOutflowAtGivenStorage" ( OBJECT reservoir, NUMERIC storage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: Uses the predefined function SolveOutflow to calculate the outflow value that leads to the final storage value provided in the input parameter &quot;storage&quot; bound by Mead min and max releases defined in the UBRuleCurveData object.<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir object for which the outflow value is desired<br>2. NUMERIC storage - the end of timestep storage target<br><br>CONSTRAINTS: Minimum and maximum releases as stored on UBRuleCurveData.ReservoirData<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT "GetMinRelease"( reservoir );
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20160915 - the ComputeOutflowAtGivenStorageForSpaceBuilding user-defined function uses the same calculation but does not contain the Min and Max Release constraints that are in this function";
    BEGIN

      "SolveOutflow"( reservoir, reservoir & "Inflow" [@"t"], storage, reservoir & "Storage" [@"t - 1"], @"t" );

    END
    UUID "{04073ef3-d4e1-45c7-b04a-b1e0bc59b5b5}";;

    FUNCTION       "ComputeOutflowAtGivenStorageForSpaceBuilding" ( OBJECT reservoir, NUMERIC storage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "DESCRIPTION: Uses the predefined function SolveOutflow to calculate the outflow value that leads to the final storage value provided as the input parameter &quot;storage&quot; without outflow constraints<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir object for which the outflow value is desired<br>2. NUMERIC storage - the end of timestep storage target<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20160915: the ComputeOutflowAtGivenStorage user-defined function uses the same calculation but contains Post-Exec Checks that constrain the outflow to Min and Max Release values; remove this one?";
    BEGIN

      "SolveOutflow"( reservoir, reservoir & "Inflow" [], storage, reservoir & "Storage" [@"t - 1"], @"t" );

    END
    UUID "{0c19ef86-9de7-426a-abd9-6bd9e5f41efd}";;

    FUNCTION       "ComputeStorageWithGivenOutflow" ( OBJECT reservoir, NUMERIC outflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Uses the predefined function SolveStorage to calculate the end of timestep storage using the provided outflow value, subject to minimum and maximum storage values from the GetInactiveCapacity and GetLiveCapacity user-defined functions<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir object for which the storage is desired<br>2. NUMERIC outflow - the outflow value used to achieve the end of timestep storage value<br><br>CONSTRAINTS: Inactive (min) and Live (max) capacities of reservoir<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT "GetInactiveCapacity"( reservoir );
    MAX_CONSTRAINT "GetLiveCapacity"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SolveStorage"( reservoir, reservoir & "Inflow" [], outflow, reservoir & "Storage" [@"t - 1"], @"t" );

    END
    UUID "{2ef4b157-2d0e-49f2-8b41-2327156c9d8a}";;

  END
  UUID "{41afa860-b2a0-482e-adaa-4ce529aa0aaf}";;

  UTILITY_GROUP "Get Data Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetMaxRelease" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function returns the maxRelease value from the UBRuleCurveData data object for the reservoir specified<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the maximum release is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "maxRelease"];

    END
    UUID "{f0b88055-71d9-4985-9437-4af8398596e0}";;

    FUNCTION       "GetMinRelease" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function returns the minRelease value from the UBRuleCurveData data object for the reservoir specified<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the minimum release is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "minRelease"];

    END
    UUID "{c2700b83-a645-45a7-8f9f-8deb90aa66ce}";;

    FUNCTION       "GetMininumSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the Min Space value from the MeadFloodControlData data object for the reservoir specified<br><br>RETURNS: Volume [L^3]<br><br>CONSTRAINTS: <NONE><br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the minimum space is desired (originally only Mead value specified in data object)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "MeadFloodControlData.MinSpace" [STRINGIFY reservoir, "Min Space"];

    END
    UUID "{b0debd7d-2986-4a80-b133-43ffad45e802}";;

    FUNCTION       "GetMaxCreditableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the maximum creditable space from the MeadFloodControlData.CredSpace table for the specified upper basin reservoir. This represents the maximum space that can be credited to available flood control space in the system for that reservoir.<br><br>RETURNS: Volume [L^3]<br><br>CONSTRAINTS: <NONE><br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the creditable space is desired<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "MeadFloodControlData.CredSpace" ["Credit. Space", STRINGIFY reservoir];

    END
    UUID "{50c246c9-958c-4468-a8fd-38e19fa3cd78}";;

    FUNCTION       "GetInactiveCapacity" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the value from the inactiveCapacityStorage column of the slot UBRuleCurveData.ReservoirData for the reservoir specified<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the inactive capacity storage is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "inactiveCapacityStorage"];

    END
    UUID "{756d25b6-6e74-4e57-9ea7-e1f760dc96de}";;

    FUNCTION       "GetLiveCapacity" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the value from the liveCapacityStorage column of the slot UBRuleCurveData.ReservoirData for the reservoir specified<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the live capacity storage is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "liveCapacityStorage"];

    END
    UUID "{0286bad3-d3e6-44d6-9bd6-eb49a1778d9b}";;

    FUNCTION       "GetTargetStorage" ( OBJECT reservoir, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the value from the slot for Target Storage on the LBRuleCurveData data object for the reservoir and date specified<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - reservoir for which Target Storage is desired<br>2. DATETIME date - date for which Target Storage is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "LBRuleCurveData." CONCAT ( STRINGIFY reservoir ) CONCAT " Target Storage" [date];

    END
    UUID "{4ca72cdc-3ac0-4ac9-b315-1af6ef9c664e}";;

    FUNCTION       "SystemSpace" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the space required in Mead for the current timestep from the MeadFloodControlData.Space slot<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "MeadFloodControlData.Space" [0.00000000, "GetMonthAsString"( @"t" )];

    END
    UUID "{2e3f8a92-94ba-4864-8946-3a3f94a0aab6}";;

    FUNCTION       "GetEndDayOfMonth" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the last day of the current month<br><br>RETURNS: Datetime<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: See Development Notes on function MaxDayOfMonth";
    BEGIN

      @"24:00:00 Current Month Max DayOfMonth, Current Year";

    END
    UUID "{f38c0a43-1ebd-456d-8f28-0ccb7be975d5}";;

    FUNCTION       "GetStartDayOfMonth" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates and returns the first day of the current month<br><br>RETURNS: First day of current month [Datetime]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: See Development Notes on function MinDayOfMonth";
    BEGIN

      @"24:00:00 Current Month Min DayOfMonth, Current Year";

    END
    UUID "{427680e6-70c3-4f12-b1c7-b3c91b0c0c0d}";;

    FUNCTION       "GetDiversionToDate" ( SLOT Slot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( @"t" == @"24:00:00 January Max DayOfMonth, Current Year" )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "SumSlot"( Slot, @"24:00:00 January 31, Current Year", @"t - 1" )
 ENDIF;

    END
    UUID "{434c0d7f-0df9-4245-8890-d580d5308bc8}";;

    FUNCTION       "GetDaysLeftInYear" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( ( "GetDayOfYear"( @"24:00:00 December Max DayOfMonth, Current Year" ) - "GetDayOfYear"( "OffsetDate"( @"t - 1", 1.00000000, "1 days" ) ) ) + 1.00000000 "day" );

    END
    UUID "{1b11b88b-53dd-49b0-a94b-3c159aad5644}";;

  END
  UUID "{951305b9-1f35-4e65-9fb4-65e4f7753e18}";;

  UTILITY_GROUP "Shortage Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetShortageElevationString" ( NUMERIC indextier )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns, as a string, the lower limit of the Mead pool elevation value for the shortage tier specified in the input argument<br><br>RETURNS: Pool elevation value as a string [NONE] <br><br>ARGUMENTS: <br>1. NUMERIC indextier - numeric indicator of Lower Basin shortage level<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( indextier == 0.00000000 )
 THEN
  "1075"
 ELSE
  IF ( indextier == 1.00000000 )
  THEN
   "1050"
  ELSE
   "1025"
  ENDIF
 ENDIF;

    END
    UUID "{e793d762-a33a-4f07-a61b-4fea6130f5f9}";;

    FUNCTION       "Arizona Shortage Depletion" ( STRING user, NUMERIC indextier, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function calculates the specified AZ user's depletion allowed under a Shortage condition<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <br>1. STRING user - specifies the user for which the shortage depletion is desired<br>2. NUMERIC indextier - specifies the index of the shortage tier<br>3. DATETIME date - specifies the date for which the depletion is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR,DATE: Unknown";
    BEGIN

      WITH STRING short_elev = "GetShortageElevationString"( indextier ) DO
  "VolumeToFlow"( % "Arizona_CU_Schedules" & user [date] - "GetObject"( ( "Arizona_Shortage" CONCAT short_elev ) CONCAT "_Schedules" ) & user ["Dec31ofYear"( date )] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"], date )
 ENDWITH;

    END
    UUID "{59061bef-9dff-4573-84da-9dcb7c4dbd36}";;

    FUNCTION       "CAP Shortage Depletion" ( NUMERIC indextier, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculate the monthly forecast CAP diversion under Shortage condition<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. NUMERIC indextier - Shortage tier<br>2. DATETIME date - date for which to calculate the monthly volume<br><br>CONSTRAINTS: Minimum of 0.00 acre-feet/month<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "Max"( "VolumeToFlow"( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"] - "GetAnnualCAPShortage"( indextier ) * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"], date ), 0.00000000 "acre-ft/month" );

    END
    UUID "{f31d3de0-8f70-417f-b161-deadf0f6427b}";;

    FUNCTION       "GetAnnualCAPShortage" ( NUMERIC indextier )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: The annual CAP shortage amount is the Arizona shortage amount minus the sum of the non-CAP shortage amounts<br><br>RETURNS: Shortage volume for CAP [L^3]<br><br>ARGUMENTS: <br>1. NUMERIC indextier - the index for a Lower Basin shortage tier<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown ";
    BEGIN

      WITH STRING short_elev = "GetShortageElevationString"( indextier ) DO
  $ "Shortage.State Shortage Volumes" [indextier, "Arizona"] - "SumSlotListDates"( "GetObject"( ( "Arizona_Shortage" CONCAT short_elev ) CONCAT "_Schedules" ), @"24:00:00 December 31, Current Year" )
 ENDWITH;

    END
    UUID "{5db09af8-19f2-48ba-a5a9-62fbca86f648}";;

  END
  UUID "{5674b93c-45b0-44c7-bfa4-0a2b069675db}";;

  UTILITY_GROUP "Surplus Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "SumPreviousYearICScredits" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: Calculates the Lower Basin states' total cumulative ICS credits for the previous calendar year. Created as part of the Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR,DATE: HMG, 8/2/2011";
    BEGIN

      $ "ICS Credits.TotalICS_AZ" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.TotalICS_CA" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.TotalICS_NV" [@"24:00:00 December 31, Previous Year"];

    END
    UUID "{f4d7b9f5-1d8f-4b27-9774-a2ad68972808}";;

    FUNCTION       "Normal_LBDemands - Include Mexico" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates Lower Basin water use under Normal Conditions by summing diversion requests, including for Mexico. Created as part of the Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Maximum value of 7.5 MAF<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/2011<br>MC, 20170522: &quot;Annual Volume&quot; is just a call to SumFlowsToVolume; replace with those calls?";
    BEGIN

      "Min"( 7500000.00000000 "acre-ft" + "Annual Volume"( $ "MexicanTreatyDelivery.Total Diversion Requested" ), "Annual Volume"( $ "PumpingFromLakeMead.Total Diversion Requested" ) + "Annual Volume"( $ "OthersMeadToMohave.Total Diversion Requested" ) + "Annual Volume"( $ "NvDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "CaDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "AzDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "FtMohaveIndRes.Total Diversion Requested" ) + "Annual Volume"( $ "MWDDiversion.Total Diversion Requested" ) + "Annual Volume"( $ "CAPDiversion.Total Diversion Requested" ) + "Annual Volume"( $ "PaloVerde.Total Diversion Requested" ) + "Annual Volume"( $ "CRIR.Total Diversion Requested" ) + "Annual Volume"( $ "CaPkrToImp.Total Diversion Requested" ) + "Annual Volume"( $ "AzPkrToImp.Total Diversion Requested" ) + "Annual Volume"( $ "AAC.Total Diversion Requested" ) + "Annual Volume"( $ "GilaGravityMainCanal.Total Diversion Requested" ) + "Annual Volume"( $ "GilaAndYumaUsers.Total Diversion Requested" ) + "Annual Volume"( $ "MexicanTreatyDelivery.Total Diversion Requested" ) + "Annual Volume"( $ "OthersBlwImp.Total Diversion Requested" ) );

    END
    UUID "{16392f4f-81b0-4e91-93d1-3fafa3504942}";;

    FUNCTION       "QuantifiedSurplusVolume" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the non-negative volume of Quantified Surplus for the current calendar year<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Minimum of 0 acre-feet<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>CH, 4/24/18: Replaced Surplus.MaxStorage (a hardcoded value) with MaxStorage function that calculates this value as specified by Appendix A of CRSS documentation.<br>S.Baker 09/25/2018: Replace storage with ElevationToStorage() with function that determines which projected pool elevation to use (24MS or MTOM). <br>GCAA, 20181030: Replaced reference from ICMA balance to Mexico Water Reserve balance";
    BEGIN

      "Max"( ( "ElevationToStorage"( % "Powell", "GetProjectedPoolElevation"( "Powell", @"24:00:00 December 31, Previous Year" ) ) + "ElevationToStorage"( % "Mead", "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) ) - "MaxStorage"(  ) - ( "SumPreviousYearICScredits"(  ) + $ "Mexico Shortage and Surplus.Mexico Water Reserve Balance" [@"24:00:00 December 31, Previous Year"] ) ) * ( 1.00000000 + ( $ "Powell.Bank Storage Coefficient" [0.00000000, 0.00000000] + $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) / 2.00000000 ) + $ "Surplus.70RLeesFerryFlow" [] COMMENTED_BY "70th percentile non-exceedance <br>flow" - ( $ "Surplus.UBEvaporation" [] + $ "Surplus.UBDemand" [@"24:00:00 December 31, Current Year"] ) - "SumLBDemands - Include Mexico"(  ), 0.00000000 "acre-ft" );

    END
    UUID "{93faffd9-c4e9-4216-be00-a076a261991f}";;

    FUNCTION       "SumLBDemands - Include Mexico" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: Calculates the Lower Basin demands as defined in the Interim Guidelines ROD. Created as part of the Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/2011";
    BEGIN

      "Normal_LBDemands - Include Mexico"(  ) + ( $ "Surplus.Average Annual Evaporation" [0.00000000, "Mead"] + $ "Surplus.Average Annual Evaporation" [0.00000000, "Mohave"] + $ "Surplus.Average Annual Evaporation" [0.00000000, "Havasu"] ) - ( "SumAllGainsBelowVolume"( % "Powell", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + "SumAllGainsBelowVolume"( % "Mead", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + "SumAllGainsBelowVolume"( % "Havasu", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) );

    END
    UUID "{c045c37d-e051-4186-b24f-6fd7dd6a15fb}";;

    FUNCTION       "Set Monthly Surplus Schedule" ( DATETIME date, STRING user )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the monthly surplus volume from the annual volume. This function was created as part of the Domestic and Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Monthly surplus volume [L^3]<br><br>ARGUMENTS<br>1. DATETIME date - date to calculate monthly surplus volume<br>2. STRING user - specifies user for which to calculate surplus volume<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR,DATE: HMG, 8/2/2011<br>MC, 20170512: Use of Monthly shortage percents is correct? If so, surplus monthly percentages are taken with the same distribution as shortage";
    BEGIN

      IF ( user == "CAP" )
 THEN
  % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"]
 ELSE
  IF ( user == "SNWA" )
  THEN
   % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"]
  ELSE
   % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Equal"]
  ENDIF
 ENDIF;

    END
    UUID "{80686dfb-d6eb-4a10-86e6-4c3697172259}";;

    FUNCTION       "Set Monthly Surplus Schedule- FC" ( DATETIME date, STRING user )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the monthly Flood Control Surplus volume from the annual volume. This function varies from the &quot;Set Monthly Surplus Schedule&quot; function in that it can be applied to any starting month instead of being limited to January. This is because a Flood Surplus can be declared at any point within the year. Once a Flood Control Surplus is declared it will continue through to the end of the current calendar year.  <br><br>RETURNS: Monthly volume [L^3]<br><br>ARGUMENTS: <br>1. DATETIME date - date used to calculate the monthly volume<br>2. STRING user - user for whom monthly volume is calculated<br><br>CONSTRAINTS: <NONE><br><br>DEVELOPMENT NOTES<br>AUTHOR,DATE: Unknown";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( user == "CAP" )
 THEN
  % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"]
 ELSE
  IF ( user == "SNWA" )
  THEN
   % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"]
  ELSE
   % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Equal"]
  ENDIF
 ENDIF;

    END
    UUID "{3efc5a9e-84df-447a-aead-d30b62a5f0b7}";;

    FUNCTION       "MaxStorage" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the maximum storage defined as the maximum combined storage of Lakes Powell and Mead that will meet the system space requirement at the beginning of the year, assuming 30% of that requirement will be met by the reservoirs upstream of Lake Powell<br><br>RETURNS: Monthly volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "CH, 4/24/18: Created to replace a scalar slot value (Surplus.MaxStorage = 47.96) to make this value dynamic. ";
    BEGIN

      "GetLiveCapacity"( % "Mead" ) + "GetLiveCapacity"( % "Powell" ) - 0.70000000 * $ "MeadFloodControlData.Space" [0.00000000, "GetMonthAsString"( @"24:00:00 December Max DayOfMonth, Current Year" )];

    END
    UUID "{38ca20d5-8305-4ce0-8c01-5d2a34174e0e}";;

    FUNCTION       "ShareofMexicoSurplusbyState" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br><br>GCAA, 20181030: Function added per Minute 323";
    BEGIN

      1.00000000 / 3.00000000;

    END
    UUID "{376ec321-31fe-4b2b-888f-60b2114f0251}";;

  END
  UUID "{aeb7d9d8-30db-4fa7-bc06-816a1da96e7d}";;

  UTILITY_GROUP "Orphan Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AlreadyUsedWater" ( OBJECT obj, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "SumFlowsToVolume"( obj & "Total Depletion", @"24:00:00 January Max DayOfMonth, Current Year", @"t - 1" );

    END
    UUID "{a879db7e-6f5d-4355-819c-6911a0e5675a}";;

    FUNCTION       "AnnualRequestedWater" ( STRING user, STRING type, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "SumFlowsToVolume"( "GetSlot"( user CONCAT ".Total " CONCAT type CONCAT " Requested" ), "OffsetDate"( date, - ( "GetMonth"( date ) - 1.00000000 ) COMMENTED_BY "The number to subtract from date to go to January of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to January of the year found in 'date'", "OffsetDate"( date, ( 12.00000000 - "GetMonth"( date ) ) COMMENTED_BY "The number to add to date to go to December of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to December of year found in 'date'" ) COMMENTED_BY "Calculated annual requested water (either depletion or diversion which is <br>specified by 'type') and expects the user to be on the San Juan River";

    END
    UUID "{3f9ec247-8a67-48bc-ae09-04f7b6ffdb82}";;

    FUNCTION       "AnticipatedInflowNavajo" ( DATETIME dateToStart, DATETIME dateToProject )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the inflow to Navajo for the entire run period<br><br>RETURN TYPE: NUMERIC<br><br>ARGUMENTS<br>1. DATETIME dateToStart<br>2. DATETIME dateToProject<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/07/2012<br>MC, 20170502: I turned this rule off and replaced its 2 references in the ruleset by its body. I'm scheduling it for deletion as unnecessary.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "SumFlowsToVolume"( $ "Navajo.Inflow", dateToStart, dateToProject );

    END
    UUID "{0a98244c-a64c-4b37-8dd5-6a862a70ea3f}";;

    FUNCTION       "April30ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the day of the year for April 30 making corrections for leap years if necessary. -CE 6/11/13";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "LeapYear"( date ) )
 THEN
  "OffsetDate"( date, "Units NONE"( 121.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ELSE
  "OffsetDate"( date, "Units NONE"( 120.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ENDIF;

    END
    UUID "{4ef9cb8c-81e7-4081-8b0c-eec0269db750}";;

    FUNCTION       "BlueMesaEOMElevationTarget" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "DESCRIPTION: This function takes a date and returns the end-of-month elevation target for Blue Mesa Reservoir.  It does this by reading the appropriate row from the BlueMesaData.BlueMesaGuide slot.  The only exception is that if the reservoir did not fill in June, then in July the function will return the June entry in the table. - sc 12/28/10<br><br>RETURNS: Pool elevation [L]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the target elevation is needed<br><br>CONSTRAINTS: <NONE><br><br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: No calls to this function so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "June" , "July" } )
 THEN
  IF ( "MaxItem"( "GetSlotVals"( $ "BlueMesa.Pool Elevation", @"t - 2", @"t - 1" ) ) >= $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] )
  THEN
   $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"]
  ELSE
   $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"]
  ENDIF
 ELSE
  $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"]
 ENDIF;

    END
    UUID "{1f010bf6-f720-4811-a078-95b622b5ed37}";;

    FUNCTION       "BlueMesaReleaseMAXConstraintByMonth" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function calculates the maximum constraint (ceiling) for the Blue Mesa release on the passed-in date.  The max constraint will not necessarily be the release, just provide an upper bound for that months release. - sc 12/28/10<br><br>RETURNS: Blue Mesa release ceiling [L^3/T]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the release ceiling is needed<br><br>CONSTRAINTS: <br><br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: May ceiling is unlimited?; no calls to function so disabled it";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "December" , "January" , "February" , "March" , "April" , "August" , "September" , "October" COMMENTED_BY "Move october and november to 2100 limit, per Paul D. - tv 7.26.12" , "November" } )
 THEN
  "Max"( "SolveBlueMesaReleaseForCrystalReleaseTarget"( 2100.00000000 "cfs", @"t" ), "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" COMMENTED_BY "change to 7516.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date ) )
 ELSE
  IF ( "GetMonthAsString"( date ) IN { "June" , "July" } )
  THEN
   "Max"( "SolveBlueMesaReleaseForCrystalReleaseTarget"( 4150.00000000 "cfs" COMMENTED_BY "Max at 4150 cfs, per Paul D. - tv 7.26.12", @"t" ), "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7519.40000000 "ft" COMMENTED_BY "change to 7519.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date ) COMMENTED_BY "Changed from mass balance to SolveOutflow function - tv 7.26.12" )
  ELSE
   9999999.00000000 "cfs"
  ENDIF
 ENDIF;

    END
    UUID "{eb723e96-7b1d-4bd2-a312-44b1da675177}";;

    FUNCTION       "BlueMesaReleaseMINConstraintByMonth" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10<br><br>MC, 20170531: No calls to function so disabled it";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC DownstreamFlowBasedConstraint = "BlueMesaReleaseMINConstraint_DownstreamFlow"( @"t" ) DO
  WITH NUMERIC ReservoirElevationBasedConstraint = "BlueMesaReleaseMINConstraint_ResElevation"( @"t" ) DO
   "Min"( "Max"( DownstreamFlowBasedConstraint, ReservoirElevationBasedConstraint ), "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", 7358.01000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "The maximum that the reservoir can release to the bottom of outlets at 7358 ft. Added 8/1/12 - tv" )
  ENDWITH
 ENDWITH;

    END
    UUID "{ce927da3-924a-41fc-aec8-930ef8a3085a}";;

    FUNCTION       "BlueMesaReleaseMINConstraint_ResElevation" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "January" } )
 THEN
  WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
   WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
    WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
     "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.17000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
    ENDWITH
   ENDWITH
  ENDWITH
 ELSE
  IF ( "GetMonthAsString"( date ) IN { "February" } )
  THEN
   WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
    WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
     WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
      "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.15000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
     ENDWITH
    ENDWITH
   ENDWITH
  ELSE
   IF ( "GetMonthAsString"( date ) IN { "March" } )
   THEN
    WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
     WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
      WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
       "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.15000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
      ENDWITH
     ENDWITH
    ENDWITH
   ELSE
    IF ( "GetMonthAsString"( date ) IN { "April" } )
    THEN
     WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
      WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
       WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
        "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.20000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
       ENDWITH
      ENDWITH
     ENDWITH
    ELSE
     IF ( "GetMonthAsString"( date ) IN { "June" } )
     THEN
      WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
       WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
        WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) DO
         "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.33000000, date ), date )
        ENDWITH
       ENDWITH
      ENDWITH
     ELSE
      IF ( "GetMonthAsString"( date ) IN { "July" } )
      THEN
       "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7519.40000000 "ft" COMMENTED_BY "Changed to 7519.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
      ELSE
       IF ( "GetMonthAsString"( date ) IN { "August" } )
       THEN
        "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" COMMENTED_BY "Changed to 7516.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
       ELSE
        IF ( "GetMonthAsString"( date ) IN { "September" } )
        THEN
         "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
        ELSE
         IF ( "GetMonthAsString"( date ) IN { "October" } )
         THEN
          "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
         ELSE
          IF ( "GetMonthAsString"( date ) IN { "November" } )
          THEN
           "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
          ELSE
           "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF;

    END
    UUID "{dc9fd606-8eb9-48eb-a603-0d3fb9a07356}";;

    FUNCTION       "BlueMesaReleaseMINConstraint_DownstreamFlow" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC flowLevel = $ "BlueMesaData.MayPeakFlowLevel" ["Dec31ofYear"( @"24:00:00 April 1, Current Year" )] DO
  IF ( "GetMonthAsString"( date ) IN { "January" } )
  THEN
   "Min"( "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "TunnelReturnFlow.Inflow" [@"t - 1"] ), @"t" ), $ "BlueMesaData.BaseFlowTarget" [date, flowLevel] )
  ELSE
   IF ( "GetMonthAsString"( date ) IN { "February" } )
   THEN
    "Min"( "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" ), $ "BlueMesaData.BaseFlowTarget" [date, flowLevel] )
   ELSE
    IF ( "GetMonthAsString"( date ) IN { "March" } )
    THEN
     "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
    ELSE
     IF ( "GetMonthAsString"( date ) IN { "April" } )
     THEN
      "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
     ELSE
      IF ( "GetMonthAsString"( date ) IN { "June" } )
      THEN
       "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "BlueMesaData.BaseFlowTarget" [date, flowLevel] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [@"t"] ), @"t" )
      ELSE
       IF ( "GetMonthAsString"( date ) IN { "July" } )
       THEN
        "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "BlueMesaData.BaseFlowTarget" [date, flowLevel] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [@"t"] ), @"t" )
       ELSE
        IF ( "GetMonthAsString"( date ) IN { "August" } )
        THEN
         "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
        ELSE
         IF ( "GetMonthAsString"( date ) IN { "September" } )
         THEN
          "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
         ELSE
          IF ( "GetMonthAsString"( date ) IN { "October" } )
          THEN
           "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
          ELSE
           IF ( "GetMonthAsString"( date ) IN { "November" } )
           THEN
            "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
           ELSE
            "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "BlueMesaData.BaseFlowTarget" [date, flowLevel] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [@"t"] ), @"t" )
           ENDIF
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END
    UUID "{9495b11b-b297-4b94-b35b-46ff3c6a9b6c}";;

    FUNCTION       "CalendarYearDatesByGroup" ( NUMERIC inputGroupNumber )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "MC, 20170502: This function is not called in the current ruleset";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH LIST prelimList = FOR ( DATETIME date IN @"Start Timestep + 1" TO @"Finish Timestep" ) WITH LIST result = { { @"Start Timestep" , 1.00000000 } } DO
  WITH NUMERIC groupNumber = GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
   IF ( "GetMonthAsString"( date ) == "October" )
   THEN
    APPEND { date , groupNumber + 1.00000000 } ONTO result
   ELSE
    APPEND { date , groupNumber } ONTO result
   ENDIF
  ENDWITH
 ENDFOR DO
  IF ( ( inputGroupNumber == 3.00000000 AND @"Start Timestep" == @"October 31" ) COMMENTED_BY "If the start month is October then there is no third water year in the run window.  Thus we need this function to be <br>non-empty and return a date that will definitely be outside of the run window. - sc 11/03/11" )
  THEN
   { @"24:00:00 December 31, 1900" }
  ELSE
   FOR ( LIST dateGroupNumber IN prelimList ) WITH LIST result = {  } DO
    IF ( ( GET @INDEX 1.00000000 FROM dateGroupNumber ) == inputGroupNumber )
    THEN
     APPEND GET @INDEX 0.00000000 FROM dateGroupNumber ONTO result
    ELSE
     result
    ENDIF
   ENDFOR
  ENDIF
 ENDWITH;

    END
    UUID "{0ccf6b27-5fdb-413a-9c9e-09d038cac148}";;

    FUNCTION       "EqualizationTeirCalculationForRelease_Orig" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC PowellVolumeOverEqLevel = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) ), 0.00000000 "acre-ft" ) DO
  WITH NUMERIC equalizationReleaseVolume = "EqualizationRelease"( EOWYDate ) DO
   WITH NUMERIC preliminaryReleaseVolume = "Min"( PowellVolumeOverEqLevel + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )], equalizationReleaseVolume ) DO
    WITH NUMERIC meadElevationWithPrelimRelease = IF ( $ "Mead.Storage" [EOWYDate] + ( preliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) >= "ElevationToStorage"( % "Mead", 1229.00000000 "feet" ) )
    THEN
     1229.00000000 "feet"
    ELSE
     "StorageToElevation"( % "Mead", $ "Mead.Storage" [EOWYDate] + ( preliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) )
    ENDIF DO
     IF ( meadElevationWithPrelimRelease < 1105.00000000 "ft" )
     THEN
      WITH NUMERIC totalVolumeToRaiseMeadTo1105 = "Max"( "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - $ "Mead.Storage" [EOWYDate], 0.00000000 "acre-ft" ) DO
       WITH NUMERIC PowellVolumeOverEqLevelLess20ft = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" ), 0.00000000 "acre-ft" ) DO
        ( "MinItem"( { equalizationReleaseVolume , totalVolumeToRaiseMeadTo1105 , PowellVolumeOverEqLevelLess20ft } ) + 8230.00000000 "1000 acre-feet" ) COMMENTED_BY "Choose the minimum of the equalization release, the release to take Mead to 1105 and the release to take Powell down to the equalization level less 20'"
       ENDWITH COMMENTED_BY "Volume of Powell storage above the equalization level minus 20 feet"
      ENDWITH COMMENTED_BY "Volume needed to release from Powell to raise Mead elevation to 1105'"
     ELSE
      preliminaryReleaseVolume
     ENDIF COMMENTED_BY "Check if the preliminary release volume takes Mead above 1105'.  If so the preliminary volume is chosen, if not continue."
    ENDWITH COMMENTED_BY "EOWY Elevation of Mead with the preliminaryReleaseVolume release from Powell"
   ENDWITH COMMENTED_BY "Preliminary annual volume release before the Mead elevation check."
  ENDWITH COMMENTED_BY "Total volume that would need to be released to equalize storage"
 ENDWITH COMMENTED_BY "Total Volume in Powell above the Current Equalization Level";

    END
    UUID "{1a8f0db2-e957-4c55-acf8-b6aeebd1fe6a}";;

    FUNCTION       "DetermineMonthlyDistribution" ( STRING slot2check, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( "FlowToVolume"( "GetSlot"( slot2check ) [date], date ) / "SumFlowsToVolume"( "GetSlot"( slot2check ), "OffsetDate"( date, - ( "GetMonth"( date ) - 1.00000000 ) COMMENTED_BY "The number to subtract from date to go to January of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to January of the year in date", "OffsetDate"( date, ( 12.00000000 - "GetMonth"( date ) ) COMMENTED_BY "The number to add to date to go to December of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to December of the year in date" ) ) COMMENTED_BY "Determines the monthly distribution of any slot.  Returns the poriton of demand/flow of <br>the date passed to the function for the slot passed to the function";

    END
    UUID "{7b303909-e545-46b0-8f10-217c6d3ac431}";;

    FUNCTION       "DummyTestFunction" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      0.00000000;

    END
    UUID "{f9aa2c8a-f953-47a3-8db2-8a1154556600}";;

    FUNCTION       "ICSAccountingForCA" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation of the ICS categories Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat) and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total California ICS Volume. The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>RETURNS: List of lists of the form &lcub;&lcub;EC delivery, SE delivery, BiNat delivery, EC ICS created, CA EC ICS, CA SE ICS, CA BiNat ICS, Total CA ICS, MWD diversion reduction&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 9/10/2014";
    BEGIN

      WITH NUMERIC totalDeliveryOfCAICS = IF ( NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  GET @INDEX 0.00000000 FROM "DeliveryAndCreationCAICS"(  )
 ENDIF COMMENTED_BY "In shortage years no delivery of ICS is possible" DO
  WITH NUMERIC creationOfCACEICS = IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 OR NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   GET @INDEX 1.00000000 FROM "DeliveryAndCreationCAICS"(  )
  ENDIF COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water" DO
   WITH NUMERIC creationSE = $ "ICS Credits.AnnualCreationSysEff_CA" ["Dec31ofYear"( @"t" )] COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water. Investments in long term <br>projects and these would be known and they would be scheduled by a date where they can start getting <br>credits after the completion of those projects, can be created under any condition.  ST 9/11/2015" DO
    WITH NUMERIC creationBiNat = $ "ICS Credits.AnnualCreationBiNat_CA" ["Dec31ofYear"( @"t" )] COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water" DO
     WITH NUMERIC deliveryChargedToEC = "Min"( totalDeliveryOfCAICS, $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfCACEICS ) DO
      WITH NUMERIC deliveryChargedToSE = "Min"( totalDeliveryOfCAICS - deliveryChargedToEC, $ "ICS Credits.SystemEfficiencyICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationSysEff_CA" ["Dec31ofYear"( @"t" )] ) DO
       WITH NUMERIC deliveryChargedToBiNat = "Min"( totalDeliveryOfCAICS - deliveryChargedToEC - deliveryChargedToSE, $ "ICS Credits.BiNationalICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_CA" ["Dec31ofYear"( @"t" )] ) DO
        WITH NUMERIC mwdDiversionReduction = "Max"( totalDeliveryOfCAICS - deliveryChargedToEC - deliveryChargedToSE - deliveryChargedToBiNat, 0.00000000 "acre-ft" ) DO
         WITH NUMERIC ECICSCA = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
         THEN
          $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfCACEICS * "SystemTaxAdjustment"(  ) - deliveryChargedToEC
         ELSE
          ( $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] - deliveryChargedToEC ) * 0.97000000 + creationOfCACEICS * "SystemTaxAdjustment"(  )
         ENDIF COMMENTED_BY "Resulting ExtraOrdinaryConservation ICS " DO
          WITH NUMERIC SEICSCA = ( $ "ICS Credits.SystemEfficiencyICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationSE - deliveryChargedToSE ) COMMENTED_BY "Resulting System Efficiency ICS " DO
           WITH NUMERIC BiNatICSCA = ( $ "ICS Credits.BiNationalICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationBiNat - deliveryChargedToBiNat ) COMMENTED_BY "Resulting Bi National ICS " DO
            WITH NUMERIC totalICSCA = ( ECICSCA + SEICSCA + BiNatICSCA ) COMMENTED_BY "Total ICS" DO
             { deliveryChargedToEC , deliveryChargedToSE , deliveryChargedToBiNat , creationOfCACEICS , ECICSCA , SEICSCA , BiNatICSCA , totalICSCA , mwdDiversionReduction , totalDeliveryOfCAICS }
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{c89f49a2-95a9-4215-8b48-ca925445c8b9}";;

    FUNCTION       "ECDF" ( LIST Data, NUMERIC num )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns the proportion of values in LIST &quot;Data&quot; that are less than value in &quot;num&quot; - MC, 20160527";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC val IN Data ) WITH NUMERIC result = 0.00000000 DO
  IF ( val <= num )
  THEN
   result + 1.00000000
  ELSE
   result
  ENDIF
 ENDFOR / LENGTH Data;

    END
    UUID "{67a186a2-8931-4b66-9bd9-2105265bce4f}";;

    FUNCTION       "EstimateBankStorageChange" ( OBJECT res, NUMERIC startStorage, NUMERIC endStorage, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates an estimate of the change in the bank storage that occurs due to the change in storage from startStorage to endStorage<br><br>RETURNS: Change in bank storage volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir for which storage change occurs<br>2. NUMERIC startStorage - beginning storage volume<br>3. NUMERIC endStorage - ending storage volume<br>4. DATETIME startDate - date on which startStorage occurs<br>5. DATETIME endDate - date on which endStorage occurs<br><br>CONSTRAINTS: <NONE><br><br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      ( endStorage - "EstimateEvaporation"( res, startStorage, endStorage, startDate, endDate ) - startStorage ) COMMENTED_BY "Available volume to contibute to bank storage" * res & "Bank Storage Coefficient" [0.00000000, 0.00000000] COMMENTED_BY "proportion of volume available for bank storage <br>that actually becomes bank storage";

    END
    UUID "{5f878d8b-3d0c-4ac1-a350-cd24d7a329af}";;

    FUNCTION       "EstimateDeltaStorageEOWY" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "RuleCurveStorage"( res, "RelativeEOWYDate"( @"t" ) ) - "PrevStorage"( res );

    END
    UUID "{75e55c9e-ad20-4dde-9841-533c3328f18f}";;

    FUNCTION       "EstimateDeltaStorageOND" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "RuleCurveStorage"( res, @"24:00:00 December Max DayOfMonth, Current Year" ) - "RuleCurveStorage"( res, @"24:00:00 October Max DayOfMonth, Current Year" );

    END
    UUID "{ae831120-f726-408d-8c8d-044b5eac2042}";;

    FUNCTION       "ForecastComputeDemandsBelow" ( OBJECT reservoir, DATETIME month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function computes the inflow to the subbasin below &quot;reservoir&quot; for the timestep &quot;month&quot; required to satisfy all subbasin diversions while meeting minimum flow requirements (see also documentation for predefined function &quot;NetSubBasinDiversionRequirement&quot;)<br><br>RETURNS: NUMERIC<br><br>ARGUMENTS<br>1. OBJECT reservoir - reservoir that defines downstream subbasin<br>2. DATETIME month - timestep for which calculation is made<br><br>CONSTRAINTS: Maximum release flow rate from specified reservoir<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170503: There are no references to this function in the current ruleset, so I am disabling it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    NOTES          "";
    BEGIN

      IF ( month <= "RunEndDate"(  ) )
 THEN
  "Max"( "NetSubBasinDiversionRequirement"( "ListSubbasin"( "Below" CONCAT STRINGIFY reservoir ), month ), 0.00000000 "acre-feet/month" )
 ELSE
  "Max"( "NetSubBasinDiversionRequirement"( "ListSubbasin"( "Below" CONCAT STRINGIFY reservoir ), "GetDate"( "GetMonthAsString"( month ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ) ), 0.00000000 "acre-feet/month" )
 ENDIF;

    END
    UUID "{514575ff-ae2c-4822-8bd0-da9d08d32077}";;

    FUNCTION       "FutureFontenelleInflow" ( STRING month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "MC, 20170503: This function has no calls to it in the current ruleset, so it is turned off.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( "MonthlyAverageFlowInModel"( $ "GreenRAboveFontenelle.Inflow", month ) - "SumObjectsAggregatedOverTime"( "UsersAboveCP9", "Total Depletion Requested", "SUM", "ALL", FALSE, "GetDate"( month CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ), "GetDate"( month CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ) ) ) COMMENTED_BY "Calculates the future (after the model end date) inflow into Fontenelle based on <br>average natural flow above Fontenelle for the particular month, and the demands <br>above Fontenelle from the last year of the model run.";

    END
    UUID "{b909d1c9-a5be-4448-bcd9-234d77ef13d6}";;

    FUNCTION       "GetMeadPowellElevDiff" ( STRING reservoir, DATETIME eowyDate, STRING elevOrStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "MC, 20170501: This function is not referenced in the ruleset.<br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC PowellAnnualVolume = $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( IF ( @"t" == @"Start Timestep" )
 THEN
  @"t"
 ELSE
  @"t + 2"
 ENDIF ) )] DO
  IF ( reservoir == "Powell" )
  THEN
   IF ( elevOrStorage == "elev" )
   THEN
    IF ( PowellAnnualVolume == 8230000.00000000 "acre-ft" )
    THEN
     $ "Powell.Pool Elevation" [eowyDate]
    ELSE
     "StorageToElevation"( % "Powell", $ "Powell.Storage" [eowyDate] + ( PowellAnnualVolume - 8230000.00000000 "acre-ft" ) )
    ENDIF
   ELSE
    $ "Powell.Storage" [eowyDate] + ( PowellAnnualVolume - 8230000.00000000 "acre-ft" )
   ENDIF
  ELSE
   IF ( elevOrStorage == "elev" )
   THEN
    IF ( PowellAnnualVolume == 8230000.00000000 "acre-ft" )
    THEN
     $ "Mead.Pool Elevation" [eowyDate]
    ELSE
     "StorageToElevation"( % "Mead", $ "Mead.Storage" [eowyDate] - ( PowellAnnualVolume - 8230000.00000000 "acre-ft" ) )
    ENDIF
   ELSE
    $ "Mead.Storage" [eowyDate] - ( PowellAnnualVolume - 8230000.00000000 "acre-ft" )
   ENDIF
  ENDIF
 ENDWITH;

    END
    UUID "{fe9d84f4-5352-4e22-a0b3-7d002f3ec1a4}";;

    FUNCTION       "GetPowellMonthlyReleases_pre20170427" ( LIST datesToEOWY )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume does a linear interpolation on that table to find releases that sum up exactly to the annual volume set for Powell.  If the passed in set of dates is the first water year in the run (i.e., starts with the run's start timestep), then this function will make an adjustment to the releases that were calculated by doing the linear interpolation to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly- sc 03/25/11<br><br>ARGUMENTS:<br>1. datesToEOWY<br><br>RETURNS: A list either of the form &lcub;Month, Monthly Release, Remaining Volume over Lower Bounds&rcub; (from CalculatePowellMonthlyRelease) OR &lcub;Month, Monthly Release, <br><br>DEVELOPMENT NOTES:<br>MC, 20160907: In calculation of newAdjustedMonthlyRel, moved subRelList<1> (and multiplied by 1 &quot;month&quot;) into call to VolumeToFlow to get desired volume; previous version was not giving correct desired volume (at least in some cases when UserInput_MinimumAnnualRelease sets the TARV) due to conversion associated with monthly flow and time scale (i.e., RW was making an unwanted conversion based on the number of days in a month); Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC annualVolume = "CurrentAnnualVolume"( GET @INDEX 0.00000000 FROM datesToEOWY ) DO
  WITH NUMERIC totalVolumeReleasedPreRun = IF ( "GetMonthAsString"( GET @INDEX 0.00000000 FROM datesToEOWY ) == "October" )
  THEN
   0.00000000 "acre-feet"
  ELSE
   "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), @"Start Timestep - 1" ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] )
  ENDIF DO
   WITH NUMERIC RemainingWYReleaseVolume = annualVolume - totalVolumeReleasedPreRun DO
    WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( annualVolume ) DO
     WITH NUMERIC LowerColumnBound = "FindReleaseLowerBoundColumn"( annualVolume, UpperColumnBound ) DO
      WITH LIST AdjustedMonthlyRel = "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYReleaseVolume ) DO
       IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" )
       THEN
        WITH NUMERIC sumMonthlyReleases = FOR ( LIST monthlyReleaseVol IN AdjustedMonthlyRel ) STAT_SUM
         "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
        ENDFOR DO
         WITH NUMERIC Tolerance = 5.00000000 "acre-ft" DO
          WITH NUMERIC VolumeDifference = RemainingWYReleaseVolume - sumMonthlyReleases DO
           IF ( "Abs"( VolumeDifference ) < Tolerance )
           THEN
            AdjustedMonthlyRel
           ELSE
            WITH NUMERIC VolumeAdjustment = VolumeDifference / LENGTH AdjustedMonthlyRel DO
             WITH LIST newAdjustedMonthlyRel = FOR ( LIST subRelList IN AdjustedMonthlyRel ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
              WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
               WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - VolumeAdjustment DO
                ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( VolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
               ENDWITH
              ENDWITH
             ENDFOR DO
              REMOVE ITEM @INDEX 0.00000000 FROM newAdjustedMonthlyRel
             ENDWITH
            ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170207: Within the function CalculatePowellMonthlyRelease there is also a check that all required volume was released;<br>	should all volume checking be made more robust & moved to CalculatePowellMonthlyRelease?<br>MC, 20170427: I thnk the check in CalculatePowellMonthlyRelease should be removed and have the adjustment done here, but <br>change the adjustment to be proportional to the monthly release.<br>"
           ENDIF
          ENDWITH
         ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
        ENDWITH COMMENTED_BY "Calculate total remaining releases from AdjustedMonthlyRel"
       ELSE
        AdjustedMonthlyRel
       ENDIF
      ENDWITH COMMENTED_BY "Calculate list of the form &lcub;Month, Adjusted monthly release rate, Remaining volume above lower bound column&rcub;"
     ENDWITH COMMENTED_BY "Detemine index of first column in monthly release table with total annual volume <= annualVolume<br>(Same as UpperColumnBound if annualVolume is equal to a column total)"
    ENDWITH COMMENTED_BY "Calculate index of first column in monthly release table with total annual volume >= annualVolume"
   ENDWITH
  ENDWITH COMMENTED_BY "Determine volume released prior to model run start"
 ENDWITH COMMENTED_BY "Retrieve TargetAnnualReleaseVolume for water year containing datesToEOWY<0>";

    END
    UUID "{0139d5af-9ba4-4668-9723-89c83f0639ea}";;

    FUNCTION       "IsSpringPeakMonth" ( OBJECT res, DATETIME date )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( res == % "Navajo" )
 THEN
  IF ( date >= @"24:00:00 April 31, Current Year" AND date <= @"24:00:00 June 30, Current Year" )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF
 ELSE
  STOP_RUN "Invalid reservoir passed to IsSpringPeakMonth"
 ENDIF;

    END
    UUID "{16ec87ad-8981-4d87-a759-147a876de996}";;

    FUNCTION       "July31ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the day of the year for July 31 making corrections for leap years if necessary. -CE 6/11/13";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "LeapYear"( date ) )
 THEN
  "OffsetDate"( date, "Units NONE"( 213.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ELSE
  "OffsetDate"( date, "Units NONE"( 212.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ENDIF;

    END
    UUID "{fed991d0-3caa-429b-aa69-1db2acaeea14}";;

    FUNCTION       "LowerTierEqualizationRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      ( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] + ( $ "Powell.Storage" [EOWYDate] - $ "Mead.Storage" [EOWYDate] ) / 2.00000000 ) COMMENTED_BY "MC, 20160803: This function is the same calculation as the EqualizationRelease function.  I changed the call in the Set Lower Balancing Release Volume and PostLBDV functions to the EqualizationRelease function instead of this one, <br>which should be deleted as redundant orphan.";

    END
    UUID "{3e20e40a-7611-46bd-9aa8-f86921029c54}";;

    FUNCTION       "MonthDayRatio" ( NUMERIC days )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( 31.00000000 "day" / days );

    END
    UUID "{60e3c115-0730-449d-863f-7a9816cfe580}";;

    FUNCTION       "MyGetSlot" ( OBJECT obj, STRING slot )
    RETURN_TYPE    SLOT;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "GetSlot"( ( STRINGIFY obj ) CONCAT ( "." CONCAT slot ) );

    END
    UUID "{1e441ffd-b415-4ded-bac6-8163b1e09555}";;

    FUNCTION       "MyPercentRank" ( LIST Data, NUMERIC num )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      1.00000000;

    END
    UUID "{9d06e054-3fd7-4059-9700-2ca457b64116}";;

    FUNCTION       "NevadaBankingICS" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC unusedNV = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  300000.00000000 "acre-ft" - $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )]
 ENDIF DO
  WITH NUMERIC nvBankedCA = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   unusedNV
  ENDIF DO
   WITH NUMERIC nvBankedAZ = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
   THEN
    0.00000000 "acre-ft"
   ELSE
    0.00000000 "acre-ft"
   ENDIF DO
    WITH NUMERIC CumulativeNVBankedInCA = $ "ICS Credits.CumulativeNVBankedinCA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + nvBankedCA - nvUnbankedCA DO
     WITH NUMERIC AnnualNVRecoverableAZ = "Min"( 40000.00000000 "acre-ft", nvBankedAZ ) DO
      WITH NUMERIC AnnuaNVRecoverableCA = "Min"( 30000.00000000 "acre-ft", CumulativeNVBankedInCA ) DO
       WITH NUMERIC AnnualNVUnbankedFromAZ = "Min"( AnnualNVRecoverableAZ, nvUnbankedAZ ) DO
        WITH NUMERIC AnnualNVUnbankedFromCA = "Min"( AnnualNVRecoverableAZ, nvUnbankedCA ) DO
         ?
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{b51d9cc9-587b-48ff-898f-56c836b8e5fa}";;

    FUNCTION       "OND" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      @"24:00:00 October Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year";

    END
    UUID "{5d5746d1-c614-465d-8956-ff1960c796a2}";;

    FUNCTION       "PrevStorage" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "Returns the storage of the argument object for the previous timestep. -CE 6/11/13";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      res & "Storage" [@"t - 1"];

    END
    UUID "{ba9d84f1-1040-4a7c-96cb-b76ba4246e4c}";;

    FUNCTION       "Quantile" ( LIST Data, NUMERIC prob )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      GET @INDEX 1.00000000 FROM Data;

    END
    UUID "{34be8df3-5ff7-4430-a45f-33912dd96e3c}";;

    FUNCTION       "RampUpDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns a list of two-item lists, each sublist of the form &lcub;date, flow target&rcub;.  The function does this by starting at the peak flow date and the peak flow value and then going backward one day at a time and calculating the new flow target until it gets down to the shoulder flow which is already set on the slot by the previous rule (April Through July Daily Canyon Flows).  The liimitations in the ramp up daily rate are no more than 500cfs and no more than 25% of the previous day's flow. - sc 12/22/10<br><br>MC, 20170531: No calls to this function, so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC peakLevel = $ "BlueMesaData.MayPeakFlowLevel" [@"24:00:00 December 31, Current Year"] DO
  WITH DATETIME peakDate = "PartialToFull"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) ) DO
   WITH NUMERIC peakFlowTarget = "Max"( $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"], $ "BlueMesaData.TargetDailyWhitewaterFlows" [peakDate] ) DO
    WITH NUMERIC daysAtPeak = $ "BlueMesaData.SpringPeakAndDurationCanyonTargets" [peakLevel, "Duration of Half Bank Days"] DO
     WITH DATETIME dateToCheckRamp = peakDate - "Floor"( daysAtPeak / 2.00000000, 1.00000000 "day" ) DO
      WHILE ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) > $ "BlueMesaData.TargetDailyWhitewaterFlows" [GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList] OR ( LENGTH dateFlowList ) == 1.00000000 ) WITH LIST dateFlowList = { { dateToCheckRamp , peakFlowTarget } } DO
       WITH DATETIME previousDaysDate = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 1.00000000 "day" DO
        WITH NUMERIC previousDaysFlow = "Max"( "Min"( ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) * ( 1.00000000 / ( 1.00000000 + 0.25000000 COMMENTED_BY "If Paul says that the ramp up rate needs to be user-controlled, <br>put the slot reference here. - sc 12/22/10" ) ) ), ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 500.00000000 "cfs" ), $ "BlueMesaData.TargetDailyWhitewaterFlows" [previousDaysDate] ) DO
         APPEND { previousDaysDate , previousDaysFlow } ONTO dateFlowList
        ENDWITH
       ENDWITH
      ENDWHILE
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{00a51ab0-f5bb-4405-8e3e-becceb62f132}";;

    FUNCTION       "RampDownDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns a list of two-item lists, each sublist of the form &lcub;date, flow target&rcub;.  The function does this by starting at the peak flow date and the peak flow value and then going forward one day at a time and calculating the new flow target until it gets down to the shoulder flow which is already set on the slot by the previous rule (April Through July Daily Canyon Flows).  The liimitations in the ramp down daily rate are no more than 400cfs and no more than15% of the previous day's flow. - sc 12/22/10<br><br>MC, 20170531: No calls to this function, so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC peakLevel = $ "BlueMesaData.MayPeakFlowLevel" [@"24:00:00 December 31, Current Year"] DO
  WITH DATETIME peakDate = "PartialToFull"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) ) DO
   WITH NUMERIC peakFlowTarget = "Max"( $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"], $ "BlueMesaData.TargetDailyWhitewaterFlows" [peakDate] ) DO
    WITH NUMERIC daysAtPeak = $ "BlueMesaData.SpringPeakAndDurationCanyonTargets" [peakLevel, "Duration At Peak Flow"] DO
     WITH DATETIME dateToCheckRamp = peakDate + ( "Floor"( daysAtPeak / 2.00000000, 1.00000000 "day" ) - IF ( daysAtPeak == 0.00000000 "day" )
     THEN
      0.00000000 "day"
     ELSE
      1.00000000 "day"
     ENDIF ) DO
      WHILE ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) > $ "BlueMesaData.TargetDailyWhitewaterFlows" [GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList] OR ( LENGTH dateFlowList ) == 1.00000000 ) WITH LIST dateFlowList = { { dateToCheckRamp , peakFlowTarget } } DO
       WITH DATETIME nextDaysDate = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) + 1.00000000 "day" DO
        WITH NUMERIC nextDaysFlow = "Max"( "Min"( ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) * ( 1.00000000 - 0.15000000 COMMENTED_BY "If Paul says that the ramp down rate needs to be user- controlled, <br>put the slot reference here. - sc 12/22/10" ) ), ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 400.00000000 "cfs" ), $ "BlueMesaData.TargetDailyWhitewaterFlows" [nextDaysDate] ) DO
         APPEND { nextDaysDate , nextDaysFlow } ONTO dateFlowList
        ENDWITH
       ENDWITH
      ENDWHILE
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END
    UUID "{6fb062e5-5978-4f1b-a5f5-326bf1c476d1}";;

    FUNCTION       "SolveBlueMesaReleaseForBlackCanyonTarget" ( NUMERIC TargetCanyonFlow, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a numeric flow target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in flow target in the Black Canyon section of the Gunnison River which is the &quot;Tunnel Return Flow&quot; object on the workspace.  The function does this by doing a water balance in the reach of the river between Blue Mesa and the Black Canyon and solving for the release from Blue Mesa. - sc 12/28/10<br><br>MC, 20170531: This function only called by other disabled Aspinall/Gunnison functions, so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date], $ "BlueMesaData.BlueMesaMinRelease" [] );

    END
    UUID "{57f458e7-095c-4b28-a89a-6ad263dc2926}";;

    FUNCTION       "SolveBlueMesaReleaseForWhitewaterTarget" ( NUMERIC TargetCanyonFlow, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a numeric flow target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in flow target in the Black Canyon section of the Gunnison River which is the &quot;Tunnel Return Flow&quot; object on the workspace.  The function does this by doing a water balance in the reach of the river between Blue Mesa and the Black Canyon and solving for the release from Blue Mesa. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( ( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [date] ) COMMENTED_BY "Would set a Blue Mesa Release enough to meet the Whitewater Target and the Gunnison Tunnel <br><br>Diversion while leveraging the gains between Blue Mesa and Grand Junction TP/MC 9/22/2015", ( $ "BlueMesaData.MinimumBlackCanyonFlow" [date] + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] ) COMMENTED_BY "This would set a Blue Mesa Release enough to meet the minimum Black Canyon Flows and the <br><br>Gunnison Tunnel Diversion while leveraging the gains between BM and the Tunnel. TP/MC <br><br>9/22/2105" );

    END
    UUID "{7a186e74-3d02-44d7-bda6-b001d6f25264}";;

    FUNCTION       "SolveBlwBlueMesaInterveningFlows" ( LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a list of dates and sums the intervening flows from Below Blue Mesa.  Usually May has already been solved for so we do not include it in this calculation. <br>TP 2/13/2014<br><br>MC, 201705031: No calls to this function so disabled it.<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN dates ) STAT_SUM
  "FlowToVolume"( $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date], date ) + "FlowToVolume"( $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date], date )
 ENDFOR;

    END
    UUID "{52842b24-88c7-42ae-b92f-68b4903d7907}";;

    FUNCTION       "SolvePoolElevation" ( OBJECT obj, NUMERIC outflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Solves for end of time step storage given an object and its outflow<br><br>RETURN TYPE: NUMERIC<br><br>ARGUMENTS<br>1. OBJECT obj<br>2. NUMERIC outflow<br><br>COMMENTS<br><br>AUTHOR, DATE: Unknown<br><br>UPDATE NOTES<br>1. Standardized description added by MC, 20170323";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "StorageToElevation"( obj, "SolveStorage"( obj, "MyGetSlot"( obj, "Inflow" ) [], outflow, "MyGetSlot"( obj, "Storage" ) [@"t - 1"], @"t" ) );

    END
    UUID "{43609b01-e075-44cf-b3af-62a4366fcef2}";;

    FUNCTION       "SpringDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates a list of the form &lcub;Date, Flow Rate&rcub; for the time period April 30 to August 1, accounting for base flow, ramp up & down days, and days at powerplant capacity<br><br>RETURNS: List of lists of the form &lcub;Date, Flow rate&rcub;<br><br>ARGUMENTS:<NONE><br><br>CONSTRAINTS:<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170503: No listed calls to this function; turned it off";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC HClass = $ "FlamingGorgeData.HClass" ["Dec31ofYear"( @"t" )] DO
  WITH NUMERIC PPC = $ "FlamingGorgeData.PowerPlantCapacity" [] DO
   WITH NUMERIC PreviousBaseflow = $ "FlamingGorge.Outflow" [@"24:00:00 April Max DayOfMonth, Current Year"] COMMENTED_BY "Set By Rule: &quot;Base Flow Operations&quot;" DO
    WITH NUMERIC Baseflow = "GetFGBaseFlowMagnitude"(  ) DO
     WITH NUMERIC BypassCapacity = $ "FlamingGorgeData.BypassCharacteristics" [0.00000000, "Bypass Capacity"] DO
      WITH NUMERIC RampUpRate = $ "FlamingGorgeData.RampUpRate" [] DO
       WITH NUMERIC RampDownRate = $ "FlamingGorgeData.BaseFlowDownrampRate" [HClass, 0.00000000] DO
        WITH NUMERIC DaysAtPPC = "GetNumberOfDaysAtPPC"( HClass ) DO
         WITH NUMERIC DaysToRampUp = "DaysToRampUp"( PPC, PreviousBaseflow, RampUpRate ) DO
          WITH NUMERIC DaysToRampDown = "DaysToDownramp"( PPC, Baseflow, RampDownRate ) DO
           WITH NUMERIC DaysToBypass = "GetDaysAtBypass"( HClass ) DO
            WITH DATETIME RampUpStartDate = "CompletePartialDate"( "NumberToDate"( $ "FlamingGorgeData.RampUpStartDate" [0.00000000, 0.00000000] ), @"t" ) COMMENTED_BY "User Input Ramp Up Start Date, should correspond with the Yampa Peak. -HG 9/13/12" DO
             WITH DATETIME PPCStartDate = RampUpStartDate + DaysToRampUp DO
              WITH DATETIME PPCEndDate = PPCStartDate + ( DaysAtPPC - 1.00000000 "day" ) DO
               WITH DATETIME RampDownEndDate = PPCEndDate + DaysToRampDown DO
                WHILE ( ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) < @"24:00:00 August 1, Current Year" ) WITH LIST dateFlowList = { { @"24:00:00 April 30, Current Year" , PreviousBaseflow } } DO
                 WITH DATETIME date = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) + 1.00000000 "day" DO
                  WITH NUMERIC PreviousDaysFlow = ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) DO
                   IF ( "GetMonth"( date ) == 6.00000000 AND "GetDayOfMonth"( date ) <= DaysToBypass )
                   THEN
                    APPEND { date , BypassCapacity } ONTO dateFlowList
                   ELSE
                    IF ( date < RampUpStartDate )
                    THEN
                     APPEND { date , PreviousBaseflow } ONTO dateFlowList
                    ELSE
                     IF ( date >= RampUpStartDate AND date < PPCStartDate )
                     THEN
                      ( APPEND { date , "Min"( PreviousDaysFlow + RampUpRate, PPC ) } ONTO dateFlowList ) COMMENTED_BY "Limit the Ramp Up to a Maximum of the Power Plant Capacity"
                     ELSE
                      IF ( date >= PPCStartDate AND date <= PPCEndDate )
                      THEN
                       APPEND { date , PPC } ONTO dateFlowList
                      ELSE
                       IF ( date <= RampDownEndDate )
                       THEN
                        APPEND { date , "Max"( PreviousDaysFlow - RampDownRate, Baseflow ) } ONTO dateFlowList
                       ELSE
                        APPEND { date , Baseflow } ONTO dateFlowList
                       ENDIF
                      ENDIF
                     ENDIF
                    ENDIF
                   ENDIF COMMENTED_BY "Set Daily Outflows"
                  ENDWITH
                 ENDWITH
                ENDWHILE COMMENTED_BY "Set Daily Outflows"
               ENDWITH
              ENDWITH
             ENDWITH
            ENDWITH COMMENTED_BY "Define Dates"
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH COMMENTED_BY "Determine Days At Each Rate"
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "This is a problem. <br>We do not know what the baseflow is going to be at the end of the spring release operations. <br>The baseflow is calculated based upon the Previous Pool Elevation and we do not know that when projecting forward. -HG 9/13/12"
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Define Flow Rates";

    END
    UUID "{d925d665-ce76-4ffb-bd92-26a7244a2c3d}";;

    FUNCTION       "StartYear" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns True if the timestep is the start timestep, and False otherwise. -CE 6/11/13";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "GetYearAsString"( @"t" ) == "GetYearAsString"( @"Start Timestep" );

    END
    UUID "{83c7ebc0-4266-4c52-a230-06b4dc3c2521}";;

    FUNCTION       "SumAnnualDivRequest" ( OBJECT object, STRING wateruser )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  "FlowToVolume"( object & wateruser [date], date )
 ENDFOR;

    END
    UUID "{2ded6bf9-3545-4932-9012-d6860f6985ec}";;

    FUNCTION       "TotalCreationOfArizonaICS" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Sums the user input creation values of ICS for Arizona TP 7/27/2015";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "ICS Credits.AnnualCreationBiNat_AZ" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationSysEff_AZ" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )];

    END
    UUID "{e238926d-1f58-4f8f-9056-f37aa646d7d9}";;

    FUNCTION       "TotalCreationOfNevadaICS" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Sums the user input creation values of ICS for Nevada TP 7/27/2015";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "ICS Credits.AnnualCreationBiNat_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationSysEff_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationEC_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationImp_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationTrib_NV" ["Dec31ofYear"( @"t" )];

    END
    UUID "{7ff76393-a126-4510-a857-443d981e01e7}";;

    FUNCTION       "VallecitoMaxBankReleaseConstraint" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This is the max bank flow for the Pinos River below Vallacito. The value is 2000 cfs and is the recommended max flow from Vallacito by the USBR operations guidelines to prevent damage downstream of Vallacito in Normal Operations.  - TP 10/8/2012<br><br>MC, 20170531: There are no calls to this function, so I disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      $ "VallecitoData.NoDamageMaxBankFlow" [];

    END
    UUID "{2914e4b0-e8c9-479e-9877-e1fa2d904d4a}";;

    FUNCTION       "DeliveryAndCreationCAICS" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the volumes of ICS delivered and EC ICS created for California, taking into account Lower Basin Demand Variability <br><br>RETURNS: List of lists of the form &lcub;&lcub;ICS delivered, EC ICS created&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20180125: Removed SystemTaxAdjustment from Annual Max in MinItem for creationOfCACEICS local variable based on USBR changes to ruleset<br>CH, 4/27/18: Changed totaldeliveryofCAICS assignment so that the available ICS water was was referencing total CA ICS, not just CA EC ICS<br>GCAA, 20181030: Changed reference from MWDDiversionData.MWDMaximumAnnualDelivery to AnnualWaterUse.MWDCanal_AnnualCapacity slot";
    BEGIN

      WITH NUMERIC creationOfCACEICS = IF ( ( ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR NaNToZero ( $ "Surplus.Quantified Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR NaNToZero ( $ "Surplus.Flood Control Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR NOT "IsMRM"(  ) ) COMMENTED_BY "If the year is a Shortage Year, a Quantified Surplus Year, a Flood Control Year, <br>or if the run is a deterministic Min, Max or Most run, do not Create any ICS TP <br>12/18/2017 <br>" )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "MinItem"( { $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Put Step 1"] COMMENTED_BY "Annual Max <br>" , "Max"( ( $ "ICS Credits.MeadBankParameters" ["California", "Max Capacity"] - $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December 31, Previous Year"] ), 0.00000000 "acre-ft" ) COMMENTED_BY "Account Space <br>" , $ "ICS Credits.MeadBankParameters" ["California", "Max Put"] COMMENTED_BY "Maximum Creation of MWD ICS <br>" , "Max"( "SumFlowsToVolume"( $ "MWDDiversion:MWD.Diversion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) - $ "AnnualWaterUse.MWDMinimumAnnualDelivery" [], 0.00000000 "acre-ft" ) COMMENTED_BY "Difference between Diversion Requests and Minimum Required MWD Delivery <br>" } )
 ENDIF DO
  WITH NUMERIC totalDeliveryOfCAICS = "MinItem"( { IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR NOT "IsMRM"(  ) )
  THEN
   0.00000000 "acre-ft" COMMENTED_BY "Shortage Years <br>"
  ELSE
   IF ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) COMMENTED_BY "If the year has domestic surplus, reduce the ICS Delivery by the amount of <br>Domestic surplus entitlement for MWD. TP 12/18/2017 <br>" )
   THEN
    "Max"( ( $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] - $ "Surplus Volume Entitlements.MWD Domestic" ["Dec31ofYear"( @"t" )] ), 0.00000000 "acre-ft" )
   ELSE
    $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] COMMENTED_BY "Not Surplus or Shortage <br>"
   ENDIF
  ENDIF , ( $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - "SumFlowsToVolume"( $ "MWDDiversion:MWD.Depletion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) ) COMMENTED_BY "MWD at full ditch (Conveyance Capacity)<br>" , "Min"( $ "ICS Credits.MeadBankParameters" ["California", "Max Take"], $ "ICS Credits.TotalICS_CA" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "Make sure the amount of Delivery taken is within the system or below the <br>Maximum Take that MWD can have. TP 12/18/2017 <br>" + creationOfCACEICS ) COMMENTED_BY "Available ICS Water <br>" } ) DO
   { totalDeliveryOfCAICS , creationOfCACEICS }
  ENDWITH
 ENDWITH;

    END
    UUID "{8e328bf2-db24-41b0-8f6d-0641a3084a6f}";;

  END
  UUID "{c60f59a8-c699-40bb-8912-ec47288b9729}";;

  UTILITY_GROUP "LB_Schedules";
  DESCRIPTION   "9/18/2018, AP: This utility group is for functions used in the calculation of LB Schedules and recalculation of schedules when the tier switches between RC 3 and RC 4. ";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "SNWP_Schedules" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "9/18/2018, AP: used in the calculation of SNWP schedules. Changed original logic to refernce Nevada_CU_Schedules instead of PumpingfromMead";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) )
 THEN
  ( "VolumeToFlow"( $ "Nevada_CU_Schedules.SNWP" [date], date ) + ( "VolumeToFlow"( $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"], date ) ) / ( 12.00000000 - "GetMonth"( @"Start Timestep" ) + 1.00000000 ) )
 ELSE
  ( "VolumeToFlow"( $ "Nevada_CU_Schedules.SNWP" [date], date ) + ( "VolumeToFlow"( $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"], date ) ) / 12.00000000 )
 ENDIF;

    END
    UUID "{b67f7c86-19a1-44b3-861c-d130e19d1d17}";;

    FUNCTION       "CAP_Outyear_Schedules" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "9/18/2018, AP: logic used in the calculation of CAP outyear schedules. Logic orignally came from Reset Monthly Forecast Use CAP - all month outyears.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( ( "VolumeToFlow"( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"], date ) ) / "GetDaysBasedOnFirstDate"( @"t" ) + "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date ) );

    END
    UUID "{31225d56-0749-4049-bdc7-0a8d76c06994}";;

    FUNCTION       "MWD_Outyear_Schedules" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "9/18/2018, AP: This function is used in the calculation of MWD schedules. Logic originally from rule Reset Monthly forecast use MWD - All months outyears";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( "VolumeToFlow"( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "California_CU_Forecast1.MWD" [@"24:00:00 December 31, Current Year"], date ) ) / "GetDaysBasedOnFirstDate"( @"t" ) + "VolumeToFlow"( $ "California_CU_Schedules.MWD" [date], date );

    END
    UUID "{0e388d7f-ee1d-4709-b1c5-d27b9bd42158}";;

    FUNCTION       "LBConditionDetermination" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the operating condition of the lower basin.<br><br>RETURNS: Lower Basin condition flag<br><br>ARGUMENTS:<br>NA<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: AP 9/18/2018<br><br>S.Baker, 20180925: Changed IF statements to use function 'GetProjectedPoolElevation' instead of looking at Mead.Pool Elevation. This will allow MTOM to determine which Mead PE projection to use (ie. AugEOYProjectedMeadPool elevation). ";
    BEGIN

      IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
 THEN
  1.00000000 COMMENTED_BY "If Mead is below 1,075 ft, then set the Basin Condition value to 1 for Shortage"
 ELSE
  IF ( "QuantifiedSurplusVolume"(  ) > 0.00000000 "acre-ft" )
  THEN
   3.00000000 COMMENTED_BY "If the Quantified Surplus Volume Calculation is greater than zero, <br> then set the Basin Condition value to 3 for Quantified Surplus"
  ELSE
   IF ( "GetProjectedPoolElevation"( "Mead", @"24:00:00 December 31, Previous Year" ) >= $ "Surplus.Domestic Surplus Trigger Elevation" [] )
   THEN
    2.00000000 COMMENTED_BY "If Mead is greater than 1,145 ft, then set the Basin Condition value to 2 for Domestic Surplus"
   ELSE
    0.00000000 COMMENTED_BY "If the Mead Elevation is between 1,075 and 1,145 and there is not enough water to <br>warrent a quantified surplus condition, set the Basin Condition value to 0 for a <br>normal condition"
   ENDIF
  ENDIF
 ENDIF;

    END
    UUID "{1c46abdf-5158-4df5-8faa-843d756c060a}";;

  END
  UUID "{e12722c5-cd2e-4fc8-a9c7-df9184cd5532}";;

  PREDEFINED_GROUP "Numeric / Math";
  DESCRIPTION   "Predefined functions which perform generic numerical computations.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "Max" ( NUMERIC arg1, NUMERIC arg2 )
    SCALE_UNITS    "1000 acre-ft/month";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{7218f516-2dc3-47ef-a06b-724866620d96}";
;

    PREDEFINED_FUNCTION "Min" ( NUMERIC arg1, NUMERIC arg2 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{42daed7f-3dc9-4b66-98be-42bd2727303f}";
;

    PREDEFINED_FUNCTION "MinItem" ( LIST arg1 )
    SCALE_UNITS    "acre-ft";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    UUID "{8db6f479-77d5-48b8-ad7b-19a72f9f09b1}";
;

    PREDEFINED_FUNCTION "Sum" ( LIST arg1 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{149b37a9-4069-423c-9b0a-fc6f26bd2214}";
;

  END
  UUID "{4dae4d3e-d781-4661-8da5-6eb8a1ea5f75}";;

  PREDEFINED_GROUP "Date / Time";
  DESCRIPTION   "Predefined functions which access and manipulate date/times.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "OffsetDate" ( DATETIME arg1, NUMERIC arg2, STRING arg3 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{70669dba-69ee-4483-bf20-8c9bf32682e4}";
;

  END
  UUID "{507561fa-8815-46f0-9c56-077951c4ef92}";;

  PREDEFINED_GROUP "Engineering";
  DESCRIPTION   "Predefined functions similar to methods on objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "SolveOutflow" ( OBJECT arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4, DATETIME arg5 )
    SCALE_UNITS    "acre-ft/month";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{07a4f092-39b2-4cb1-a8ee-7825028f2f0f}";
;

  END
  UUID "{679abd7c-6a32-4d0e-8f28-bc2573a2aaeb}";;

  PREDEFINED_GROUP "Workspace";
  DESCRIPTION   "Predefined functions which access information on slots and objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "TableInterpolation" ( SLOT arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4, DATETIME arg5 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    UUID "{3f52800a-53d8-4a14-82c7-7f9c10ca79c6}";
;

  END
  UUID "{4bd18aaf-f23b-4fa5-9227-0b5d3d42e29f}";;

  REPORT_GROUP "Report Group";
  DESCRIPTION  "";
  NOTES  "";
  BEGIN
  END
  UUID "{82213d73-dfc6-4866-a9c2-9ce4d699edd4}";;

END
UUID "{ab281990-c627-4d76-b0b9-e4f3661ac5ff}";
