# RiverWare_Ruleset 7.1.4 Patch
# Created 11:29 April 20, 2018
# 
RULESET
NAME "MTOM_Rules (from MRM run)";
AGENDA_ORDER ASCENDING;
DESCRIPTION "";
PRECISION   8;
VIEW_DOC_INFO
  DOC_INFO_LOC_PART2 "MTOM_Rules_2013-DocTemplate.html";
  DOC_INFO_FORMAT "Auto";
NOTES "";
BEGIN

  POLICY_GROUP   "Calculate Final State Use and Overruns";
  DESCRIPTION    "This policy group contains rules that compute the projected annual water use for the Lower Division States and large junior priority users in each state (i.e. MWD, CAP, and SNWA). It also computes any projected over- or under-runs after all water schedule adjustments have been made. <br><br>The slots containing the state adjusted apportionments do not get changed when shortage or surplus is declared. They also do not get changed for Lower Basin demand variability. So, the difference in the schedules will appear as an overrun or underrun.";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Final SNWP Diversion";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for SNWA after all schedule adjustments. Adjustments may be made to get Nevada to their projected annual apportionment, lower basin demand variability, shortage, or surplus.<br><br>SLOTS SET: ForecastUse.SNWPAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "ForecastUse.SNWPAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" );

    END;

    RULE                 "Final CAP Diversion";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for CAP after all schedule adjustments. Adjustments may be made to get Arizona to their projected annual apportionment, lower basin demand variability, shortage, or surplus.<br><br>SLOTS SET: Forecast.CAPAnnualFC<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "ForecastUse.CAPAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "CAPDiversion.Total Diversion Requested" );

    END;

    RULE                 "Final MWD Diversion";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for MWD after all schedule adjustments. Adjustments may be made to get California to their projected annual apportionment, lower basin demand variability, shortage, or surplus.<br><br>SLOTS SET: ForecastUse.MWDDiversionAnnualFC; ForecastUse.MWDAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "ForecastUse.MWDDiversionAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Annual Volume"( $ "MWDDiversion:MWD.Diversion Requested" );

      $ "ForecastUse.MWDAnnualFC" [@"24:00:00 December Max DayOfMonth, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
 THEN
  "SumSlot"( $ "California_CU_Actual.MWD", @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" ) + "SumFlowsToVolume"( $ "MWDDiversion:MWD.Depletion Requested", @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" )
 ELSE
  FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
   "FlowToVolume"( $ "MWDDiversion:MWD.Depletion Requested" [date], date )
  ENDFOR
 ENDIF;

    END;

    RULE                 "Final CA Overrun - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected overrun or underrun for California after all schedule adjustments by calculating the difference between the total annual diversion request and the annual apportionment for the current calendar year.<br><br>SLOTS SET: AnnualWaterUse.CaOverrun";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.CaOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.CaTotalAnnual" [@"24:00:00 December 31, Current Year"] - IF ( "IsMRM"(  ) )
 THEN
  $ "AnnualWaterUse.California_FinalAdjustedApportionment" [@"24:00:00 December 31, Current Year"]
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF;

    END;

    RULE                 "Final CA Annual Use - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for California after all schedule adjustments by summing the non-MWD diversion requests and the MWD depletion request for the current calendar year.  This rule also calculates the value of the California Final Adjusted Apportionment.<br><br>SLOTS SET: AnnualWaterUse.CaTotalAnnual; AnnualWaterUse.California_FinalAdjustedApportionment";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND ( @"t" == @"24:00:00 December 31, Current Year" OR @"t" == @"Finish Timestep" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.CaTotalAnnual" [@"24:00:00 December 31, Current Year"] := FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  FOR ( OBJECT diversionSite IN "ListSubbasin"( "California nonMWD WaterUsers" ) ) STAT_SUM
   IF ( diversionSite == % "PaloVerde" )
   THEN
    "FlowToVolume"( diversionSite & "Total Diversion Requested" [date], date )
   ELSE
    "FlowToVolume"( diversionSite & "Diversion Requested" [date], date )
   ENDIF
  ENDFOR + "FlowToVolume"( $ "MWDDiversion:MWD.Depletion Requested" [date], date )
 ENDFOR COMMENTED_BY "This assignment now calculates the Total Diversion by California by Adding all non MWD <br>user Diversion requests to the MWD diversion request less the return flow from MWD. <br>TP 7/13/2015";

      $ "AnnualWaterUse.California_FinalAdjustedApportionment" [@"24:00:00 December 31, Current Year"] := IF ( "IsMRM"(  ) )
 THEN
  IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) )
  THEN
   $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
  ELSE
   $ "AnnualWaterUse.California_PreliminaryAdjustedApportionment" [@"24:00:00 December 31, Current Year"] + NaNToZero ( $ "ICS Credits.AnnualNVBankedinCA" ["Dec31ofYear"( @"t" )] ) - NaNToZero ( $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )] ) + ( NaNToZero ( $ "ICS Credits.AnnualDeliveryBiNat_CA" ["Dec31ofYear"( @"t" )] ) + NaNToZero ( $ "ICS Credits.AnnualDeliveryEC_CA" ["Dec31ofYear"( @"t" )] ) + NaNToZero ( $ "ICS Credits.AnnualDeliverySysEff_CA" ["Dec31ofYear"( @"t" )] ) )
  ENDIF
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF;

    END;

    RULE                 "Final AZ Overrun - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected overrun or underrun for Arizona after all schedule adjustments by calculating the difference between the total diversion request and the annual apportionment for the current calendar year. <br><br>SLOTS SET: AnnualWaterUse.AzOverrun<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.AzOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.AzTotalAnnual" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.Arizona_Apportionment" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Final AZ Annual Use - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for Arizona after all schedule adjustments by summing the CAP and non-CAP annual diversion requests for the current calendar year. <br><br>SLOTS SET: AnnualWaterUse.AzTotalAnnual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.AzTotalAnnual" [@"24:00:00 December 31, Current Year"] := "SumAnnualCAPDivRequest"(  ) + $ "AnnualWaterUse.AzNoCAPTotalAnnual" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Final NV Overrun - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected overrun or underrun for Nevada after all schedule adjustments by calculating the difference between the total diversion requests and the annual apportionment for the current calendar year. <br><br>SLOTS SET: AnnualWaterUse.NVOverrun<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.NVOverrun" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.NvTotalAnnual" [@"24:00:00 December 31, Current Year"] - $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"];

    END;

    RULE                 "Final NV Annual Use - Div Req";
    DESCRIPTION          "DESCRIPTION: Calculates projected annual water use for Nevada after all schedule adjustments by summing the diversion requests of Nevada water users for the current calendar year. <br><br>SLOTS SET: AnnualWaterUse.NvTotalAnnual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "AnnualWaterUse.NvTotalAnnual" [@"24:00:00 December 31, Current Year"] := FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  FOR ( OBJECT diversionSite IN "ListSubbasin"( "NevadaWaterUsers" ) ) STAT_SUM
   IF ( diversionSite == % "NvDvsToPkr" )
   THEN
    "FlowToVolume"( diversionSite & "Total Diversion Requested" [date], date )
   ELSE
    "FlowToVolume"( diversionSite & "Diversion Requested" [date], date )
   ENDIF
  ENDFOR
 ENDFOR;

    END;

    RULE                 "Compute Lower Basin Energy";
    DESCRIPTION          "DESCRIPTION: This rule must fire after all schedule adjustments have been made, which is why it is in the highest priority polict group.<br><br>SLOTS SET: Lower Basin Energy.Computed Davis Energy Using Input Eff; Lower Basin Energy.Computed Davis Head using Turbine Release; Lower Basin Energy.Davis KWH per AF; Lower Basin Energy.Computed Parker Energy Using Input Eff; Lower Basin Energy.Computed PD Project Energy Using Peak Base Power Calc; Lower Basin Energy.Computed PD Project Energy Using Input Eff<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Lower Basin Energy.Computed Davis Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] ) * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" );

      $ "Lower Basin Energy.Computed Davis Head using Turbine Release" [] := "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] );

      $ "Lower Basin Energy.Davis KWH per AF" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * "Compute Head as a Function of Turbine Release"( $ "Mohave.Turbine Release" [] ) * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) / "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * 1.00000000 "ft" * 1.00000000 "ft";

      $ "Lower Basin Energy.Computed Parker Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Parker Efficiency" [] * "FlowToVolume"( $ "Havasu.Turbine Release" [], @"t" ) * $ "Havasu.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" );

      $ "Lower Basin Energy.Computed PD Project Energy Using Peak Base Power Calc" [] := $ "Mohave.Energy" [] + $ "Havasu.Energy" [] / 2.00000000;

      $ "Lower Basin Energy.Computed PD Project Energy Using Input Eff" [] := $ "Lower Basin Energy.Input Davis Efficiency" [] * "FlowToVolume"( $ "Mohave.Turbine Release" [], @"t" ) * $ "Mohave.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) + $ "Lower Basin Energy.Input Parker Efficiency" [] * "FlowToVolume"( $ "Havasu.Turbine Release" [], @"t" ) * $ "Havasu.Operating Head" [] * 9789.00000000 "newton" / ( ( 1.00000000 "m" * 1.00000000 "m" ) * 1.00000000 "m" ) / 2.00000000;

    END;

  END;

  POLICY_GROUP   "FloodControl";
  DESCRIPTION    "This policy group contains all the rules required to simulate Lake Mead/Hoover Dam flood control operations. Flood control operations are based on the USACE Water Control Manual for Flood Control: Hoover Dam and Lake Mead Colorado River, December 1982 (Flood Control Manual)";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Compute LC Dam Capacity";
    DESCRIPTION          "DESCRIPTION: This rule sets the power slots for the LC dams based on their power capacity values and power plant capacity fractions<br><br>SLOTS SET: Mead.Power; Mohave.Power; Havasu.Power<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 4.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Mead.Power" [] := $ "EnergyInfo.EffectiveHooverCapacity" [] * $ "Mead.Power Plant Cap Fraction" [];

      $ "Mohave.Power" [] := $ "Lower Basin Energy.Davis_Power_Capacity" [] * $ "Mohave.Power Plant Cap Fraction" [];

      $ "Havasu.Power" [] := $ "Lower Basin Energy.Parker_Power_Capacity" [] * $ "Havasu.Power Plant Cap Fraction" [];

    END;

    RULE                 "FC Surplus Schedules Data Volume to Simulation Flow";
    DESCRIPTION          "DESCRIPTION: In the event of Flood Control the Diversion Schedules are set to the Monthly Surplus Schedules for Flood Control. TP 7/28/2015<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Flood Control Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet; OthersBlwImp.AzPumpersBlwImp.Diversion Requested; AzPkrToImp:CibolaValleyIID.Diversion Requested; AzPkrToImp:Parker.Diversion Requested; GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested; CAPDiversion.Total Diversion Requested; MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested; AAC:Coachella.Diversion Requested; AAC:IID.Diversion Requested; CaPkrToImp:CaPumpersAbvImp.Diversion Requested; CaDvsToPkr:Needles.Diversion Requested; MexicanTreatyDelivery:MexicoSched.Diversion Requested; PumpingFromLakeMead:SNWP.Diversion Requested; PumpingFromLakeMead:SNWP.Depletion Requested<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 ) AND IsNaN $ "Surplus.Flood Control Surplus Flag" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015<br>MC, 20170920: Changed beginning datetime in FOR loop from @&quot;24:00:00 January 31, Current Year&quot; to @&quot;t&quot; per Sep 19 email from Shana T. and Corinne H.";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 3.00000000;

            $ "Surplus.Flood Control Surplus Flag" [date] := 1.00000000;

            $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

          INACTIVE      $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "AzPumpersBlwImp" ), date );

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CibolaValleyIID" ), date );

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "City of Parker" ), date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Gila Monster Farms" ), date );

            $ "CAPDiversion.Total Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CAP" ), date );

            $ "MWDDiversion:MWD.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "MWD" ), date );

            $ "MWDDiversion:MWD.Depletion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "MWD" ), date ) - "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Coachella" ), date );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "IID" ), date );

            $ "CaPkrToImp:CaPumpersAbvImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "CaPumpersAbvImp" ), date );

            $ "CaDvsToPkr:Needles.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Needles" ), date );

            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule- FC"( date, "Mexico" ), date );

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

            $ "PumpingFromLakeMead:SNWP.Depletion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Compute Effective Hoover Capacity Regression";
    DESCRIPTION          "DESCRIPTION: This Rule is used to set the EnergyInfo.EffectiveHooverCapacity so that it can go out to 60 weeks.  The regression equation provided is from the LC BoR office and can be adjusted using this rule. <br><br>SLOTS SET: EnergyInfo.EffectiveHooverCapacity; Mead.Power Plant Cap Fraction<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF_STATEMENT (( NOT "IsMRM"(  ) ) COMMENTED_BY "This check determines if a run is a deterministic run or an MRM run and the data comes<br>out of the Ensemble Forecast Sheet. TP 3/28/2013") THEN
            IF_STATEMENT ("IsInput"( $ "EnergyInfo.EffectiveHooverCapacityInput", @"t" )) THEN
          DESCRIPTION          "Use input value";
      $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := $ "EnergyInfo.EffectiveHooverCapacityInput" [@"t"];

      ELSE
          DESCRIPTION          "Calculate based on Mead pool elevation";
      WITH_STATEMENT (NUMERIC elevMead = $ "Mead.Pool Elevation" [@"t"]) DO
            $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := IF ( elevMead >= 1170.00000000 "feet" )
 THEN
  2074.00000000 "MW"
 ELSE
  ( elevMead * ( 5.64540000 "MW" / 1.00000000 "foot" ) - 4530.50000000 "MW" )
 ENDIF;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC elevMead = $ "Mead.Pool Elevation" [@"t"]) DO
            $ "EnergyInfo.EffectiveHooverCapacity" [@"t"] := IF ( elevMead >= 1170.00000000 "feet" )
 THEN
  2074.00000000 "MW"
 ELSE
  ( elevMead * ( 5.64540000 "MW" / 1.00000000 "foot" ) - 4530.50000000 "MW" )
 ENDIF;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Set Mead power plant capacity fraction if necessary";
      IF_STATEMENT (NOT "IsInput"( $ "Mead.Power Plant Cap Fraction", @"t" )) THEN
            $ "Mead.Power Plant Cap Fraction" [@"t"] := $ "Mead.Power Plant Cap Fraction" [@"t - 12"];

      END_IF_STATEMENT;

    END;

    RULE                 "Mead Space Building";
    DESCRIPTION          "DESCRIPTION: If the storage in Mead is greater than the target storage (based on the minimum system space that must be available), this rule resets the outflow to achieve the target storage during space building months (August 1 - December 31); if the Flood Control Flag is not already set, this rule also sets it based on whether the outflow was reset by the rule<br><br>SLOTS SET: Mead.Outflow; FloodControlOutput.Flood Control Flag<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND NOT IsNaN $ "Mead.Storage" [] AND @"t" > @"24:00:00 July Max DayOfMonth, Current Year" AND IsNaN $ "FloodControlOutput.Flood Control Flag" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF_STATEMENT ($ "Mead.Storage" [] > "ComputeTargetStorage"(  )) THEN
            $ "Mead.Outflow" [] := "Max"( "ComputeOutflowAtGivenStorage"( % "Mead", "ComputeTargetStorage"(  ) ), $ "Mead.Outflow" [] );

      END_IF_STATEMENT;

      $ "FloodControlOutput.Flood Control Flag" [] := IF ( IsNaN $ "FloodControlOutput.Flood Control Flag" [] )
 THEN
  IF ( $ "Mead.Storage" [] > "ComputeTargetStorage"(  ) )
  THEN
   1.00000000
  ELSE
   0.00000000
  ENDIF
 ENDIF;

    END;

    RULE                 "Mead Flood Control Release";
    DESCRIPTION          "DESCRIPTION: This rule checks that the release from Mead computed for downstream demands is large enough to satisfy flood control during the runoff season. If not, Mead Outflow is reset to the required flood control release which was previously calculated in the <Set Flood Control Release> rule and stored as FloodControlOutput.FCrelease. The flood control flag is also set to 1, which will cause the system to solve downstream and eventually force more water out of Havasu and Mohave.<br><br>SLOTS SET: Mead.Outflow; FloodControlOutput.Flood Control Flag<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND NOT IsNaN $ "Mead.Outflow" [] AND "GetRunCycleIndex"(  ) >= 3.00000000 AND IsNaN $ "FloodControlOutput.Flood Control Flag" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170518: Rule modified to only use 1 IF statement ";
    BEGIN

      IF_STATEMENT ($ "Mead.Outflow" [] < $ "FloodControlOutput.FCrelease" []) THEN
            $ "Mead.Outflow" [] := $ "FloodControlOutput.FCrelease" [];

            $ "FloodControlOutput.Flood Control Flag" [] := 1.00000000;

      ELSE
            $ "FloodControlOutput.Flood Control Flag" [] := 0.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Mead Exclusive Flood Control Space";
    DESCRIPTION          "DESCRIPTION: This rule ensures that Mead does not violate the 1.5 maf space requirement (on MeadFloodControlData.MinSpace slot) at any time of the year. Although this is the highest priority rule, we don't want it to fire until the other flood control procedures have potentially executed. The rule checks the storage in Mead, and if it does not provide the minimum space, the outflow is recalculated so that the minimum space is achieved. If the outflow is recalculated, the FloodControlOutput.Exclusive Space Flag is set to 1; otherwise it is set to 0.<br><br>SLOTS SET: Mead.Outflow; FloodControlOutput.Exclusive Space Flag<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "FloodControlOutput.Flood Control Flag" [] AND NOT IsNaN $ "Mead.Storage" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170518: Modified rule to use only 1 IF statement instead of 2, and only print statement in the case the IF statement is TRUE<br>MC, 20170920: Modified calculation of Mead.Outflow to take the larger of outflow to reach min space requirement or outflow to meet downstream requirement per Sep 19 email from Shana T. and Corinne H. (previously did not consider downstream requirement)";
    BEGIN

    DESCRIPTION          "If Mead storage exceeds what provides the minimum space requirement, <br>recalculate outflow so the storage provides the minimum space.";
      IF_STATEMENT ($ "Mead.Storage" [] >= "ComputeMinimumSpace"( % "Mead" ) COMMENTED_BY "Storage with min space requirement" OR $ "Mead.Outflow" [] < "VolumeToFlow"( $ "Lower Basin Output.DownstreamReq" [], @"t" ) COMMENTED_BY "Storage with min space requirement") THEN
            $ "Mead.Outflow" [] := "Max"( "ComputeOutflowAtGivenStorage"( % "Mead", "ComputeMinimumSpace"( % "Mead" ) ), "VolumeToFlow"( $ "Lower Basin Output.DownstreamReq" [], @"t" ) ) COMMENTED_BY "Calculate outflow to reach storage with min space requirement or meet <br>downstream requirement, whichever volume is larger<br>(This will be constrained to MaxSpaceBuildingRelease outflow) <br>";

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "FloodControlOutput.Exclusive Space Flag" []) THEN
            $ "FloodControlOutput.Exclusive Space Flag" [] := IF ( $ "Mead.Storage" [] >= "ComputeMinimumSpace"( % "Mead" ) )
 THEN
  1.00000000
 ELSE
  0.00000000
 ENDIF;

      END_IF_STATEMENT;

      PRINT "Flood Control due to violating Exclusive Flood Control Space: Mead Storage reset";

    END;

    RULE                 "Set Flood Control Release";
    DESCRIPTION          "DESCRIPTION: This rule sets the Mead flood control release according to Table 1 in Exhibit A of the Flood Control Manual, which dictates release steps given inflow and available storage, during flood control months (January 1 - July 31) or as the minimum of either releases needed to achieve target storage or the maximum space building release (28,000 cfs) during space building months (August 1 - December 31).<br><br>SLOTS SET: FloodControlOutput.FCrelease<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.FCrelease" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "FloodControlOutput.FCrelease" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  GET @INDEX 0.00000000 FROM "ForecastRunoffSeason "(  )
 ELSE
  "ComputeTargetStorageRelease"(  )
 ENDIF;

      PRINT IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "entering Runoff Forecast Season routine for" CONCAT "GetMonthAsString"( @"t" )
 ELSE
  "Mead Flood Control Release is not computed in" CONCAT "GetMonthAsString"( @"t" )
 ENDIF;

    END;

    RULE                 "Set Without Release";
    DESCRIPTION          "DESCRIPTION: This rule calculates the forecasted Mead inflow and the Mead inflow volume in excess of the available space in Mead and Powell<br><br>SLOTS SET: FloodControlOutput.Forecas; FloodControlOutput.Withoutrel<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND IsNaN $ "FloodControlOutput.Withoutrel" [] AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: The AvailableSpace, DeltaBankStorage, and FloodControlEvap values were previously calculated in Set Forecast Data. Can those slot values be used here instead of recalculating those values? Also, replace call to ForecastMeadInflow with appropriate call to SumFlowsToVolume";
    BEGIN

      $ "FloodControlOutput.Forecas" [] := "ForecastMeadInflow"(  );

    DESCRIPTION          "Calculate the Mead inflow volume in excess of available space";
      $ "FloodControlOutput.Withoutrel" [] := "ForecastMeadInflow"(  ) - "AvailableSpace"( % "Mead" ) - "AvailableSpace"( % "Powell" ) + $ "MeadFloodControlData.MinSpace" [0.00000000, 0.00000000] - "DeltaBankStorage"(  ) - "FloodControlEvap"( % "Mead" ) - "FloodControlEvap"( % "Powell" ) - $ "FloodControlOutput.Consnev" [];

    END;

    RULE                 "Set Effective Space";
    DESCRIPTION          "DESCRIPTION: This rule calculates the total effective space available in Flaming Gorge (incl. Fontenelle), Blue Mesa, and Navajo until the end of July of the current year by choosing, for each individual reservoir, the minimum of the total available space remaining (*use) or the difference between the Inflow and Outflow (*pred) for the period and summing those values. Used in ForecastMeadInflow function to calculate Mead inflow forecast for calculation of flood control releases according to the Flood Control Algorithm in Exhibit One of the Flood Control Manual.<br><br>SLOTS SET: FloodControlOutput.UBEffective<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.UBEffective" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "FloodControlOutput.UBEffective" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "Min"( $ "FloodControlOutput.FGuse" [], $ "FloodControlOutput.FGpred" [] ) + "Min"( $ "FloodControlOutput.BMuse" [], $ "FloodControlOutput.BMpred" [] ) + "Min"( $ "FloodControlOutput.NAVuse" [], $ "FloodControlOutput.NAVpred" [] )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

    END;

    RULE                 "Set Consnev";
    DESCRIPTION          "DESCRIPTION: This rule calculates the total diversion volume requested by SNWP from the current timestep to the end of July of the current year<br><br>SLOTS SET: FloodControlOutput.Consnev<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" AND IsNaN $ "FloodControlOutput.Withoutrel" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: The function call in this rule can be replaced by a call to the predefined function SumFlowsToVolume <br>MC, 20180312: The above replacement was made sometime between these two comments. The MTOM changelog may have the specific month that the change was made.";
    BEGIN

      $ "FloodControlOutput.Consnev" [] := "SumFlowsToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested", @"t", @"24:00:00 July Max DayOfMonth, Current Year" );

    END;

    RULE                 "Set Forecast Data";
    DESCRIPTION          "DESCRIPTION: This rule calculates and stores the current available storage and expected net change in storage between the current timestep and the end of July of the current year for Flaming Gorge, Blue Mesa, Navajo, Powell and Mead. The change in bank storage and the evaporation are also calculated and stored. These storage calculations are used to determine effective upstream reservoir storage in the Mead Space Building rule. Effective UB storage is used to calculate Mead inflow forecast in the ForecastMeadInflow function for determination of flood control releases using the Flood Control Algorithmin Exhibit One of the Flood Control Manual.<br><br>SLOTS SET: FloodControlOutput.FGuse; FloodControlOutput.FGpred; FloodControlOutput.BMuse; FloodControlOutput.BMpred; FloodControlOutput.NAVuse; FloodControlOutput.NAVpred; FloodControlOutput.MeadPred; FloodControlOutput.MeadCredEff; FloodControlOutput.PowellPred; FloodControlOutput.PowellCredEff; FloodControlOutput.Deltabs; FloodControlOutput.Evapmd; FloodControlOutput.Evapow<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "FloodControlOutput.Withoutrel" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170717: Replaced explicit calculations for UC reservoirs with calls to AvailableSpace function<br>MC, 20170531 - the GetLiveCapacity(reservoir) - reservoir.Storage[@&quot;t-1&quot;] calculation is codified in the function AvailableSpace; call that function here?";
    BEGIN

      WITH_STATEMENT (LIST MonthlyDatelist = "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" )) DO
          DESCRIPTION          "(Inflow - Outflow) between current timestep and end of July of current year";
      $ "FloodControlOutput.FGuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "SumSlotVolume"( $ "FlamingGorgeInflow.Unregulated", MonthlyDatelist ) - "SumSlotVolume"( $ "FlamingGorge.Outflow", MonthlyDatelist )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

          DESCRIPTION          "Calculate additional available storage in Flaming Gorge";
      $ "FloodControlOutput.FGpred" [] := "AvailableSpace"( % "FlamingGorge" ) + "AvailableSpace"( % "Fontenelle" );

          DESCRIPTION          "(Inflow - Outflow) between current timestep and end of July of current year";
      $ "FloodControlOutput.BMuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "SumSlotVolume"( $ "BlueMesaInflow.Unregulated", MonthlyDatelist ) - "SumSlotVolume"( $ "BlueMesa.Outflow", MonthlyDatelist )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

          DESCRIPTION          "Calculate additional available storage in Blue Mesa";
      $ "FloodControlOutput.BMpred" [] := "AvailableSpace"( % "BlueMesa" );

          DESCRIPTION          "(Inflow - Outflow) between current timestep and end of July of current year";
      $ "FloodControlOutput.NAVuse" [] := IF ( @"t" <= @"24:00:00 July Max DayOfMonth, Current Year" )
 THEN
  "SumSlotVolume"( $ "Navajo.Inflow", MonthlyDatelist ) - "SumSlotVolume"( $ "Navajo.Outflow", MonthlyDatelist )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

          DESCRIPTION          "Calculate additional available storage in Navajo";
      $ "FloodControlOutput.NAVpred" [] := "AvailableSpace"( % "Navajo" );

          DESCRIPTION          "Calculate additional available storage in Mead";
      $ "FloodControlOutput.MeadPred" [] := "AvailableSpace"( % "Mead" );

            $ "FloodControlOutput.MeadCredEff" [] := "AvailableSpace"( % "Mead" );

          DESCRIPTION          "Calculate additional available storage in Powell";
      $ "FloodControlOutput.PowellPred" [] := "AvailableSpace"( % "Powell" );

            $ "FloodControlOutput.PowellCredEff" [] := "AvailableSpace"( % "Powell" );

          DESCRIPTION          "Calculate change in bank storage with available space";
      $ "FloodControlOutput.Deltabs" [] := "DeltaBankStorage"(  );

          DESCRIPTION          "Calculate evaporation between current timestep and end of July of current year";
      $ "FloodControlOutput.Evapmd" [] := "FloodControlEvap"( % "Mead" );

            $ "FloodControlOutput.Evapow" [] := "FloodControlEvap"( % "Powell" );

      END_WITH_STATEMENT;

    END;

    RULE                 "Set Schedule Release";
    DESCRIPTION          "DESCRIPTION: This rule copies the initial Mead release needed to meet downstream demands to the FloodControlOutput data object in slot MeadSchedRel. The value should only be reported the first time Mead calculates its outflow based on downstream demands.<br><br>SLOTS SET: Lower Basin Output.MeadSchedRel<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Lower Basin Output.MeadSchedRel" [] AND NOT IsNaN $ "Mead.Outflow" [] AND "GetRunCycleIndex"(  ) == 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Lower Basin Output.MeadSchedRel" [] := $ "Mead.Outflow" [];

    END;

  END;

  POLICY_GROUP   "Mexico ICMA";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Mexico ICMA Accounting";
    DESCRIPTION          "DESCRIPTION: This rule calculates the value of the ICMA balance for Mexico<br><br>SLOTS SET: Mexico Shortage and Surplus.ICMA Balance";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 December 31, Current Year" OR @"t" == "RunEndDate"(  ) AND "GetRunCycleIndex"(  ) == 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE;<br>MC, 20160908: Moved slot Mexico Shortage and Surplus.AnnualCreationICMA inside parentheses so it is subject to 0.97 factor per Shana T. email on 20160831";
    BEGIN

      $ "Mexico Shortage and Surplus.ICMA Balance" [@"24:00:00 December 31, Current Year"] := ( $ "Mexico Shortage and Surplus.ICMA Balance" [@"24:00:00 December 31, Previous Year"] + $ "Mexico Shortage and Surplus.AnnualCreationICMA" [@"24:00:00 December 31, Current Year"] - $ "Mexico Shortage and Surplus.AnnualDeliveryICMA" [@"24:00:00 December 31, Current Year"] - $ "ICS Credits.AnnualCreationBiNat_AZ" [@"24:00:00 December 31, Current Year"] - $ "ICS Credits.AnnualCreationBiNat_CA" [@"24:00:00 December 31, Current Year"] - $ "ICS Credits.AnnualCreationBiNat_NV" [@"24:00:00 December 31, Current Year"] ) * 0.97000000;

    END;

  END;

  POLICY_GROUP   "ICS Accounting and Releases Cal";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Flood Control ICS Reduction";
    DESCRIPTION          "DESCRIPTION: This rule will use the Flood Control Volume to reduce the amount of Extraordinary Conservation ICS for each state. If the Flood Control Volume is greater than the volume of EC ICS water for all of the states and EC Delivery for each state, the balance of EC water is taken to 0 AF for each state. If the volume of FC water is less than the total EC volume, then the volume reduced from each state will be proportional to the volume that each state has when the Flood Control occurs. This rule assigns the new values of EC ICS water for California, Nevada, and Arizona and also re calculates and assignes the Total ICS Volumes for each state. TP 11/4/2014<br><br>SLOTS SET: ICS Credits.ExtraordinaryConservationICS_CA; ICS Credits.ExtraordinaryConservationICS_NV; ICS Credits.ExtraordinaryConservationICS_AZ; ICS Credits.TotalICS_CA; ICS Credits.TotalICS_NV; ICS Credits.TotalICS_AZ; ICS Credits.AnnualDeliveryEC_CA; ICS Credits.AnnualDeliveryEC_NV; ICS Credits.AnnualDeliveryEC_AZ";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND NaNToZero ( $ "FloodControlOutput.Flood Control Flag" [@"t"] ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 11/4/2014";
    BEGIN

      WITH_STATEMENT (NUMERIC floodControlVol = $ "FloodControlOutput.FCrelease" [@"t"]) DO
            WITH_STATEMENT (LIST stateECBalances = "FloodControlECICSBalance"( "FlowToVolume"( floodControlVol, @"t" ) )) DO
            $ "ICS Credits.ExtraordinaryConservationICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM stateECBalances;

            $ "ICS Credits.ExtraordinaryConservationICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM stateECBalances;

            $ "ICS Credits.TotalICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 6.00000000 FROM stateECBalances;

            $ "ICS Credits.TotalICS_NV" ["Dec31ofYear"( @"t" )] := GET @INDEX 7.00000000 FROM stateECBalances;

            $ "ICS Credits.TotalICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 8.00000000 FROM stateECBalances;

            $ "ICS Credits.AnnualDeliveryEC_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM stateECBalances;

            $ "ICS Credits.AnnualDeliveryEC_NV" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM stateECBalances;

            $ "ICS Credits.AnnualDeliveryEC_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM stateECBalances;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "California ICS Accounting and Releases";
    DESCRIPTION          "DESCRIPTION: This Rule assigns the values for the California ICS.  The function &quot;ICSAccountingForCA&quot; calculates the delivery and annual values based on input<br>creation values, and assigns the appropriate slots for California ICS.  The rule also re-sets the MWD Diversion request each month to the percentage<br>that is applied each month to an average Shortage delivery pattern for a year.  The rule only fires in January or the Start timestep. TP 9/10/2014<br><br>SLOTS SET: ICS Credits.AnnualDeliveryEC_CA; ICS Credits.AnnualDeliverySysEff_CA; ICS Credits.AnnualDeliveryBiNat_CA; ICS Credits.AnnualCreationEC_CA; ICS Credits.ExtraordinaryConservationICS_CA; ICS Credits.SystemEfficiencyICS_CA; ICS Credits.BiNationalICS_CA; ICS Credits.TotalICS_CA; MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested; MWDDiversion:Tijuana.Depletion Requested<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 9/10/2014<br><br>MC, 20180125: Made changes to newMWDDivAmount local variable and subsequent assignments based on changes USBR made in their ruleset";
    BEGIN

      WITH_STATEMENT (LIST caICSValues = "ICSAccountingForCA"(  )) DO
          DESCRIPTION          "CA Extraordinary Conservation ICS Delivery";
      $ "ICS Credits.AnnualDeliveryEC_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM caICSValues;

          DESCRIPTION          "CA System Efficiency ICS Delivery";
      $ "ICS Credits.AnnualDeliverySysEff_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM caICSValues;

          DESCRIPTION          "CA Bi National ICS Delivery";
      $ "ICS Credits.AnnualDeliveryBiNat_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM caICSValues;

          DESCRIPTION          "CA Extraordinary Conservation ICS Creation";
      $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM caICSValues;

          DESCRIPTION          "CA Extraordinary Conservation ICS";
      $ "ICS Credits.ExtraordinaryConservationICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM caICSValues;

          DESCRIPTION          "CA System Efficiency ICS";
      $ "ICS Credits.SystemEfficiencyICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM caICSValues;

          DESCRIPTION          "CA Bi National ICS";
      $ "ICS Credits.BiNationalICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 6.00000000 FROM caICSValues;

          DESCRIPTION          "CA Total ICS";
      $ "ICS Credits.TotalICS_CA" ["Dec31ofYear"( @"t" )] := GET @INDEX 7.00000000 FROM caICSValues;

            IF_STATEMENT ("IsMRM"(  ) AND ( "GetYear"( @"t" ) != "GetYear"( @"Start Timestep" ) OR @"t" == @"24:00:00 January Max DayOfMonth, Start Year" )) THEN
            WITH_STATEMENT (NUMERIC totalDeliveryCAICS = GET @INDEX 9.00000000 FROM caICSValues) DO
            WITH_STATEMENT (NUMERIC totalCreationECICS = GET @INDEX 3.00000000 FROM caICSValues) DO
          DESCRIPTION          "Adjust the MWD Diversion Request to reduce the request if there is not enough total ICS in the system for the total delivery to California.  The reduction will be <br>the difference between the determined delivery to california above the state apportionment minus the availalbe ICS volume.  MWD takes the reduction. ";
      FOREACH (DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC newMWDDivAmount = "VolumeToFlow"( "Min"( $ "MWDDiversionData.MWDMaximumAnnualDelivery" [], "SumFlowsToVolume"( $ "MWDDiversion:MWD.Diversion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + ( ( totalDeliveryCAICS - GET @INDEX 8.00000000 FROM caICSValues ) - totalCreationECICS ) COMMENTED_BY "Increase the MWD depletion amount by the total delivery less any over delivery <br>that might be occuring in a given scenario, or decrease the delivery if any <br>creation of water for a given scenario. TP 12/22/2017 <br>" ) * $ "Shortage.MonthlyPercents" ["GetMonth"( date ) - 1.00000000, "Equal"], date )) DO
            $ "MWDDiversion:MWD.Diversion Requested" [date] := newMWDDivAmount;

            $ "MWDDiversion:MWD.Depletion Requested" [date] := newMWDDivAmount - "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

            $ "MWDDiversion:Tijuana.Depletion Requested" [date] := $ "MWDDiversion:Tijuana.Diversion Requested" [date];

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END;

  END;

  POLICY_GROUP   "Lower Basin Demand Variability";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Reset Monthly Forecast SNWP LC Demand Variability";
    DESCRIPTION          "DESCRIPTION: This rule will reset the SNWP diversion request for Lower Basin Demand Variability outside of Surplus or Shortage.  If the local inflows above Hoover Dam are greater than the 90% historic local inflow volume then the pumping is reduced by 5%.  In the case that the local inflows are less than the 10% exceedence historic local inflow volume then the pumping is increased by 5%. The factor is applied to the monthly pumping requests and set by this rule. This rule also sets the data slot to show if LBDV was set for the Above Hoover local inflows in the AbvHooverTriggerSet slot. TP 7/27/2015<br><br>SLOTS SET: PumpingFromLakeMead:SNWP.Diversion Requested; PumpingFromLakeMead:SNWP.Depletion Requested; LowerBasinDemandVariability.AbvHooverTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) AND NaNToZero ( $ "Surplus.Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Domestic Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Flood Control Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND "IsMRM"(  );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 7/27/2015";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (SLOT slot IN { $ "PumpingFromLakeMead:SNWP.Diversion Requested" , $ "PumpingFromLakeMead:SNWP.Depletion Requested" }) DO
            slot [date] := $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] * "MeadPumpingDemandVariabilityFactor"( date );

      ENDFOREACH;

            $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := IF ( "MeadPumpingDemandVariabilityFactor"( date ) == 1.00000000 )
 THEN
  0.00000000
 ELSE
  IF ( "MeadPumpingDemandVariabilityFactor"( date ) == 0.95000000 )
  THEN
   1.00000000
  ELSE
   - 1.00000000
  ENDIF
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Reset Monthly Forecast CAP LC Demand Variability";
    DESCRIPTION          "DESCRIPTION: This rule resets the CAP Diversion request based on a demand variability factor.  The Function CAPDemandVariabilityFactor will return a scale value that will either decrease the CAP Diversion Request in Non Shortage or Surplus years to 90% of the original diversion schedule if local inflows to the system below Parker Dam are greater than the 90% exceedence of historic local inflows.  If the local inflows are below the 10% exceedence of the historic local inflows, then the diversion requested can be increased in an amount equal to the difference in the State Apportionment for the year and the volume of Senior Prority user diversion requests.  This value is added to any ICS delivery if Lake Mead is above 1,100 Ft.  The sum of the remaining state apportionment and the ICS Delivery is what CAP is allowed to divert.  TP 7/27/2015<br><br>SLOTS SET: CAPDiversion.Total Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) AND NaNToZero ( $ "Surplus.Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Domestic Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND NaNToZero ( $ "Surplus.Flood Control Surplus Flag" ["Dec31ofYear"( @"t" )] ) == 0.00000000 AND "IsMRM"(  );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 7/27/2015";
    BEGIN

      FOREACH (DATETIME date IN "DateMax"( "GetFirstDate"( @"t" ), @"Start Timestep" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := $ "CAPDiversion.Total Diversion Requested" [date] * "CAPDemandVariabilityFactor"( date ) + "VolumeToFlow"( IF ( ( ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= 1100.00000000 "ft" ) AND "IsMRM"(  ) ) COMMENTED_BY "If the Projected January Lake Mead Elevation is to be greater than 1,100 ft, then set the ICS delivery <br>to AZ System Efficiency 2014 Volume/10. If Lake Mead is below 1,100 do not allow any delivery of <br>ICS. The logic only needs to know if Lake Mead is above 1,110 ft and the delivery will be added to <br>any normal condition CAP Div Req already set. " )
 THEN
  10305.00000000 "acre-ft"
 ELSE
  0.00000000 "acre-ft"
 ENDIF, date ) * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"];

          INACTIVE      $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( date )] := IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker90"] )
 THEN
  1.00000000
 ELSE
  IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker10"] )
  THEN
   - 1.00000000
  ELSE
   0.00000000
  ENDIF
 ENDIF;

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "LB Surplus";
  DESCRIPTION    "This policy group contains the rules required to simulate Lower Basin Surplus operations. Lower Basin Surplus operations are based on the 2007 Interim Guidelines as well as IBWC Minute 323. Surplus volume entitlements are based on contracts between Reclamation and the various water users, as well as the 2007 Interim Guidelines and Minute 323.";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Quantified Surplus Schedules Data Volume to Simulation Flow";
    DESCRIPTION          "DESCRIPTION: This rule converts volumes allowed under Quantified Surplus into monthly flow rates and sets associated slots. Surplus flags and LBDV.AbvHooverTriggerSet flag are also set in this rule.<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Quantified Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet; PumpingFromLakeMead:SNWP.Diversion Requested; MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested; GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested; OthersBlwImp:AzPumpersBlwImp.Diversion Requested; CAPDiversion.Total Diversion Requested; AAC.Coachella.Diversion Requested; AAC:IID.Diversion Requested; AzPkrToImp:CibolaValleyIID.Diversion Requested; AzPkrToImp:Parker.Diversion Requested<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND @"t" == @"24:00:00 January 31, Current Year" AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170706: Moved the setting of Surplus.Surplus Flag and Surplus.Quantified Surplus Flag slots to new rule Set Quantified Surplus Flag; removed IsNaN Surplus.Surplus Flag[] execution constraint from this rule";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
          INACTIVE      $ "Surplus.Surplus Flag" [date] := 2.00000000;

          INACTIVE      $ "Surplus.Quantified Surplus Flag" [date] := 1.00000000;

          INACTIVE      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

          INACTIVE      $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

            $ "PumpingFromLakeMead:SNWP.Depletion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "MWD" ), date );

            $ "MWDDiversion:MWD.Depletion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "MWD" ), date ) - "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "Coachella" ), date );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "IID" ), date );

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "AzPumpersBlwImp" ), date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "Gila Monster Farms" ), date );

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "CibolaValleyIID" ), date );

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "City of Parker" ), date );

            $ "CAPDiversion.Total Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "CAP" ), date );

      ENDFOREACH;

    END;

    RULE                 "Domestic Surplus Schedules Data Volume to Simulation Flow";
    DESCRIPTION          "DESCRIPTION: This rule converts volumes allowed under Domestic Surplus into monthly flow rates and sets associated slots. Surplus flags and LBDV.AbvHooverTriggerSet flag are also set in this rule.<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Domestic Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet; PumpingFromLakeMead:SNWP.Diversion Requested; MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested; GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested; OthersBlwImp:AzPumpersBlwImp.Diversion Requested; CAPDiversion.Total Diversion Requested<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170706: Moved the setting of Surplus.Surplus Flag and Surplus.Domestic Surplus Flag slots to new rule Set Domestic Surplus Flag; removed IsNaN Surplus.Surplus Flag[] execution constraint from this rule";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
          INACTIVE      $ "Surplus.Surplus Flag" [date] := 1.00000000;

          INACTIVE      $ "Surplus.Domestic Surplus Flag" [date] := 1.00000000;

          INACTIVE      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

          INACTIVE      $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( date )] := 2.00000000;

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

            $ "PumpingFromLakeMead:SNWP.Depletion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] > "SumAnnualSNWADivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "SNWA" ), date )
 ENDIF;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "MWD" ), date );

            $ "MWDDiversion:MWD.Depletion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "MWD" ), date ) - "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "Gila Monster Farms" ), date );

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "AzPumpersBlwImp" ), date );

            $ "CAPDiversion.Total Diversion Requested" [date] := IF ( $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] > "SumAnnualCAPDivRequest"(  ) )
 THEN
  "VolumeToFlow"( "Set Monthly Surplus Schedule"( date, "CAP" ), date )
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set Flood Control Surplus Schedules";
    DESCRIPTION          "DESCRIPTION: If a the Flood Control or Exclusive Space Flag is on (greater than 0) this rule will fire and set the Surplus Schedules for all water users impacted by Flood Control Surplus. The computed schedules are the Total Annual Schedules for each water user, meaning Normal and Surplus schedules.  Flood Control Surplus is in priority over Quantified Surplus Volumes. -HMG 8/2/11<br><br>SLOTS SET: Surplus Total Annual Schedules.AzPumpersBlwImp; Surplus Total Annual Schedules.CAP; Surplus Total Annual Schedules.CibolaValleyIID; Surplus Total Annual Schedules.City of Parker; Surplus Total Annual Schedules.Gila Monster Farms; Surplus Total Annual Schedules.SNWA; Surplus Total Annual Schedules.MWD; Surplus Total Annual Schedules.Coachella; Surplus Total Annual Schedules.IID; Surplus Total Annual Schedules.Needles; Surplus Total Annual Schedules.CaPumpersAbvImp; Surplus Total Annual Schedules.Mexico<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT $ "FloodControlOutput.Flood Control Flag" [] > 0.00000000 OR $ "FloodControlOutput.Exclusive Space Flag" [] > 0.00000000 AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/2011";
    BEGIN

      $ "Surplus Total Annual Schedules.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.CAPCanal_AnnualCapacity" [];

      $ "Surplus Total Annual Schedules.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CibolaValleyIID" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.City of Parker" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.City of Parker" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.City of Parker" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] := $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.SNWA Quantified and FC" [@"24:00:00 December 31, Current Year"] + ( $ "ICS Credits.AnnualDeliveryImpICS_NV" [@"24:00:00 December 31, Current Year"] + $ "ICS Credits.AnnualDeliveryTribICS_NV" [@"24:00:00 December 31, Current Year"] ) COMMENTED_BY "Annual Delivery of ICS from Nevada of Imported and Tributary ICS Water";

      $ "Surplus Total Annual Schedules.MWD" [@"24:00:00 December 31, Current Year"] := 1250000.00000000 "acre-ft";

      $ "Surplus Total Annual Schedules.Coachella" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.Coachella" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 0.00000000] + 100000.00000000 "acre-ft";

      $ "Surplus Total Annual Schedules.IID" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.IID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 1.00000000];

      $ "Surplus Total Annual Schedules.Needles" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.Needles" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Needles" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CaPumpersAbvImp" [@"24:00:00 December 31, Current Year"] := $ "California_CU_Forecast1.CaPumpersAbvImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CaPumpersAbvImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Mexico" [@"24:00:00 December 31, Current Year"] := 1700000.00000000 "acre-ft";

    END;

    RULE                 "Set Quantified Surplus Schedules";
    DESCRIPTION          "DESCRIPTION: If there is a positive Quantified Surplus Volume this rule will fire and set the Total Annual Schedules for all water Users Impacted by Quantified Surplus. The Total Annual Schedules include both the Normal and Surplus Schedules. Rule fires only once per year during January. Quantified Surplus is higher in priority than Domestic Surplus, but lower in priority than Flood Control Surplus. Therefore, this rule will override any Domestic Surplus Schedules, but may then be overriden by Flood Control Surplus Schedules if a Flood Control Surplus exists. -HMG 8/2/11<br><br>SLOTS SET: Surplus Total Annual Schedules.MWD; Surplus Total Annual Schedules.Coachella; Surplus Total Annual Schedules.IID; Surplus Total Annual Schedules.AzPumpersBlwImp; Surplus Total Annual Schedules.Gila Monster Farms; Surplus Total Annual Schedules.City of Parker; Surplus Total Annual Schedules.CibolaValleyIID; Surplus Total Annual Schedules.CAP; Surplus Total Annual Schedules.SNWA<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/11";
    BEGIN

      $ "Surplus Total Annual Schedules.MWD" [@"24:00:00 December 31, Current Year"] := $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Coachella" [@"24:00:00 December 31, Current Year"] := IF ( $ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"] )
 THEN
  $ "California_CU_Forecast1.Coachella" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 0.00000000]
 ELSE
  $ "California_CU_Forecast1.Coachella" [@"24:00:00 December 31, Current Year"]
 ENDIF;

      $ "Surplus Total Annual Schedules.IID" [@"24:00:00 December 31, Current Year"] := IF ( $ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"] )
 THEN
  $ "California_CU_Forecast1.IID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CA Ag" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of CA Ag Surplus" [0.00000000, 1.00000000]
 ELSE
  $ "California_CU_Forecast1.IID" [@"24:00:00 December 31, Current Year"]
 ENDIF;

      $ "Surplus Total Annual Schedules.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.City of Parker" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.City of Parker" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.City of Parker" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.CibolaValleyIID" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CibolaValleyIID" [@"24:00:00 December 31, Current Year"];

    INACTIVE      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := 1835000.00000000 "acre-ft" COMMENTED_BY "<assumes CAP will take a full ditch even lacking full surplus volume for interstate banking. Surplus Volume Entitlement contains actual CAP quantified surplus volume>";

      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := ( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CAP Quantified" [@"24:00:00 December 31, Current Year"] + $ "ICS Credits.AnnualDeliverySysEff_AZ" [@"24:00:00 December 31, Current Year"] ) COMMENTED_BY "CAP Diversion Request plus Quantified CAP entitlement plus ICS Available";

      $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] := $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.SNWA Quantified and FC" [@"24:00:00 December 31, Current Year"] + ( $ "ICS Credits.AnnualDeliveryImpICS_NV" [@"24:00:00 December 31, Current Year"] + $ "ICS Credits.AnnualDeliveryTribICS_NV" [@"24:00:00 December 31, Current Year"] ) COMMENTED_BY "Annual Delivery of ICS from Nevada of Imported and Tributary ICS Water";

    END;

    RULE                 "Set Domestic Surplus Schedules - Minute 323";
    DESCRIPTION          "DESCRIPTION: If a Domestic Surplus exists, meaning that Mead's Pool Elevation is greater than the Domestic Surplus Trigger, then this rule will fire in January of the Current Year and set the Total Annual Schedules for all water users impacted by Domestic Surplus. Domestic Surplus is the lowest priority surplus, meaning that a Quantified or Flood Control Surplus will override these values.  -HMG 8/2/11<br><br>SLOTS SET: Surplus Total Annual Schedules.SNWA; Surplus Total Annual Schedules.MWD; Surplus Total Annual Schedules.Gila Monster Farms; Surplus Total Annual Schedules.AzPumpersBlwImp; Surplus Total Annual Schedules.CAP<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170512: No execution constraint that forces execution in January (i.e., could happen in Start Timestep or any timestep)?";
    BEGIN

      $ "Surplus Total Annual Schedules.SNWA" [@"24:00:00 December 31, Current Year"] := $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.SNWA Domestic" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.MWD" [@"24:00:00 December 31, Current Year"] := "Min"( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] + $ "ICS Credits.AnnualNVBankedinCA" [@"24:00:00 December 31, Current Year"] - $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December 31, Current Year"], 1250000.00000000 "acre-ft" - $ "Mexico_CU_Forecast1.MexicoTJ" [@"24:00:00 December 31, Current Year"] );

      $ "Surplus Total Annual Schedules.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] := $ "Arizona_CU_Forecast1.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"];

      $ "Surplus Total Annual Schedules.CAP" [@"24:00:00 December 31, Current Year"] := $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] + IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= 1100.00000000 "feet" )
 THEN
  10305.00000000 "acre-ft"
 ELSE
  0.00000000 "acre-ft"
 ENDIF COMMENTED_BY "If Mead is above 1,100 Ft then release the annual ICS System Efficiency amount of water <br>which is calculated as 1/10 of the 2014 System Efficiency ICS Volume for Arizona of 103,050 AF. <br>";

    END;

    RULE                 "Set Quantified Surplus Entitlement Vols CAP and MWD";
    DESCRIPTION          "DESCRIPTION: This rule distributes the volume of quantified surplus available between MWD and CAP<br><br>SLOTS SET: Surplus Volume Entitlements.MWD Quantified; Surplus Volume Entitlements.CAP Quantified<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Surplus Volume Entitlements.MWD Quantified" [@"24:00:00 December 31, Current Year"] := IF ( $ "Surplus.California Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] )
 THEN
  $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
   "FlowToVolume"( $ "MWDDiversion:MWD.Diversion Requested" [date], date )
  ENDFOR COMMENTED_BY "Total current year MWD diversion request volume"
 ELSE
  $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"]
 ENDIF;

      $ "Surplus Volume Entitlements.CAP Quantified" [@"24:00:00 December 31, Current Year"] := WITH NUMERIC RemainingCanalCapacity = $ "AnnualWaterUse.CAPCanal_AnnualCapacity" [] - "SumAnnualCAPDivRequest"(  ) - $ "ICS Credits.AnnualDeliverySysEff_AZ" [@"24:00:00 December 31, Current Year"] DO
  WITH NUMERIC RemainingQS_AZ = $ "Surplus.Arizona Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] - ( $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] ) DO
   IF ( RemainingQS_AZ > 0.00000000 "acre-feet" )
   THEN
    "Min"( RemainingQS_AZ, RemainingCanalCapacity )
   ELSE
    $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"]
   ENDIF
  ENDWITH
 ENDWITH;

    END;

    RULE                 "Set Domestic and FC Surplus Entitlement Vols for MWD - Minute 323";
    DESCRIPTION          "DESCRIPTION: In Domestic Surplus then MWD gets 1,250 KAF less the MWD Diversion to date, less 1/3 the Mexico Shortage and surplus volume if the year is prior to 2017, after 2017 then the calculation is 250 KAF less 1/3 the Mexico annual surplus value. In a flood control year MWD is entitled to a Full Canal so their entitlement is the current diversion plus what it takes to fill the canal. TP 7/28/2015<br><br>SLOTS SET: Surplus Volume Entitlements.MWD Domestic; Surplus Volume Entitlements.MWD FC<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015";
    BEGIN

      BREAKPOINT BEFORE_EXEC TRUE;
      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.MWD Domestic" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
 THEN
  $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
   "FlowToVolume"( $ "MWDDiversion:MWD.Diversion Requested" [date], date )
  ENDFOR - 1.00000000 / 3.00000000 * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"]
 ELSE
  IF ( $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-ft" AND $ "Surplus Volume Entitlements.SNWA Domestic" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-ft" )
  THEN
   250000.00000000 "acre-ft" - 1.00000000 / 3.00000000 * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"]
  ELSE
   250000.00000000 "acre-ft"
  ENDIF
 ENDIF;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.MWD FC" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.MWD FC" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.MWDCanal_AnnualCapacity" [] - "SumAnnualMWDDivRequest"(  );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Domestic and FC Surplus Entitlement Vols for CAP - Minute 323";
    DESCRIPTION          "DESCRIPTION: If the year is greater than 2017, then determine the Domestic Surplus entitlement for CAP which is calculated as 100 KAF - 1/3*Mexico Annual Surplus - (Surplus entitlements for Gila Monster Farms + AZ pumpers blw Imp).  If the system is in Flood Control, the CAP FC volume is set to 1,835 KAF less the current CAP Diversion Request so that they are entitled to a full canal volume of 1,835 KAF in a year of Flood Control. TP 7/28/2015<br><br>SLOTS SET: Surplus Volume Entitlements.CAP Domestic, Surplus Volume Entitlements.CAP FC<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015";
    BEGIN

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.CAP Domestic" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"24:00:00 January 31, Current Year" ) < 2017.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  100000.00000000 "acre-ft" - 1.00000000 / 3.00000000 * $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"] - ( $ "Surplus Volume Entitlements.Gila Monster Farms" [@"24:00:00 December 31, Current Year"] + $ "Surplus Volume Entitlements.AzPumpersBlwImp" [@"24:00:00 December 31, Current Year"] )
 ENDIF;

      END_IF_STATEMENT;

      IF_STATEMENT (IsNaN $ "Surplus Volume Entitlements.CAP FC" [@"24:00:00 December 31, Current Year"]) THEN
            $ "Surplus Volume Entitlements.CAP FC" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.CAPCanal_AnnualCapacity" [] - "SumAnnualCAPDivRequest"(  );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Quantified Volumes by State";
    DESCRIPTION          "DESCRIPTION: If there is a positive Quantified Surplus volume, this rule will distribute it among the lower basin states of AZ, CA, and NV. The distribution amounts (shares) are stored in a slot on the Surplus object. If there is not a positive Quantified Surplus, the execution contraints will prevent this rule from firing. -HMG 8/2/11<br><br>SLOTS SET: Surplus.<state> Quantified Surplus Volume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/2011";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "Surplus" & ( state CONCAT " Quantified Surplus Volume" ) [@"24:00:00 December 31, Current Year"] := $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] * $ "Surplus.Share of Quantified Surplus by State" [0.00000000, state];

      ENDFOREACH;

    END;

    RULE                 "Set Outyear Surplus Schedules for Mexico - Minute 323";
    DESCRIPTION          "DESCRIPTION: This rule uses the volume associated with the Mexico Surplus Flag to set the Mexico diversion request for surplus according to the Mexico Surplus Table TP 7/28/2015<br><br>SLOTS SET: MexicanTreatyDelivery:MexicoSched.Diversion Requested, Mexico Shortage and Surplus.Mexico Annual Surplus<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND $ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date] + $ "Mexico Shortage and Surplus.Mexico Surplus Table" [$ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Volume"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Mexico"], date );

      ENDFOREACH;

      $ "Mexico Shortage and Surplus.Mexico Annual Surplus" [@"24:00:00 December 31, Current Year"] := $ "Mexico Shortage and Surplus.Mexico Surplus Table" [$ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Volume"];

    END;

  END;

  POLICY_GROUP   "Shortage";
  DESCRIPTION    "This policy group contains the rules required to simulate Lower Basin Shortage operations. Lower Basin Shortage operations are based on the 2007 Interim Guidelines as well as IBWC Minute 323. <br><br>Shortage volumes in Arizona are based on the Arizona Shortage Sharing Agreement. All shortage volumes are the volumes used during the 2007 Interim Guidelines EIS, and were provided by the state of Arizona for use in the EIS process.<br><br>Mexico shortage volumes are based on IBWC Minute 323.   ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Mexico Outyear Shortage Schedules - Minute 323";
    DESCRIPTION          "DESCRIPTION: This rule sets a shortage diversion amount to the water use object MexicanTreatyDelivery:MexicoSched. The Mexico schedule is reduced by the shortage volume. The Mexico shortage volume is specified in IBWC Minute 323.<br><br>SLOTS SET: MexicanTreatyDelivery:MexicoSched.Diversion Requested, Mexico Shortage and Surplus.Mexico Annual Shortage<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date] - $ "Mexico Shortage and Surplus.Mexico Shortage Volumes" [$ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Mexico"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Mexico"], date );

      ENDFOREACH;

      $ "Mexico Shortage and Surplus.Mexico Annual Shortage" [@"24:00:00 December 31, Current Year"] := $ "Mexico Shortage and Surplus.Mexico Shortage Volumes" [$ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, "Mexico"];

    END;

    RULE                 "Set Outyear Shortage Schedules";
    DESCRIPTION          "DESCRIPTION: This rule sets the shortage schedules located in data objects or calculated to the diversion requested slots of the appropriate U.S. water use simulation objects.<br><br>SLOTS SET: PumpingFromLakeMead:SNWP.Diversion Requested, PumpingFromLakeMead:SNWP.Depletion Requested, AzDvsToPkr:LakeHavasuCity.Diversion Requested, AzDvsToPkr:MohaveValleyIID.Diversion Requested, AzDvsToPkr:BullheadCity.Diversion Requested, AzDvsToPkr:CibolaValleyIID.Diversion Requested, AzDvsToPkr:Parker.Diversion Requested, AzDvsToPkr:Ehrenberg.Diversion Requested, GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested, GilaAndYumaUsers:CocopahIndRes.Diversion Requested, AzPkrToImp:AzPumpersAbvImp.Diversion Requested, OthersBlwImp:AzPumpersBlwImp.Diversion Requested, AzDvsToPkr:AzPumpersDvsToPkr.Diversion Requested, CAPDiversion.Total Diversion Requested<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170306: Calculation of snwpDivVol modified by Sarah B. to correct an error";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
          DESCRIPTION          "snwpDivVol modified by Sarah B. 20170306 to correct error";
      WITH_STATEMENT (NUMERIC snwpDivVol = "VolumeToFlow"( WITH NUMERIC dssDeliveries = $ "ICS Credits.AnnualDeliveryTribDSS_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualDeliveryImpDSS_NV" ["Dec31ofYear"( @"t" )] DO
  WITH NUMERIC shortageVolume = $ "Shortage.State Shortage Volumes" [( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) - 1.00000000, "Nevada"] DO
   WITH NUMERIC NonSNWANevadaDivReqs = FOR ( DATETIME date2 IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year" ) STAT_SUM
    "FlowToVolume"( $ "FtMohaveIndRes:NV.Diversion Requested" [date2], date ) + "FlowToVolume"( $ "NvDvsToPkr:BigBend.Diversion Requested" [date2], date ) + "FlowToVolume"( $ "NvDvsToPkr:SCE.Diversion Requested" [date2], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date2], date )
   ENDFOR DO
    ( ( 300000.00000000 "acre-ft" - NonSNWANevadaDivReqs ) + dssDeliveries - shortageVolume ) COMMENTED_BY "Annual SNWP volume = (AZ annual allotment - Priority users diversions <br>+ Developed Shortage Supplies - Shortage volume)"
   ENDWITH
  ENDWITH
 ENDWITH * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"] COMMENTED_BY "Multiply by monthly percentage to get monthly volume", date ) COMMENTED_BY "Calculate the monthly SNWP diversion request under Shortage as a flow rate") DO
            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := snwpDivVol;

            $ "PumpingFromLakeMead:SNWP.Depletion Requested" [date] := snwpDivVol;

      END_WITH_STATEMENT;

          DESCRIPTION          "Set AZ users' diversion requests under shortage";
      $ "AzDvsToPkr:LakeHavasuCity.Diversion Requested" [date] := "Arizona Shortage Depletion"( "LakeHavasuCity", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzDvsToPkr:MohaveValleyIID.Diversion Requested" [date] := "Arizona Shortage Depletion"( "MohaveValleyIID", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzDvsToPkr:BullheadCity.Diversion Requested" [date] := "Arizona Shortage Depletion"( "BullheadCity", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := "Arizona Shortage Depletion"( "CibolaValleyIID", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := "Arizona Shortage Depletion"( "City of Parker", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:Ehrenberg.Diversion Requested" [date] := "Arizona Shortage Depletion"( "Ehrenberg", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := "Arizona Shortage Depletion"( "Gila Monster Farms", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "GilaAndYumaUsers:CocopahIndRes.Diversion Requested" [date] := "Arizona Shortage Depletion"( "Cocopah Indian Res", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzPkrToImp:AzPumpersAbvImp.Diversion Requested" [date] := "Arizona Shortage Depletion"( "AzPumpersAbvImp", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := "Arizona Shortage Depletion"( "AzPumpersBlwImp", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "AzDvsToPkr:AzPumpersDvsToPkr.Diversion Requested" [date] := "Arizona Shortage Depletion"( "AzPumpersDvsToPkr", $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

            $ "CAPDiversion.Total Diversion Requested" [date] := "CAP Shortage Depletion"( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000, date );

      ENDFOREACH;

    END;

    RULE                 "Set CAP Annual Shortage Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the annual shortage volume for CAP in Arizona. The CAP shortage volume is based on the Arizona Shortage Sharing Agreement. It is calculated as the total Arizona shortage volume (based on Lake Mead trigger elevation) minus the sum of the shortage volumes of the other Arizona water users.<br><br>SLOTS SET: Shortage.CAP Annual Shortage Volume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Shortage.CAP Annual Shortage Volume" [@"24:00:00 December 31, Current Year"] := IF ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] > 0.00000000 )
 THEN
  "GetAnnualCAPShortage"( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] - 1.00000000 )
 ELSE
  0.00000000 "acre-feet"
 ENDIF;

    END;

  END;

  POLICY_GROUP   "ICS Accounting and Releases AZ and NV";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Nevada Banking";
    DESCRIPTION          "DESCRIPTION: This rule assigns the Banked Storage from NV in CA and AZ for each year.  As of implementation Unbanked water from CA and AZ is 0 af and will continue to be for the foreseable future.  The values of 0 acre-feet are input on those slots.  If logic is used to solve for those, then logic will have to go into this rule where appropriate. This rule only sets data objects and that data is used in subsequent rules in the Shortage, Surplus and LBDV logic. TP 7.28.2015<br><br>SLOTS SET: ICS Credits.AnnualNevadaUnused, ICS Credits.CumulativeNVBankedinCA, ICS Credits.CumulativeNVBankedinAZ, ICS Credits.AnnualNVBankedinCA, ICS Credits.AnnualNVBankedinAZ, ICS Credits.AnnualNVRecoverableCA, ICS Credits.AnnualNVRecoverableAZ, ICS Credits.AnnualNVUnBankedFromCA, ICS Credits.AnnualNVUnbankedFromAZ<br><br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015";
    BEGIN

      WITH_STATEMENT (NUMERIC unusedNV = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  ( 300000.00000000 "acre-ft" - $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )] + IF ( "MeadPumpingDemandVariabilityFactor"( @"t" ) == 0.95000000 )
  THEN
   ( "SumAnnualSNWADivRequest"(  ) * 0.05000000 ) COMMENTED_BY "Side inflows are high"
  ELSE
   IF ( "MeadPumpingDemandVariabilityFactor"( @"t" ) == 1.05000000 )
   THEN
    ( "SumAnnualSNWADivRequest"(  ) * - 0.05000000 ) COMMENTED_BY "Side Inflows are low"
   ELSE
    0.00000000 "acre-ft" COMMENTED_BY "Normal Side inflows above Hoover"
   ENDIF
  ENDIF COMMENTED_BY "With Regard to Lower Basin Demand Variability, if the side inflows above Hoover are high, <br>then the SNWA diversion is reduced and the available unused Nevada water is increased <br>by 5% of the SNWA diversion. If the side inflows are low, then the SNWA diversion is <br>increased by 5% and the amount of unused Nevada water is decreased by that amount. <br>In a normal year, do not apply any change. TP 7/30/2015" ) COMMENTED_BY "MC, 20170512: Add in a Max&lcub; ..., 0 acre-ft&rcub; here to ensure unused never negative?"
 ENDIF) DO
          DESCRIPTION          "Right now, all unused NV water is going to CA Banking, more logic will  have to go in the following With statements <br>to get that figured out. ";
      WITH_STATEMENT (NUMERIC nvBankedCA = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  unusedNV - $ "ICSProjectionData.NV_LeftinMead" ["Dec31ofYear"( @"t" )]
 ENDIF) DO
            WITH_STATEMENT (NUMERIC nvBankedAZ = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  0.00000000 "acre-ft"
 ENDIF) DO
          DESCRIPTION          "Nevada is permitted to recover up to 40,000 AF from AZ and 30,000 AF from CA annually, added based on <br>an email, April 27, 2015 subject &quot;Re: MTOM Action Items&quot; from Shana Tighi to Tony Powell";
      WITH_STATEMENT (NUMERIC annNVRecoverableAZ = "Min"( 40000.00000000 "acre-ft", $ "ICS Credits.CumulativeNVBankedinAZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] )) DO
            WITH_STATEMENT (NUMERIC annNVRecoverableCA = "Min"( 30000.00000000 "acre-ft", $ "ICS Credits.CumulativeNVBankedinCA" [@"24:00:00 December Max DayOfMonth, Previous Year"] )) DO
          DESCRIPTION          "When the NV unbanked to CA logic needs to be improved, the next two With statements is <br>where that should happen. Currently, the values for unbanked to CA and AZ will be 0 acre-feet.  <br>When logic is generated it needs to be limited to the Recoverable water available to NV. ";
      WITH_STATEMENT (NUMERIC nvUnbankedCA = "Min"( 0.00000000 "acre-ft", annNVRecoverableCA )) DO
            WITH_STATEMENT (NUMERIC nvUnbankedAZ = "Min"( 0.00000000 "acre-ft", annNVRecoverableAZ )) DO
          DESCRIPTION          "Annual Nevada Water not Used";
      $ "ICS Credits.AnnualNevadaUnused" ["Dec31ofYear"( @"t" )] := unusedNV;

            $ "ICS Credits.CumulativeNVBankedinCA" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.CumulativeNVBankedinCA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + nvBankedCA * 0.66666600 - nvUnbankedCA;

            $ "ICS Credits.CumulativeNVBankedinAZ" ["Dec31ofYear"( @"t" )] := $ "ICS Credits.CumulativeNVBankedinAZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] + nvBankedAZ - nvUnbankedAZ;

            $ "ICS Credits.AnnualNVBankedinCA" ["Dec31ofYear"( @"t" )] := nvBankedCA;

            $ "ICS Credits.AnnualNVBankedinAZ" ["Dec31ofYear"( @"t" )] := nvBankedAZ;

            $ "ICS Credits.AnnualNVRecoverableCA" ["Dec31ofYear"( @"t" )] := annNVRecoverableCA;

            $ "ICS Credits.AnnualNVRecoverableAZ" ["Dec31ofYear"( @"t" )] := annNVRecoverableAZ;

            $ "ICS Credits.AnnualNVUnBankedFromCA" ["Dec31ofYear"( @"t" )] := nvUnbankedCA;

            $ "ICS Credits.AnnualNVUnbankedFromAZ" ["Dec31ofYear"( @"t" )] := nvUnbankedAZ;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Nevada ICS Accounting and Releases";
    DESCRIPTION          "DESCRIPTION: This Rule assigns the values for the Nevada ICS.  The function &quot;ICSAccountingForNV&quot; calculates the annual values based on input<br>creation values, delivery values, and assigns the appropriate slots for Nevada ICS. Any diversion changes due to shortage and Delivery of ICS are adjusted in the Shortage logic.  The rule only fires in January or the Start timestep. TP 9/11/2014<br><br>SLOTS SET: ICS Credits.(AnnualCreationTribICS_NV, AnnualCreationTribDSS_NV, SystemEfficiencyICS_NV, ExtraordinaryConservationICS_NV, TributaryDSS_NV, ImportedDSS_NV, BiNationalICS_NV, TotalICS_NV, AnnualDeliveryTribDSS_NV, AnnualDeliveryImpDSS_NV, AnnualCreationImpICS_NV, AnnualCreationImpDSS_NV, ImportedICS_NV, TributaryICS_NV, AnnualDeliveryTribICS_NV, AnnualDeliveryImpICS_NV<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 9/10/2014";
    BEGIN

      WITH_STATEMENT (LIST nvICSValues = "ICSAccountingForNV"(  )) DO
          DESCRIPTION          "Creation of Trib ICS";
      $ "ICS Credits.AnnualCreationTribICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 0.00000000 FROM nvICSValues );

          DESCRIPTION          "Creation of Trib DSS";
      $ "ICS Credits.AnnualCreationTribDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 1.00000000 FROM nvICSValues );

          DESCRIPTION          "NV System Efficiency ICS";
      $ "ICS Credits.SystemEfficiencyICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 2.00000000 FROM nvICSValues );

          DESCRIPTION          "NV Extraordinary Conservation ICS";
      $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 3.00000000 FROM nvICSValues );

          DESCRIPTION          "NV Tributary DSS ICS";
      $ "ICS Credits.TributaryDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 4.00000000 FROM nvICSValues );

          DESCRIPTION          "NV Imported DSS ICS";
      $ "ICS Credits.ImportedDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 5.00000000 FROM nvICSValues );

          DESCRIPTION          "NV Bi National ICS";
      $ "ICS Credits.BiNationalICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 6.00000000 FROM nvICSValues );

          DESCRIPTION          "NV Total ICS";
      $ "ICS Credits.TotalICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 7.00000000 FROM nvICSValues );

          DESCRIPTION          "Delivery of Trib DSS NV";
      $ "ICS Credits.AnnualDeliveryTribDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 8.00000000 FROM nvICSValues );

          DESCRIPTION          "Delivery of Imp DSS NV";
      $ "ICS Credits.AnnualDeliveryImpDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 9.00000000 FROM nvICSValues );

          DESCRIPTION          "Creation of Imp ICS ";
      $ "ICS Credits.AnnualCreationImpICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 10.00000000 FROM nvICSValues );

          DESCRIPTION          "Creation of IMP DSS";
      $ "ICS Credits.AnnualCreationImpDSS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 11.00000000 FROM nvICSValues );

          DESCRIPTION          "Imported ICS NV";
      $ "ICS Credits.ImportedICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 12.00000000 FROM nvICSValues );

          DESCRIPTION          "Tributary ICS NV";
      $ "ICS Credits.TributaryICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 13.00000000 FROM nvICSValues );

          DESCRIPTION          "Delivery of Tributary ICS NV - Quantified Surplus Year";
      $ "ICS Credits.AnnualDeliveryTribICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 14.00000000 FROM nvICSValues );

          DESCRIPTION          "Delivery of Imported ICS NV - Quantified Surplus Year";
      $ "ICS Credits.AnnualDeliveryImpICS_NV" ["Dec31ofYear"( @"t" )] := ( GET @INDEX 15.00000000 FROM nvICSValues );

      END_WITH_STATEMENT;

    END;

    RULE                 "Arizona ICS Accounting and Releases";
    DESCRIPTION          "DESCRIPTION: This Rule assigns the values for the Arizona ICS.  The function &quot;ICSAccountingForAZ&quot; calculates the delivery and annual values based on input creation values, and assigns the appropriate slots for Arizona ICS. The rule only sets informative values to data object slots and not any simulation object slots, the Lower Basin Demand Variability, Surplus and Shortage Logic will reference this data in later rules.  The rule only fires in January or the Start timestep. TP 9/10/2014<br><br>SLOTS SET: ICS Credits.AnnualDeliveryEC_AZ; ICS Credits.AnnualDeliverySysEff_AZ; ICS Credits.AnnualDeliveryBiNat_AZ; ICS Credits.ExtraordinaryConservationICS_AZ; ICS Credits.SystemEfficiencyICS_AZ; ICS Credits.BiNationalICS_AZ; ICS Credits.TotalICS_AZ<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 January Max DayOfMonth, Current Year" OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 3.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) ) COMMENTED_BY "Rule executes in Run Cycle 3 at the Start Timestep or January, if the rule has not already executed successfully";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 9/10/2014";
    BEGIN

      WITH_STATEMENT (LIST azICSValues = "ICSAccountingForAZ"(  )) DO
          DESCRIPTION          "AZ Extraordinary Conservation ICS Delivery";
      $ "ICS Credits.AnnualDeliveryEC_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM azICSValues;

          DESCRIPTION          "AZ System Efficiency ICS Delivery";
      $ "ICS Credits.AnnualDeliverySysEff_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM azICSValues;

          DESCRIPTION          "AZ Bi National ICS Delivery";
      $ "ICS Credits.AnnualDeliveryBiNat_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM azICSValues;

          DESCRIPTION          "AZ Extraordinary Conservation ICS";
      $ "ICS Credits.ExtraordinaryConservationICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM azICSValues;

          DESCRIPTION          "AZ System Efficiency ICS";
      $ "ICS Credits.SystemEfficiencyICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM azICSValues;

          DESCRIPTION          "AZ Bi National ICS";
      $ "ICS Credits.BiNationalICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 5.00000000 FROM azICSValues;

          DESCRIPTION          "AZ Total ICS";
      $ "ICS Credits.TotalICS_AZ" ["Dec31ofYear"( @"t" )] := GET @INDEX 6.00000000 FROM azICSValues;

      END_WITH_STATEMENT;

    END;

  END;

  POLICY_GROUP   "Mead and Lower Basin Condition Determination";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Quantified Surplus Flags";
    DESCRIPTION          "DESCRIPTION: This rule sets the flags that indicate a Quantified Surplus condition<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Quantified Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND @"t" == @"24:00:00 January 31, Current Year" AND IsNaN $ "Surplus.Surplus Flag" [] AND $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] > 0.00000000 "acre-feet";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170706<br><br>MC, 20170706: The setting of these flags was moved from the rule Quantified Surplus Schedules Data Volume to Simulation Flow at the suggestion of Shana T. to consolidate setting of flags related to Mead condition. Note that the Execution Constraints for this rule depend on the Surplus.Quantified Surplus Volume slot, which isn't set until Rule 39-Copute Quantified Surplus Volume - Minute 323; so, this rule will not fire successfully until after that rule";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 2.00000000;

            $ "Surplus.Quantified Surplus Flag" [date] := 1.00000000;

      ENDFOREACH;

      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" [@"24:00:00 December 31, Current Year"] := 2.00000000;

    END;

    RULE                 "Set Domestic Surplus Flags";
    DESCRIPTION          "DESCRIPTION: This rule sets the flags that indicate a Domestic Surplus condition<br><br>SLOTS SET: Surplus.Surplus Flag; Surplus.Domestic Surplus Flag; LowerBasinDemandVariability.AbvHooverTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [] AND IsNaN $ "Surplus.Surplus Flag" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170706<br><br>MC, 20170706: The setting of these flags was moved from the rule Domestic Surplus Schedules Data Volume to Simulation Flow at the suggestion of Shana T. to consolidate setting of flags related to Mead condition";
    BEGIN

      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December 31, Current Year") DO
            $ "Surplus.Surplus Flag" [date] := 1.00000000;

            $ "Surplus.Domestic Surplus Flag" [date] := 1.00000000;

      ENDFOREACH;

      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" [@"24:00:00 December 31, Current Year"] := 2.00000000;

    END;

    RULE                 "Compute Quantified Surplus Volume - Minute 323";
    DESCRIPTION          "DESCRIPTION: This rule computes the total volume of Quantified Surplus water for the year. This slot only computes once per year in January and is NOT recalculated if Lower Basin demands are revised. If this value is postitive, there is a Quantified Surplus determination and water use schedules are revised as appropriate. <br>Equation:   Surplus Volume = (Powell Storage + Mead Storage - maxstorage - previous year ICS credits)*(1+avgBankStorcoef) + runoff - UBDemand - LBDemand <br>Variable Definitions:<br>  Powell Storage = Powell storage at beginning of the year (December month-end) <br>  Mead Storage = Mead storage at the beginning of the year (December month-end) <br>  Max Storage = 47.96 maf <br>  Previous year ICS credits - cumulative ICS credits over entire Lower Basin over all years <br>  avgBankStorcoef = average of Powell and Mead bank storage coefficients <br>  Runoff = 17.4 maf (70th percentile non-exceedence flow) <br>  UBDemand = Upper Basin depletion scheduled for the year + average evaporation loss in the Upper Basin (same as in 602a calculation, 560 kaf) <br>  LBDemand = sum of depletions below Powell + evaporation losses in the Lower Basin (avg 900 kaf) ? avg gains below Powell (Powell to Mead and below Mead) <br><br>-HMG 8/2/11<br><br>SLOTS SET: Surplus.Quantified Surplus Volume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/11<br>MC, 20160114: There is a function, QuantifiedSurplusVolume, with the same calculation in it.  Are both necessary?<br>MC, 20170512: Need to edit Execution Constraints to ensure execution in January?";
    BEGIN

      $ "Surplus.Quantified Surplus Volume" [@"24:00:00 December 31, Current Year"] := "QuantifiedSurplusVolume"(  );

    END;

    RULE                 "Determine Mead and Lower Basin Condition";
    DESCRIPTION          "DESCRIPTION: This rule sets a slot that determines the Condition of Lake Mead and the Lower Basin. A setting of 0 means a normal year, a 1 means shortage, a 2 means Domestic Surplus and a 3 is Quantified Surplus.  In the condition of anything that is not normal. TP 7/28/2015<br><br>SLOTS SET: LowerBasinDemandVariability.LowerBasinCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 3.00000000 ) COMMENTED_BY "Rule executes in Run Cycle 3 in January that is not the Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/28/2015";
    BEGIN

      BREAKPOINT BEFORE_EXEC TRUE;
      $ "LowerBasinDemandVariability.LowerBasinCondition" [@"24:00:00 December 31, Current Year"] := IF ( $ "Mead.Pool Elevation" [@"t - 1"] <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
 THEN
  1.00000000 COMMENTED_BY "If Mead is below 1,075 ft, then set the Basin Condition value to 1 for Shortage"
 ELSE
  IF ( "QuantifiedSurplusVolume"(  ) > 0.00000000 "acre-ft" )
  THEN
   3.00000000 COMMENTED_BY "If the Quantified Surplus Volume Calculation is greater than zero, <br> then set the Basin Condition value to 3 for Quantified Surplus"
  ELSE
   IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [] )
   THEN
    2.00000000 COMMENTED_BY "If Mead is greater than 1,145 ft, then set the Basin Condition value to 2 for Domestic Surplus"
   ELSE
    0.00000000 COMMENTED_BY "If the Mead Elevation is between 1,075 and 1,145 and there is not enough water to <br>warrent a quantified surplus condition, set the Basin Condition value to 0 for a <br>normal condition"
   ENDIF
  ENDIF
 ENDIF;

    END;

    RULE                 "Set Mexico Surplus Flag - Minute 323";
    DESCRIPTION          "DESCRIPTION: This rule sets the Mexico Surplus flag as a function of Mead compared to the Mexico Surplus Table. A Mead elevation of >= 1,200 ft. receives a value of 3, a value greater than 1,170 ft and less than the level 3 elevation, receives a value of 2, a value of 1,145 ft and less than a level 2 receives a value of 0 and any other condition receives a value of 0. This flag is used in subsequent Mexico Surplus rules. TP 7/28/2015<br><br>SLOTS SET: Mexico Shortage and Surplus.Mexico Surplus Flag<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170706: Moved from Priority 41 while consolidating Mead conditions flag-setting per Shana T. suggestion";
    BEGIN

      $ "Mexico Shortage and Surplus.Mexico Surplus Flag" [@"24:00:00 December 31, Current Year"] := IF ( $ "Mead.Pool Elevation" [@"t - 1"] >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [2.00000000, "Elevation"] )
 THEN
  3.00000000
 ELSE
  IF ( $ "Mead.Pool Elevation" [@"t - 1"] >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [1.00000000, "Elevation"] )
  THEN
   2.00000000
  ELSE
   IF ( $ "Mead.Pool Elevation" [@"t - 1"] >= $ "Mexico Shortage and Surplus.Mexico Surplus Table" [0.00000000, "Elevation"] )
   THEN
    1.00000000
   ELSE
    0.00000000
   ENDIF
  ENDIF
 ENDIF;

    END;

    RULE                 "Set Shortage Flag";
    DESCRIPTION          "DESCRIPTION: In the event that a Lower Basin shortage is projected, this rule sets the Shortage Flag slot to indicate the level of shortage. No shortage = 0. Most severe shortage (Mead < 1025 feet) = 3. Mead < 1050 ft = 2, Mead < 1075 ft = 1. If there is a shortage or surplus then the Abv Hoover Trigger is set to a 2 and no LBDV will occur for the parties that look at the Above Hoover Trigger Set for LBDV.  (SNWP)<br><br>SLOTS SET: Shortage.Shortage Flag, LowerBasinDemandVariability.AbvHooverTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND @"t" != @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 3.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170706: Moved from Priority 46 while consolidating Mead conditions flag-setting per Shana T. suggestion";
    BEGIN

      $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] := IF ( $ "Mead.Pool Elevation" [@"t - 1"] < $ "Shortage.Mead Shortage Elevations" [2.00000000, 0.00000000] )
 THEN
  3.00000000
 ELSE
  IF ( $ "Mead.Pool Elevation" [@"t - 1"] < $ "Shortage.Mead Shortage Elevations" [1.00000000, 0.00000000] )
  THEN
   2.00000000
  ELSE
   IF ( $ "Mead.Pool Elevation" [@"t - 1"] <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
   THEN
    1.00000000
   ELSE
    0.00000000
   ENDIF
  ENDIF
 ENDIF;

      $ "LowerBasinDemandVariability.AbvHooverTriggerSet" [@"24:00:00 December 31, Current Year"] := IF ( $ "Mead.Pool Elevation" [@"t - 1"] <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
 THEN
  2.00000000
 ENDIF;

    END;

  END;

  POLICY_GROUP   "Powell Steady Flow Experiment";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Steady Flow Experiment Release";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT $ "PowellData.SteadyFlowExperimentFlag" [] == 1.00000000 AND "GetRunCycleIndex"(  ) == 3.00000000;
    NOTES                "";
    BEGIN

      IF_STATEMENT ("MonthIs"( { "September" } )) THEN
            $ "Powell.Outflow" [] := "GetSeptemberSteadyFlowRelease"( $ "PowellData.TargetAnnualReleaseVolume" [] );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "October" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [@"t - 1"];

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "April" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.5_ReduceApril" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "May" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.6_ReduceMay" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "June" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - ( $ "PowellSteadyFlowExperiment.4_ReduceJune_2" ["CurrentYear"(  )] + $ "PowellSteadyFlowExperiment.3_ReduceJune_1" ["CurrentYear"(  )] ) / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "July" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.2_ReduceAugust" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

      IF_STATEMENT ("MonthIs"( { "July" } )) THEN
            $ "Powell.Outflow" [] := $ "Powell.Outflow" [] - $ "PowellSteadyFlowExperiment.1_ReduceJuly" ["CurrentYear"(  )] / "GetDaysInMonth"( @"t" );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Steady Flow Reductions";
    DESCRIPTION          "";
    ACTIVE               FALSE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "April" } ) AND "GetRunCycleIndex"(  ) == 3.00000000;
    NOTES                "";
    BEGIN

      $ "PowellSteadyFlowExperiment.1_ReduceJuly" ["CurrentYear"(  )] := "SteadyFlowReduce_1_July"(  );

      $ "PowellSteadyFlowExperiment.2_ReduceAugust" ["CurrentYear"(  )] := "SteadyFlowReduce_2_August"(  );

      $ "PowellSteadyFlowExperiment.3_ReduceJune_1" ["CurrentYear"(  )] := "SteadyFlowReduce_3_June1"(  );

      $ "PowellSteadyFlowExperiment.4_ReduceJune_2" ["CurrentYear"(  )] := "SteadyFlowReduce_4_June2"(  );

      $ "PowellSteadyFlowExperiment.5_ReduceApril" ["CurrentYear"(  )] := "SteadyFlowReduce_5_April"(  );

      $ "PowellSteadyFlowExperiment.6_ReduceMay" ["CurrentYear"(  )] := "SteadyFlowReduce_6_May"(  );

    END;

  END;

  POLICY_GROUP   "PowellAfterLBDV";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Lower Balancing Release VolumePostLBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Lower Elevation Balancing Tier. This version of the rule executes in Run Cycle 4 with Lower Basin Demand Variability in effect.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsYearDemandVariabilityAndRunCycle4"( @"t + 2" ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "For Start Timestep with Lower Balancing Release Tier in initial water year";
      IF_STATEMENT (@"t" == @"Start Timestep" AND "TierIs"( "Lower", @"t", TRUE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

    DESCRIPTION          "For August timestep with Lower Balancing Release Tier in next outyear";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND "TierIs"( "Lower", @"t", FALSE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t + 2" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Mid-Elevation Release VolumePostLBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Mid-Elevation Tier. This version of the rule executes in Run Cycle 4 if Lower Basin Demand Variability is in effect.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsYearDemandVariabilityAndRunCycle4"( @"t + 2" ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "MC, 20171102: Need to check if the LBDV situation can handle WY1 & WY2 together or needs to be <br>separated like initial settings <br>";
      IF_STATEMENT (( @"t" == @"Start Timestep" AND "TierIs"( "Mid", @"t", TRUE ) ) COMMENTED_BY "For Start Timestep with Mid-Elevation tier in initial water year") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF, NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

    DESCRIPTION          "In August with Mid-elevation tier for the next outyear";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND "TierIs"( "Mid", @"t", FALSE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "Mead.Pool Elevation" [@"24:00:00 December 31, Current Year"] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF;

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Refine Equalization Release VolumePostLBDV";
    DESCRIPTION          "DESCRIPTION: This rule refines the annual release volume from Powell when either the Equalization Tier or Upper Elevation Balancing Tier B3 branch is operative for setting the annual release from Powell.  The release needs to be refined by this rule because when it is originally set, it is a preliminary &quot;guess&quot; for the volume it will take to arrive at the appropriate final (end of water year) condition (Equalized storage volumes, or Powell at a specific pool elevation at the end of the year - see Equalization Tier logic for more details as to what the final eowy condition should be).  This volume is then released and the end of year condition is checked against what it is supposed to be.  The first guess will almost always be off by some amount because of the non-linear elements in the water balance in both Powell and Mead of Evaporation and Bank Storage.  So rather than trying to set up a calculation or mini-simulation to calculate the exact right release volume to hit the end of water year condtion the first time, the guess volume is actually released and then this rule, because it can see the results of the original release, adjusts the release volume to eliminate the deviation from the target that it observes as a result of the initial guess release.  This rule is allowed to fire multiple times in a timestep and may do so in order to hit exactly the end of water year target condition. - sc 06/21/12<br><br>This version of the rule executes in Run Cycle 4 with Lower Basin Demand Variability in effect.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT WITH DATETIME eoyDate = IF ( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
 THEN
  "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )
 ELSE
  "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )
 ENDIF DO
  "HasRuleFiredSuccessfully"( "Set Equalization Release Volume" ) OR ( "HasRuleFiredSuccessfully"( "Set Upper Balancing Release Volume" ) AND $ "PowellData.UpperElevBalBranch" [eoyDate] == 1.30000000 ) AND ( "IsYearDemandVariabilityAndRunCycle4"( @"t + 2" ) OR "IsUEBEqualizingBranchAndRunCycle4"( eoyDate ) )
 ENDWITH;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 06/21/2012";
    BEGIN

      IF_STATEMENT (( @"t" == @"Start Timestep" AND ( "TierIs"( "Upper", @"t", TRUE ) OR "TierIs"( "Equalization", @"t", TRUE ) ) AND NOT "MonthIs"( { "August" } ) ) COMMENTED_BY "At Start Timestep for initial water year when release tier is either Upper Elevation Balancing or Equalization") THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t" ) )) DO
            IF_STATEMENT ("Abs"( ReleaseAdjustment ) > $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] + ReleaseAdjustment , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } );

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      IF_STATEMENT (( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND ( "TierIs"( "Upper", @"t", FALSE ) OR "TierIs"( "Equalization", @"t", FALSE ) ) ) COMMENTED_BY "Check in August timestep or StartMonth of September with UEBT or Equalization for outyear") THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t + 2" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t + 2" ) )) DO
            IF_STATEMENT ("Abs"( VolumeDeviation ) > 0.00000000 "acre-feet") THEN
            WITH_STATEMENT (NUMERIC CurrentAnnualRelease = FOR ( DATETIME dates IN "GetDates"( "OffsetDate"( @"24:00:00 September Max DayOfMonth, Next Year", - 11.00000000, "1 months" ), @"24:00:00 September Max DayOfMonth, Next Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Outflow" [dates], dates )
 ENDFOR) DO
          DESCRIPTION          "MC, 20171102: This version added to handle carryover situation by setting ReleaseVolumeSetFlag <br>";
      IF_STATEMENT ("Abs"( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] - CurrentAnnualRelease - VolumeDeviation ) > ( $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) COMMENTED_BY "The tolerance of the TARV slot; if the proposed change is less than this value the slot value won't change <br>") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "MaxItem"( { IF ( VolumeDeviation > 0.00000000 "acre-ft" )
 THEN
  ( CurrentAnnualRelease - IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 999.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] )
  ENDIF COMMENTED_BY "Remove the Carryover That has been Added from last year Unless an Equalization Tier is the <br>current tier. <br>" ) + ReleaseAdjustment
 ELSE
  $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] + ReleaseAdjustment
 ENDIF , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } );

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END;

    RULE                 "Set Upper Balancing Release Volume PostLBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Upper Elevation Balancing Tier. It also sets the Upper Elevation Balancing Branch, which indicates the conditions controlling the release volume, and resets the Release Tier and the Controlling Equalization Condition if necessary (UEB Branch = 1.3). This version of the rule executes in Run Cycle 4 if Lower Basin Demand Variability is in effect.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.UpperElevBalBranch; PowellData.ReleaseTier; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT WITH DATETIME eoyDate = IF ( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
 THEN
  "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )
 ELSE
  "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )
 ENDIF DO
  ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND ( "IsYearDemandVariabilityAndRunCycle4"( @"t + 2" ) OR "IsUEBEqualizingBranchAndRunCycle4"( eoyDate ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND @"t + 2" <= @"Finish Timestep"
 ENDWITH;
    NOTES                "AUTHOR, DATE: Unknown<br>MC, 20161215: In the conditional statement checking for EqualizationTeirCalculationForRelease, changed PowellToMeadData.AugEOYPowellPEProjection[meadProjectionDate] to Powell.Pool Elevation[DateToCheckEOWYElevation(@&quot;t&quot;,TRUE)]. The check needs to be on the EOWY pool elevation, not the previous year's projected EOY pool elevation, because this is checking to see if the decision tree should follow the branch from Upper Elevation Balancing to Equalization. I had incorrectly changed the date used when adding the carryover functionality.<br>MC, 20170511: The GetRunCycleIndex()==3 condition will never be satisfied due to the Execution Constraints. Compare with initial version of rule for Run Cycle 4 and correct";
    BEGIN

      IF_STATEMENT (( @"t" == @"Start Timestep" AND ( "GetRunCycleIndex"(  ) == 3.00000000 OR "IsYearDemandVariabilityAndRunCycle4"( @"t" ) ) AND "TierIs"( "Upper", @"t", TRUE ) ) COMMENTED_BY "For Start Timestep in Run Cycle 4 with Lower Basin Demand Variability in effect and UEBT in Start Year") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := WITH DATETIME meadProjectionDate = IF ( @"t" <= @"September 30" )
 THEN
  @"24:00:00 December 31, Previous Year"
 ELSE
  @"24:00:00 December 31, Current Year"
 ENDIF DO
  IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", TRUE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [meadProjectionDate] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) )
  THEN
   GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ELSE
   IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" [meadProjectionDate] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [meadProjectionDate] ) ) >= 1075.00000000 "ft" )
   THEN
    "Max"( "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ELSE
    "Max"( "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ENDIF COMMENTED_BY "Determine which branch of UEBT to follow"
  ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue..."
 ENDWITH;

          DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", TRUE ), TRUE )) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 0.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      IF_STATEMENT (( ( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) ) AND "TierIs"( "Upper", @"t", FALSE ) ) COMMENTED_BY "In August or September start month with UEBT for outyear") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", FALSE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) )
 THEN
  ( GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "DateToCheckEOWYElevation"( @"t", FALSE ) )] )
 ELSE
  IF ( ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "Mead.Pool Elevation" [@"24:00:00 December 31, Current Year"] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1075.00000000 "ft" ) COMMENTED_BY "Determine which branch of UEBT to follow" )
  THEN
   "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ELSE
   "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ENDIF
 ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue...";

          DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", FALSE ), FALSE )) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 0.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Equalization Release VolumePostLBDV";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) for years when the Release Tier is Equalization. It also calculates and sets the Controlling Equalization Condition slot, which indicates the equalization condition that dictated the volume to be released. This version executes in Run Cycle 4 if Lower Basin Demand Variability is in effect.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT WITH DATETIME eoyDate = IF ( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
 THEN
  "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )
 ELSE
  "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )
 ENDIF DO
  ( "IsYearDemandVariabilityAndRunCycle4"( @"t + 2" ) AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) )
 ENDWITH COMMENTED_BY "This rule only fires in Run Cycle 4 with demand variability in effect, it is August, and the model has selected the Equalization teir for the current year. - sc 02/02/11; TP 08/20/2014; MC, 20170511";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF_STATEMENT (( @"t" == @"Start Timestep" AND "TierIs"( "Equalization", @"t", TRUE ) ) COMMENTED_BY "Initial water year with Equalization") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

    DESCRIPTION          "Outyear with Equalization";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND "TierIs"( "Equalization", @"t", FALSE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

      END_IF_STATEMENT;

      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

    END;

    RULE                 "Preliminary Set Out Year Release Volume To 8.23MAF post LBDV";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsYearDemandVariabilityAndRunCycle4"( @"t + 2" ) AND "MonthIs"( { "August" } ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND @"t + 2" <= @"Finish Timestep";
    NOTES                "AUTHOR, DATE: SC, 03/25/2011";
    BEGIN

      WITH_STATEMENT (NUMERIC waterYearNumber = "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF) DO
            WITH_STATEMENT (NUMERIC AvailablePowellWater = ( IF ( "GetMonth"( @"Start Timestep" ) == 9.00000000 )
 THEN
  $ "Powell.Storage" [@"t - 1"]
 ELSE
  $ "Powell.Storage" [@"t + 1"]
 ENDIF COMMENTED_BY "MC, 20170511: I don't understand the below conditions" + FOR ( DATETIME date IN "WaterYearDatesByGroup"( waterYearNumber ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Inflow" [date], date )
 ENDFOR ) COMMENTED_BY "This is added to check that in years when Powell might go very low, the model won't bomb out <br>when setting the preliminary release when Powell is low. TP 1/22/2013<br>") DO
            WITH_STATEMENT (NUMERIC VolumeToRelease = "Min"( "Max"( 8230.00000000 "1000 acre-feet", "CalcReleaseForMaxPoolElevation"( "WaterYearDatesByGroup"( waterYearNumber ) ) ), AvailablePowellWater )) DO
            IF_STATEMENT (NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "OffsetDate"( "RelativeEOWYDate"( @"Start Timestep" ), waterYearNumber - 1.00000000, "1 years" ) ) )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "OffsetDate"( "RelativeEOWYDate"( @"Start Timestep" ), waterYearNumber - 1.00000000, "1 years" ) )] := VolumeToRelease;

          DESCRIPTION          "These flags have to be reset and set again if go to LBDV <br>";
      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 0.00000000;

          INACTIVE      $ "PowellData.CarryoverSetFlag" ["Dec31ofYear"( "GetWaterYearEndDate"( @"t + 2" ) )] := 0.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Preliminary Set WY1 Release Volume To 8.23MAF post LBDV";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsYearDemandVariabilityAndRunCycle4"( @"t + 2" ) AND @"t" == @"Start Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: SC, 03/25/2011";
    BEGIN

      IF_STATEMENT (NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { 8230.00000000 "1000 acre-feet" , "CalcReleaseForMaxPoolElevation"( "WaterYearDatesByGroup"( 1.00000000 ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) } COMMENTED_BY "MC, 20170511: Compare with other preliminary volume rules" );

          DESCRIPTION          "These flags have to be reset and set again if go to LBDV <br>";
      $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 0.00000000;

          INACTIVE      $ "PowellData.CarryoverSetFlag" ["Dec31ofYear"( "GetWaterYearEndDate"( @"t" ) )] := 0.00000000;

      END_IF_STATEMENT;

    END;

  END;

  POLICY_GROUP   "Powell";
  DESCRIPTION    "Annual operations of Lake Powell follow the guidelines specified in the 2007 Record of Decision for the Colorado River Interim Guidelines for Lower Basin Shortages and the Coordinated Operations for Lake Powell and Lake Mead (2007 Interim Guidelines). The 2007 Interim Guidelines specify several requirements that coordinate annual operations between Lake Powell and Lake Mead. The objective of coordinated operations is to avoid curtailment of uses in the Upper Basin, minimize shortages in the Lower Basin, and not adversely affect the yield for development available in the Upper Basin.<br>The 2007 Interim Guidelines specify annual release volumes for each of the four tiers, described herein. Operating tiers are set based upon the August projection of the following January 1 elevation, but in some cases are subject to an April adjustment.   <br>Equalization Tier <br>In water years when the Lake Powell January 1 pool elevation is projected to be greater than or equal to the Equalization elevation for the water year (see the 2007 Interim Guidelines), an amount of water greater than 8.23 MAF will be released from Lake Powell to the extent necessary to avoid spills or equalize the storage in the two reservoirs, otherwise to remain at 8.23 MAF. If, however, Lake Powell reaches the Equalization elevation and the September 30 projected Lake Mead elevation is below 1,105 feet, then additional water will be released until the first of the following occur: (i) Lake Powell and Lake Mead storages equalize, (ii) Lake Mead pool elevation reaches 1,105 feet, or (iii) Lake Powell pool elevation is equal to 20 feet less than the Equalization level for that year. <br>Upper Elevation Balancing Tier <br>If the August 24-Month Study projects the Lake Powell pool elevation for January 1 to be less than the elevation stated in the Lake Powell Equalization Elevation Table and at or above 3,575 feet, then the tier is Upper Elevation Balancing Tier. If the August 24-Month Study also projects the Lake Mead January 1 pool elevation to be greater than 1,075 feet, then 8.23 MAF will be released from Lake Powell. <br>If the August 24-Month Study projects the January 1 Lake Powell elevation to be below the elevation stated in the Lake Powell Equalization Elevation Table and at or above 3,575 feet, and the projected January 1 Lake Mead elevation is below 1,075 feet, the release from Lake Powell shall balance the contents of Lake Mead and Lake Powell, but shall be not more than 9.0 MAF and not less than 7.0 MAF in the water year. <br>When operating in the Upper Elevation Balancing Tier, if the April 24-Month Study projects the September 30 Lake Powell elevation to be greater than the elevation in the Lake Powell Equalization Elevation Table, the Equalization Tier will govern the operation of Lake Powell for the remainder of the water year (through September). <br>When operating under the Upper Elevation Balancing Tier with an 8.23 MAF release, if the April 24-Month Study projects the September 30 Lake Mead elevation to be below 1,075 feet and the September 30 Lake Powell elevation to be at or above 3,575 feet, the releases from Lake Powell shall balance the contents of Lake Mead and Lake Powell, but shall not be more than 9.0 MAF and not less than 8.23 MAF in the water year. <br>Mid-Elevation Release Tier <br>If the August 24-Month Study projects the January 1 Lake Powell pool elevation to be less than 3,575 feet and greater than or equal to 3,525 feet, the operating tier is the Mid-Elevation Release Tier. Within this tier, if the August 24-Month Study projects the Lake Mead January 1 pool elevation to be greater than 1,025 feet, Lake Powell will release 7.48 MAF. If the August 24-Month Study projects the Lake Mead January 1 pool elevation to be less than or equal to 1,025 feet, Lake Powell will release 8.23 MAF. Once established in August, this Lake Powell annual release volume is set for the duration of the upcoming water year. <br>Lower Elevation Balancing Tier <br>If the August 24-Month Study projects the Lake Powell January 1 pool elevation to be less than 3,525 feet, the operating tier is Lower Elevation Balancing Tier. The release from Lake Powell is set to balance the contents of Lakes Powell and Mead by the end of the upcoming water year, but will not be greater than 9.5 MAF and not less than 7.0 MAF. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Lower Balancing Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Lower Elevation Balancing Tier. <br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: Unknown<br><br>TP 20171017: Removed Setting the volume for the first water year, only sets outyear volumes now";
    BEGIN

    DESCRIPTION          "For August timestep with Lower Balancing Release Tier in next outyear";
      IF_STATEMENT (( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) ) AND "TierIs"( "Lower", @"t", FALSE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t + 2" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Mid-Elevation Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Mid-Elevation Tier for Out Years. <br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170718: Added &quot;OR StartMonthIsSeptember()&quot; to condition originally for August; Sarah B. discovered this error and proposed the fix<br><br>TP, 20171017: Removed any setting of the First water year from this Rule";
    BEGIN

    DESCRIPTION          "In August with Mid-elevation tier for the next outyear";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND "TierIs"( "Mid", @"t", FALSE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "Mead.Pool Elevation" [@"24:00:00 December 31, Current Year"] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF;

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Refine Equalization Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule refines the annual release volume from Powell when either the Equalization Tier or Upper Elevation Balancing Tier B3 branch is operative for setting the annual release from Powell.  The release needs to be refined by this rule because when it is originally set, it is a preliminary &quot;guess&quot; for the volume it will take to arrive at the appropriate final (end of water year) condition (Equalized storage volumes, or Powell at a specific pool elevation at the end of the year - see Equalization Tier logic for more details as to what the final eowy condition should be).  This volume is then released and the end of year condition is checked against what it is supposed to be.  The first guess will almost always be off by some amount because of the non-linear elements in the water balance in both Powell and Mead of Evaporation and Bank Storage.  So rather than trying to set up a calculation or mini-simulation to calculate the exact right release volume to hit the end of water year condtion the first time, the guess volume is actually released and then this rule, because it can see the results of the original release, adjusts the release volume to eliminate the deviation from the target that it observes as a result of the initial guess release.  This rule is allowed to fire multiple times in a timestep and may do so in order to hit exactly the end of water year target condition. - sc 06/21/12<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT WITH DATETIME eoyDate = IF ( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) )
 THEN
  "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )
 ELSE
  "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )
 ENDIF COMMENTED_BY "Make sure using appropriate year value" DO
  "HasRuleFiredSuccessfully"( "Set Equalization Release Volume" ) OR ( "HasRuleFiredSuccessfully"( "Set Upper Balancing Release Volume" ) AND $ "PowellData.UpperElevBalBranch" [eoyDate] == 1.30000000 ) AND "GetRunCycleIndex"(  ) == 3.00000000
 ENDWITH;
    NOTES                "AUTHOR, DATE: SC, 06/21/2012<br><br>MC, 20171102: Added use of new slot PowellData.TARVTolerance to determine when refinement of TARV will stop.";
    BEGIN

      BREAKPOINT BEFORE_EXEC TRUE;
      IF_STATEMENT (( @"t" == @"Start Timestep" AND ( "TierIs"( "Upper", @"t", TRUE ) OR "TierIs"( "Equalization", @"t", TRUE ) ) AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) ) COMMENTED_BY "At Start Timestep for initial water year when release tier is either Upper Elevation Balancing or Equalization") THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t" ) )) DO
            IF_STATEMENT ("Abs"( ReleaseAdjustment ) > $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] + ReleaseAdjustment , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } );

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Check in August timestep or StartMonth of September with UEBT or Equalization for outyear";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND ( "TierIs"( "Upper", @"t", FALSE ) OR "TierIs"( "Equalization", @"t", FALSE ) )) THEN
            WITH_STATEMENT (NUMERIC VolumeDeviation = "VolumeDeviationFromEOWYTarget"( "RelativeEOWYDate"( @"t + 2" ) )) DO
            WITH_STATEMENT (NUMERIC ReleaseAdjustment = "ReleaseAdjustment"( VolumeDeviation, "RelativeEOWYDate"( @"t + 2" ) )) DO
            IF_STATEMENT ("Abs"( VolumeDeviation ) > 0.00000000 "acre-feet") THEN
            WITH_STATEMENT (NUMERIC CurrentAnnualRelease = FOR ( DATETIME dates IN "GetDates"( "OffsetDate"( @"24:00:00 September Max DayOfMonth, Next Year", - 11.00000000, "1 months" ), @"24:00:00 September Max DayOfMonth, Next Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Outflow" [dates], dates )
 ENDFOR) DO
          DESCRIPTION          "MC, 20171102: This version added to handle carryover situation by setting ReleaseVolumeSetFlag <br>";
      IF_STATEMENT ("Abs"( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] - ( CurrentAnnualRelease + VolumeDeviation ) ) > ( $ "PowellData.TARVTolerance" [] * $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) COMMENTED_BY "The tolerance of the TARV slot; if the proposed change is less than this value the slot value won't change <br>") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "MaxItem"( { IF ( ReleaseAdjustment > 0.00000000 "acre-ft" )
 THEN
  ( CurrentAnnualRelease - IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 999.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] )
  ENDIF COMMENTED_BY "Remove the Carryover That has been Added from last year Unless an Equalization Tier is the <br>current tier. <br>" ) + ReleaseAdjustment
 ELSE
  $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] + ReleaseAdjustment
 ENDIF , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) , IF ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.27000000 OR $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.29000000 )
 THEN
  7000000.00000000 "acre-feet"
 ELSE
  8230000.00000000 "acre-feet"
 ENDIF COMMENTED_BY "If in UEB 1.2, the Min annual release is 7.0 MAF <br>" } );

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

          INACTIVE    DESCRIPTION          "MC, 20180111: This is now handled in ReleaseAdjustment function<br>If UEB Branch is 1.4, make sure release is within limits <br>";
      IF_STATEMENT ($ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 1.40000000) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "EnsureReleaseLimits"( "EqualizationRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ), 8230.00000000 "1000 acre-ft", 9000.00000000 "1000 acre-ft" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Upper Balancing Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) when the Release Tier is set to Upper Elevation Balancing Tier for out years. It also sets the Upper Elevation Balancing Branch, which indicates the conditions controlling the release volume, and resets the Release Tier and the Controlling Equalization Condition if necessary (UEB Branch = 1.3)<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.UpperElevBalBranch; PowellData.ReleaseTier; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND @"t + 2" <= @"Finish Timestep";
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20161215: In the conditional statement checking for EqualizationTeirCalculationForRelease, changed PowellToMeadData.AugEOYPowellPEProjection[meadProjectionDate] to Powell.Pool Elevation[DateToCheckEOWYElevation(@&quot;t&quot;,TRUE)]. The check needs to be on the EOWY pool elevation, not the previous year's projected EOY pool elevation, because this is checking to see if the decision tree should follow the branch from Upper Elevation Balancing to Equalization. I had incorrectly changed the date used when adding the carryover functionality.<br><br>MC, 20170511: The IsYearDemandVariabilityAndRunCycle4 condition will never be met because the rule does not execute in Run Cycle 4 due to the Execution Constraints<br><br>TP, 10/17/2017: Only allow out year to be set by this rule<br><br>MC, 20171102: This rule was changed by Tony to only operate on out years after the addition of two new rules that set WY1 only; I added IF-ELSE version to only set Release flag if NOT in EQ from UEB";
    BEGIN

      BREAKPOINT BEFORE_EXEC TRUE;
    DESCRIPTION          "In August or September start month with UEBT for outyear";
      IF_STATEMENT (( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) ) AND "TierIs"( "Upper", @"t", FALSE )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", FALSE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) )
 THEN
  ( GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) ) - $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "DateToCheckEOWYElevation"( @"t", FALSE ) )]
 ELSE
  IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "Mead.Pool Elevation" [@"24:00:00 December 31, Current Year"] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Current Year"] ) ) >= 1075.00000000 "ft" )
  THEN
   "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ELSE
   "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", FALSE ) )
  ENDIF COMMENTED_BY "Determine which branch of UEBT to follow"
 ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue...";

          DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", FALSE ), FALSE )) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 0.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      ELSE
            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set Equalization Release Volume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) for out years when the Release Tier is Equalization. It also calculates and sets the Controlling Equalization Condition slot, which indicates the equalization condition that dictated the volume to be released.<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume; PowellData.ControllingEqualizationCondition<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( "GetRunCycleIndex"(  ) == 3.00000000 AND ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) AND $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] == 0.00000000 ) COMMENTED_BY "This rule only executes in Run Cycle 3; at the Start Timestep in September or in any August; with a <br>timestep more than 2 away from the model run finish; and if the rule has not already fired successfully <br>for the timestep and only sets volumes in out years- sc 02/02/11;TP 08/20/2014; MC, 20170511; TP <br>10/17/2017  <br>";
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      BREAKPOINT BEFORE_EXEC TRUE;
      IF_STATEMENT (( "MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND "TierIs"( "Equalization", @"t", FALSE ) ) COMMENTED_BY "Outyears") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "MaxItem"( { GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , 8230000.00000000 "acre-feet" } );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", FALSE ) );

            $ "PowellData.ReleaseVolumeSetFlag" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 1.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Preliminary Set Out Year Release Volume To 8.23MAF";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) AND @"t + 2" <= @"Finish Timestep";
    NOTES                "AUTHOR, DATE: SC, 03/25/2011<br>MC, 20160728: Changed the local variable &quot;watYearIndex&quot; name to &quot;waterYearNumber&quot; for consistency with the rule Set Powell Outflow; make a function to do the calculation?; added the setting of Powell.Outflow values for testing with new carryover functionality<br>MC, 20170405: Can add use of user-defined function GetWaterYearNumber in calculation of local varaible waterYearNumber";
    BEGIN

      WITH_STATEMENT (NUMERIC waterYearNumber = ( "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF ) COMMENTED_BY "See notes on this calculation in Preliminarily Set Navajo Outflow to Desired Base Flow") DO
            WITH_STATEMENT (NUMERIC AvailablePowellWater = ( IF ( "GetMonth"( @"Start Timestep" ) == 9.00000000 )
 THEN
  $ "Powell.Storage" [@"t - 1"]
 ELSE
  $ "Powell.Storage" [@"t + 1"]
 ENDIF COMMENTED_BY "MC, 20170510: I don't understand the timesteps used for the <br>below condition" + FOR ( DATETIME date IN "WaterYearDatesByGroup"( waterYearNumber ) ) STAT_SUM
  "FlowToVolume"( $ "Powell.Inflow" [date], date )
 ENDFOR ) COMMENTED_BY "This is added to check that in years when Powell might go very low, the model won't bomb out <br>when setting the preliminary release when Powell is low. TP 1/22/2013<br>") DO
            WITH_STATEMENT (DATETIME WY_EndOfCalendarYearDate = "Dec31ofYear"( "OffsetDate"( "RelativeEOWYDate"( @"Start Timestep" ), waterYearNumber - 1.00000000, "1 years" ) )) DO
            WITH_STATEMENT (NUMERIC VolumeToRelease = "Min"( "MaxItem"( { 8230.00000000 "1000 acre-feet" , "Min"( 8230.00000000 "1000 acre-feet", $ "PowellData.PowellMonthlyReleaseTable" ["AnnualTotal", "NumColumns"( $ "PowellData.PowellMonthlyReleaseTable" ) - 2.00000000] ) COMMENTED_BY "Ensure release enough so Powell doesn't exceed max pool elevation" , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" [WY_EndOfCalendarYearDate] ) COMMENTED_BY "User input minimum annual release volume" } ), AvailablePowellWater )) DO
            IF_STATEMENT (NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", WY_EndOfCalendarYearDate )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" [WY_EndOfCalendarYearDate] := VolumeToRelease;

      END_IF_STATEMENT;

          INACTIVE    DESCRIPTION          "Set Powell.Outflow values based on preliminary Target Annual Release Volume";
      IF_STATEMENT (NOT IsNaN $ "Powell.Outflow" ["RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 AND @"t" == @"Start Timestep" )
 THEN
  waterYearNumber
 ELSE
  waterYearNumber - 1.00000000
 ENDIF ) )]) THEN
            FOREACH (LIST dateRelease IN "GetPowellReleasesCorrectedForBypass"( "Sort"( "GetPowellMonthlyReleases_v2"( "WaterYearDatesByGroup"( waterYearNumber ), VolumeToRelease ) ) )) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Set Release Tier";
    DESCRIPTION          "DESCRIPTION: This rule fires at the Start Timestep and in August timesteps to set the Powell Release tier, as well as preliminarily setting the Upper Elevation Balancing Branch and Controlling Equalization Condition values to 999<br><br>SLOTS SET: PowellData.ReleaseTier; PowellData.UpperElevBalBranch; PowellData.ControllingEqualizationCondition<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND ( "StartMonthIsSeptember"(  ) OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination";
    BEGIN

    INACTIVE    DESCRIPTION          "Model needs to set the teir for the current year if at the start timestep, regardless of month. - sc 02/02/11";
      IF_STATEMENT (@"t" == @"Start Timestep" AND IsNaN $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "PowellReleaseTier"( $ "PowellToMeadData.AugEOYPowellPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )], "RelativeEOWYDate"( @"t" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

      BREAKPOINT BEFORE_EXEC TRUE;
    DESCRIPTION          "Model needs to set the teir for the following water year if current timestep is August. - sc 02/02/11";
      IF_STATEMENT ("MonthIs"( { "August" } ) OR "StartMonthIsSeptember"(  ) AND @"t + 2" IN "WaterYearDatesByGroup"( 2.00000000 ) AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) )) THEN
            WITH_STATEMENT (NUMERIC Carryover = NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] )) DO
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - Carryover )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( IF ( @"t" == @"Start Timestep" )
 THEN
  $ "PowellToMeadData.AugEOYPowellPEProjection" ["DateToCheckJan1Elevation"( @"t + 2", TRUE )]
 ELSE
  EffectivePoolElevation
 ENDIF, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "The model will set the tier for the third year of the model run (second out year)";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 3.00000000 ) AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Third out year of the model run";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 4.00000000 ) AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Fourth out year of model run";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 5.00000000 ) AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "Fifth out year of model run if it exists in the forecast";
      IF_STATEMENT ("MonthIs"( { "August" } ) AND @"t + 2" IN "WaterYearDatesByGroup"( 6.00000000 ) AND NOT "IsInput"( $ "PowellData.ReleaseTier", "Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) ) )) THEN
            WITH_STATEMENT (NUMERIC EffectivePoolElevation = "StorageToElevation"( % "Powell", $ "Powell.Storage" [@"24:00:00 December 31, Current Year"] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [@"24:00:00 December 31, Next Year"] ) )) DO
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := "PowellReleaseTier"( EffectivePoolElevation, "RelativeEOWYDate"( @"t + 2" ) );

            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t + 2" ) )] := 999.00000000;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Set WY1 ReleaseVolume";
    DESCRIPTION          "DESCRIPTION: This rule sets the Target Annual Release Volume (TARV) for the first WY for any release Tier designation. It also calculates and sets the Controlling Equalization Condition slot, which indicates the condition that dictated the volume to be released based on which Tier has been set. <br><br>SLOTS SET: Some combination of the following - PowellData.TargetAnnualReleaseVolume; PowellData.ControllingEqualizationCondition; PowellData.UpperElevBalBranch<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( "GetRunCycleIndex"(  ) == 3.00000000 AND @"t" == @"Start Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) COMMENTED_BY "This rule only executes in Run Cycle 3; at the Start Timestep for only the first WY;  and if the rule has <br>not already fired successfully for the timestep - sc 02/02/11;TP 08/20/2014; MC, 20170511; TP <br>10/13/2017  <br>";
    NOTES                "AUTHOR, DATE: Unknown<br><br>TP: 20171017: Added and set the rule to only set the first water year.";
    BEGIN

      IF_STATEMENT (( @"t" == @"Start Timestep" AND "TierIs"( "Equalization", @"t", TRUE ) AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) ) COMMENTED_BY "Initial water year, in an Equalization Condition in Start Year <br>") THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) , 8230000.00000000 "acre-feet" } );

            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep in Run Cycle 3 with UEBT in Start Year";
      IF_STATEMENT (@"t" == @"Start Timestep" AND ( "GetRunCycleIndex"(  ) == 3.00000000 OR "IsYearDemandVariabilityAndRunCycle4"( @"t" ) ) AND "TierIs"( "Upper", @"t", TRUE ) AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := WITH DATETIME meadProjectionDate = IF ( @"t" <= @"September 30" )
 THEN
  @"24:00:00 December 31, Previous Year"
 ELSE
  @"24:00:00 December 31, Current Year"
 ENDIF DO
  IF ( "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" ["DateToCheckEOWYElevation"( @"t", TRUE )] ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) ) > "EqLevel"( "DateToCheckEOWYElevation"( @"t", TRUE ) ) OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.30000000 ) )
  THEN
   GET @INDEX 0.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) )
  ELSE
   IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" [meadProjectionDate] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) ) >= 1075.00000000 "ft" OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND NOT $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.20000000 ) )
   THEN
    "Max"( "B1_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ELSE
    "Max"( "B2_Branch_UpperBalancingTierVolume"( "DateToCheckEOWYElevation"( @"t", TRUE ) ), NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) )
   ENDIF COMMENTED_BY "Determine which branch of UEBT to follow"
  ENDIF COMMENTED_BY "Check EOWY Powell Elevation.  If above equalization level then go to equalization teir calculation.  If not, continue..."
 ENDWITH;

          DESCRIPTION          "Set Upper Elevation Balancing branch, and, if necessary, Release Tier and <br>Controlling Equalization Condition";
      WITH_STATEMENT (NUMERIC upperElevBranch = IF ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) )
 THEN
  $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]
 ELSE
  "UpperElevationBalancingBranchCalculation"( "DateToCheckEOWYElevation"( @"t", TRUE ), TRUE )
 ENDIF) DO
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := upperElevBranch;

            IF_STATEMENT (upperElevBranch == 1.30000000) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 0.00000000;

            IF_STATEMENT (NOT "IsInput"( $ "PowellData.ControllingEqualizationCondition", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := GET @INDEX 1.00000000 FROM "EqualizationTierCalculationForRelease"( "DateToCheckEOWYElevation"( @"t", TRUE ) );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep with Mid-Elevation tier in initial water year";
      IF_STATEMENT (@"t" == @"Start Timestep" AND "TierIs"( "Mid", @"t", TRUE ) AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Max"( IF ( "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "PowellToMeadData.AugEOYMeadPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["DateToCheckJan1Elevation"( @"t", TRUE )] ) ) >= 1025.00000000 "ft" )
 THEN
  7480.00000000 "1000 acre-ft"
 ELSE
  8230.00000000 "1000 acre-ft"
 ENDIF, NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"Start Timestep" ) )] ) );

      END_IF_STATEMENT;

    DESCRIPTION          "For Start Timestep with Lower Balancing Release Tier in initial water year";
      IF_STATEMENT (@"t" == @"Start Timestep" AND "TierIs"( "Lower", @"t", TRUE ) AND NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "Min"( "Max"( "EqualizationReleaseWithCarryover"( "RelativeEOWYDate"( @"t" ) ), $ "PowellData.LowerTierMinAnnualRelease" [] ), $ "PowellData.LowerTierMaxAnnualRelease" [] );

      END_IF_STATEMENT;

    END;

    RULE                 "Set WY1 Release Tier";
    DESCRIPTION          "DESCRIPTION: This rule fires at the Start Timestep and in August timesteps to set the Powell Release tier, as well as preliminarily setting the Upper Elevation Balancing Branch and Controlling Equalization Condition values to 999, for the First Water Year<br><br>SLOTS SET: PowellData.ReleaseTier; PowellData.UpperElevBalBranch; PowellData.ControllingEqualizationCondition<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination<br>TP, 20171017: Added this rule and only allow it to execute in the start timestep for the first water year";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND @"t" == @"Start Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: SC, 02/02/2011<br>MC, 20160802: Added EffectivePoolElevation variable for incorporating unreleased carryover volume into the release tier determination<br>TP, 20171017: Added this rule and only allow it to execute in the start timestep for the first water year";
    BEGIN

    DESCRIPTION          "Model needs to set the teir for the current year if at the start timestep, regardless of month. - sc 02/02/11";
      IF_STATEMENT (@"t" == @"Start Timestep" AND IsNaN $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ReleaseTier" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "PowellReleaseTier"( $ "PowellToMeadData.AugEOYPowellPEProjection" ["DateToCheckJan1Elevation"( @"t", TRUE )], "RelativeEOWYDate"( @"t" ) );

            IF_STATEMENT (IsNaN $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

            IF_STATEMENT (IsNaN $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )]) THEN
            $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := 999.00000000;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Preliminary Set WY1 Release Volume To 8.23MAF";
    DESCRIPTION          "DESCRIPTION: This rule preliminarily sets outflows from Powell in order to evaluate the projections of Powell and Mead elevations used for tierthe  selection calculation.  It sets the release volume to 8.23 MAF unless doing so will cause the model to fail by overfilling Powell.  In that case it sets the annual release volumes to the amount needed to just keep Powell below its max elevation.  The rule fires on the first timestep of run cycle 3 and should allow the whole model to solve for this preliminary condition.  Subsequent rules will then calculate the appropriate tier values for each water year in the run and then set the releases from Powell on a monthly basis. - sc 03/25/11<br><br>SLOTS SET: PowellData.TargetAnnualReleaseVolume<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 3.00000000 AND @"t" == @"Start Timestep" AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: SC, 03/25/2011<br>MC, 20160908: Previously added SumFlowsToVolume(...) to MaxItem; added IF-ELSE to deal with October when no previous WY release would have occurred";
    BEGIN

      IF_STATEMENT (NOT "IsInput"( $ "PowellData.TargetAnnualReleaseVolume", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) )) THEN
            $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] := "MaxItem"( { 8230.00000000 "1000 acre-feet" , "Min"( "CalcReleaseForMaxPoolElevation"( "WaterYearDatesByGroup"( 1.00000000 ) ), $ "PowellData.PowellMonthlyReleaseTable" ["AnnualTotal", "NumColumns"( $ "PowellData.PowellMonthlyReleaseTable" ) - 2.00000000] ) COMMENTED_BY "Ensure enough water released so Powell does not exceed max pool elevation" , NaNToZero ( $ "PowellData.UserInput_MinAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] ) COMMENTED_BY "User input min annual volume was added to allow overriding automatic determination" , IF ( "GetMonth"( @"t" ) != 10.00000000 )
 THEN
  "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( @"t", "MonthsSinceEOWY"( @"t" ), "-1 months" ), @"Start Timestep - 1" )
 ELSE
  0.00000000 "acre-foot"
 ENDIF COMMENTED_BY "Ensure TARV is not less than volume already released in water year" } );

      END_IF_STATEMENT;

    END;

    RULE                 "Set Powell Outflow";
    DESCRIPTION          "DESCRIPTION: In most months, interpolate values from the monthly release table using the current value of annual release volume. In August and September the annual release volume has already been set for the subsequent water year, so use the previous water year's annual volume. <br><br>SLOTS SET: Powell.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 3.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "August" } ) ) AND @"t + 2" <= @"Finish Timestep";
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      BREAKPOINT BEFORE_EXEC TRUE;
      IF_STATEMENT (@"t" == @"Start Timestep" AND NOT IsNaN $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )]) THEN
            WITH_STATEMENT (LIST PowellOutflowsAndCarryover = "GetPowellReleasesCorrectedForBypass"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( 1.00000000 ) ) )) DO
          DESCRIPTION          "Set the outflow for the initial water year, checking for the necessity of bypass based on pool elevations";
      FOREACH (LIST dateRelease IN PowellOutflowsAndCarryover) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

            WITH_STATEMENT (NUMERIC iterMax = ( LENGTH PowellOutflowsAndCarryover ) - 1.00000000) DO
            WITH_STATEMENT (DATETIME CarryoverYear = "OffsetDate"( "Dec31ofYear"( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH PowellOutflowsAndCarryover ) - 1.00000000 FROM PowellOutflowsAndCarryover ), 12.00000000, "1 Months" )) DO
            $ "PowellToMeadData.CarryoverVolume" [CarryoverYear] := "Max"( "Floor"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH PowellOutflowsAndCarryover ) - 1.00000000 FROM PowellOutflowsAndCarryover, 1.00000000 "acre-feet" ), 0.00000000 "acre-feet" );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      WITH_STATEMENT (NUMERIC waterYearNumber = ( "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF ) COMMENTED_BY "Calculate water year number for outyears") DO
            WITH_STATEMENT (DATETIME WaterYear = "Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
            IF_STATEMENT ("IsInput"( $ "PowellData.TargetAnnualReleaseVolume", WaterYear )) THEN
            FOREACH (LIST dateRelease IN "Sort"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

      ELSE
            IF_STATEMENT (( NOT IsNaN $ "PowellData.TargetAnnualReleaseVolume" [WaterYear] ) COMMENTED_BY "TARV for waterYearNumber has been set" AND ( NOT IsNaN $ "Powell.Outflow" ["RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( IF ( ( "GetMonth"( @"Start Timestep" ) > 9.00000000 AND @"t" == @"Start Timestep" ) COMMENTED_BY "in StartTimestep>Sep" )
 THEN
  waterYearNumber
 ELSE
  ( waterYearNumber - 1.00000000 ) COMMENTED_BY "in StartTimestep<=Sep OR non-StartTimestep August"
 ENDIF ) )] ) COMMENTED_BY "Outflow for Sep 30 of the current or prior water year is set (either by rule or as input)<br>MC, 20170510: I don't understand the necessity of this condition") THEN
            WITH_STATEMENT (LIST PowellOutflowsAndCarryover = "GetPowellReleasesCorrectedForBypass"( "GetPowellMonthlyReleases"( "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
          DESCRIPTION          "Set the monthly Powell Releases for the Water Year <br>";
      FOREACH (LIST dateRelease IN PowellOutflowsAndCarryover) DO
            $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM dateRelease] := GET @INDEX 1.00000000 FROM dateRelease;

      ENDFOREACH;

          DESCRIPTION          "If there is carryover volume in the last element of the PowellOutflowsAndCarryover List, then <br>add that to the next Water Year to be released in the next water year.  <br>";
      WITH_STATEMENT (DATETIME CarryoverYear = "Dec31ofYear"( WaterYear + 1.00000000 "year" )) DO
            $ "PowellToMeadData.CarryoverVolume" [CarryoverYear] := "Max"( "Floor"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH PowellOutflowsAndCarryover ) - 1.00000000 FROM PowellOutflowsAndCarryover, 1.00000000 "acre-feet" ), 0.00000000 "acre-feet" );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

  END;

  POLICY_GROUP   "Navajo";
  DESCRIPTION    "The main goals of the operations of Navajo Reservoir are to benefit the environmental needs of the San Juan River, the irrigators downstream of Navajo Reservoir, the diversion of NIIP water from Navajo Reservoir, and other municipal and industrial uses throughout the San Juan Basin. The environmental requirements are detailed in Flow Recommendations for the San Juan River, May 1999 (1999 Flow Recommendations) prepared by the San Juan River Basin Recovery Implementation Program (SJRIP). A general overview of the 1999 Flow Recommendations from Chapter 8 of the document includes: <br>?         Flows greater than 10,000 cfs during spring runoff must flow for a minimum of 5 days between March 1 and July 31 in 20% of the years with a maximum interval of 11 years. <br>?         Flows greater than 8,000 cfs during spring runoff must flow for a minimum of 10 days between March 1 and July 31 in 33% of years with a maximum interval of 7 years. <br>?         Flows greater than 5,000 cfs during spring runoff must flow for a minimum of 21 days between March 1 and July 31 in 50% of the years with a maximum interval of 5 years. <br>?         Flows greater than 2,500 cfs during spring runoff must flow for a minimum of 10 days between March 1 and July 31 in 80% of the years with a maximum interval of 3 years. <br>?         Peak flows must occur within 5 days of the historic mean peak date of May 31 (based on modeling for the period 1929 ? 1993). <br>?         Weekly target base flows are 500 cfs but range between 500 and 1,000 cfs where the actual target flow is the average of the weekly base flow at three of four stream flow gaging stations on the San Juan River below Navajo in accordance with the Biological Opinion. <br>?         Flood control releases will be handled as high magnitude, short duration spikes and releases when the flood control rules require except the release shall not occur earlier than September 1 unless necessary for protection of life and property. <br>The operations at Navajo Reservoir call for a spring peak flow to occur between April and July and base flow operations to occur the rest of the year. The spring peak is determined using the flow chart in Figure 8.1 of the 1999 Flow Recommendations document. The date of the spring peak release is determined by the flow from the Animas River downstream of Navajo Reservoir and is within the specified time range of the 1999 Flow Recommendations. <br>During base operations there is a weekly minimum flow target of an average of 500 cfs at each of four gaging stations downstream of the confluence with the Animas River: Farmington, Shiprock, Four Corners, and Bluff. The target flow range at each of the four gages is between 500 and 1,000 cfs; the modeled flows depend on the hydrologic conditions in the basin and the local inflows between Navajo Reservoir and the gaging stations. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Fall Peak Release ";
    DESCRIPTION          "DESCRIPTION: This Rule Uses the already set pool elevations for Navajo from the prevoius rule and uses the October Pool elevation to check if the elevation is above 6,065 ft.  If the volume at the beginning of October is above 6,065, then increase the September release so the pool elevation at the beginning of October is 6,065.  The reason we are looking at the October pool elevation is in the rare event that October is Wet, then the pool elevation in September will allow for the high flows in October to result in a Pool Elevation of 6,065 heading into the Winter months.  If we use the September Pool elevation and don' t release enough the system might have to release more the next spring than needed. <br><br>This rule only fires in months after the Spring Peak Release cannot be set (July - September) and only after the model has the opportunity to set outflows from Navajo at the maximum 1,000 cfs per day for the months of July - September. <br><br>SLOTS SET: Navajo.Outflow[September, Current Year]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonth"( @"t" ) >= 7.00000000 AND "GetMonth"( @"t" ) <= 9.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: TP 9/13/2012<br><br>MC, 20170502: The description written by Tony suggests the rule is targeting an end of October pool elevation, but the rule is setting the September outflow to lead to a beginning of October (end of September) target pool elevation";
    BEGIN

    DESCRIPTION          "Retrieve the storage at the beginning of October (end of September)";
      WITH_STATEMENT (NUMERIC NavajoOctoberStorage = "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [@"24:00:00 September Max DayOfMonth, Current Year"] )) DO
          DESCRIPTION          "Retrieve the end of water year target pool elevation";
      WITH_STATEMENT (NUMERIC TargetPEStorage = "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" ["Dec31ofYear"( @"24:00:00 September Max DayOfMonth, Current Year" )] )) DO
          DESCRIPTION          "If the October storage is greater than that of the target, increase the release to meet the target";
      IF_STATEMENT (NavajoOctoberStorage > TargetPEStorage) THEN
            $ "Navajo.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"] := $ "Navajo.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"] + "VolumeToFlow"( NavajoOctoberStorage - TargetPEStorage, @"24:00:00 September Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Dam Protection Flood Control";
    DESCRIPTION          "DESCRIPTION: If Navajo Pool Elevation is in threat of going above the maximum pool elevation (6,082 ft) then release the amount of outflow to reduce the pool elevation to the max pool elevation. This rule is a flood protection rule. <br><br>SLOTS SET: Navajo.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      WITH_STATEMENT (DATETIME EndOfWY = @"24:00:00 September 30, Current Year") DO
            IF_STATEMENT ($ "Navajo.Pool Elevation" [] > $ "NavajoData.PostDamProtectionPE" []) THEN
          DESCRIPTION          "Calculate list of lists of form &lcub;Modified outflow, Outflow volume modification, Volume released to achieve dam protection&rcub;";
      WITH_STATEMENT (LIST damProtectionNavajo = "NavajoAboveMaxPEOperations"(  )) DO
          DESCRIPTION          "Update outflow";
      $ "Navajo.Outflow" [] := GET @INDEX 0.00000000 FROM damProtectionNavajo;

            $ "NavajoData.DamProtectionFlag" [@"t"] := 1.00000000;

          DESCRIPTION          "Store annual volume released for dam protection";
      $ "NavajoData.VolumeReleasedForDamProtection" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM damProtectionNavajo;

            IF_STATEMENT (@"t" < EndOfWY) THEN
            WITH_STATEMENT (NUMERIC lessRelFromNav = GET @INDEX 2.00000000 FROM damProtectionNavajo) DO
          DESCRIPTION          "Reduce remaining WY outflows to account for released volume, but not below base release value";
      FOREACH (DATETIME date IN @"t + 1" TO EndOfWY) DO
            WITH_STATEMENT (NUMERIC numberOfMonths = "GetMonth"( EndOfWY ) - "GetMonth"( @"t" )) DO
            $ "Navajo.Outflow" [date] := "Max"( $ "Navajo.Outflow" [date] - "VolumeToFlow"( lessRelFromNav / numberOfMonths, date ), $ "NavajoData.BaseRelease" [] );

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Reduce Outflow and Diversions if Navajo is below Min Level";
    DESCRIPTION          "DESCRIPTION: If the reservoir is in threat of going below 5,990 ft, apply shortage sharing to the outflow of Navajo and NIIP diversions.<br><br>SLOTS SET: Navajo.Outflow; NavajoIndianIrrigationProjectNIIP.Diversion<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "IsLowFlowAdjustmentNecessary"(  ) AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" );
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (LIST DateDiffR IN "DetermineLowFlowsatNavajo"(  )) DO
            $ "Navajo.Outflow" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 1.00000000 FROM DateDiffR;

            $ "NavajoIndianIrrigationProjectNIIP.Diversion" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 2.00000000 FROM DateDiffR;

          INACTIVE      $ "NavajoIndianIrrigationProjectNIIP.Depletion Requested" [GET @INDEX 0.00000000 FROM DateDiffR] := GET @INDEX 2.00000000 FROM DateDiffR;

      ENDFOREACH;

    END;

    RULE                 "SumNavajoOutflowtoMonthly";
    DESCRIPTION          "DESCRIPTION: Solve Navajo Daily outflow on the data object and set the monthly outflow on the Reservoir simulation object.  This rule only on the start timestep and in March timesteps.<br><br>SLOTS SET: Navajo.Outflow<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: TP 9/30/2015";
    BEGIN

      WITH_STATEMENT (DATETIME endDate = IF ( "GetMonth"( @"t" ) < 3.00000000 )
 THEN
  @"24:00:00 February Max DayOfMonth, Current Year"
 ELSE
  @"24:00:00 February Max DayOfMonth, Current Year + 12"
 ENDIF) DO
            IF_STATEMENT (@"t" == @"Start Timestep") THEN
            FOREACH (DATETIME date IN "GetDates"( @"t", endDate, "1 months" )) DO
            $ "Navajo.Outflow" [date] := "VolumeToFlow"( "DetermineNavajoMonthlyFlowVolumeNew"( date ), date );

      ENDFOREACH;

      END_IF_STATEMENT;

            IF_STATEMENT ("MonthIs"( { "March" } )) THEN
            FOREACH (DATETIME date IN "GetDates"( @"24:00:00 March 31, Current Year", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 months" )) DO
            $ "Navajo.Outflow" [date] := "VolumeToFlow"( "DetermineNavajoMonthlyFlowVolumeNew"( date ), date );

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "March through July Daily Release";
    DESCRIPTION          "DESCRIPTION: Calculate the Daily release given the policy constraints outlined by the Flow recomendation document from the San Juan Flow Recommendations and recommendations on the policy by the Bureau of Reclation.  These flows will be based on the policy from the release level calculated and not the actual available water. That will come after a scale value is applied. <br><br>SLOT SET: NavajoData.MarchThruJulyDaily<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 3.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP, 20120531 (?)";
    BEGIN

    DESCRIPTION          "Determine the Daily Releases from Navajo Reservoir for the release level and spring peak volumes";
      FOREACH (DATETIME date IN "GetDates"( @"t - 1", @"24:00:00 February Max DayOfMonth, Current Year + 12", "1 days" )) DO
            $ "NavajoData.MarchThruJulyDaily" [date] := "DailyOutflowsForNavajo"( date, $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoData.NoseLevel" ["Dec31ofYear"( @"t" )], $ "NavajoData.ExcessOfRelease" ["Dec31ofYear"( @"t" )] );

      ENDFOREACH;

    END;

    RULE                 "DetermineReleaseLevelValues";
    DESCRIPTION          "DESCRIPTION: Determine the release level (0-4) for the spring release based on the calculated available flow to achieve the EOWYTargetPE. The determination of level is based on the values in the SpringPeakReleaseLevels table.  The Rule sets the Release Level, the Spring Peak Release Volume, the Nose Level (If Applicable), the Nose Volume (if Applicable), and the excess of a Nose Volume (If Applicable).<br><br>SLOTS SET: NavajoData.ReleaseLevel; NavajoData.SpringPeakRelease; NavajoData.NoseLevel; NavajoData.SpringPeakNose; NavajoData.ExcessOfRelease<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND ( @"t" == @"Start Timestep" OR "MonthIs"( { "March" } ) ) AND NOT "HasRuleFiredSuccessfully"( "Current Rule" );
    NOTES                "AUTHOR, DATE: TP, 5/31/2012 (?)<br><br>MC, 20170717: Reorganized rule to combine the cases for Month == March and (Start Timestep AND Month < Oct)";
    BEGIN

    DESCRIPTION          "Determines the Release Levels, Nose Levels and Volumes to be set to meet the Navajo Target elevation <br>for the end of September.  This rule only executes on the start timestep or in March.";
      WITH_STATEMENT (LIST EoWYRelLevel = "DetermineNavajoEoWYReleaseLevel"( "Dec31ofYear"( @"t" ) )) DO
            IF_STATEMENT (@"t" == @"Start Timestep" AND "GetMonth"( @"t" ) >= 10.00000000) THEN
          DESCRIPTION          "Set all values to zero";
      IF_STATEMENT (NOT "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( @"t" ) )) THEN
            $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )] := 0.00000000;

      END_IF_STATEMENT;

            $ "NavajoData.SpringPeakRelease" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

            $ "NavajoData.NoseLevel" ["Dec31ofYear"( @"t" )] := 0.00000000;

            $ "NavajoData.SpringPeakNose" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

            $ "NavajoData.ExcessOfRelease" ["Dec31ofYear"( @"t" )] := 0.00000000 "acre-ft";

      ELSE
          DESCRIPTION          "Month is March or (Start Timestep AND Month < 10) <br>";
      IF_STATEMENT (NOT "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( @"t" ) )) THEN
            $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( @"t" )] := GET @INDEX 1.00000000 FROM EoWYRelLevel;

      END_IF_STATEMENT;

            $ "NavajoData.SpringPeakRelease" ["Dec31ofYear"( @"t" )] := GET @INDEX 0.00000000 FROM EoWYRelLevel;

            $ "NavajoData.NoseLevel" ["Dec31ofYear"( @"t" )] := GET @INDEX 2.00000000 FROM EoWYRelLevel;

            $ "NavajoData.SpringPeakNose" ["Dec31ofYear"( @"t" )] := GET @INDEX 3.00000000 FROM EoWYRelLevel;

            $ "NavajoData.ExcessOfRelease" ["Dec31ofYear"( @"t" )] := GET @INDEX 4.00000000 FROM EoWYRelLevel;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Preliminarily Set Navajo Outflow to Desired Base Flow";
    DESCRIPTION          "DESCRIPTION: This rule sets the outflow from Navajo for the current timestep to the end of February of the next year. The outflow is set to the greater of the Base Release or what is necessary, together with the Animas contribution, to meet the downstream flow targets. Doing this allows Navajo to solve for the Available water calculation.<br><br>SLOTS SET: Navajo.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "For the current timestep to the End of February of the next year, set the outflow from Navajo to the greater of <br>the Base Release from Navajo or what is necessary to meet the downstream flow targets with the Animas <br>contribution. Doing this will allow Navajo to solve for the Available water calculation";
      WITH_STATEMENT (NUMERIC waterYearNumber = ( "GetYear"( @"t" ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF ) COMMENTED_BY "This variable is not used in the body, so delete it.") DO
            WITH_STATEMENT (LIST dateList = IF ( @"t" == @"Start Timestep" AND NOT "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( @"t" ) ) AND "GetMonth"( @"t" ) < 10.00000000 )
 THEN
  @"t" TO "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12 Month", @"Finish Timestep" )
 ELSE
  @"t" TO "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12 Month", @"Finish Timestep" )
 ENDIF COMMENTED_BY "MC, 20170508: Both conditions use the same calculation?") DO
            FOREACH (DATETIME date IN dateList) DO
            $ "Navajo.Outflow" [date] := "Max"( $ "NavajoData.MinTargetBaseflow" [] - $ "AnimasRiverInflow.Animas_at_Durango" [date], $ "NavajoData.BaseRelease" [] );

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "SetNavajoDiversions";
    DESCRIPTION          "DESCRIPTION: Sets the NIIPDiversions Requested slot, the SanJuanBelowNavajo.TotalDiversion Slot, and NIIP.Fractional Return Flow Slot values based on user input.  The Fractional Inflow values will at some point need to be changed in the future to the value that would be the fractional return flow. This rule fires so that the input values in the NavajoData.NIIPAnnualRequest and NavajoData.SJDownstreamDiversions slots  are assigned if input is provided for those two slots. <br><br>SLOTS SET: SanJuanBelowNavajo.Total Diversion; NavajoIndianIrrigationProjectNIIP.Fractional Return Flow; NavajoIndianIrrigationProjectNIIP.Diversion; Azotea Tunnel.Diversion<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND @"t" == @"Start Timestep";
    NOTES                "AUTHOR, DATE: TP, 8/5/2012 (?)";
    BEGIN

    DESCRIPTION          "Set the Diversions for the NIIP and Azotea Tunnel to the Diversion Requests so that the <br>appropriate water is allowed to be diverted.  For the Azotea Tunnel diversion make sure a <br>minimum flow is left in the Upper San Juan River above Navajo. ";
      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (IsNaN $ "SanJuanBelowNavajo.Total Diversion" [date]) THEN
            $ "SanJuanBelowNavajo.Total Diversion" [date] := $ "NavajoData.SJDownstreamDepletions" [date, 0.00000000];

      END_IF_STATEMENT;

            $ "NavajoIndianIrrigationProjectNIIP.Fractional Return Flow" [date] := 0.00000000;

            $ "NavajoIndianIrrigationProjectNIIP.Diversion" [date] := $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [date];

            $ "Azotea Tunnel.Diversion" [date] := "Min"( $ "Azotea Tunnel.Diversion Requested" [date], "Max"( $ "UpperSanJuan.Inflow" [date] - $ "NavajoData.UpperSanJuanMinFlow" [date, 0.00000000], 0.00000000 "cfs" ) );

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Flaming Gorge ";
  DESCRIPTION    "The operations of Flaming Gorge Reservoir meet the requirements detailed in the 2006 Record of Decision for the Operation of Flaming Gorge Dam Final Environmental Impact Statement (2006 ROD) that were designed to achieve the authorized purposes of the CRSP Act while addressing environmental requirements. The 2006 ROD outlines the operational guidelines of Flaming Gorge and implements, to the extent possible, recommendations to assist in the recovery of four endangered fish species, outlined in the 2000 Flow and Temperature Recommendations for Endangered Fish in the Green River Downstream of Flaming Gorge Dam (2000 Flow and Temperature Recommendations). This report outlines the peak flow magnitudes, high flow duration, and outflow temperature recommendations for three reaches of the Green River: <br>Reach 1<br>?Reach 1? is 65 river miles long, beginning at Flaming Gorge Dam and ending at the confluence of the Green and Yampa Rivers. Flaming Gorge Dam releases comprise the primary component of Green River flow in this reach. The peak flow requirements for Reach 1 are compiled in Table 5.4 of the 2000 Flow and Temperature Recommendations and are summarized below. <br>?         Peak flow magnitude of at least 4,600 cfs each year and at least 8,600 cfs in wet years (0 to 10% Exceedance) <br>  <br>?         The peak flow period should coincide with the spring peak and immediate post peak flows of the Yampa River <br>  <br>?         Reach 1 Mean baseflow magnitude requirements are established for five hydrologic year classifications: <br>o   Wet (0-10% Exceedance): between 1,800 and 2,700 cfs <br>o   Moderately Wet (10-30% Exceedance): between 1,500 and 2,600 cfs <br>o   Average (30-70% Exceedance): between 800 and 2,200 cfs <br>o   Moderately Dry (70-90% Exceedance): between 800 and 1,300 cfs <br>o   Dry (90-100% Exceedance): between 800 and 1,000 cfs <br>  <br>?         The daily rate of decline from the peak flow period is limited as follows: <br>o   For Wet and Moderately Wet years (0-30% Exceedance):  approximately 1,000 cfs /day <br>o   For Average years (30-70% Exceedance):  approximately 500 cfs /day <br>o   For Dry and Moderately Dry years (70-100% Exceedance):  approximately 350 cfs /day <br>Where applicable, the historic unregulated Flaming Gorge inflow between the years of 1963 and 1996 are used to determine the respective percent exceedances for the criteria established. Hydrologic classifications and percent exceedances for the Yampa River basin are established using the historic record from 1922 to 1996. This is the case for all reaches. <br>Reach 2<br>?Reach 2? is 99 river miles in length and extends from the confluence of the Green and Yampa Rivers to the confluence of the Green and White Rivers. In this reach, Flaming Gorge Dam releases and the Yampa River are the primary contributors to river flow. Flow recommendations establish peak flow and sustained high flow requirements at the Green River at the Jensen, Utah USGS stream gage for five hydrologic year types. These requirements are established in Table 5.5 of the 2000 Flow and Temperature Recommendations and are summarized below. <br>?         Peak releases should coincide with the annual spring peak and immediate post peak of the Yampa River <br>  <br>?         Peak flow magnitude recommendations measured on the Green River at Jensen are established for five hydrologic classifications as follows: <br>o   Wet (0-10% Exceedance): at least 26,400 cfs <br>o   Moderately Wet (10-30% Exceedance): at least 20,300 cfs <br>o   Average (30-70% Exceedance): at least 18,600 cfs in one of two average years and 8,300 cfs in other average years <br>o   Dry and Moderately Dry (70-100% Exceedance): at least 8,300 cfs <br>  <br>?         Recommendations for the duration of peak flows are established as follows: <br>o   Wet (0-10% Exceedance): maintain at least 22,700 cfs for at least 2 weeks and 18,600 cfs for at least 4 weeks <br>o   Moderately Wet (10-30% Exceedance): maintain at least 18,600 cfs for at least 2 weeks <br>o   Average (30-70% Exceedance): maintain at least 18,600 cfs for at least 2 weeks in 1 of 4 average years <br>o   Moderately Dry (70-90% Exceedance): maintain at least 8,300 cfs for at least 1 week <br>o   Dry (90-98% Exceedance): maintain at least 8,300 cfs for at least 2 days <br>o   Extremely Dry (98-100% Exceedance): no flow duration recommendations <br>  <br>?         Mean baseflow magnitudes are recommended for each hydrologic classification as follows: <br>o   Wet (0-10% Exceedance): between 2,800 and 3,000 cfs <br>o   Moderately Wet (10-30% Exceedance): between 2,400 and 2,800 cfs <br>o   Average (30-70% Exceedance): between 1,500 and 2,400 cfs <br>o   Moderately Dry (70-90% Exceedance): between 1,100 and 1,500 cfs <br>o   Dry (90-100% Exceedance): between 900 and 1,100 cfs <br>  <br>?         Rate of decline from the peak flow is regulated by the rate of decline in Reach 1 and the rate of decline of the Yampa River <br>  <br>?         Baseflow variation should be consistent with the variability observed in the pre-dam era <br>Reach 3 <br>?Reach 3? is 246 river miles in length and extends from the confluence of the White and Green River to the confluence of the Green and Colorado Rivers. Flow in this reach is supplemented primarily by tributary flow from the White, Duchesne, Price, and San Rafael Rivers as well as releases from Flaming Gorge Dam and flow from the Yampa River. Although independent flow recommendations were outlined for Reach 3 as well as Reaches 1 and 2, it is assumed that meeting the flow requirements in Reach 1 and Reach 2 will result in the flow requirements for Reach 3 being adequately met. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Calculate Daily Jensen Flows";
    DESCRIPTION          "DESCRIPTION: Calculates the daily Jensen flow using daily FG releases and daily Yampa flows with the assumption that FG releases are lagged one day.<br><br>SLOTS SET: KNN_MTOM.JensenDaily<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Calculates the daily Jensen flow using daily FG releases and daily Yampa flows with the assumption <br>that FG releases are lagged one day.";
      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.JensenDaily" [date] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  $ "KNN_MTOM.FlamingGorgeDaily" [date]
 ELSE
  $ "KNN_MTOM.FlamingGorgeDaily" [date - 1.00000000 "day"]
 ENDIF + IF ( "GetMonth"( @"t" ) >= 4.00000000 AND "GetMonth"( @"t" ) <= 7.00000000 )
 THEN
  $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date]
 ELSE
  $ "YampaRiverInflow.Yampa_at_Deerlodge" []
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Fill Daily Flaming Gorge Releases for Months Outside of April-July";
    DESCRIPTION          "DESCRIPTION: Sets the daily FG releases and daily Yampa releases to the average monthly FG outflow and Yampa gaged outflow, respectively.<br><br>SLOTS SET: KNN_MTOM.FlamingGorgeDaily; KNN_MTOM.YampaDailyDeerlodgeDepleted<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "MonthIs"( { "April" , "May" , "June" , "July" , "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [date] := $ "FlamingGorge.Outflow" [];

            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date] := $ "YampaRiverInflow.Yampa_at_Deerlodge" [];

      ENDFOREACH;

    END;

    RULE                 "Sum Daily Flaming Gorge Release Schedule to Monthly";
    DESCRIPTION          "DESCRIPTION: Sets FG outflow to the aggregated daily release volume.<br><br>SLOTS SET: FlamingGorge.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "April" , "May" , "June" , "July" , "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      WITH_STATEMENT (NUMERIC SummedDaily = "VolumeToFlow"( "SumFlowsToVolume"( $ "KNN_MTOM.FlamingGorgeDaily", @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ), @"t" )) DO
            WITH_STATEMENT (NUMERIC OutflowToMaxPE = "SolveOutflow"( % "FlamingGorge", $ "FlamingGorge.Inflow" [], "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ), $ "FlamingGorge.Storage" [@"t - 1"], @"t" )) DO
            $ "FlamingGorge.Outflow" [] := "Max"( SummedDaily, OutflowToMaxPE );

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Min Flow in Extremely Dry Years with Low Storage";
    DESCRIPTION          "DESCRIPTION: This rule sets the Flaming Gorge outflow to the absolute min release if the pool elevation is below the min release trigger and the base flow hydrologic class is Dry; also sets a flag indicating the low release conditions occurred.<br><br>SLOTS SET: FlamingGorge.Outflow; FlamingGorgeData.LowReleaseFlag<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "MonthIs"( { "May" , "June" , "July" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      IF_STATEMENT ($ "FlamingGorge.Pool Elevation" [] < $ "FlamingGorgeData.MinReleaseTrigger" [] AND $ "KNN_MTOM.BaseFlowHClass" [] == 0.00000000) THEN
            $ "FlamingGorge.Outflow" [] := $ "FlamingGorgeData.AbsoluteMinRelease" [];

            $ "FlamingGorgeData.LowReleaseFlag" [] := 1.00000000;

      END_IF_STATEMENT;

    END;

    RULE                 "Adjust Daily for August Base Flow";
    DESCRIPTION          "DESCRIPTION: Determines if July releases were at power plant or bypass capacity during moderately wet and wet hydrology and ramps down in August.  Rule sets August releases at steady base flows or downramps from high FG releases through July 31st to August base flows. August ramp down is contained in the Flow Recommendations. <br><br>SLOTS SET: KNN_MTOM.FlamingGorgeDaily; KNN_MTOM.YampaDailyDeerlodgeDepleted<br><br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "August" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      WITH_STATEMENT (NUMERIC RampRate = $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs") DO
            WITH_STATEMENT (NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] - $ "FlamingGorge.Outflow" [] ) / RampRate * 1.00000000 "day" )) DO
            IF_STATEMENT ($ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] > $ "FlamingGorge.Outflow" [] + RampRate) THEN
          DESCRIPTION          "Multiple days of downramping required";
      FOREACH (LIST AugustFlows IN "AugustDownRamp"(  )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [GET @INDEX 0.00000000 FROM AugustFlows] := GET @INDEX 1.00000000 FROM AugustFlows;

      ENDFOREACH;

      ELSE
          DESCRIPTION          "Downramping not required";
      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [date] := "GetFGBaseFlowMagnitude"(  );

      ENDFOREACH;

      END_IF_STATEMENT;

          DESCRIPTION          "Set Daily Deerlodge Depleted";
      FOREACH (DATETIME date IN "GetDates"( @"24:00:00 Current Month Min DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year", "1 days" )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [date] := $ "YampaRiverInflow.Yampa_at_Deerlodge" [];

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Set Flaming Gorge Daily April to July Schedule";
    DESCRIPTION          "DESCRIPTION: This rule is called at Start Timesteps between April & August and for each April of the run period to make the daily date and flow list (through the functions) and assign them to the data object<br><br>SLOTS SET: KNN_MTOM.FlamingGorgeDaily<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "April" , "May" , "June" , "July" , "August" } ) AND @"t" == @"Start Timestep" OR "MonthIs"( { "April" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>MC, 20170503: Should the rule fire for an August Start Timestep? No consideration for August date in rule, but will use July 1 based on logic";
    BEGIN

    DESCRIPTION          "Rule fires in Apr, May, June, July and August to set the daily release schedule which is put together in the function. It must fire each month to know where the reservoir was at at the end of the previous month and update the remaining daily schedule as far as base flow <br>goes. Daily releases are not changed back in time and only replace the rest of the remaining daily schedule through July 31. -tv 8.17.12";
      FOREACH (LIST dateandflow IN "MakeDailyFlamingGorgeReleaseDateandFlowList"( IF ( "MonthIs"( { "April" } ) )
 THEN
  @"24:00:00 April 1, Current Year"
 ELSE
  IF ( "MonthIs"( { "May" } ) )
  THEN
   @"24:00:00 May 1, Current Year"
  ELSE
   IF ( "MonthIs"( { "June" } ) )
   THEN
    @"24:00:00 June 1, Current Year"
   ELSE
    @"24:00:00 July 1, Current Year" COMMENTED_BY "July or August"
   ENDIF
  ENDIF
 ENDIF )) DO
            $ "KNN_MTOM.FlamingGorgeDaily" [GET @INDEX 0.00000000 FROM dateandflow] := GET @INDEX 1.00000000 FROM dateandflow;

      ENDFOREACH;

    END;

    RULE                 "Release to Meet ULDE";
    DESCRIPTION          "DESCRIPTION: For March or April, set the outflow to be the value necessary to meet the May 1 ULDE<br><br>SLOTS SET: FlamingGorge.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "March" , "April" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      $ "FlamingGorge.Outflow" [] := "GetFGBaseFlowMagnitudeUnconstrained"(  );

    END;

    RULE                 "Base Flow Operations";
    DESCRIPTION          "DESCRIPTION: Sets the base flows for all months except March and April.  Base flow releases are set so reservoir stays below maximum pool elevation (6039 ft), release is above minimum flows or stays within the base flow range based on the hydrologic classification.<br><br>SLOTS SET: FlamingGorge.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT "MonthIs"( { "March" , "April" } ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20180312: Modified this rule between the FEB18 and MAR18 MTOM runs to only call the function GetFGBaseFlowMagnitude, which was also modified to ensure the outflow is sufficient to keep the reservoir below the Max PE";
    BEGIN

    INACTIVE      $ "FlamingGorge.Outflow" [] := IF ( $ "FlamingGorge.Storage" [@"t - 1"] >= "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ) )
 THEN
  "Max"( ( ( ( $ "FlamingGorge.Storage" [@"t - 1"] - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ) + "SumFlowsToVolume"( $ "FlamingGorge.Inflow", @"t", @"t" ) ) - "EstimateEvaporation"( % "FlamingGorge", $ "FlamingGorge.Storage" [@"t - 1"], $ "FlamingGorge.Storage" [@"t - 1"], @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ) ) / 1.00000000 "month" ) COMMENTED_BY "Outflow to achieve Max pool elevation", $ "FlamingGorgeData.MinFlow" [] )
 ELSE
  "GetFGBaseFlowMagnitude"(  )
 ENDIF;

      $ "FlamingGorge.Outflow" [] := "GetFGBaseFlowMagnitude"(  );

    END;

    RULE                 "Spring Flow Hydrologic Classification";
    DESCRIPTION          "DESCRIPTION: Sets the spring flow classification based on ROD percent exceedance ranges.  Hydrologic class exceedance percentile limits: Dry (0) = 100-90%; ModDry (1) = 90-70%; Average (2) = 70-30%; ModWet (3) = 30-10%; Wet (4) = 10-0%<br><br>SLOTS SET: KNN_MTOM.SpringHClass<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetMonthAsString"( @"t" ) IN { "March" , "April" , "May" , "June" , "July" , "August" } AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Sets the spring hydrologic classification based on the forecasted April-July volume.";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "KNN_MTOM.SpringHClass" []) THEN
            $ "KNN_MTOM.SpringHClass" [] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    DESCRIPTION          "Yampa";
      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "FlamingGorgeData.YampaAprJulPercentExceedance" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "FlamingGorgeData.YampaHClass" []) THEN
            $ "FlamingGorgeData.YampaHClass" [] := index;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Base Flow Hydrologic Classification";
    DESCRIPTION          "DESCRIPTION: Sets the base flow classification based on ROD percent exceedance ranges.  Under ROD compliance, base flows can change one classification higher or lower depending upon the previous month's observed unregulated inflow. Hydrologic class exceedance percentile limits: Dry (0) = 100-90%; ModDry (1) = 90-70%; Average (2) = 70-30%; ModWet (3) = 30-10%; Wet (4) = 10-0%<br><br>SLOTS SET: KNN_MTOM.BaseFlowHClass<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (NUMERIC index IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 }) DO
            IF_STATEMENT ($ "KNN_MTOM.AprJulPercentExceedanceBaseFlow" [] <= $ "FlamingGorgeData.HydrologicClassPercentileLimits" [index, 1.00000000]) THEN
            IF_STATEMENT (IsNaN $ "KNN_MTOM.BaseFlowHClass" []) THEN
            $ "KNN_MTOM.BaseFlowHClass" [] := IF ( @"t" == "RunStartDate"(  ) )
 THEN
  index
 ELSE
  IF ( ( index > $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] + 1.00000000 ) COMMENTED_BY "If index is at least 2 greater than previous timestep's, then increase" )
  THEN
   $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] + 1.00000000
  ELSE
   IF ( ( index < $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] - 1.00000000 ) COMMENTED_BY "If index is at least 2 less than previous timestep's, then decrease" )
   THEN
    $ "KNN_MTOM.BaseFlowHClass" [@"t - 1"] - 1.00000000
   ELSE
    index
   ENDIF
  ENDIF
 ENDIF;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Calc Percent Exceedance";
    DESCRIPTION          "DESCRIPTION: Calculate the percent exceedance for the April-July Base and Spring flow volumes, and the Yampa April-July flow volume<br><br>SLOTS SET: KNN_MTOM.AprJulPercentExceedanceSpringFlow; KNN_MTOM.AprJulPercentExceedanceBaseFlow; FlamingGorgeData.YampaAprJulPercentExceedance<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170725: Modified some date calculations to remove use of CONCAT in favor of more recent RW capabilities (e.g., &quot;Previous Year&quot;)<br>MC, 20160913: Calculate exceedance percentages for April to July Spring and Base flow volumes; is the UpdateHistoricRecord flag still necessary after the changes to the HDB DMI and automating the HydrologicClassificationEndYear dates?";
    BEGIN

      $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.AprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
 THEN
  @"24:00:00 December Max DayOfMonth, Previous Year" COMMENTED_BY "Use the end of the previous year"
 ELSE
  "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ) ) ) COMMENTED_BY "Use the end year specified on the KNN_MTOM object"
 ENDIF ), $ "KNN_MTOM.AprJulVolSpringFlow" [] );

      $ "KNN_MTOM.AprJulPercentExceedanceBaseFlow" [] := 1.00000000 - "PercentRank"( "GetSlotVals"( $ "FlamingGorgeData.AprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
 THEN
  @"24:00:00 December Max DayOfMonth, Previous Year" COMMENTED_BY "Use the end of the previous year"
 ELSE
  "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ) ) ) COMMENTED_BY "Use the end year specified on the KNN_MTOM object"
 ENDIF ), $ "KNN_MTOM.AprJulVolBaseFlow" [] );

      $ "FlamingGorgeData.YampaAprJulPercentExceedance" [] := 1.00000000 - "PercentRank"( IF ( "GetYear"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) < "GetYear"( "RunStartDate"(  ) ) - 1.00000000 AND $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
 THEN
  IF ( "GetYear"( @"t" ) == "GetYear"( "RunStartDate"(  ) ) )
  THEN
   "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) ) ) COMMENTED_BY "Use Hydrologic Classification Start and End years"
  ELSE
   WITH LIST futureData = "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "RunStartDate"(  ) ) ), @"24:00:00 December Max DayOfMonth, Previous Year" ) COMMENTED_BY "From end of Start Year to end of year prior to current year" DO
    FOR ( NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH futureData ) - 1.00000000, 1.00000000 ) ) WITH LIST result = "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) ) ) DO
     ( APPEND GET @INDEX i FROM futureData ONTO result ) COMMENTED_BY "Add futureData values to YampaHydrologicClassification data list values"
    ENDFOR
   ENDWITH
  ENDIF
 ELSE
  "GetSlotVals"( $ "FlamingGorgeData.YampaAprJulVolAnnual", "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ) ) ), IF ( $ "KNN_MTOM.UpdateHistoricRecord" [] == 1.00000000 )
  THEN
   @"24:00:00 December Max DayOfMonth, Previous Year" COMMENTED_BY "Use end of previous year"
  ELSE
   "GetDate"( "December 31, " CONCAT "GetYearAsString"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ) ) ) COMMENTED_BY "Use year specified as HydrologicClassificationEndYear"
  ENDIF )
 ENDIF, $ "FlamingGorgeData.YampaAprJulVol" [] );

    END;

    RULE                 "Initilize PE and Daily Rules";
    DESCRIPTION          "DESCRIPTION: Sets the slot FlamingGorgeData.ManualSpill for the current timestep to 0.00 acre-feet/month, and the slot KNN_MTOM.FlamingGorgeDaily[Dec 31, 2013] = FlamingGorge.Outflow[Jan 31, 2014]<br><br>SLOTS SET: FlamingGorgeData.ManualSpill; KNN_MTOM.FlamingGorgeDaily";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unkinown<br><br>MC, 20160913: The rule name is misleading, there is no PE explicitly initialized; should the dates be hardcoded?<br>MC, 20170508: I don't see this rule doing anything useful. Can it be removed? Rule Set Flaming Gorge Daily April to July Schedule sets KNN_MTOM.FlamingGorgeDaily slot for period between Start Timestep and July 31, Current Year";
    BEGIN

      $ "FlamingGorgeData.ManualSpill" [] := 0.00000000 "acre-ft/month";

      $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 December 31, 2013"] := $ "FlamingGorge.Outflow" [@"24:00:00 January Max DayOfMonth, 2014"];

    END;

    RULE                 "Calc April July Volume Monthly";
    DESCRIPTION          "DESCRIPTION: This rule calculates the April-July unregulated inflow volumes for Flaming Gorge for Base Flow and Spring Flow purposes, and the April-July volume for the Yampa at the Deerlodge gage.<br><br>SLOTS SET: KNN_MTOM.AprJulSpringFlow; KNN_MTOM.AprJulVolBaseFlow; FlamingGorgeData.YampaAprJulVol<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "For spring flow operations we are interested in the april - july volume for the upcoming season beginning in January through April. <br>The May official forecast is used for spring operations through July. <br>This number is needed in march to determine releases to meet the ULDE. ";
      $ "KNN_MTOM.AprJulVolSpringFlow" [] := "SpringFlowA-JVolumeUpdate"(  );

    DESCRIPTION          "For base flow operations we are interested in the available observed volume in the previous april - july season. <br>Since base flow may actually start in june calculate this number then. <br>The August - December base flows use the observed A-J volume.  Jan-Feb use forecast A-J and ULDE and base flow range.<br>";
      $ "KNN_MTOM.AprJulVolBaseFlow" [] := "BaseFlowA-JVolumeUpdate"(  );

      $ "FlamingGorgeData.YampaAprJulVol" [] := IF ( "MonthIs"( { "April" } ) )
 THEN
  "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"t", @"t + 3" )
 ELSE
  IF ( @"t" == "RunStartDate"(  ) )
  THEN
   0.00000000 "acre-ft"
  ELSE
   $ "FlamingGorgeData.YampaAprJulVol" [@"t - 1"]
  ENDIF
 ENDIF;

    END;

    RULE                 "Update Historic Record";
    DESCRIPTION          "DESCRIPTION: If necessary (i.e., the April-July Volume is NaN), the most recent April to July volume (previous year if earlier than August, current year if later) is calculated. <br><br>SLOTS SET: FlamingGorgeData.YampaAprJulVolAnnual; FlamingGorgeData.AprJulVolAnnual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "MonthIs"( { "August" } ) OR @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unkinown<br><br>MC, 20160913: Was this made unnecessary by automating the HydrologicClassificationEndYear slots for FG and Yampa?";
    BEGIN

    DESCRIPTION          "If earlier than August, use the previous year's data";
      IF_STATEMENT ("GetMonth"( @"t" ) < 8.00000000) THEN
            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] := "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Previous Year", @"24:00:00 July Max DayOfMonth, Previous Year" );

      END_IF_STATEMENT;

            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Previous Year"] := "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Previous Year", @"24:00:00 July Max DayOfMonth, Previous Year" );

      END_IF_STATEMENT;

      ELSE
          DESCRIPTION          "Othewise, use the current year";
      IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.YampaAprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] := "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

            IF_STATEMENT (NaNToZero ( $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] ) == 0.00000000 "acre-ft") THEN
            $ "FlamingGorgeData.AprJulVolAnnual" [@"24:00:00 December Max DayOfMonth, Current Year"] := "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" );

      END_IF_STATEMENT;

      END_IF_STATEMENT;

    END;

    RULE                 "Calculate April To July Volume Annual Slot";
    DESCRIPTION          "DESCRIPTION: Calculates the Flaming Gorge Unregulated Inflow and Yampa River at Deerlodge April to July volumes for each year between the classification Start Year and End Year<br><br>SLOTS SET: FlamingGorgeData.AprJulVolAnnual; FlamingGorgeData.YampaAprJulVolAnnual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == "RunStartDate"(  ) AND "GetRunCycleIndex"(  ) == 2.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20160908: Changed variable reference in calculation of FlamingGorgeData.YampaAprJulVolAnnual from KNN_MTOM.HistoricYampaAtDeerlodge to YampaRiverInflow.Yampa_at_Deerlodge; ";
    BEGIN

    DESCRIPTION          "Flaming Gorge Unregulated Apr-Jul Inflow volume";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationStartYear" [] ), "NumberToDate"( $ "KNN_MTOM.FGHydrologicClassificationEndYear" [] ), "1 years" )) DO
            $ "FlamingGorgeData.AprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", "GetDate"( "April, " CONCAT "GetYearAsString"( time ) ), "GetDate"( "July, " CONCAT "GetYearAsString"( time ) ) );

      ENDFOREACH;

    DESCRIPTION          "Yampa Apr-Jul Inflow Vol";
      FOREACH (DATETIME time IN "GetDates"( "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationStartYear" [] ), "NumberToDate"( $ "KNN_MTOM.YampaHydrologicClassificationEndYear" [] ), "1 years" )) DO
            $ "FlamingGorgeData.YampaAprJulVolAnnual" ["GetDate"( "December 31, " CONCAT "GetYearAsString"( time ) )] := "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", "GetDate"( "April, " CONCAT "GetYearAsString"( time ) ), "GetDate"( "July, " CONCAT "GetYearAsString"( time ) ) );

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "KNN Yampa Daily Flow";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Peak Yampa Flow";
    DESCRIPTION          "DESCRIPTION: This rule finds the maximum daily flow of Deerlodge Depleted for the current year's KNN StartMonth to EndMonth period (currently April - July)<br><br>SLOTS SET: KNN_MTOM.YampaPeakDailyFlow[Current year]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      $ "KNN_MTOM.YampaPeakDailyFlow" [@"24:00:00 December Max DayOfMonth, Current Year"] := "MaxItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", "GetDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ) CONCAT " 1, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ), "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ( ( GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ", current year" ) ), "." ) ) CONCAT "," ) CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( @"24:00:00 December Max DayOfMonth, Current Year" ), "." ) ) ) );

    END;

    RULE                 "Set Yampa Daily Depleted Flow at Deerlodge For Second Stage Disagg";
    DESCRIPTION          "DESCRIPTION: Sets the daily depleted flow value at Deerlodge equal to the daily natural flow after the second stage disaggregation<br><br>SLOTS SET: KNN_MTOM.YampaDailyDeerlodgeDepleted[Current year's spring period]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "HasRuleFiredSuccessfully"( "Set Yampa Daily Natural - Second Stage Disagg" ) AND "GetRunCycleIndex"(  ) == 1.00000000 AND $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )];

      ENDFOREACH;

    END;

    RULE                 "Set Yampa Daily Natural - Second Stage Disagg";
    DESCRIPTION          "DESCRIPTION: This rule calculates a daily flow rate for each day in the current year's period based on the volume proportion for the day in the historical index year's monthly volume<br><br>SLOTS SET: KNN_MTOM.YampaDailyNatural[Current year's dates]; KNN_MTOM.SecondStageDisaggFlag[Current year]<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "MinItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) ) < 0.00000000 "cfs" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := ( ( GET @INDEX i FROM "GetSecondStageProportionVector"(  ) ) * "GetCurrentMonthlyNaturalInflow"( GET @INDEX i FROM "GetCurrentYearDailyList"(  ) ) ) COMMENTED_BY "Multiply daily proportion by monthly volume" / 24.00000000 "hour";

      ENDFOREACH;

    DESCRIPTION          "Set flag for current year";
      $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] := 1.00000000;

    END;

    RULE                 "Set Yampa Daily Depleted Flow at Deerlodge";
    DESCRIPTION          "DESCRIPTION: Sets the daily depleted flow value at Deerlodge equal to the daily natural flow<br><br>SLOTS SET: KNN_MTOM.YampaDailyDeerlodgeDepleted[Current year's spring period]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetCurrentYearDailyList"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyDeerlodgeDepleted" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )];

      ENDFOREACH;

    END;

    RULE                 "Set Yampa Daily Natural Flow from KNN - primary disagg";
    DESCRIPTION          "DESCRIPTION: This function calcluates a daily flow vector that represents a disaggregation of the current spring volume based on the daily volume proportions of the historical index year and sets the second stage disaggregation slot flag to a value of 0.<br><br>SLOTS SET: KNN_MTOM.YampaDailyNatural[Current year's spring period]; KNN_MTOM.SecondStageDisaggFlag[Dec 31, Current Year]<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Loop over the historical proportions vector and multiply the current year's spring volume by each daily proportion";
      FOREACH (NUMERIC i IN "GetNumbers"( 0.00000000, ( LENGTH "GetProportionVector"(  ) ) - 1.00000000, 1.00000000 )) DO
            $ "KNN_MTOM.YampaDailyNatural" [GET @INDEX i FROM "GetCurrentYearDailyList"(  )] := "VolumeToFlow"( ( GET @INDEX i FROM "GetProportionVector"(  ) ) * "GetSpringVolume"(  ), GET @INDEX i FROM "GetCurrentYearDailyList"(  ) );

      ENDFOREACH;

    DESCRIPTION          "Initialize the flag to 0";
      $ "KNN_MTOM.SecondStageDisaggFlag" [@"24:00:00 December Max DayOfMonth, Current Year"] := 0.00000000;

    END;

    RULE                 "Set Index Year- Ratios";
    DESCRIPTION          "DESCRIPTION: This rule sets the value of the index year chosen from the K nearest neighbors of the current year. The K nearest neighbors are calculated based on the seasonal volume proportions of each month in the April-July period<br><br>SLOTS SET: KNN_MTOM.IndexYear[Current Year]<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"] := WITH NUMERIC seasonalVol = "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) DO
  "ChooseIndexYearRatio"( "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 April Max DayOfMonth, Current Year"], @"24:00:00 April Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 May Max DayOfMonth, Current Year"], @"24:00:00 May Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 June Max DayOfMonth, Current Year"], @"24:00:00 June Max DayOfMonth, Current Year" ) / seasonalVol, "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [@"24:00:00 July Max DayOfMonth, Current Year"], @"24:00:00 July Max DayOfMonth, Current Year" ) / seasonalVol ) COMMENTED_BY "Select the index year"
 ENDWITH;

    END;

    RULE                 "Set Random Number";
    DESCRIPTION          "DESCRIPTION: This rule generates a random number between 0 and 1 used in selecting a nearest neighbor historical year to use as an index year<br><br>SLOTS SET: KNN_MTOM.randomNum[Current Year]";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT ( ( @"t" == @"24:00:00 March Max DayOfMonth, Current Year" ) OR ( @"t" == @"Start Timestep" ) AND "GetRunCycleIndex"(  ) == 1.00000000 ) COMMENTED_BY "Changing the month this rule executes will change the random number generated <br>by the funciton call as the random number index is different for every month/year.<br>";
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      $ "KNN_MTOM.randomNum" [@"24:00:00 December Max DayOfMonth, Current Year"] := "Random"( "GetRandSeed"(  ), $ "KNN_MTOM.randomIndex" [], 0.00000000 );

    END;

  END;

  POLICY_GROUP   "Aspinall Ops";
  DESCRIPTION    "The April 2012 Record of Decision for the Aspinall Unit Operations Final Environmental Impact Statement (2012 Aspinall ROD) and the decree quantifying the Federal Reserved Water Right for the Black Canyon of the Gunnison specify the spring peak outflow hydrograph and base flow for the rest of the year based on the hydrologic conditions upstream of Blue Mesa Reservoir, specifically the forecasted inflow to Blue Mesa Reservoir for April through July in the year of interest.  The 2012 Aspinall ROD provides specifications to avoid jeopardizing the continued existence of fish listed under the Endangered Species Act and to ensure the dam's operations do not result in the destruction or adverse modification of critical habitat in the Gunnison and Colorado rivers. <br><br>Data used to calculate the peak flow and duration targets are on the BlueMesaData object in the slots GunnisonDurationTargets, CanyonFlowCalcData, PeakFlowCalcData";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Release Control Indicator";
    DESCRIPTION          "DESCRIPTION: This rule determines which constraint dictated the Blue Mesa outflow by comparing the outflow to the outflows required to meet the various conditions<br><br>SLOTS SET: BlueMesaData.ReleaseControl<br><br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "AUTHOR, DATE: MC, 201707<br><br>MC, 20170906: Added calculations of NoReleaseStorage, SpillwayStorage, VolumeAboveSpillway, and ReleaseableVolumeRate and replaced maxPossibleOutflow with ReleaseableVolumeRate in indicator-setting conditional";
    BEGIN

      WITH_STATEMENT (NUMERIC MonthlyWhitewaterTarget = IF ( ( "GetMonth"( @"t" ) == 5.00000000 OR "GetMonth"( @"t" ) == 6.00000000 ) AND ( $ "BlueMesa.Storage" [@"t - 1"] + "FlowToVolume"( $ "BlueMesa.Inflow" [@"t"], @"t" ) > "ElevationToStorage"( % "BlueMesa", 7487.90000000 "feet" ) OR $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] < 3.00000000 ) )
 THEN
  FOR ( DATETIME date IN "GetDates"( "GetStartDayOfMonth"(  ), "GetEndDayOfMonth"(  ), "1 days" ) ) STAT_AVE
   $ "BlueMesaData.TargetDailyWhitewaterFlows" [date]
  ENDFOR
 ELSE
  $ "BlueMesaData.BaseCanyonTargetFlows" [@"t"]
 ENDIF) DO
            WITH_STATEMENT (NUMERIC MonthlyCanyonFlows = IF ( $ "BlueMesaData.MeetCanyonDecreeFlows" [] == 1.00000000 )
 THEN
  FOR ( DATETIME date IN "GetDates"( "GetStartDayOfMonth"(  ), "GetEndDayOfMonth"(  ), "1 days" ) ) STAT_AVE
   $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date]
  ENDFOR
 ELSE
  0.00000000 "acre-ft/month"
 ENDIF) DO
            WITH_STATEMENT (NUMERIC MeetDownstreamFlowTargets = "SolveBlueMesaReleaseForDownstreamTargets"( MonthlyWhitewaterTarget, @"t", MonthlyCanyonFlows )) DO
            WITH_STATEMENT (NUMERIC ReleaseToMeetBMMaxPE = "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MaximumPoolElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" )) DO
            WITH_STATEMENT (NUMERIC ReleaseToMeetBMTargetPE = "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), 0.00000000 "cfs" COMMENTED_BY "IF the reservoir is below MaxPoolElevation = 7,519.4 feet, the SolveOutflow function will calculate a negative outflow, this <br>prevents that from being included in solving the Blue Mesa Outflow TP 9/22/2015" )) DO
            WITH_STATEMENT (NUMERIC MaxReleaseToAvoidMinPE = WITH NUMERIC tunnelDiv = $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [@"t"] DO
  WITH NUMERIC WaterAvailToCanyon = "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPowerElevation" [] COMMENTED_BY "Input Minimum Pool Elevation on the Blue Mesa Data Object" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), % "BlueMesa" & "Inflow" [@"t"] ) DO
   WITH NUMERIC GainsAbvCrystal = $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [@"t"] + $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [@"t"] DO
    WITH NUMERIC GainsBMToGJ = GainsAbvCrystal + $ "GunnisonBelowCrystal:GunnisonNrGJ_Whitewater.Local Inflow" [@"t"] DO
     WITH NUMERIC flowLevel = $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] DO
      WITH NUMERIC WaterRigtsAtWW = $ "BlueMesaData.BaseCanyonTargetFlows" [@"t", flowLevel] DO
       "Max"( tunnelDiv + "MinItem"( { WaterAvailToCanyon , "MaxItem"( { WaterRigtsAtWW - GainsBMToGJ , $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"] - GainsAbvCrystal , 0.00000000 "cfs" } ) , IF ( $ "BlueMesa.Pool Elevation" [@"t - 1"] <= $ "BlueMesaData.MinimumPowerElevation" [] )
       THEN
        "Max"( 300.00000000 "cfs" - GainsAbvCrystal, 0.00000000 "cfs" )
       ELSE
        "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPowerElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) - tunnelDiv, 0.00000000 "cfs" )
       ENDIF } ), "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPowerElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), 0.00000000 "cfs" ) )
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH) DO
            WITH_STATEMENT (NUMERIC MaxReleaseToPreventCrystalOverflow = "SolveBlueMesaReleaseForCrystalReleaseTarget"( $ "BlueMesaData.CrystalMaxOutflow" [@"t"], @"t" )) DO
            WITH_STATEMENT (NUMERIC BMPoolElevWithNoRelease = "TableInterpolation"( $ "BlueMesa.Elevation Volume Table", 1.00000000, 0.00000000, $ "BlueMesa.Storage" [@"t - 1"] + "FlowToVolume"( $ "BlueMesa.Inflow" [@"t"], @"t" ), @"t" )) DO
            WITH_STATEMENT (NUMERIC NoReleaseStorage = "ElevationToStorage"( % "BlueMesa", BMPoolElevWithNoRelease ) COMMENTED_BY "Calculate storage volume without release") DO
            WITH_STATEMENT (NUMERIC SpillwayStorage = "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.SpillwayElevation" [] ) COMMENTED_BY "Calculate storage at spillway invert") DO
            WITH_STATEMENT (NUMERIC VolumeAboveSpillway = NoReleaseStorage - SpillwayStorage) DO
            WITH_STATEMENT (NUMERIC ReleaseableVolumeRate = VolumeAboveSpillway / 1.00000000 "month" + $ "BlueMesa.Maximum Controlled Release" [0.00000000, 0.00000000]) DO
            WITH_STATEMENT (NUMERIC maxPossibleOutflow = "TableInterpolation"( $ "BlueMesaData.BlueMesa_MaxOutflowTable", 0.00000000, 1.00000000, BMPoolElevWithNoRelease, @"t" )) DO
            WITH_STATEMENT (NUMERIC maxOutflowToBottom = "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MaxDeadPoolElevation" [] + 0.10000000 "feet" ) COMMENTED_BY "The minimum elevation is a tenth of a foot high to prevent the reservoir from failing from the <br>mass balance for the reservoir. TP 9/28/2015", "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" )) DO
            WITH_STATEMENT (NUMERIC TargetReleaseFromBM = "Max"( "MinItem"( { "MaxItem"( { MeetDownstreamFlowTargets , ReleaseToMeetBMTargetPE } ) , MaxReleaseToPreventCrystalOverflow , MaxReleaseToAvoidMinPE , ReleaseableVolumeRate COMMENTED_BY "Replaced maxPossibleOutflow with ReleaseableVolumeRate" , maxOutflowToBottom } ), ReleaseToMeetBMMaxPE COMMENTED_BY "Release necessary to prevent Flood Control" )) DO
            $ "BlueMesaData.ReleaseControl" [@"t"] := IF ( $ "BlueMesa.Outflow" [@"t"] == MeetDownstreamFlowTargets )
 THEN
  1.00000000
 ELSE
  IF ( $ "BlueMesa.Outflow" [@"t"] == ReleaseToMeetBMTargetPE )
  THEN
   2.00000000
  ELSE
   IF ( $ "BlueMesa.Outflow" [@"t"] == MaxReleaseToPreventCrystalOverflow )
   THEN
    3.00000000
   ELSE
    IF ( $ "BlueMesa.Outflow" [@"t"] == MaxReleaseToAvoidMinPE )
    THEN
     4.00000000
    ELSE
     IF ( $ "BlueMesa.Outflow" [@"t"] == ReleaseableVolumeRate )
     THEN
      5.00000000
     ELSE
      IF ( $ "BlueMesa.Outflow" [@"t"] == maxOutflowToBottom )
      THEN
       6.00000000
      ELSE
       IF ( $ "BlueMesa.Outflow" [@"t"] == ReleaseToMeetBMMaxPE )
       THEN
        7.00000000
       ELSE
        0.00000000
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Blue Mesa Operations";
    DESCRIPTION          "DESCRIPTION: This rule uses the function BlueMesaOutflowCalc to determine monthly releases from Blue Mesa Reservoir<br><br>SLOTS SET: BlueMesa.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "BlueMesa.Outflow" [] AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      $ "BlueMesa.Outflow" [] := "BlueMesaOutflowCalc"(  );

    END;

    RULE                 "Calculate May Release Volume";
    DESCRIPTION          "DESCRIPTION: Sets the Total May release volume by summing the daily flow requirements necessary to meet the 2012 ROD Flows for the Whitewater Gage and the Federal Reserve Water Right flows through the Black Canyon.  This rule also calculates the daily outflow from Blue Mesa necessary to meet those two flow requirements.  That data is written to the Blue Mesa Data object and is for informative purposes only.  TP 9/25/2015<br><br>SLOTS SET: BlueMesaData.MayReleaseVolume; BlueMesaData.TargetDailyOutflowFromBlueMesa<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170705: In calculation of MayReleaseVolume, conditional statement was IF (date < @&quot;Start Timestep&quot; AND NOT GetMonth(date) == 5.00), and was changed to just IF (date < @&quot;Start Timestep&quot;) because all dates being considered are in May, so second part of Boolean was never true and past outflows were not being used for May dates prior to Start Timestep<br><br>MC, 20170712: Added DateMin(..., @&quot;Finish Timestep&quot;) to calculation of BMD.TargetDailyOutflowFromBlueMesa; without it, the final year of the run could not calculate completely, and the rule was finishing ineffectively meaning the MayReleaseVolume did not get populated for the final year of the run";
    BEGIN

      $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] := FOR ( DATETIME date IN "GetDates"( @"24:00:00 May 1, Current Year", @"24:00:00 May 31, Current Year", "1 days" ) ) STAT_AVE
  IF ( date < @"Start Timestep" AND ( NOT "GetMonth"( date ) == 5.00000000 ) COMMENTED_BY "MC, 20170725: This doesn't make sense because all dates being considered <br>are in May. Should current year May use the previously determined outflow, <br>or should all dates, whether prior to Start Timestep or not calculate outflow?  <br>" )
  THEN
   $ "BlueMesa.Outflow" ["MaxDayOfMonth"( date )]
  ELSE
   "SolveBlueMesaReleaseForDownstreamTargets"( $ "BlueMesaData.TargetDailyWhitewaterFlows" [date], "MaxDayOfMonth"( date ), $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date] )
  ENDIF
 ENDFOR COMMENTED_BY "Calculate average daily flow in May" * 31.00000000 "day";

    DESCRIPTION          "Set daily flows for remainder of current year";
      FOREACH (DATETIME date IN "GetDates"( "DateMax"( @"24:00:00 January 1, Current Year", "MinDayOfMonth"( @"Start Timestep" ) ), "DateMin"( @"24:00:00 December 31, Current Year", @"Finish Timestep" ), "1 days" )) DO
            $ "BlueMesaData.TargetDailyOutflowFromBlueMesa" [date] := "Max"( "SolveBlueMesaReleaseForDownstreamTargets"( $ "BlueMesaData.TargetDailyWhitewaterFlows" [date], "MaxDayOfMonth"( date ), $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date] ), 0.00000000 "cfs" );

      ENDFOREACH;

    END;

    RULE                 "Annual Daily Black Canyon Flow Determination";
    DESCRIPTION          "DESCRIPTION: This rule calculates the preliminary daily flow targets for the flow through the Black Cayone that satisfies the Federal Reserve Water Right for the entire year of a model run.  The ramp up and down to the peak date are included.   This rule will set each day to either the ramp up or down value, the peak flow (as determined on the algorithm to satisfy the Water Right) or the base flow value for any day outside of this range for the Flow through the Black Canyon.  Though the model is monthly, these values are written to a daily slot on BlueMesaData that will be aggregated and converted to a monthly release from Blue Mesa Res in a subsequent rule (Blue Mesa Operations). - sc 12/27/10<br><br>SLOTS SET: BlueMesaData.TargetDailyBlackCanyonFlows<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Black Canyon Target Peak Flow";
      WITH_STATEMENT (NUMERIC peakCanyonFlow = $ "BlueMesaData.CanyonPeakFlowTarget" [@"24:00:00 December 31, Current Year"]) DO
          DESCRIPTION          "May Base Flow Value";
      WITH_STATEMENT (NUMERIC mayCanyonBaseFlow = $ "BlueMesaData.MinimumBlackCanyonFlow" [@"24:00:00 May 31, Current Year"]) DO
          DESCRIPTION          "Number of days to ramp up<br>Solve for x = no. days in &lcub;BaseFlow*(1+UpRate)^x >= PeakFlow&rcub;";
      WITH_STATEMENT (NUMERIC daysOfRampUp = "Ceiling"( "Ln"( peakCanyonFlow / mayCanyonBaseFlow, 0.00000000 ) / "Ln"( 1.00000000 + $ "BlueMesaData.CanyonRampUpRateToPeak" [], 0.00000000 ), 1.00000000 ) * 1.00000000 "day") DO
          DESCRIPTION          "Number of days to ramp down";
      WITH_STATEMENT (NUMERIC daysOfRampDown = "Ceiling"( "Ln"( mayCanyonBaseFlow / peakCanyonFlow, 0.00000000 ) / "Ln"( 1.00000000 - $ "BlueMesaData.CanyonRampDownRateFromPeak" [], 0.00000000 ), 1.00000000 ) * 1.00000000 "day") DO
          DESCRIPTION          "Calculate peak date, and dates on which to begin and end ramping";
      WITH_STATEMENT (DATETIME peakDate = "CompletePartialDate"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" )) DO
            WITH_STATEMENT (DATETIME startRampUpDate = peakDate - daysOfRampUp) DO
            WITH_STATEMENT (DATETIME endRampDownDate = peakDate + daysOfRampDown) DO
          DESCRIPTION          "Set daily flow rates for current calendar year";
      FOREACH (DATETIME date IN "GetDates"( "DateMax"( @"24:00:00 January 1, Current Year", "GetStartDayOfMonth"(  ) ), @"24:00:00 December 31, Current Year", "1 days" )) DO
            WITH_STATEMENT (NUMERIC baseFlow = $ "BlueMesaData.MinimumBlackCanyonFlow" [date]) DO
            $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date] := IF ( date >= @"April 1" AND date <= @"July 25" )
 THEN
  IF ( date >= startRampUpDate AND date < peakDate )
  THEN
   WITH NUMERIC nDaysUp = ( date - startRampUpDate + 1.00000000 "day" ) / 1.00000000 "day" DO
    baseFlow * ( 1.00000000 + $ "BlueMesaData.CanyonRampUpRateToPeak" [] ) ^ nDaysUp
   ENDWITH COMMENTED_BY "Flows during ramp up period"
  ELSE
   IF ( date == peakDate )
   THEN
    peakCanyonFlow
   ELSE
    IF ( date > peakDate AND date <= endRampDownDate - 1.00000000 "day" )
    THEN
     WITH NUMERIC nDaysDown = ( date - peakDate ) / 1.00000000 "day" DO
      peakCanyonFlow * ( 1.00000000 - $ "BlueMesaData.CanyonRampDownRateFromPeak" [] ) ^ nDaysDown
     ENDWITH COMMENTED_BY "Flows during ramp down period"
    ELSE
     baseFlow
    ENDIF
   ENDIF
  ENDIF
 ELSE
  baseFlow
 ENDIF;

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Annual Daily Whitewater Flow Determination";
    DESCRIPTION          "DESCRIPTION: This rule calculates the preliminary daily flow targets for the Whitewater Gage for the entire year of a model run. They are preliminary in that the ramp up and ramp down from the peak flow target are not included yet. This rule will set each day to either the shoulder flow, the peak flow (as determined on the Spring Peak And Duration Canyon Targets slot) or the base flow value for any day outside of this range for the Whitewater Gage. Though the model is monthly, these values are written to a daily slot on BlueMesaData.TargetDailyWhitewaterFlows that will be aggregated and converted to a monthly release from Blue Mesa Res in a subsequent rule (Blue Mesa Operations). <br><br>SLOTS SET: BlueMesaData.TargetDailyWhitewaterFlows<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20170705: Added BlueMesaData.WhitewaterOpsAssurance value to the peak and shoulder flows per Rick C.'s recommendation to improve probability of achieving ROD Whitewater targets. The daily flows are then averaged into the local variable MonthlyWhitewaterTarget in the function BlueMesaOutflowCalc<br><br>CF, 5/5/2017:  This rule was restructured so that new slots  Peak & ShoulderFlowDuration. The shoulder flow function was removed since shoulder/half-bank flow is now fixed by the ROD to 8,070. This value is stored in slot BlueMesaData.ShoulderFlowTarget. - CF 5/5/2017<br><br>TP/MC, 9/25/2015: This rule calculates the may peak flow target for the Whitewater Gage, the shoulder flow is set to 8,070 cfs as part of the 2012 ROD, the May Peak Flow Level which is a value between 0 adn 5 that is based on the 2012 ROD for the Aspinall Unit which is calculated with the Blue Mesa Unregulated Inflow for April through July.  The rule also determines the Black Canyon Peak flow that will meet the Federal Reserve Water Right and the April through July volume for Blue Mesa Reservoir unregulated inflow. This rule only fires on the first day of the year or first day of the run.";
    BEGIN

    DESCRIPTION          "ROD peak flow Target";
      WITH_STATEMENT (NUMERIC peakFlow = $ "BlueMesaData.WhitewaterPeakFlowTarget" [@"24:00:00 December 31, Current Year"]) DO
          DESCRIPTION          "ROD Shoulder Flow Target";
      WITH_STATEMENT (NUMERIC shoulderFlow = $ "BlueMesaData.HalfBankFlow" []) DO
          DESCRIPTION          "ROD Peak Flow Hydrologic Year classification,";
      WITH_STATEMENT (NUMERIC level = $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"]) DO
          DESCRIPTION          "Number of Days at Peak Flow based on the ROD Target";
      WITH_STATEMENT (NUMERIC daysOfPeak = $ "BlueMesaData.PeakFlowDuration" [@"24:00:00 December 31, Current Year"]) DO
            WITH_STATEMENT (NUMERIC daysOfShoulder = $ "BlueMesaData.ShoulderFlowDuration" [@"24:00:00 December 31, Current Year"]) DO
            WITH_STATEMENT (DATETIME peakDate = "CompletePartialDate"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ), @"24:00:00 December 31, Current Year" )) DO
            WITH_STATEMENT (DATETIME startShoulderFlowDate = peakDate - daysOfShoulder / 2.00000000) DO
            WITH_STATEMENT (DATETIME endShoulderDate = startShoulderFlowDate + daysOfShoulder - 1.00000000 "day") DO
            WITH_STATEMENT (DATETIME startPeakFlowDate = peakDate - daysOfPeak / 2.00000000) DO
            WITH_STATEMENT (DATETIME endPeakFlowDate = startPeakFlowDate + daysOfPeak - 1.00000000 "day") DO
            FOREACH (DATETIME date IN "GetDates"( "DateMax"( @"24:00:00 January 1, Current Year", "GetStartDayOfMonth"(  ) ), @"24:00:00 December 31, Current Year", "1 days" )) DO
            WITH_STATEMENT (NUMERIC baseFlow = $ "BlueMesaData.BaseCanyonTargetFlows" [date, level]) DO
            $ "BlueMesaData.TargetDailyWhitewaterFlows" [date] := IF ( date >= @"April 1" AND date <= @"July 25" )
 THEN
  IF ( date >= startShoulderFlowDate )
  THEN
   IF ( date >= startPeakFlowDate AND date <= endPeakFlowDate )
   THEN
    ( peakFlow + $ "BlueMesaData.WhitewaterOpsAssurance" [] ) COMMENTED_BY "This is the period of time to ramp up to the Peak flow, this is assuming that the ramp up will only <br>be for about one day, this can be edited if this logic needs to be more precise. TP 9/19/2015"
   ELSE
    IF ( date <= endShoulderDate )
    THEN
     $ "BlueMesaData.HalfBankFlow" [] + $ "BlueMesaData.WhitewaterOpsAssurance" []
    ELSE
     baseFlow
    ENDIF
   ENDIF
  ELSE
   baseFlow
  ENDIF
 ELSE
  baseFlow
 ENDIF;

      END_WITH_STATEMENT;

      ENDFOREACH;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Calculate Gunnison Flow Targets";
    DESCRIPTION          "DESCRIPTION: This rule calculates: <br>- The peak flow target for the Whitewater Gage. <br>- The hydrologic year classification which is a value between 0 (Dry) and 5 (Wet) that is based on the 2012 ROD which is calculated with the Blue Mesa Unregulated Inflow for April-July. <br>- The Black Canyon peak flow that will meet the Federal Reserve Water Right <br>- The April through July volume for Blue Mesa Reservoir unregulated inflow.  <br>- The WW peak and shoulder flow durations acording to the ROD.  <br><br>SLOTS SET: BlueMesaData.WWPeakFlowTarget; BlueMesaData.GunnisonHClass; BlueMesaData.CanyonPeakFlowTarget; BlueMesaData.BlueMesaAprilThroughJulyVolume <br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR "GetMonth"( @"t" ) == 1.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>TP/MC, 20150925: This rule calculates the may peak flow target for the Whitewater Gage, the shoulder flow is set to 8,070 cfs as part of the 2012 ROD, the May Peak Flow Level which is a value between 0 adn 5 that is based on the 2012 ROD for the Aspinall Unit which is calculated with the Blue Mesa Unregulated Inflow for April through July.  The rule also determines the Black Canyon Peak flow that will meet the Federal Reserve Water Right and the April through July volume for Blue Mesa Reservoir unregulated inflow. This rule only fires on the first day of the year or first day of the run.<br><br>CF, 5/5/2017: This rule and the accompanying functions were restructured so that AprilThoughJulyVolume and  Gunnison Hydroglogic year class (GunnisonHClass), previously called MayFlowLevel, are calculated only once and then passed as arguments to the functions rather than being recalculated by each function. The shoulder flow function was removed since shoulder/half-bank flow is now fixed by the ROD to 8,070. This value is stored in slot BlueMesaData.ShoulderFlowTarget. - The WW peak and shoulder flow durations are now calculated and set to seperate slots for reference by later rules. <br><br><br>";
    BEGIN

      WITH_STATEMENT (NUMERIC currentForecast = "SumFlowsToVolume"( $ "BlueMesaInflow.Unregulated", @"24:00:00 April 30, Current Year", @"24:00:00 July 31, Current Year" )) DO
            $ "BlueMesaData.BlueMesaAprilThroughJulyVolume" [@"24:00:00 December 31, Current Year"] := currentForecast;

            WITH_STATEMENT (NUMERIC HClass = "CalcGunnisonHClass"( currentForecast )) DO
            $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] := HClass;

            $ "BlueMesaData.WhitewaterPeakFlowTarget" [@"24:00:00 December 31, Current Year"] := "CalcGunnisonWWPeakFlowTarget"( HClass, currentForecast );

            $ "BlueMesaData.CanyonPeakFlowTarget" [@"24:00:00 December 31, Current Year"] := "CalcCanyonPeakFlowTarget"( currentForecast );

            $ "BlueMesaData.ShoulderFlowDuration" [@"24:00:00 December 31, Current Year"] := $ "BlueMesaData.GunnisonDurationTargets" [HClass, 1.00000000];

            $ "BlueMesaData.PeakFlowDuration" [@"24:00:00 December 31, Current Year"] := $ "BlueMesaData.GunnisonDurationTargets" [HClass, 2.00000000];

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Set Morrow Point and Crystal Storage";
    DESCRIPTION          "DESCRIPTION: This rule sets the storage on Crystal and Morrow Point Reservoirs for the entire run on the first timestep to the storage on the initial timestep.  These reservoirs just need to pass Blue Mesa outflow to meet flow requirements. This is done per Paul Davidson's recommendation. - sc 01/02/10<br><br>SLOTS SET: Crystal.Storage; MorrowPoint.Storage<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: SC, 01/02/2010";
    BEGIN

    DESCRIPTION          "Since the MTOM Model is a monthly model, the Crystal and Morrow Point <br>Reservoirs are going to be treated as reservoirs that pass inflow.  The model <br>does this by setting the storage to a constant value for the entire model run. ";
      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "Crystal.Storage" [date] := $ "Crystal.Storage" [@"t - 1"];

      ENDFOREACH;

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "MorrowPoint.Storage" [date] := $ "MorrowPoint.Storage" [@"t - 1"];

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Vallecito Ops";
  DESCRIPTION    "The operations of Vallecito Reservoir are based on analysis of the historic record in which a target pool elevation curve was created (VallecitoData.VallecitoGuide). A flow of 2,000 cfs is the maximum target outflow for Vallecito Reservoir to minimize downstream bank damage, but in times of flood control, outflow can be greater than the maximum release target. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "VallecitoFloodControlProtection";
    DESCRIPTION          "DESCRIPTION: Determines the Vallacito outflow when the pool elevation exceeds the target elevation for the given month. The Vallecito outflow is increased until either the maximum outflow is reached, or the Vallecito pool elevation is equal to the end of month target elevation for Vallecito. -ce 6/6/13<br><br>SLOTS SET: Vallecito.Outflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000 AND $ "Vallecito.Pool Elevation" [] > "GetEOMTargetElevation"( % "Vallecito", @"t" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE, 6/6/2013 (?)";
    BEGIN

      WITH_STATEMENT (NUMERIC previousPoolElevation = $ "Vallecito.Pool Elevation" [@"t - 1"]) DO
            $ "Vallecito.Outflow" [@"t"] := "Min"( "GetReservoirMaxConstraint"( % "Vallecito", @"t", previousPoolElevation ), "VolumeToFlow"( "ElevationToStorageAtDate"( % "Vallecito", $ "Vallecito.Pool Elevation" [], @"t" ) - "ElevationToStorageAtDate"( % "Vallecito", "GetEOMTargetElevation"( % "Vallecito", @"t" ), @"t" ), @"t" ) + $ "Vallecito.Outflow" [@"t"] );

      END_WITH_STATEMENT;

    END;

    RULE                 "Vallecito Guide Release";
    DESCRIPTION          "DESCRIPTION: This rule sets the Vallecito Reservoir releases for the entire run on the first timestep.  The ability to do this is predicated on the fact that Vallecito operations only need to know the inflow to the reservoir and nothing else about the state of the system.  If this changes, then it will have be done each timestep.<br><br>SLOTS SET: Vallecito.Outflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE:  SC, 12/15/2010";
    BEGIN

      FOREACH (LIST dateOutflowElevation IN "SimulateHeadwaterRes"( % "Vallecito" )) DO
            $ "Vallecito.Outflow" [GET @INDEX 0.00000000 FROM dateOutflowElevation] := GET @INDEX 1.00000000 FROM dateOutflowElevation;

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Taylor Park Ops";
  DESCRIPTION    "The operational guide curves for Taylor Park in MTOM are based on an analysis of the historic record which served as the foundation for developing target pool elevations for each month (TaylorParkData.TaylorParkGuide). The target pool elevation is used to set an outflow for a specific month where the outflow is bound by a minimum monthly flow and a maximum monthly flow depending on the pool elevation of the previous month. At Taylor Park, the maximum flow is constrained by the outlet works based on the data in the TaylorPark.Max Release table. Minimum flows are reduced if they would cause the reservoir to go below its minimum pool elevation.";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Taylor Park Guide Release";
    DESCRIPTION          "DESCRIPTION: This rule sets the Taylor Park Reservoir releases for the entire run on the first timestep.  The ability to do this is predicated on the fact that Taylor Park operations only need to know the inflow to the reservoir and nothing else about the state of the system.  If this changes, then it will have be done each timestep<br><br>SLOTS SET: TaylorPark.Outflow<br><br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: SC, 12/31/2010<br><br>MC, 20170720: Wrote modifed version of reduced MinFlow situation to adaptively reduce MinFlow values so that MinElevation is avoided; not active yet because haven't run it by USBR<br><br>MC, 20170621: (a) Changed reference  in local variable ToSpillway from 9,330 feet to TaylorParkData.SpillwayElevation; (b) Changed reference in first IF statement from TaylorParkData.TaylorPark_LowestFlow to TaylorParkData.MinFlow * TaylorParkData.MinFlowReductionFactor. (b) will allow more flexibility in flow reductions due to low pool elevations than hard-coding new min flow values.<br><br>MC, 20170508: Added conditional logic and LowestFlow slot to address problems Sarah B. was having with her model runs; changes developed by Sarah and confirmed with Erik K.<br><br>MC, 20170124: With midmonth ensembles, situation occurred in which the maximum release constraint in SimulateHeadwaterRes prevented use of spillway and led to storage greater than maximum in storage-volume table and aborted runs. I rewrote the rule so now TP only solves one timestep at a time but utilizes spill possibility. Three possibilities for relative size of outflows calculated:<br>1. ToSpillway < ToTarget < MaximumControlled: release to hit target<br>2. ToSpillway < MaximumControlled < ToTarget: release maximum and end of month elevation will be lower than spillway but higher than target<br>3. MaximumControlled < ToSpillway < ToTarget: release to spillway, which will require spill, but not excessive spill that would be required to reach target<br><br>Need Minimum Flow in case inflow is insufficient to reach Target";
    BEGIN

      WITH_STATEMENT (DATETIME EndDate = "DateMin"( "GetWaterYearEndDate"( @"t" ), @"Finish Timestep" )) DO
            $ "TaylorPark.Outflow" [@"t"] := IF ( ( $ "TaylorPark.Pool Elevation" [@"t - 1"] < ( $ "TaylorParkData.TaylorParkGuide" [@"t - 1"] - 70.00000000 "ft" ) ) COMMENTED_BY "Previous pool elevation is more than 70ft below guide curve OR (more than 20ft below AND inflows less than lowest outflows)" OR ( $ "TaylorPark.Pool Elevation" [@"t - 1"] < ( $ "TaylorParkData.TaylorParkGuide" [@"t - 1"] - 20.00000000 "ft" ) AND "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) < "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) * $ "TaylorParkData.MinFlowReductionFactor" [] ) )
 THEN
  "VolumeToFlow"( "FlowToVolume"( $ "TaylorParkData.MinFlow" [@"t"], @"t" ) * $ "TaylorParkData.MinFlowReductionFactor" [], @"t" )
 ELSE
  WITH NUMERIC MaximumControlled = $ "TaylorPark.Maximum Controlled Release" [0.00000000, 0.00000000] DO
   WITH NUMERIC ToTarget = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.TaylorParkGuide" [@"t"] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the pool elevation target" DO
    WITH NUMERIC ToSpillway = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.SpillwayElevation" [] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the spillway" DO
     "Max"( "Max"( "Min"( ToTarget, MaximumControlled ), ToSpillway ), $ "TaylorParkData.MinFlow" [@"t"] )
    ENDWITH
   ENDWITH
  ENDWITH
 ENDIF;

      END_WITH_STATEMENT;

    INACTIVE      WITH_STATEMENT (DATETIME EndDate = "DateMin"( "GetWaterYearEndDate"( @"t" ), @"Finish Timestep" )) DO
          DESCRIPTION          "MC, 20170720: I added this prospective change because I thought the conditions for reducing the Min Flow <br>and the reduction factor (0.67) were too arbitrary. Haven't run this by USBR yet, though.   <br>";
      $ "TaylorPark.Outflow" [@"t"] := IF ( ( $ "TaylorPark.Storage" [@"t - 1"] + "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) - "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) < "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.MinElevation" [] ) ) COMMENTED_BY "Min outflows lead to EOWY PE less than minimum <br>" )
 THEN
  WITH NUMERIC FlowReductionFactor = ( ( "SumFlowsToVolume"( $ "TaylorPark.Inflow", "GetWaterYearBeginDate"( @"t" ), EndDate ) + $ "TaylorPark.Storage" [@"t - 1"] - "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.MinElevation" [] ) ) / "SumFlowsToVolume"( $ "TaylorParkData.MinFlow", "GetWaterYearBeginDate"( @"t" ), EndDate ) * 1.00000000 ) COMMENTED_BY "Scale MinFlow either to reach MinElevation (multiply by 1) or reduce coefficient for factor of safety <br>" DO
   "VolumeToFlow"( "FlowToVolume"( $ "TaylorParkData.MinFlow" [@"t"], @"t" ) * FlowReductionFactor, @"t" )
  ENDWITH
 ELSE
  WITH NUMERIC MaximumControlled = $ "TaylorPark.Maximum Controlled Release" [0.00000000, 0.00000000] DO
   WITH NUMERIC ToTarget = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.TaylorParkGuide" [@"t"] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the pool elevation target" DO
    WITH NUMERIC ToSpillway = "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [@"t"], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.SpillwayElevation" [] ), $ "TaylorPark.Storage" [@"t - 1"], @"t" ) COMMENTED_BY "Outflow required to reach the spillway" DO
     "Max"( "Max"( "Min"( ToTarget, MaximumControlled ), ToSpillway ), $ "TaylorParkData.MinFlow" [@"t"] )
    ENDWITH
   ENDWITH
  ENDWITH
 ENDIF;

      END_WITH_STATEMENT;

    END;

  END;

  POLICY_GROUP   "Fontenelle";
  DESCRIPTION    "The Fontenelle Reservoir operational policies implemented in MTOM were developed based on operator experience and analysis of historic operations. In general, releases are set to meet various target elevations throughout the year while staying within practical and authorized limits. The target elevations for various months are as follows: <br>?         October through March outflows are controlled by the April 1 target elevation of 6,468 feet <br>?         April and June outflows are controlled by the July 1 target elevation of 6,500 feet ; May outflow is controlled by an intermediate target of 6,480 ft.<br>?         July outflow is controlled by the August 1 target elevation of 6,505.5 feet <br>?         The maximum release is about 11,500 cfs (Safe Channel Capacity)<br>?         Minimum releases are set to 400 cfs during the months Sep-Mar and to 600 cfs during the months Apr-Aug<br>  <br>Maximum and minimum releases take precedence over releases required to meet a specific month?s target elevation. A release that will cause the pool elevation to drop below 6,465 feet will be reduced such that the minimum elevation will not be violated except for minimum releases required to maintain flow in the reach below Fontenelle. Spills may occur as necessary to limit the pool elevation to 6,506 feet or to meet the target pool elevation in August. The spill algorithm releases the entire volume necessary to enforce the maximum pool elevation in a single month. ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Fontenelle Outflow";
    DESCRIPTION          "DESCRIPTION: This rule uses a more in depth function that replaces 11 rules that previously set the Fontenelle outflow.  The rule uses the function to set the Fontenelle outflow for the current timestep.<br><br>SLOTS SET: Fontenelle.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: TP, 5/11/2015";
    BEGIN

      $ "Fontenelle.Outflow" [] := "FontenelleMonthlyOutflow"(  );

    END;

    RULE                 "Set Unset Outflow";
    DESCRIPTION          "DESCRIPTION: Sets the outflow equal to inflow so that  spillCalc and power methods can execute, registering dependencies so that higher priority rules can set values. <br><br>SLOTS SET: Fontenelle.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>";
    BEGIN

      $ "Fontenelle.Outflow" [] := $ "Fontenelle.Inflow" [];

    END;

    RULE                 "ForecastFutureFGInflow";
    DESCRIPTION          "DESCRIPTION: Determines the projected inflow for Flaming Gorge based on the sum of the projected outflow from Fontenelle and the local inflows between Fontenelle and Flaming Gorge.<br><br>SLOTS SET: FlamingGorgeData.ProjectedInflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: ce 6/6/13 (?)";
    BEGIN

      FOREACH (NUMERIC index IN "GetNumbers"( 1.00000000, IF ( ( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) < 0.00000000 ) COMMENTED_BY "Next month is greater than April, forecast to April of next year" )
 THEN
  12.00000000 - "Abs"( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) ) + 1.00000000
 ELSE
  ( "GetMonth"( @"24:00:00 April Max DayOfMonth, Next Year" ) - "GetMonth"( @"t + 1" ) + 1.00000000 ) COMMENTED_BY "Forecast to April of current year"
 ENDIF, 1.00000000 )) DO
            $ "FlamingGorgeData.ProjectedInflow" ["OffsetDate"( @"t", index, "1 MONTHS" )] := ( GET @INDEX index - 1.00000000 FROM GET @INDEX 1.00000000 FROM "ForecastFontenelleRelease"( @"t + 1", @"24:00:00 April Max DayOfMonth, Next Year" ) ) + $ "GreenAboveFlamingGorge:InterveningAboveFlamingGorge.Local Inflow" ["OffsetDate"( @"t", index, "1 MONTHS" )];

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Set LB Outflows";
  DESCRIPTION    "This policy group contains rules that pertain to Lake Mead operations. Lake Mead has 2 basic modes of operation - meeting downstream demands or flood control.<br><br>There are two primary modes of operation at Lake Mead: Flood Control, and meet downstream demand. Flood Control operations are the highest priority, and are consistent with the 1984 Field Working Agreement between Reclamation and the U.S. Army Corps of Engineers (USACE Flood Control Manual). When Lake Mead is not in Flood Control, the system is operated to meet downstream water demands. In this mode of operation, releases from Lake Mead are currently governed by the 2007 Interim Guidelines. These guidelines specify conditions for determining when the Lower Basin water supply is under the Surplus, Normal, or Shortage Conditions. The guidelines also specify that when certain conditions exist, equalization or balancing of the contents of Lake Powell and Lake Mead shall be achieved. The coordinated operations of the reservoirs are consistent with the described methodology for Lake Powell operations in the previous section and follow the Lake Powell annual release flow chart. Other factors in setting Lake Mead operations are the 1944 Treaty with Mexico and International Boundary and Water Commission (IBWC) Minutes. <br><br>Lake Mohave<br>Lake Mead outflow takes into consideration the amount of water needed to be stored or released from Lake Mohave. The release from Lake Mohave is set to meet the downstream water demands while retaining the end of month target storage (see LBRuleCurveData.Mohave Target Storage).<br><br>Lake Havasu<br>As stated above, Lake Mead outflow takes into consideration the amount of water needed to be stored or released from Lake Mohave and Lake Havasu. The release from Lake Havasu is set with the objectives of meeting the downstream water demands while retaining the end of month target storage (see LBRuleCurveData.Havasu Target Storage). ";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Set Flow To Mexico (flow at NIB) exp";
    DESCRIPTION          "DESCRIPTION: This rule computes the flow to Mexico as the scheduled diversion requested plus the excess and stores it on the Lower Basin Output data object in the slot NIBFlow for subsequent write to hdb<br><br>SLOTS SET: Lower Basin Output.NIBFlow<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>";
    BEGIN

    DESCRIPTION          "Calculate the NIB Flow based on any calculated excess to Mexico less the scheduled request for Mexico. ";
      $ "Lower Basin Output.NIBFlow" [] := $ "Lower Basin Output.MexicoExcessFlow" [] + $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [];

    END;

    RULE                 "Set Mexico Excess";
    DESCRIPTION          "DESCRIPTION:  This rule determines the excess flow to Mexico which is just the actual Mead release minus the release determined to meet downstream requirements <br><br>SLOTS SET: Lower Basin Output.MexicoExcessFlow<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "If the Mead outflow is greater than the sum of the downtream demands, then Mexico gets the excess";
      $ "Lower Basin Output.MexicoExcessFlow" [] := $ "Mead.Outflow" [] - "VolumeToFlow"( $ "Lower Basin Output.DownstreamReq" [], @"t" );

    END;

    RULE                 "Set DownStream Requirement exp";
    DESCRIPTION          "DESCRIPTION: This rule calculates the demand downstream of Lake Mead. It should get reset if shortage or surplus schedules are applied.<br><br>SLOTS SET: Lower Basin Output.DownstreamReq<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Set the data object that reports the necessary water required downstream of Mead to meet all demands. ";
      $ "Lower Basin Output.DownstreamReq" [] := IF ( @"t" <= @"Start Timestep" )
 THEN
  "FlowToVolume"( $ "HavasuOutflow.BHOPSParkerOutflow" [], @"t" )
 ELSE
  $ "HavasuOutflow.ParkerRequirement" []
 ENDIF + "SumAllDiversionsBelowVolume"( % "Mead", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Mead", @"t", @"t" ) + "ComputeDeltaTargetStorage"( % "Mohave" ) + "ComputeDeltaTargetStorage"( % "Havasu" ) + $ "Mohave.Evaporation" [] + $ "Havasu.Evaporation" [];

    END;

    RULE                 "Set Parker Final Requirement";
    DESCRIPTION          "DESCRIPTION: This rule sets the data object slot HavasuOutflow.ParkerRequirement to the difference between the diversions and the local inflows below Havasu<br><br>SLOTS SET: HavasuOutflow.ParkerRequirement<br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      $ "HavasuOutflow.ParkerRequirement" [] := "SumAllDiversionsBelowVolume"( % "Havasu", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Havasu", @"t", @"t" );

    END;

    RULE                 "Havasu Rule Curve";
    DESCRIPTION          "DESCRIPTION: In any month except the Start Timestep, set the Havasu outflow such that the reservoir pool elevation target is met.<br><br>SLOTS SET: Havasu.Outflow";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000 AND @"t" > @"Start Timestep";
    NOTES                "AUTHOR, DATE: Unknown<br>Unknown Commenter, Unknown Date: This rule could just as easily use a target elevation rather than a storage. It would probably be safer to do so.";
    BEGIN

      $ "Havasu.Outflow" [] := "SolveOutflow"( % "Havasu", $ "Havasu.Inflow" [], "GetTargetStorage"( % "Havasu", @"t" ), $ "Havasu.Storage" [@"t - 1"], @"t" );

    END;

    RULE                 "Set Havasu Outflow Exp";
    DESCRIPTION          "DESCRIPTION: If the Havasu outflow is not set at the Start Timestep, set it to the BHOPS Parker Outflow, which is a user input value and comes from the 24 MS. <br><br>SLOTS SET: Havasu.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "Havasu.Outflow" [] AND @"t" <= @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>MC, 20160426: LC changed this from setting the first 2 months of the run to just the first month";
    BEGIN

      $ "Havasu.Outflow" [] := $ "HavasuOutflow.BHOPSParkerOutflow" [];

    END;

    RULE                 "Mohave Rule Curve";
    DESCRIPTION          "DESCRIPTION: Set the Outflow from Mohave to what is necesary to hit the Mohave Target Storages. This rule passes the inflow necessary to meet downstream demands and preserve the target storage for Mohave.<br><br>SLOTS SET: Mohave.Outflow<br><br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br>Unknown Commenter, Unknow Date: This rule could just as easily use a target elevation rather than a storage. It would probably be safer to do so.";
    BEGIN

      $ "Mohave.Outflow" [] := "SolveOutflow"( % "Mohave", $ "Mohave.Inflow" [], "GetTargetStorage"( % "Mohave", @"t" ), $ "Mohave.Storage" [@"t - 1"], @"t" );

    END;

    RULE                 "Set Mead Outflow To Demands";
    DESCRIPTION          "DESCRIPTION: Set the Lake Mead outflow to the smaller of the sum of the lower basin demands OR the water available in Mead (if Run Cycle >=3; otherwise use 9,999,999 acre-ft/month). This rule can execute as many times as necessary to set releases to meet demands. <br><br>SLOTS SET: Mead.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

      BREAKPOINT BEFORE_EXEC TRUE;
      $ "Mead.Outflow" [] := "Min"( IF ( "GetRunCycleIndex"(  ) >= 3.00000000 )
 THEN
  "CheckResPhysicalConstraint"( % "Mead", @"t" )
 ELSE
  9999999.00000000 "acre-ft/month"
 ENDIF, IF ( @"t" <= @"Start Timestep" )
 THEN
  "VolumeToFlow"( "FlowToVolume"( $ "HavasuOutflow.BHOPSParkerOutflow" [], @"t" ) + "SumAllDiversionsBelowVolume"( % "Mead", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Mead", @"t", @"t" ) + "ComputeDeltaTargetStorage"( % "Mohave" ) + "ComputeDeltaTargetStorage"( % "Havasu" ) + $ "Mohave.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Mohave", "GetTargetStorage"( % "Mohave", @"t" ) ) + "StorageToArea"( % "Mohave", $ "Mohave.Storage" [@"t - 1"] ) ) / 2.00000000 ) * 1.00000000 "month" + $ "Havasu.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Havasu", "GetTargetStorage"( % "Havasu", @"t" ) ) + "StorageToArea"( % "Havasu", $ "Havasu.Storage" [@"t - 1"] ) ) / 2.00000000 ) * 1.00000000 "month", @"t" )
 ELSE
  "VolumeToFlow"( "SumAllDiversionsBelowVolume"( % "Havasu", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Havasu", @"t", @"t" ) + "SumAllDiversionsBelowVolume"( % "Mead", @"t", @"t" ) - "SumAllGainsBelowVolume"( % "Mead", @"t", @"t" ) + "ComputeDeltaTargetStorage"( % "Mohave" ) + "ComputeDeltaTargetStorage"( % "Havasu" ) + $ "Mohave.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Mohave", "GetTargetStorage"( % "Mohave", @"t" ) ) + "StorageToArea"( % "Mohave", "GetTargetStorage"( % "Mohave", @"t - 1" ) ) ) / 2.00000000 ) * 1.00000000 "month" + $ "Havasu.Evaporation Coefficients" ["GetMonth"( @"t" ) - 1.00000000, 0.00000000] * ( ( "StorageToArea"( % "Havasu", "GetTargetStorage"( % "Havasu", @"t" ) ) + "StorageToArea"( % "Havasu", "GetTargetStorage"( % "Havasu", @"t - 1" ) ) ) / 2.00000000 ) * 1.00000000 "month", @"t" )
 ENDIF );

    END;

  END;

  POLICY_GROUP   "Set Future Uses - SNWP, CAP, MWD";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Reset Monthly Forecast Use CAP - Nov and Dec, Cur Year";
    DESCRIPTION          "DESCRIPTION: Reset the CAP Diversion requests based on the estimated available to CAP from the state apportionment and the other user diversion requests and the forecast scheduled volume for CAP.  This rule will only execute in the start timestep and set values for November and December.  This is so that if CAP sets a schedule in a timestep prior to November, the schedule can be adjusted in the last two months of the year such that there are no Arizona overruns. <br><br>SLOTS SET: CAPDiversion.Total Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND NOT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetMonth"( @"t" ) < 11.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "reset the CAP Diversion requests based on the estimated available to CAP from the state apportionment and the other user diversion requests and the forecast scheduled volume for CAP.  This <br><br>rule will only execute in the start timestep and set values for November and December.  This is so that if CAP sets a schedule in a timestep prior to November, the schedule can be adjusted in <br><br>the last two months of the year such that there are no Arizona overruns. ";
      FOREACH (DATETIME date IN @"24:00:00 November Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := ( ( "VolumeToFlow"( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Arizona_CU_Forecast1.CAP" ["Dec31ofYear"( date )], date ) ) / 2.00000000 + "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date ) );

      ENDFOREACH;

    END;

    RULE                 "Reset Monthly Forecast Use CAP - All Months Outyears";
    DESCRIPTION          "DESCRIPTION: Reset the CAP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests). <br><br>SLOTS SET: CAPDiversion.Total Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Reset the CAP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests). ";
      FOREACH (DATETIME date IN "GetFirstDate"( @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := ( ( "VolumeToFlow"( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Arizona_CU_Forecast1.CAP" [@"24:00:00 December 31, Current Year"], date ) ) / "GetDaysBasedOnFirstDate"( @"t" ) + "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date ) );

      ENDFOREACH;

    END;

    RULE                 "Reset Monthly Forecast Use SNWP All Years";
    DESCRIPTION          "DESCRIPTION: Reset the SNWP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests).  <br><br>SLOTS SET: PumpingFromLakeMead:SNWP.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND ( @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Reset the SNWP Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests).  ";
      FOREACH (DATETIME date IN @"t" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            FOREACH (SLOT slot IN { $ "PumpingFromLakeMead:SNWP.Diversion Requested" , $ "PumpingFromLakeMead:SNWP.Depletion Requested" }) DO
            slot [date] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) )
 THEN
  ( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] + ( "VolumeToFlow"( $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"], date ) ) / ( 12.00000000 - "GetMonth"( @"Start Timestep" ) + 1.00000000 ) )
 ELSE
  ( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] + ( "VolumeToFlow"( $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"], date ) ) / 12.00000000 )
 ENDIF;

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "Redistribute MWD Nov & Dec Div Request";
    DESCRIPTION          "DESCRIPTION: This rule redistributes Nov and Dec MWD requests that may be over the canal capacity.  This can occur when LBDV is initiated below Parker and there is additional supply available to MWD.<br><br>SLOTS SET: MWDDiversion:MWD.Diversion Requested; ICS Credits.AnnualCreationEC_CA<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND NOT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetMonth"( @"t" ) < 11.00000000 AND ( "GetRunCycleIndex"(  ) == 1.00000000 OR "GetRunCycleIndex"(  ) == 3.00000000 );
    NOTES                "AUTHOR, DATE: MC/JR, Unknown<br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed, also changing ForecastUse.MWDResetAnnualFC, because creation of EC ICS (an Input value) is not allowed in that case (Shortage).<br>MC, 20180125: Removed Shortage as condition for Execution Constraint based on USBR changes to rules";
    BEGIN

      WITH_STATEMENT (NUMERIC InitialTotalRequest = FOR ( DATETIME date IN "GetDates"( @"t", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "MWDDiversion.Total Diversion Requested" [date], date )
 ENDFOR) DO
          DESCRIPTION          "<br>If Nov or Dec diversion request exceeds canal capacity, redistribute the excess request to months between the current month and October of the current year.<br>";
      WITH_STATEMENT (NUMERIC NovExcessRequest = "Max"( $ "MWDDiversion.Total Diversion Requested" [@"24:00:00 November Max DayOfMonth, Current Year"] - $ "MWDDiversionData.MWDCanal_DailyCapacity" [], 0.00000000 "acre-feet/month" )) DO
            WITH_STATEMENT (NUMERIC DecExcessRequest = "Max"( $ "MWDDiversion.Total Diversion Requested" [@"24:00:00 December Max DayOfMonth, Current Year"] - $ "MWDDiversionData.MWDCanal_DailyCapacity" [], 0.00000000 "acre-feet/month" )) DO
            IF_STATEMENT (NovExcessRequest + DecExcessRequest > 0.00000000 "acre-feet/month") THEN
          DESCRIPTION          "Redistribute excess diversion requests";
      FOREACH (DATETIME date IN "GetDates"( @"t", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" )) DO
            $ "MWDDiversion:MWD.Diversion Requested" [date] := ( GET @INDEX "GetMonth"( date ) - 1.00000000 FROM "CheckAndAdjustToCapacity"( $ "MWDDiversion.Total Diversion Requested", $ "MWDDiversionData.MWDCanal_DailyCapacity" [] ) ) - $ "MWDDiversion:Tijuana.Diversion Requested" [date];

      ENDFOREACH;

      END_IF_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC FinalTotalRequest = FOR ( DATETIME date IN "GetDates"( @"t", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) STAT_SUM
  "FlowToVolume"( $ "MWDDiversion.Total Diversion Requested" [date], date )
 ENDFOR) DO
          DESCRIPTION          "If the request excess is more than available capacity, assign the remainder to <br>ICS EC credits";
      WITH_STATEMENT (NUMERIC ICSAddition = "Max"( InitialTotalRequest - FinalTotalRequest, 0.00000000 "acre-feet" )) DO
            $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )] := NaNToZero ( $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )] ) + ICSAddition;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

    END;

    RULE                 "Reset Monthly Forecast Use MWD - Nov and Dec, Cur Year";
    DESCRIPTION          "DESCRIPTION: Reset the MWD DIversion and depletion requests based on the estimated available to MWD from the state apportionment and the other user diversion requests and the forecast scheduled volume for MWD.  This rule will only execute in the start timestep and set values for November and December.  This is so that if MWD sets a schedule in a timestep prior to November, the schedule can be adjusted in the last two months of the year such that there are no California overruns. <br><br>SLOTS SET: MWDDiversion:MWD.Depletion Requested; MWDDiversion:MWD.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND NOT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetMonth"( @"t" ) < 11.00000000 AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed, also changing ForecastUse.MWDResetAnnualFC, because creation of EC ICS (an Input value) is not allowed in that case.<br>MC, 20180125: Removed Shortage as condition for Execution Constraint based on USBR changes to rules";
    BEGIN

    DESCRIPTION          "reset the MWD DIversion and depletion requests based on the estimated <br>available to MWD from the state apportionment and the other user diversion <br>requests and the forecast scheduled volume for MWD.  <br><br>This rule will only execute in the start timestep and set values for November and December.  This is so that if MWD sets a schedule in a timestep prior to November, the schedule can be adjusted in the last two months of the year such that there are no California overruns. ";
      FOREACH (DATETIME date IN @"24:00:00 November Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC mwdDepletionAmount = "Max"( 0.00000000 "acre-ft/month", ( "VolumeToFlow"( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "California_CU_Forecast1.MWD" ["Dec31ofYear"( date )], date ) ) / 2.00000000 + $ "MWDDiversion:MWD.Depletion Requested" [date] )) DO
            $ "MWDDiversion:MWD.Depletion Requested" [date] := mwdDepletionAmount;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := mwdDepletionAmount + "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

      END_WITH_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Reset Monthly Forecast Use MWD - All Months Outyears";
    DESCRIPTION          "DESCRIPTION: Reset the MWD Diversion request based on the reset annual forecast use (difference in state apportionment and the other diversion requests).  This calculation gives the amount of water that California can take as a consumptive use amount so the diversion needs to be set to that amount plus the estimated return flow that is returned at the diversion location. <br><br>SLOTS SET: MWDDiversion:MWD.Depletion Requested; MWDDiversion:MWD.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT NOT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND ( @"t" != @"Start Timestep" AND @"t" == @"24:00:00 January Max DayOfMonth, Current Year" ) AND ( ( "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "Current Rule" ) ) OR ( "GetRunCycleIndex"(  ) == 3.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 ) );
    NOTES                "AUTHOR, DATE: Unknown<br><br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed, also changing ForecastUse.MWDResetAnnualFC, because creation of EC ICS (an Input value) is not allowed in that case.";
    BEGIN

    DESCRIPTION          "Reset the MWD Diversion request based on the reset annual forecast use (difference in state apportionment and the other <br>diversion requests).  This calculation gives the amount of water that California can take as a consumptive use amount so <br>the diversion needs to be set to that amount plus the estimated return flow that is returned at the diversion location. ";
      FOREACH (DATETIME date IN "GetFirstDate"( @"t" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            WITH_STATEMENT (NUMERIC mwdDepletionAmount = ( "VolumeToFlow"( $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"], date ) - "VolumeToFlow"( $ "California_CU_Forecast1.MWD" [@"24:00:00 December 31, Current Year"], date ) ) / "GetDaysBasedOnFirstDate"( @"t" ) + "VolumeToFlow"( $ "California_CU_Schedules.MWD" [date], date )) DO
            $ "MWDDiversion:MWD.Depletion Requested" [date] := mwdDepletionAmount;

            $ "MWDDiversion:MWD.Diversion Requested" [date] := mwdDepletionAmount + "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date );

      END_WITH_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "SumAnnualStateUse - Div Req";
    DESCRIPTION          "DESCRIPTION: Sum the Annual State Use based on the monthly orders for AZ without CAP, NV, and CA without MWD<br><br>SLOTS SET: AnnualWaterUse.AzNoCAPTotalAnnual; AnnualWaterUse.NvTotalAnnual; AnnualWaterUse.CaNoMWDTotalAnnual";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Sum the Annual State Use based on the Monthly orders for AZ without CAP, Nevada, and <br><br>California with no MWD considered. ";
      FOREACH (STRING state IN { "AzNoCAP" , "Nv" , "CaNoMWD" }) DO
            "AnnualWaterUse." CONCAT state CONCAT "TotalAnnual" [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
 THEN
  "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyOrder" ), @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" ) + "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyActual" ), @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" )
 ELSE
  "SumSlot"( % "AnnualWaterUse" & ( state CONCAT "TotalMonthlyOrder" ), @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" )
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "SumStateMonthlyOrders - DivReq";
    DESCRIPTION          "DESCRIPTION: Sum the monthly AZ no CAP, NV, and CA no MWD orders based on the set diversion request for each state's diversion locations.<br><br>SLOTS SET: AnnualWaterUse.AzNoCAPTotalMonthlyOrder; AnnualWaterUse.NvTotalMonthlyOrder; AnnualWaterUse.CaNoMWDTotalMonthlyOrder";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Sum the Monthly AZ no CAP, Nevada, and CA no MWD orders based on the set diversion request <br><br>for each state's diversion locations. ";
      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "AnnualWaterUse.AzNoCAPTotalMonthlyOrder" [date] := "FlowToVolume"( $ "AzPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaGravityMainCanal.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaAndYumaUsers.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR:CRIRAz.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:BlmPumpersBlwImp.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:SouthernPacific.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:YAO.Diversion Requested" [date], date ) + "FlowToVolume"( $ "FtMohaveIndRes:AZ.Diversion Requested" [date], date ) + "FlowToVolume"( $ "AzDvsToPkr.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "PumpingFromLakeMead:LMNRA Az Mead.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Az Mohave.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:Ft Yuma.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:DavisDamProject.Diversion Requested" [date], date );

            $ "AnnualWaterUse.NvTotalMonthlyOrder" [date] := "FlowToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date], date ) + "FlowToVolume"( $ "NvDvsToPkr.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "FtMohaveIndRes:NV.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date], date );

            $ "AnnualWaterUse.CaNoMWDTotalMonthlyOrder" [date] := "FlowToVolume"( $ "AAC.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaDvsToPkr.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR:CRIRCa.Diversion Requested" [date], date ) + "FlowToVolume"( $ "FtMohaveIndRes:CA.Diversion Requested" [date], date ) + "FlowToVolume"( $ "PaloVerde.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp:YumaIsland.Diversion Requested" [date], date );

      ENDFOREACH;

    END;

    RULE                 "Set Normal Schedules MWD & SNWP";
    DESCRIPTION          "DESCRIPTION: Set the MWD Diversion Request and Depletion Request and the SNWP Diversion request to the normal schedules input to the MTOM model.<br><br>SLOTS SET: MWDDiversion:MWD.Diversion Requested; MWDDiversion:MWD.Depletion Requested; PumpingFromLakeMead:SNWP.Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>Need to separate CAP & CVWD from MWD & SNWP for full surplus";
    BEGIN

    DESCRIPTION          "Set the MWD Diversion Request and Depletion Request and the SNWP Diversion request to the <br><br>normal schedules input to the MTOM model.";
      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December 31, Finish Year") DO
            $ "MWDDiversion:MWD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.MWDDiversion" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.MWDDiversion" [date], date )
 ENDIF;

            $ "MWDDiversion:MWD.Depletion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.MWD" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.MWD" [date], date )
 ENDIF;

            $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.SNWP" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.SNWP" [date], date )
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set Normal Schedules CAP";
    DESCRIPTION          "DESCRIPTION: Set the CAP Diversion Request to the Normal input schedule for CAP<br><br>SLOTS SET: CAPDiversion.Total Diversion Requested";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown<br><br>May need 2nd condition (@t = Jan, current year) for full surplus<br>Need to separate CAP from MWD & SNWP for full surplus";
    BEGIN

    DESCRIPTION          "Set the CAP Diversion Request to the Normal input schedule for CAP";
      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December 31, Finish Year") DO
            $ "CAPDiversion.Total Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CAP" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CAP" [date], date )
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Reset MWD Annual Forecast Use - Force to CA Apportionment";
    DESCRIPTION          "DESCRIPTION: Set the MWD Forecast annual diversion to the state apportionment (in the deterministic run or in the first year of the run, use the input state apportionment, in an outyear use the adjusted state apportionment), less any senior users to MWD diversion requested. <br><br>SLOTS SET: ForecastUse.MWDResetAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000 OR ( "GetRunCycleIndex"(  ) == 3.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 );
    NOTES                "AUTHOR, DATE: Unknown<br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 and Shortage is in effect.  This is required because the slot AnnualWaterUse.California_PreliminaryAdjustedApportionment will have changed because creation of EC ICS (an Input value) is not allowed in that case.";
    BEGIN

    DESCRIPTION          "Set the MWD Forecast annual diversion to the state apportionment (in the deterministic run or in <br><br>the first year of the run, use the input state apportionment, in an outyear use the adjusted state <br><br>apportionment), less any senior users to MWD diversion requested. ";
      $ "ForecastUse.MWDResetAnnualFC" [@"24:00:00 December 31, Current Year"] := IF ( "IsMRM"(  ) )
 THEN
  IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) )
  THEN
   $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
  ELSE
   $ "AnnualWaterUse.California_PreliminaryAdjustedApportionment" [@"24:00:00 December 31, Current Year"]
  ENDIF
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF - FOR ( DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 January Max DayOfMonth, Current Year" ) TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  FOR ( OBJECT diversionSite IN "ListSubbasin"( "California nonMWD WaterUsers" ) ) STAT_SUM
   IF ( diversionSite == % "PaloVerde" )
   THEN
    "FlowToVolume"( diversionSite & "Total Diversion Requested" [date], date )
   ELSE
    "FlowToVolume"( diversionSite & "Diversion Requested" [date], date )
   ENDIF
  ENDFOR
 ENDFOR COMMENTED_BY "Sum all Non MWD Diversion Requests";

    END;

    RULE                 "Reset Annual CAP Forecast Use - Force to AZ Apportionment";
    DESCRIPTION          "DESCRIPTION: Set the CAP annual diversion to the AZ state apportionment less the more senior Arizona diversions. <br><br>SLOTS SET: ForecastUse.CAPResetAnnualFC<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Set the CAP annual diversion to the AZ state apportionment less the more senior Arizona diversions. ";
      $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.Arizona_Apportionment" [@"24:00:00 December 31, Current Year"] - FOR ( DATETIME date IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year" ) STAT_SUM
  FOR ( OBJECT nonCAPUser IN "ListSubbasin"( "ArizonaNonCAPWaterUsers" ) ) STAT_SUM
   "FlowToVolume"( nonCAPUser & "Diversion Requested" [date], date )
  ENDFOR
 ENDFOR COMMENTED_BY "Sum all Non CAP Diversion Requests";

    END;

    RULE                 "Reset Annual SNWP Forecast Use - Force to NV Apportionment";
    DESCRIPTION          "DESCRIPTION: Set the SNWP Forecast value to the difference between the Nevada State Apportionment and the other Nevada users. <br><br>SLOTS SET: ForecastUse.SNWPResetAnnualFC";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT IsNaN $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Set the SNWP Forecast value to the difference between the Nevada State <br>Apportionment and the other Nevada users. ";
      $ "ForecastUse.SNWPResetAnnualFC" [@"24:00:00 December 31, Current Year"] := $ "AnnualWaterUse.Nevada_Apportionment" [@"24:00:00 December 31, Current Year"] - FOR ( DATETIME date IN @"24:00:00 January 31, Current Year" TO @"24:00:00 December 31, Current Year" ) STAT_SUM
  "FlowToVolume"( $ "FtMohaveIndRes:NV.Diversion Requested" [date], date ) + "FlowToVolume"( $ "NvDvsToPkr:BigBend.Diversion Requested" [date], date ) + "FlowToVolume"( $ "NvDvsToPkr:SCE.Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date], date )
 ENDFOR COMMENTED_BY "Sum all Non SNWP Nevada Diversion Requests";

    END;

  END;

  POLICY_GROUP   "LC WaterUse Data Setup";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Below Parker Hydrologic Demand Variability";
    DESCRIPTION          "DESCRIPTION: Allow the senior users in the Lower Basin to take additional water or decrease their demand based on the Below Parker Hydrologic Demand Variability.  If the local inflows below Parker are greater than the historic 90th percentile (wet) observed value, then decrease the diversion requests by 10%. If the local inflows are less than the 10th percentile (dry) observed value, then increase the diversion requests by 5%. <br><br>SLOTS SET: PaloVerde.Total Diversion Requested; CRIR:CRIRAz.Diversion Requested; AAC:IID.Diversion Requested; AAC:Coachella.Diversion Requested; GilaGravityMainCanal:WMIDD.Diversion Requested; GilaGravityMainCanal:YCWUA.Diversion Requested; GilaGravityMainCanal:YMIDD.Diversion Requested; LowerBasinDemandVariability.BlwParkerTriggerSet<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"24:00:00 January Max DayOfMonth, Current Year" AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "This Rule" ) AND "IsMRM"(  );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN "DateMax"( @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep" ) TO @"24:00:00 December Max DayOfMonth, Current Year") DO
            $ "PaloVerde.Total Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.PaloVerde" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "PVID" );

            $ "CRIR:CRIRAz.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.CRIRAz" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "CRIRaz" );

            $ "AAC:IID.Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.IID" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "IID" );

            $ "AAC:Coachella.Diversion Requested" [date] := "VolumeToFlow"( $ "California_CU_Schedules.Coachella" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "CVWD" );

            $ "GilaGravityMainCanal:WMIDD.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.WMIDD" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "WMIDD" );

            $ "GilaGravityMainCanal:YCWUA.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.YCWUA" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "YCWUA" );

            $ "GilaGravityMainCanal:YMIDD.Diversion Requested" [date] := "VolumeToFlow"( $ "Arizona_CU_Schedules.YMIDD" [date], date ) * "AgUsersBelowParkerDemandVariabilityFactor"( date, "YMIDD" );

            $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( date )] := IF ( "AgUsersBelowParkerDemandVariabilityFactor"( date, "PVID" ) == 1.00000000 )
 THEN
  0.00000000
 ELSE
  IF ( "AgUsersBelowParkerDemandVariabilityFactor"( date, "PVID" ) == 0.90000000 )
  THEN
   1.00000000
  ELSE
   - 1.00000000
  ENDIF
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set Operational GainLoss";
    DESCRIPTION          "DESCRIPTION: Set the Operational Gain loss on the Havasu to Imperial Reach object by taking the difference between what is scheduled on the reach objects and what is input to the model as the Scheduled outflow from Havasu. <br><br>SLOTS SET: HavasuToImperial:DailyOperationalGainLoss.LocalInflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "HavasuToImperial:DailyOperationalGainLoss.Local Inflow" [date] := IF ( date <= @"Start Timestep + 1" )
 THEN
  ( "VolumeToFlow"( $ "HavasuOutflow.ParkerScheduleRequirement" [date], date ) - $ "HavasuOutflow.BHOPSParkerOutflow" [date] )
 ELSE
  0.00000000 "acre-ft/month"
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set Parker Schedule Requirement";
    DESCRIPTION          "DESCRIPTION: Sum the diversion requests that were set in a previous rule and set the slot value for the total required release from Havasu for the model run period.<br><br>SLOTS SET: HavasuOutflow.ParkerScheduleRequirement<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND IsNaN $ "HavasuOutflow.ParkerScheduleRequirement" [];
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "HavasuOutflow.ParkerScheduleRequirement" [date] := "FlowToVolume"( $ "AAC.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "AzPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CRIR.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "CaPkrToImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaAndYumaUsers.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "GilaGravityMainCanal.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "PaloVerde.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "OthersBlwImp.Total Diversion Requested" [date], date ) + "FlowToVolume"( $ "MexicanTreatyDelivery.Total Diversion Requested" [date], date ) - ( "FlowToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow" [date], date ) + "FlowToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow" [date], date ) + "FlowToVolume"( $ "BelowImperialDam:Gila River.Local Inflow" [date], date ) );

      ENDFOREACH;

    END;

    RULE                 "Sum State Monthly Actual CU";
    DESCRIPTION          "DESCRIPTION: Calculate the Annual Consumptive Use values for all users in each of the lower basin states less the junior priority users, if applicable, for the beginning of the current year to the timestep prior to the run start. For Arizona, calculate the consumptive use forecast without CAP considered. For Nevada calculate the total Consumptive use forecast. For California, calculate the consumptive use forecast without MWD being considered.<br><br>SLOTS SET: AnnualWaterUse.AzNoCAPTotalMonthlyActual; AnnualWaterUse.NvTotalMonthlyActual; AnnualWaterUse.CaNoMWDTotalMonthlyActual<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
            $ "AnnualWaterUse.AzNoCAPTotalMonthlyActual" [date] := $ "Arizona_CU_Actual.CRIRAz" [date] + $ "Arizona_CU_Actual.CibolaNWR" [date] + $ "Arizona_CU_Actual.CibolaValleyIID" [date] + $ "Arizona_CU_Actual.City of Parker" [date] + $ "Arizona_CU_Actual.ImperialNWR" [date] + $ "Arizona_CU_Actual.BrookeWater" [date] + $ "Arizona_CU_Actual.Ehrenberg" [date] + $ "Arizona_CU_Actual.AzPumpersAbvImp" [date] + $ "Arizona_CU_Actual.AzPumpersBlwImp" [date] + $ "Arizona_CU_Actual.BlmPumpersAbvImp" [date] + $ "Arizona_CU_Actual.BlmPumpersBlwImp" [date] + $ "Arizona_CU_Actual.NGVIDD" [date] + $ "Arizona_CU_Actual.WMIDD" [date] + $ "Arizona_CU_Actual.YCWUA" [date] + $ "Arizona_CU_Actual.MCAirStation" [date] + $ "Arizona_CU_Actual.YMIDD" [date] + $ "Arizona_CU_Actual.YID" [date] + $ "Arizona_CU_Actual.UnitB" [date] + $ "Arizona_CU_Actual.City of Yuma" [date] + $ "Arizona_CU_Actual.UofA" [date] + $ "Arizona_CU_Actual.LakeHavasuCity" [date] + $ "Arizona_CU_Actual.YumaUnionHighScl" [date] + $ "Arizona_CU_Actual.YumaProvingGround" [date] + $ "Arizona_CU_Actual.Cocopah Indian Res" [date] + $ "Arizona_CU_Actual.Gila Monster Farms" [date] + $ "Arizona_CU_Actual.DesertLawnMemorial" [date] + $ "Arizona_CU_Actual.SouthernPacific" [date] + $ "Arizona_CU_Actual.YAO" [date] + $ "Arizona_CU_Actual.BullheadCity" [date] + $ "Arizona_CU_Actual.FtMohaveAz" [date] + $ "Arizona_CU_Actual.DavisDamProject" [date] + $ "Arizona_CU_Actual.MohaveValleyIID" [date] + $ "Arizona_CU_Actual.MohaveWaterConsDist" [date] + $ "Arizona_CU_Actual.HavasuNWR" [date] + $ "Arizona_CU_Actual.GoldenShores" [date] + $ "Arizona_CU_Actual.LMNRA Az Mead" [date] + $ "Arizona_CU_Actual.LMNRA Az Mohave" [date] + $ "Arizona_CU_Actual.Ft Yuma" [date] + $ "Arizona_CU_Actual.AzPumpersDvsToPkr" [date];

            $ "AnnualWaterUse.NvTotalMonthlyActual" [date] := $ "Nevada_CU_Actual.SNWP" [date] + $ "Nevada_CU_Actual.FtMohaveNv" [date] + $ "Nevada_CU_Actual.BigBend" [date] + $ "Nevada_CU_Actual.SCE" [date] + $ "Nevada_CU_Actual.LMNRA Mohave" [date];

            $ "AnnualWaterUse.CaNoMWDTotalMonthlyActual" [date] := $ "California_CU_Actual.CaPumpersAbvImp" [date] + $ "California_CU_Actual.Chemehuevi" [date] + $ "California_CU_Actual.Coachella" [date] + $ "California_CU_Actual.CRIRCa" [date] + $ "California_CU_Actual.FtMohaveCa" [date] + $ "California_CU_Actual.IID" [date] + $ "California_CU_Actual.Needles" [date] + $ "California_CU_Actual.OtherLCWSP" [date] + $ "California_CU_Actual.PaloVerde" [date] + $ "California_CU_Actual.Ranch5" [date] + $ "California_CU_Actual.SaltonSea" [date] + $ "California_CU_Actual.Winterhaven" [date] + $ "California_CU_Actual.YumaIsland" [date] + $ "California_CU_Actual.YumaProject" [date];

      ENDFOREACH;

    END;

    RULE                 "Overruns Based on State Apportionments";
    DESCRIPTION          "DESCRIPTION: Estimate each lower basin state's Overrun based on the forecast values and the state apportionment values<br><br>SLOTS SET: California_CU_Overrun.California_Overrun_State_Ap;Arizona_CU_Overrun.Arizona_Overrun_State_Ap; Nevada_CU_Overrun.Nevada_Overrun_State_Ap;<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            "GetObject"( state CONCAT "_CU_Overrun" ) & ( state CONCAT "_Overrun_State_Ap" ) [] := % "AnnualWaterUse" & ( state CONCAT "_Forecast1" ) [@"24:00:00 December 31, Current Year"] - % "AnnualWaterUse" & ( state CONCAT "_Apportionment" ) [@"24:00:00 December 31, Current Year"];

      ENDFOREACH;

    END;

    RULE                 "Sum Annual Approvals for Lower Basin States";
    DESCRIPTION          "DESCRIPTION: Sum the monthly Annual Approval input values to Annual Approval values calculated from the input consumptive use schedules at the beginning of the run. <br><br>SLOTS SET: AnnualWaterUse.California_AnnualApproval; AnnualWaterUse.Nevada_AnnualApproval; AnnualWaterUse.Arizona_AnnualApproval;<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "AnnualWaterUse" & ( state CONCAT "_AnnualApproval" ) [@"24:00:00 December 31, Current Year"] := IF ( state == "Nevada" )
 THEN
  $ "Nevada_CU_AnnualApproval.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.BigBend" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.FtMohaveNv" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.LMNRA Mohave" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_AnnualApproval.SCE" [@"24:00:00 December 31, Current Year"]
 ELSE
  IF ( state == "California" )
  THEN
   "SumSlotListDates"( "GetObject"( state CONCAT "_CU_AnnualApproval" ), @"24:00:00 December 31, Current Year" ) - $ "California_CU_AnnualApproval.MWDDiversion" [@"24:00:00 December 31, Current Year"] - $ "California_CU_AnnualApproval.MWDReturns" [@"24:00:00 December 31, Current Year"]
  ELSE
   "SumSlotListDates"( "GetObject"( state CONCAT "_CU_AnnualApproval" ), @"24:00:00 December 31, Current Year" )
  ENDIF
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Sum Annual Forecast1 for Lower Basin States";
    DESCRIPTION          "DESCRIPTION: Sum the various components for each state forecast and set and Annual Forecast estimation for each state<br><br>SLOTS SET: AnnualWaterUse.California_Forecast1; AnnualWaterUse.Nevada_Forecast1; AnnualWaterUse.Arizona_Forecast1<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            % "AnnualWaterUse" & ( state CONCAT "_Forecast1" ) [@"24:00:00 December 31, Current Year"] := IF ( state == "Nevada" )
 THEN
  $ "Nevada_CU_Forecast1.SNWP" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.BigBend" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.FtMohaveNv" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.LMNRA Mohave" [@"24:00:00 December 31, Current Year"] + $ "Nevada_CU_Forecast1.SCE" [@"24:00:00 December 31, Current Year"]
 ELSE
  IF ( state == "California" )
  THEN
   "SumSlotListDates"( % "California_CU_Forecast1", @"24:00:00 December 31, Current Year" ) - $ "California_CU_Forecast1.MWDDiversion" [@"24:00:00 December 31, Current Year"] - $ "California_CU_Forecast1.MWDReturns" [@"24:00:00 December 31, Current Year"]
  ELSE
   "SumSlotListDates"( % "Arizona_CU_Forecast1", @"24:00:00 December 31, Current Year" )
  ENDIF
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set Forecast1";
    DESCRIPTION          "DESCRIPTION: Determine the Annual Demand for each user in each &quot;State_CU_Forecast1&quot; object by summing the actual and consumptive use schedules for each user. <br><br>SLOTS SET: <state>_CU_Forecast1.<user><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" , "Mexico" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Forecast1" ) )) DO
            "GetObject"( state CONCAT "_CU_Forecast1" ) & user [@"24:00:00 December 31, Current Year"] := IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) AND "GetMonth"( @"Start Timestep" ) > 1.00000000 )
 THEN
  "SumSlot"( "GetObject"( state CONCAT "_CU_Actual" ) & user, @"24:00:00 January Max DayOfMonth, Current Year", @"Start Timestep - 1" ) + "SumSlot"( "GetObject"( state CONCAT "_CU_Schedules" ) & user, @"Start Timestep", @"24:00:00 December Max DayOfMonth, Current Year" )
 ELSE
  "AnnualVolumeSlot"( "GetObject"( state CONCAT "_CU_Schedules" ) & user )
 ENDIF;

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "Set Schedules Volume to Flow";
    DESCRIPTION          "DESCRIPTION: For Each user in California, Arizona and Nevada, set the Reach Simulation Diversion request as this will allow the simulation of the Basin for the RiverWare model.  Setting these diversion requests so early in the ruleset allows for this initial setting of Lower Basin Demands that will ultimately sum to be the outflow from Lake Mead.  This step and the following rules will allow for the MTOM model to simulate in a somewhat realistic way and help in the Lake Powell Tier determination that occurs later in the policy. This rule sets the monthly diversion requests for lower basin diversion for each timestep in the run period. - CE 9/17/13<br><br>SLOTS SET:<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December 31, Finish Year") DO
            $ "PaloVerde.Total Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.PaloVerde" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.PaloVerde" [date], date )
 ENDIF;

            $ "CRIR:CRIRAz.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CRIRAz" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CRIRAz" [date], date )
 ENDIF;

            $ "CRIR:CRIRCa.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.CRIRCa" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.CRIRCa" [date], date )
 ENDIF;

            $ "CaPkrToImp:Winterhaven.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Winterhaven" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Winterhaven" [date], date )
 ENDIF;

            $ "CaPkrToImp:CaPumpersAbvImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.CaPumpersAbvImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.CaPumpersAbvImp" [date], date )
 ENDIF;

            $ "AzPkrToImp:AzPumpersAbvImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersAbvImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersAbvImp" [date], date )
 ENDIF;

            $ "AzPkrToImp:BlmPumpersAbvImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BlmPumpersAbvImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BlmPumpersAbvImp" [date], date )
 ENDIF;

            $ "AzPkrToImp:BrookeWater.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BrookeWater" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BrookeWater" [date], date )
 ENDIF;

            $ "AzPkrToImp:CibolaNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CibolaNWR" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CibolaNWR" [date], date )
 ENDIF;

            $ "AzPkrToImp:CibolaValleyIID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.CibolaValleyIID" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.CibolaValleyIID" [date], date )
 ENDIF;

            $ "AzPkrToImp:Ehrenberg.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Ehrenberg" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Ehrenberg" [date], date )
 ENDIF;

            $ "AzPkrToImp:ImperialNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.ImperialNWR" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.ImperialNWR" [date], date )
 ENDIF;

            $ "AzPkrToImp:Parker.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.City of Parker" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.City of Parker" [date], date )
 ENDIF;

            $ "AAC:SaltonSea.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.SaltonSea" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.SaltonSea" [date], date )
 ENDIF;

            $ "AAC:IID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.IID" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.IID" [date], date )
 ENDIF;

            $ "AAC:Coachella.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Coachella" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Coachella" [date], date )
 ENDIF;

            $ "AAC:YumaProject.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.YumaProject" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.YumaProject" [date], date )
 ENDIF;

            $ "AAC:Ranch5.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Ranch5" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Ranch5" [date], date )
 ENDIF;

            $ "GilaAndYumaUsers:CocopahIndRes.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Cocopah Indian Res" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Cocopah Indian Res" [date], date )
 ENDIF;

            $ "GilaAndYumaUsers:DesertLawnMemorial.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.DesertLawnMemorial" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.DesertLawnMemorial" [date], date )
 ENDIF;

            $ "GilaAndYumaUsers:GilaMonsterFarms.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Gila Monster Farms" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Gila Monster Farms" [date], date )
 ENDIF;

            $ "OthersBlwImp:AzPumpersBlwImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersBlwImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersBlwImp" [date], date )
 ENDIF;

            $ "OthersBlwImp:BlmPumpersBlwImp.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BlmPumpersBlwImp" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BlmPumpersBlwImp" [date], date )
 ENDIF;

            $ "OthersBlwImp:SouthernPacific.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.SouthernPacific" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.SouthernPacific" [date], date )
 ENDIF;

            $ "OthersBlwImp:YAO.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YAO" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YAO" [date], date )
 ENDIF;

            $ "OthersBlwImp:YumaIsland.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.YumaIsland" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.YumaIsland" [date], date )
 ENDIF;

            $ "OthersBlwImp:Ft Yuma.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.Ft Yuma" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.Ft Yuma" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:CityOfYuma.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.City of Yuma" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.City of Yuma" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:MCAirStation.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.MCAirStation" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.MCAirStation" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:NGVIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.NGVIDD" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.NGVIDD" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:UnitB.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.UnitB" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.UnitB" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:UofA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.UofA" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.UofA" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:WMIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.WMIDD" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.WMIDD" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YCWUA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YCWUA" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YCWUA" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YID" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YID" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YMIDD.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YMIDD" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YMIDD" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YumaProvingGround.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YumaProvingGround" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YumaProvingGround" [date], date )
 ENDIF;

            $ "GilaGravityMainCanal:YumaUnionHighScl.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.YumaUnionHighScl" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.YumaUnionHighScl" [date], date )
 ENDIF;

            $ "MWDDiversion:Tijuana.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoTJ" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoTJ" [date], date )
 ENDIF;

            $ "MWDDiversion:Tijuana.Depletion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoTJ" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoTJ" [date], date )
 ENDIF;

            $ "MWDDiversion.Total Return Flow" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.MWDReturns" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.MWDReturns" [date], date )
 ENDIF;

            $ "MexicanTreatyDelivery:MexicoSched.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoSched" [date] - $ "Mexico_CU_Actual.MexicoTJ" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoSched" [date] - $ "Mexico_CU_Schedules.MexicoTJ" [date], date )
 ENDIF;

            $ "MexicanTreatyDelivery:MexicoBypass.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoBypass" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoBypass" [date], date )
 ENDIF;

            $ "MexicanTreatyDelivery:MexicoExcess.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Mexico_CU_Actual.MexicoExcess" [date], date )
 ELSE
  "VolumeToFlow"( $ "Mexico_CU_Schedules.MexicoExcess" [date], date )
 ENDIF;

            $ "FtMohaveIndRes:NV.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.FtMohaveNv" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.FtMohaveNv" [date], date )
 ENDIF;

            $ "FtMohaveIndRes:CA.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.FtMohaveCa" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.FtMohaveCa" [date], date )
 ENDIF;

            $ "FtMohaveIndRes:AZ.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.FtMohaveAz" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.FtMohaveAz" [date], date )
 ENDIF;

            $ "NvDvsToPkr:SCE.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.SCE" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.SCE" [date], date )
 ENDIF;

            $ "NvDvsToPkr:BigBend.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.BigBend" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.BigBend" [date], date )
 ENDIF;

            $ "OthersMeadToMohave:LMNRA Nv Mohave.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Nevada_CU_Actual.LMNRA Mohave" [date], date )
 ELSE
  "VolumeToFlow"( $ "Nevada_CU_Schedules.LMNRA Mohave" [date], date )
 ENDIF;

            $ "AzDvsToPkr:BullheadCity.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.BullheadCity" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.BullheadCity" [date], date )
 ENDIF;

            $ "CaDvsToPkr:Chemehuevi.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Chemehuevi" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Chemehuevi" [date], date )
 ENDIF;

            $ "CaDvsToPkr:Needles.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.Needles" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.Needles" [date], date )
 ENDIF;

            $ "CaDvsToPkr:OtherLCWSP.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "California_CU_Actual.OtherLCWSP" [date], date )
 ELSE
  "VolumeToFlow"( $ "California_CU_Schedules.OtherLCWSP" [date], date )
 ENDIF;

            $ "OthersMeadToMohave:DavisDamProject.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.DavisDamProject" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.DavisDamProject" [date], date )
 ENDIF;

            $ "AzDvsToPkr:GoldenShores.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.GoldenShores" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.GoldenShores" [date], date )
 ENDIF;

            $ "AzDvsToPkr:HavasuNWR.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.HavasuNWR" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.HavasuNWR" [date], date )
 ENDIF;

            $ "AzDvsToPkr:LakeHavasuCity.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LakeHavasuCity" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LakeHavasuCity" [date], date )
 ENDIF;

            $ "AzDvsToPkr:MohaveValleyIID.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.MohaveValleyIID" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.MohaveValleyIID" [date], date )
 ENDIF;

            $ "AzDvsToPkr:MohaveWaterConsDist.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.MohaveWaterConsDist" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.MohaveWaterConsDist" [date], date )
 ENDIF;

            $ "AzDvsToPkr:AzPumpersDvsToPkr.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.AzPumpersDvsToPkr" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.AzPumpersDvsToPkr" [date], date )
 ENDIF;

            $ "PumpingFromLakeMead:LMNRA Az Mead.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mead" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mead" [date], date )
 ENDIF;

            $ "PumpingFromLakeMead:LMNRA Az Mead.Depletion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mead" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mead" [date], date )
 ENDIF;

            $ "OthersMeadToMohave:LMNRA Az Mohave.Diversion Requested" [date] := IF ( date < @"Start Timestep" )
 THEN
  "VolumeToFlow"( $ "Arizona_CU_Actual.LMNRA Az Mohave" [date], date )
 ELSE
  "VolumeToFlow"( $ "Arizona_CU_Schedules.LMNRA Az Mohave" [date], date )
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Set LC Actuals";
    DESCRIPTION          "DESCRIPTION: This rule sets the historical flows for California MWD and Nevada SNWP for January of the start year to the month before the start timestep. - CE, 9/17/13<br><br>SLOTS SET: California_CU_Actual.MWD; Nevada_CU_Actual.SNWP<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
          DESCRIPTION          "Set the MWD Consumptive Use actual values based on the input MWDDiversion actual values <br>and the Actual MWD Return input values. <br>";
      $ "California_CU_Actual.MWD" [date] := IF ( IsNaN $ "California_CU_Actual.MWD" [date] AND NOT IsNaN $ "California_CU_Actual.MWDDiversion" [date] )
 THEN
  $ "California_CU_Actual.MWDDiversion" [date] - $ "California_CU_Actual.MWDReturns" [date]
 ENDIF;

          DESCRIPTION          "Set the SNWP Actuals to the Actual input party values for SNWP";
      $ "Nevada_CU_Actual.SNWP" [date] := $ "Nevada_CU_Actual.SNWADiversion" [date] + $ "Nevada_CU_Actual.BasicManagement" [date] + $ "Nevada_CU_Actual.LMNRA Mead" [date] + $ "Nevada_CU_Actual.BoulderCanyonProject" [date] + $ "Nevada_CU_Actual.NvDeptFishGame" [date] + $ "Nevada_CU_Actual.PacificCoastBuilding" [date] + $ "Nevada_CU_Actual.City of Henderson" [date] - $ "Nevada_CU_Actual.LVWashReturns" [date];

      ENDFOREACH;

    END;

    RULE                 "Set Actuals to Zero In Future";
    DESCRIPTION          "DESCRIPTION: This rule sets the actual water use to zero over the run period for the each user in the lower basin. This rule fires at the start timestep of the first runcycle. -CE 9/17/13<br><br>SLOTS SET: AnnualWaterUse.AzNoCAPTotalMonthlyActual; AnnualWaterUse.CaNoPVYPIIDTotalMonthlyActual; AnnualWaterUse.NvTotalMonthlyActual; AnnualWaterUse.P123bTotalMonthlyActual; <state>_CU_Actual.<user><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"Start Timestep" TO @"Finish Timestep") DO
            FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Actual" ) )) DO
            "GetObject"( state CONCAT "_CU_Actual" ) & user [date] := 0.00000000 "acre-ft";

      ENDFOREACH;

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "Set NaN Actuals To Schedule";
    DESCRIPTION          "DESCRIPTION: This rule sets the Acutal schedules for each state to the Consumptive use schedule if the Actual schedule was not input to the MTOM Model. This step is done to prevent any model failure if data does not exist due to that data not being entered or imported into the MTOM model. This rule fires only on the start timestep of the first run cycle<br><br>SLOTS SET: <state>_CU_Actual.<user><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"Start Timestep - 1") DO
            FOREACH (STRING state IN { "California" , "Arizona" , "Nevada" , "Mexico" }) DO
            FOREACH (STRING user IN "SlotToString"( "GetObject"( state CONCAT "_CU_Actual" ) )) DO
            "GetObject"( state CONCAT "_CU_Actual" ) & user [date] := IF ( user != "SNWP" )
 THEN
  IF ( IsNaN "GetObject"( state CONCAT "_CU_Actual" ) & user [date] )
  THEN
   "GetObject"( state CONCAT "_CU_Schedules" ) & user [date]
  ENDIF
 ENDIF;

      ENDFOREACH;

      ENDFOREACH;

      ENDFOREACH;

    END;

    RULE                 "Set LC Annual Schedules";
    DESCRIPTION          "DESCRIPTION: This rule calculates the annual consumptive use (CU) schedules for Nevada and California. This rule fires for all run cycles. -CE 9/17/13<br><br>SLOTS SET: Nevada_CU_AnnualApproval.SNWP; California_CU_AnnualApproval.MWDReturns; California_CU_AnnualApproval.MWD<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Thist rule sets the data slots for Annual Consumptive Use Approval for SNWP and MWD";
      $ "Nevada_CU_AnnualApproval.SNWP" [@"24:00:00 December 31, Current Year"] := "AnnualVolumeSlot"( $ "Nevada_CU_Schedules.SNWP" );

      $ "California_CU_AnnualApproval.MWDReturns" [@"24:00:00 December 31, Current Year"] := "AnnualVolumeSlot"( $ "California_CU_Schedules.MWDReturns" );

      $ "California_CU_AnnualApproval.MWD" [@"24:00:00 December 31, Current Year"] := "AnnualVolumeSlot"( $ "California_CU_Schedules.MWD" );

    END;

    RULE                 "Set LC Monthly Schedules";
    DESCRIPTION          "DESCRIPTION: This rule sets the consumptive use schedules for Nevada and California. -CE 9/17/13. Set the SNWP and MWD schedules based on the input consumptive use schedules for the various entities listed.  For SNWP this includes all groups with schedules for which the SNWP diversion delivers water.  For MWD, the return flow schedule is assumed to be constant at 8.5 acre-feet per day.  The MWDDiversion slot is input and so the returns schedule and the MWD (consumptive use portion) is set by this rule. <br><br>SLOTS SET: Nevada_CU_Schedules.SNWP; California_CU_Schedules.MWDReturns; California_CU_Schedules.MWD<br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) >= 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      FOREACH (DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO "Dec31ofYear"( @"Finish Timestep" ) COMMENTED_BY "This is for testing purposes, this should be Finish timestep<br>when the model is actually moved forward and all input<br>is taken care of") DO
            $ "Nevada_CU_Schedules.SNWP" [date] := $ "Nevada_CU_Schedules.SNWADiversion" [date] + $ "Nevada_CU_Schedules.BasicManagement" [date] + $ "Nevada_CU_Schedules.LMNRA Mead" [date] + $ "Nevada_CU_Schedules.BoulderCanyonProject" [date] + $ "Nevada_CU_Schedules.NvDeptFishGame" [date] + $ "Nevada_CU_Schedules.PacificCoastBuilding" [date] + $ "Nevada_CU_Schedules.City of Henderson" [date] - $ "Nevada_CU_Schedules.LVWashReturns" [date];

            $ "California_CU_Schedules.MWDReturns" [date] := 8.50000000 "acre-feet" * ( "GetDaysInMonth"( date ) / 1.00000000 "day" );

            $ "California_CU_Schedules.MWD" [date] := $ "California_CU_Schedules.MWDDiversion" [date] - 8.50000000 "acre-feet" * ( "GetDaysInMonth"( date ) / 1.00000000 "day" );

      ENDFOREACH;

    END;

  END;

  POLICY_GROUP   "Data Setup";
  DESCRIPTION    "";
  ACTIVE         TRUE;
  NOTES          "";
  BEGIN

    RULE                 "Compute Upper Basin Gains";
    DESCRIPTION          "DESCRIPTION: This rule calculates the local gains for each reservoir and local inflow in the upper basin from the relevent RFC forecasts. - CE 9/17/13 Assign each one of the reach simulation Local Inlow slots in the Upper basin based on the input <br>CBRFC forecast values that are input to the model on data objects.  The CBRFC forecasts for the headwater reservoirs (Taylor Park, Fontenelle and Vallecito) are input directly to the simulation reservoir object.  For the reach objects, consideration needs to be made to any upstream forecasts and the appropriate intervening flow for the reach needs to be determined.  This rule makes that calculation.<br><br>SLOTS SET: ColoradoAbovePowell:InterveningAbovePowell.Local Inflow; UpperSanJuan.Inflow; GreenBelowFlamingGorge:YampaRiver.Local Inflow; SanJuanBelowNavajo:AnimasRiver.Local Inflow; GunnisonBelowCrystal:GunnisonNrGJ_Whitewater.Local Inflow; GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow; GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow; GunnisonAboveBlueMesa:InterveningAboveBlueMesa.Local Inflow; Azotea Tunnel.Fractional Return Flow; GreenAboveFlamingGorge:InterveningAboveFlamingGorge.Local Inflow; GReenAboveFlamingGorge.Outflow<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOREACH (DATETIME index IN @"Start Timestep" TO @"Finish Timestep") DO
            $ "ColoradoAbovePowell:InterveningAbovePowell.Local Inflow" [index] := $ "PowellInflow.Unregulated" [index] + ( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [index] + $ "Azotea Tunnel.Diversion Requested" [index] + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [index] ) - ( ( $ "CrystalInflow.Unregulated" [index] + $ "FlamingGorgeInflow.Unregulated" [index] + $ "NavajoInflow.ModUnregulated" [index] + NaNToZero ( $ "GainsCrystalToGJ.GainsCrystalToGJ" [index] ) + NaNToZero ( $ "AnimasRiverInflow.Animas_at_Durango" [index] ) ) + NaNToZero ( $ "YampaRiverInflow.Yampa_at_Deerlodge" [index] ) );

            $ "UpperSanJuan.Inflow" [index] := $ "NavajoInflow.ModUnregulated" [index] - $ "Vallecito.Inflow" [index];

            $ "GreenBelowFlamingGorge:YampaRiver.Local Inflow" [index] := NaNToZero ( $ "YampaRiverInflow.Yampa_at_Deerlodge" [index] );

            $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" [index] := NaNToZero ( $ "AnimasRiverInflow.Animas_at_Durango" [index] );

            $ "GunnisonBelowCrystal:GunnisonNrGJ_Whitewater.Local Inflow" [index] := NaNToZero ( $ "GainsCrystalToGJ.GainsCrystalToGJ" [index] );

            $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [index] := $ "MorrowPointInflow.Unregulated" [index] - $ "BlueMesaInflow.Unregulated" [index];

            $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [index] := $ "CrystalInflow.Unregulated" [index] - $ "MorrowPointInflow.Unregulated" [index];

            $ "GunnisonAboveBlueMesa:InterveningAboveBlueMesa.Local Inflow" [index] := $ "BlueMesaInflow.Unregulated" [index] - $ "TaylorPark.Inflow" [index];

          DESCRIPTION          "This assignment is necessary for RW 6.6. Per instruction from BoR this value is set to 0 for all <br>timesteps. LJ 03/19/2015.";
      $ "Azotea Tunnel.Fractional Return Flow" [index] := 0.00000000;

          INACTIVE    DESCRIPTION          "This is added because these local inflows need to be assigned and the previous rule &quot;Forecast <br>Test&quot; has been removed. The Local Inflow at the Gila River is set to 0 AF/Month. TP 6/12/2015<br><br>LBDV.GilaRiverLocalInflow and BID:Gila River.Local Inflow share the name &quot;GilaRiver&quot; in the OutToMTPO name map used in the Excel Input DMI. LBDV.GilaRiverLocalInflow is set by DMI for the period (Start-12) to (Dec, Finish Year), <br>but BID:Gila River.Local Inflow is set here with LBDV.GilaRiverLocalInflow. Can BID.Gila River be set by DMI or does it need to be set by rule? MC 20161101<br>";
      $ "BelowImperialDam:Gila River.Local Inflow" [index] := $ "LowerBasinDemandVariability.GilaRiverLocalInflow" [index];

      ENDFOREACH;

      FOREACH (DATETIME index IN "OffsetDate"( "RunStartDate"(  ), - 12.00000000, "1 months" ) TO "OffsetDate"( "RunEndDate"(  ), 12.00000000, "1 months" )) DO
            $ "GreenAboveFlamingGorge:InterveningAboveFlamingGorge.Local Inflow" [index] := $ "FlamingGorgeInflow.Unregulated" [index] - $ "Fontenelle.Inflow" [index];

      ENDFOREACH;

      FOREACH (DATETIME index IN "OffsetDate"( "RunStartDate"(  ), - 12.00000000, "1 months" ) TO "OffsetDate"( "RunStartDate"(  ), - 1.00000000, "1 months" )) DO
            $ "GreenAboveFlamingGorge.Outflow" [index] := $ "FlamingGorgeInflow.Unregulated" [index] - $ "Fontenelle.Inflow" [index] + $ "Fontenelle.Outflow" [index];

      ENDFOREACH;

    END;

    RULE                 "SetCaliforniaPreliminaryStateAdjustedApportionment";
    DESCRIPTION          "DESCRIPTION: For any out year, the California State Apportionment needs to be adjusted based on the estimated Payback and estimated EC ICS Creation for IID that is input to the model. This preliminary adjustment to the CA State Apportionment allows for a calculation of MWD Diversion that takes the estimated parameters into consideration. This is a more realistic calculation than using the standard CA State Apportionment. The payback and ICS Creation can be adjusted in later logic and the MWD can be adjusted again.<br><br>SLOTS SET: AnnualWaterUse.California_PreliminaryAdjustedApportionment[Current Year]";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" OR @"t" == @"24:00:00 January 31, Current Year" AND ( ( "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "ThisRule" ) ) OR ( "GetRunCycleIndex"(  ) == 3.00000000 AND NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 ) );
    NOTES                "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20160623: Added the Execution Constraint to allow the rule to refire if in Run Cycle 3 AND Shortage is in effect and the alternate calculation in the rule if that is the case.  In the case of shortage, EC ICS Creation is not allowed and the value (Input to the model) is not used in the calculation of apportionment.  Subsequent rules (Reset MWD Annual Forecast Use - Force to CA Apportionment, Reset Monthly Forecast Use MWD - All Months Outyears, Reset Monthly Forecast Use MWD - Nov and Dec, Cur Year, and Redistribute MWD Nov & Dec Div Request) that depend on the value calculated in this rule were also modified to allow execution in Run Cycle 3 if Shortage is in effect.";
    BEGIN

      $ "AnnualWaterUse.California_PreliminaryAdjustedApportionment" ["Dec31ofYear"( @"t" )] := IF ( "IsMRM"(  ) )
 THEN
  IF ( "GetYear"( @"t" ) == "GetYear"( @"Start Timestep" ) )
  THEN
   $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
  ELSE
   IF ( NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
   THEN
    $ "AnnualWaterUse.CA_BasicApportionment" [] - $ "ICSProjectionData.California_EstimatedPayback" ["Dec31ofYear"( @"t" )] - $ "ICSProjectionData.CA_SystemConservation" ["Dec31ofYear"( @"t" )]
   ELSE
    $ "AnnualWaterUse.CA_BasicApportionment" [] - $ "ICSProjectionData.California_EstimatedPayback" ["Dec31ofYear"( @"t" )] - $ "ICSProjectionData.California_ECICSCreationIID" ["Dec31ofYear"( @"t" )] - $ "ICSProjectionData.CA_SystemConservation" ["Dec31ofYear"( @"t" )]
   ENDIF
  ENDIF
 ELSE
  $ "AnnualWaterUse.California_Apportionment" [@"24:00:00 December 31, Current Year"]
 ENDIF;

    END;

    RULE                 "INPUT MISSING NOTIFICATION";
    DESCRIPTION          "DESCRIPTION: This rule checks if the necessary RFC inflow information has been entered. This includes inflow information for all upper basin reserviors. -CE 9/17/13<br><br>SLOTS SET: <br><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT TRUE;
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE, 9/17/13 ";
    BEGIN

    DESCRIPTION          "This rule executes if there is missing input data and if this rule. If this rule does execute and <br>give an error, make sure the input data sheet is set up correctly (CBRFC_EnsembleForecast) <br>and that the run period is correct for the current model run.  ";
      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "BlueMesaInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: BlueMesaInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "TaylorPark.Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: TaylorPark.Inflow Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "MorrowPointInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: MorrowPointInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "CrystalInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: CrystalInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "FlamingGorgeInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: FlamingGorgeInflow.Unregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Fontenelle.Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: Fontenelle.Inflow Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "NavajoInflow.ModUnregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: NavajoInflow.ModUnregulated Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Vallecito.Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: Vallecito.Inflow Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "PowellInflow.Unregulated" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: PowellInflow.Unregulated Missing"
 ENDIF;

    INACTIVE      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: NavajoIndianIrrigationProjectNIIP.Diversion Requested Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "Azotea Tunnel.Diversion Requested" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: AzoteaTunnel.Diversion Requested Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: TunnelDiversionBelowCrystalForAg.Diversion Requested Missing"
 ENDIF;

      $ "DummyDataObject.DummyDataSlot" [] := IF ( IsNaN $ "SanJuanBelowNavajo:AnimasRiver.Local Inflow" [] )
 THEN
  STOP_RUN "Run Stopped, Gain Calculation Failed: SanJuanBelowNavajo:AnimasRiver.Local Inflow Missing"
 ENDIF;

    END;

    RULE                 "Set Extended Forecasts to Historic Average Hydrology";
    DESCRIPTION          "DESCRIPTION: This rule sets the inflow above Fontenelle and the unregulated inflow to Flaming Gorge for the 12 months beyond the run end date. Note that the rule actually will set all unpopulated (NaN) timesteps from the run start to 12 months after the finish with historic average values. However, the DMI Excel_InputFrom24MS populates the run period values as Inputs. The DMI is set to import values until Finish Timestep + 12 timesteps, but only those values until the end of the run are currently provided by the spreadsheet.<br><br>SLOTS SET: Fontenelle.Inflow; FlamingGorgeInflow.Unregulated";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>SC, 20111201: This rule set the inflows above Fontenelle, the unregulated inflow to Flaming Gorge, and the Yampa River Inflow for the 12 months beyond the run end date.  These values are needed by the operations rules for Flaming Gorge and Fontenelle as written by CADSWES.  Would be nice to review these rules and see if this is absolutely necessary. - sc 12/1/11<br>MC, 20160913: The comment in the body suggests the forecasts will be extended beyond the Finish Timestep by historic values, but actually all timesteps are being set with those values. Are the values being used?";
    BEGIN

    DESCRIPTION          "This rule will extend the forecasts for the locations specified beyond the RFC forecast period.  <br>The values in the extended forecast are set to historic input values for the specific location.";
      FOREACH (DATETIME index IN @"Start Timestep" TO @"Finish Timestep + 12") DO
            $ "Fontenelle.Inflow" [index] := IF ( IsNaN $ "Fontenelle.Inflow" [index] )
 THEN
  $ "HistoricData.HistoricAverageMonthlyInflows" [index, "FontenelleMonthlyAveInflow"]
 ENDIF;

            $ "FlamingGorgeInflow.Unregulated" [index] := IF ( IsNaN $ "FlamingGorgeInflow.Unregulated" [index] )
 THEN
  $ "HistoricData.HistoricAverageMonthlyInflows" [index, "FlamingGorgeMonthlyAveUnregInflow"]
 ENDIF;

      ENDFOREACH;

    END;

    RULE                 "Run Cycle Counter Print Message";
    DESCRIPTION          "DESCRIPTION: This rule records the run cycle in the diagnostic output window for debugging purposes. -CE 9/17/13<br><br>SLOTS SET: <NONE><br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep";
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE, 9/17/13";
    BEGIN

      PRINT "******************************************************";

      PRINT "Begin Run Cycle # " CONCAT "GetRunCycleIndex"(  );

      PRINT "******************************************************";

    END;

    RULE                 "Set LB Demand Variability Triggers Below Parker";
    DESCRIPTION          "DESCRIPTION: This rule fires in the beginning timestep but sets the trigger values for the whole run. Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request based on side inflow hydrology between certain locations.  The below Parker variability takes into considerations the side inflows below Parker Dam and sets a slot value (trigger) that will be used when compared to a historic statistically derived volume to determine the variability thresholds. This rule only sets the volumes and those will be used in subsequent rules when compared to historic threshold inflow values. <br><br>SLOTS SET: LowerBasinDemandVariability.LocalInflowBelowParkerTrigger<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "ThisRule" );
    NOTES                "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request based on side inflow hydrology between certain locations.  The <br>below Parker variability takes into considerations the side inflows below Parker Dam and sets a slot value (trigger) that will be used when compared to a historic statistically derived <br>volume to determine the variability thresholds. This rule only sets the volumes and those will be used in subsequent rules when compared to historic threshold inflow values. ";
      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (date == @"Start Timestep" OR "GetMonth"( date ) == 9.00000000 AND "OffsetDate"( date, 4.00000000, "1 Months" ) <= @"Finish Timestep") THEN
            IF_STATEMENT (date == @"Start Timestep") THEN
            IF_STATEMENT ("GetMonth"( date ) < 10.00000000) THEN
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVolYr2 = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowBelowParkerVolYr2;

      END_WITH_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowBelowParkerVol = "SumFlowsToVolume"( $ "BelowImperialDam:GainsImpToNIB.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "HavasuToImperial:GainsPkrToImp.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" )] := sideInflowBelowParkerVol;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

    RULE                 "Set LB Demand Variability Triggers Above Hoover";
    DESCRIPTION          "DESCRIPTION: This rule fires in the beginning timestep but sets the trigger values for the whole run.  Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request based on side inflow hydrology between certain locations.  <br>The above Mead variability takes into considerations the side inflows below Glen Canyon Dam and above Hoover Dam and sets a slot value (trigger) that will be used when compared to a historic statistically-derived volume to determine the variability thresholds. <br>This rule only determines the side inflow volume that will be used later for the comparison.<br><br>SLOTS SET: LowerBasinDemandVariability.LocalInflowAboveHooverTrigger; LowerBasinDemandVariability.PowellUnregulatedInflowTrigger<br><br>";
    ACTIVE               TRUE;
    RULE_EXEC_CONSTRAINT @"t" == @"Start Timestep" AND "GetRunCycleIndex"(  ) == 1.00000000 AND NOT "HasRuleFiredSuccessfully"( "ThisRule" );
    NOTES                "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

    DESCRIPTION          "Lower Basin Demand Variability determines if users in the Lower Basin can increase or decrease their diversion request <br>based on side inflow hydrology between certain locations.  <br>The above Mead variability takes into considerations the side inflows below Glen Canyon Dam and above Hoover Dam <br>and sets a slot value (trigger) that will be used when compared to a historic statistically-derived volume to determine the <br>variability thresholds. <br>This rule only determines the side inflow volume that will be used later for the comparison.";
      FOREACH (DATETIME date IN "GetDates"( @"Start Timestep", @"Finish Timestep", "1 Months" )) DO
            IF_STATEMENT (( date == @"Start Timestep" OR "GetMonth"( date ) == 9.00000000 AND "OffsetDate"( date, 4.00000000, "1 Months" ) <= @"Finish Timestep" ) COMMENTED_BY "Note that the following expression evaluates as &quot;(A OR B) AND C&quot;, not as &quot;A OR (B AND C)&quot; - mc, <br>1/4/2016") THEN
            IF_STATEMENT (date == @"Start Timestep") THEN
            IF_STATEMENT ("GetMonth"( date ) < 10.00000000) THEN
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVolYr2 = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowAboveHooverVolYr2;

      END_WITH_STATEMENT;

          INACTIVE      WITH_STATEMENT (NUMERIC unregInflowPowellYr2 = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", @"24:00:00 October 31, Current Year", "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 2.00000000 ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := unregInflowPowellYr2;

      END_WITH_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year", "Dec31ofYear"( date ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVolYr2 = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", @"24:00:00 January 31, Current Year + 12", "Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( @"24:00:00 January 31, Current Year + 12" )] := sideInflowAboveHooverVolYr2;

      END_WITH_STATEMENT;

          INACTIVE      WITH_STATEMENT (NUMERIC unregInflowPowellYr2 = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", @"24:00:00 October 31, Current Year", "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( 1.00000000 ) ) )] := unregInflowPowellYr2;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      ELSE
            WITH_STATEMENT (NUMERIC sideInflowAboveHooverVol = "SumFlowsToVolume"( $ "PowellToMead:GainsAboveHoover.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "PowellToMead:GainsGrandCanyon.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) ) + "SumFlowsToVolume"( $ "PowellToMead:LeesFerryGage.Local Inflow", "OffsetDate"( "Dec31ofYear"( date ), 1.00000000, "1 Months" ), "OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" ) )) DO
            $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["OffsetDate"( "Dec31ofYear"( date ), 12.00000000, "1 Months" )] := sideInflowAboveHooverVol;

      END_WITH_STATEMENT;

          INACTIVE      WITH_STATEMENT (NUMERIC waterYearNumber = "GetYear"( date ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 )
 THEN
  1.00000000
 ELSE
  2.00000000
 ENDIF) DO
            WITH_STATEMENT (NUMERIC unregInflowPowell = "SumFlowsToVolume"( $ "PowellInflow.Unregulated", "OffsetDate"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ), - 11.00000000, "1 Months" ), "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )) DO
            $ "LowerBasinDemandVariability.PowellUnregulatedInflowTrigger" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM "WaterYearDatesByGroup"( waterYearNumber ) ) )] := unregInflowPowell;

      END_WITH_STATEMENT;

      END_WITH_STATEMENT;

      END_IF_STATEMENT;

      END_IF_STATEMENT;

      ENDFOREACH;

    END;

  END;

  UTILITY_GROUP "Powell Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "B1_Branch_UpperBalancingTierVolume" ( DATETIME eowyDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the Powell release volume when the tier has been designated as Upper Elevation Balancing, Branch B1. The release attempts to balance the Powell and Mead end of water year storages, within the release range of 8.23 MAF and 9.0 MAF, if the elevation criteria are met; otherwise, the release is set to 8.23 MAF<br><br>RETURNS: Annual release volume from Lake Powell<br><br>ARGUMENTS:<br>1. DATETIME eowyDate - the end of water year date at which to compare the Powell and Mead storages<br><br>CONSTRAINTS: Releases no less than 8.23 MAF and no more than 9.0 MAF<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT $ "PowellData.UpperTierB4MinAnnualRelease" [];
    MAX_CONSTRAINT $ "PowellData.UpperTierB4MaxAnnualRelease" [];
    NOTES          "DEVELOPMENT NOTES<br>MC, 20160801: Included consideration for possible untransferred carryover volume between Powell and Mead<br>MC, 20170501: Added Post-Execution Checks and removed unneeded call to user-defined function EnsureReleaseLimits, which applied the same constraints that are now in the Post-Execution Checks";
    BEGIN

      WITH DATETIME eoyDate = "Dec31ofYear"( eowyDate ) DO
  WITH NUMERIC CarryoverVolume = NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [eoyDate] ) DO
   WITH NUMERIC PowellEffectivePool = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", $ "Powell.Pool Elevation" [eowyDate] ) - CarryoverVolume ) DO
    WITH NUMERIC MeadEffectivePool = "StorageToElevation"( % "Mead", "ElevationToStorage"( % "Mead", $ "Mead.Pool Elevation" [eowyDate] ) + CarryoverVolume ) DO
     IF ( MeadEffectivePool <= 1075.00000000 "ft" AND PowellEffectivePool > 3575.00000000 "ft" OR ( "IsInput"( $ "PowellData.UpperElevBalBranch", "Dec31ofYear"( "RelativeEOWYDate"( @"t" ) ) ) AND $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "RelativeEOWYDate"( @"t" ) )] == 1.40000000 ) COMMENTED_BY "If the tier specification is user input for UEB, then release what is suggested for <br>that tier. This is placed so that if a specific Tier and balancing branch for any <br>year, but specifically WY1 has been made, then the logic will honor that and <br>estimate a balancing release instead of an 8.23 MAF release. TP 10/17/2017 <br>" )
     THEN
      "EqualizationReleaseWithCarryover"( eowyDate )
     ELSE
      $ "PowellData.BaseAnnualRelease" [] COMMENTED_BY "BaseAnnualRelease is 8.23 MAF"
     ENDIF
    ENDWITH
   ENDWITH
  ENDWITH COMMENTED_BY "Calculate effective pool elevations as if any carryover volume had been transferred for comparison to pool elevation trigger levels"
 ENDWITH COMMENTED_BY "If Mead's EOWY elevation is less than 1075' and Powell's EOWY elevation is greater than 3575' then release enough to balance <br>the storages up to 9.0 MAF and no less than 8.23 MAF annual release volume.  Otherwise just release 8.23 MAF.";

    END;

    FUNCTION       "B2_Branch_UpperBalancingTierVolume" ( DATETIME eowyDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the Powell release volume when the tier has been designated as Upper Elevation Balancing, Branch B2. The release attempts to balance the Powell and Mead end of water year storages, within the release range of 7.0 MAF and 9.0 MAF<br><br>RETURNS: Annual release volume from Lake Powell<br><br>ARGUMENTS:<br>1. DATETIME eowyDate - the end of water year date at which to compare the Powell and Mead storages<br><br>CONSTRAINTS: Releases no less than 7.0 MAF and no more than 9.0 MAF<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>MC, 20160801: Included consideration for possible untransferred carryover volume between Powell and Mead";
    BEGIN

      "EnsureReleaseLimits"( "EqualizationReleaseWithCarryover"( eowyDate ), $ "PowellData.UpperTierB2MinAnnualRelease" [], $ "PowellData.UpperTierB2MaxAnnualRelease" [] );

    END;

    FUNCTION       "CalcReleaseForMaxPoolElevation" ( LIST waterYearDates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: this function calculates a minimum annual volume needed to be released from Powell in order to keep the reservoir from overfilling and crashing the run during the preliminary annual volume setting phase.  The preliminary volume will be 8.23 MAF in most cases, but if the inflows are high or the starting storage in Powell is high and 8.23 MAF is not enough to keep Powell from overfilling, then this function calculates the annual volume needing to be released in order to just prevent overfilling and crashing the model (does not currently include terms for evap and bankstorage).  An exact annual release volume will be calculated in subsequent rules. - sc 03/25/11<br><br>RETURNS: Water volume required to be released from Lake Powell to prevent overfilling [L^3]<br><br>ARGUMENTS:<br>1. LIST waterYearDates - list of the dates remaining in the water year<br><br>CONSTRAINTS: Value greater than or equal to 0 acre-feet<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT 0.00000000 "acre-ft";
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 03/25/2011";
    BEGIN

      WITH DATETIME firstTimestep = GET @INDEX 0.00000000 FROM waterYearDates DO
  WITH DATETIME lastTimestep = IF ( ( LENGTH waterYearDates ) >= 3.00000000 )
  THEN
   GET @INDEX ( LENGTH waterYearDates ) - 3.00000000 FROM waterYearDates
  ELSE
   GET @INDEX ( LENGTH waterYearDates ) - 1.00000000 FROM waterYearDates
  ENDIF DO
   ( ( $ "Powell.Storage" ["OffsetDate"( firstTimestep, - 1.00000000, " 1 months" )] + "SumFlowsToVolume"( $ "Powell.Inflow", firstTimestep, lastTimestep ) - "ElevationToStorage"( % "Powell", 3711.00000000 "feet" ) ) / ( ( ( lastTimestep - firstTimestep ) + 1.00000000 "month" ) * 0.90000000 ) ) COMMENTED_BY "The factor 0.9 in the denominator ensures the calculated volume is slightly greater than the volume that takes the pool elevation just to its maximum"
  ENDWITH COMMENTED_BY "lastTimestep date is July 31 unless firstTimestep is August or September, in which case lastTimestep is September 30"
 ENDWITH COMMENTED_BY "The period firstTimestep to lastTimestep is used to calculate an annualized volume to release from Powell to avoid overfilling." * 1.00000000 "year";

    END;

    FUNCTION       "CurrentAnnualVolume" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and returns the annual release volume for Powell for the water year in which the passed-in date lies.<br><br>RETURNS: Target annual release volume in 1000 acre-feet<br><br>ARGUMENTS:<br>1. DATETIME date - a date within the run period<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: sc, 20110215";
    BEGIN

      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( date ) )];

    END;

    FUNCTION       "EqualizationRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function attempts to equalize the end of water year Powell and Mead storages by adding half the difference between the currently calculated end of water year storages to the target annual release from Powell<br><br>RETURNS: Annual release volume in 1000 kaf<br><br>ARGUMENTS:<br>1. DATETIME EOWYdate - the end of water year date for which the storages should be compared<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] + ( $ "Powell.Storage" [EOWYDate] - $ "Mead.Storage" [EOWYDate] ) / ( 2.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] );

    END;

    FUNCTION       "EqualizationTierCalculationForRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the target annual release volume and the controlling equalization condition (constraint) when Powell is operating in the Equalization tier; the controlling equalization condition represents the condition constraining the calculated release volume<br><br>RETURNS: List of the form &lcub;Annual release volume in 1000 kaf, Controlling Equalization Condition&rcub;<br><br>ARGUMENTS:<br>1. DATETIME EOWYdate - the end of water year date <br><br>CONSTRAINTS: The calculated release volume may be constrained by: the Powell equalization level for the water year; equalized storage in Powell and Mead; Mead pool elevation reaches 1,105 ft; Powell pool elevation reaches 20 ft less than the equalization level for the water year<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC PowellVolumeOverEqLevel = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) ), 0.00000000 "acre-ft" ) DO
  WITH NUMERIC EqualizationReleaseVolume = "EqualizationRelease"( EOWYDate ) DO
   WITH NUMERIC PreliminaryReleaseVolume = "Min"( PowellVolumeOverEqLevel / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )], EqualizationReleaseVolume ) DO
    WITH NUMERIC MeadElevationWithPrelimRelease = IF ( $ "Mead.Storage" [EOWYDate] + ( PreliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) * ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) >= "ElevationToStorage"( % "Mead", 1229.00000000 "feet" ) )
    THEN
     1229.00000000 "feet"
    ELSE
     "StorageToElevation"( % "Mead", $ "Mead.Storage" [EOWYDate] + ( PreliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) * ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) )
    ENDIF DO
     IF ( MeadElevationWithPrelimRelease < 1105.00000000 "ft" )
     THEN
      WITH NUMERIC totalVolumeToRaiseMeadTo1105 = "Max"( ( "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - $ "Mead.Storage" [EOWYDate] ) / ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ), 0.00000000 "acre-ft" ) DO
       WITH NUMERIC PowellVolumeOverEqLevelLess20ft = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" ), 0.00000000 "acre-ft" ) DO
        IF ( EqualizationReleaseVolume < totalVolumeToRaiseMeadTo1105 AND EqualizationReleaseVolume < PowellVolumeOverEqLevelLess20ft / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) )
        THEN
         { EqualizationReleaseVolume + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.30000000 }
        ELSE
         IF ( totalVolumeToRaiseMeadTo1105 < EqualizationReleaseVolume AND totalVolumeToRaiseMeadTo1105 < PowellVolumeOverEqLevelLess20ft )
         THEN
          { totalVolumeToRaiseMeadTo1105 + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.40000000 }
         ELSE
          { PowellVolumeOverEqLevelLess20ft / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] , 0.50000000 }
         ENDIF
        ENDIF COMMENTED_BY "Choose the minimum of the equalization release, the release to take Mead to 1105 and the release to take Powell down to the equalization level less 20'"
       ENDWITH COMMENTED_BY "Volume of Powell storage above the equalization level minus 20 feet"
      ENDWITH COMMENTED_BY "Volume needed to release from Powell to raise Mead elevation to 1105'"
     ELSE
      IF ( PreliminaryReleaseVolume == PowellVolumeOverEqLevel / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] ) + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] )
      THEN
       { PreliminaryReleaseVolume , 0.10000000 }
      ELSE
       { PreliminaryReleaseVolume , 0.20000000 }
      ENDIF
     ENDIF COMMENTED_BY "Check if the preliminary release volume takes Mead above 1105'.  If so the preliminary volume is chosen, if not continue."
    ENDWITH COMMENTED_BY "EOWY Elevation of Mead with the preliminaryReleaseVolume release from Powell"
   ENDWITH COMMENTED_BY "Preliminary annual volume release before the Mead elevation check."
  ENDWITH COMMENTED_BY "Total volume that would need to be released to equalize storage"
 ENDWITH COMMENTED_BY "Total Volume in Powell above the Current Equalization Level";

    END;

    FUNCTION       "FindReleaseUpperBoundColumn" ( NUMERIC release )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function finds the index corresponding to the first column in PowellData.PowellMonthlyReleaseTable with an annual total value greater than the release volume value provided as a parameter<br><br>RETURNS: Column index value<br><br>ARGUMENTS:<br>1. NUMERIC release - annual release volume for Powell<br><br>CONSTRAINTS: Min - 0; Max - Number of columns in table - 1<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      WHILE ( release - $ "PowellData.PowellMonthlyReleaseTable" ["AnnualTotal", result] > 0.01000000 "1000 acre-ft" ) WITH NUMERIC result = 0.00000000 DO
  result + 1.00000000
 ENDWHILE COMMENTED_BY "While the annual total of the column with index &quot;result&quot; is less than the provided release volume, increment the value of &quot;result&quot;";

    END;

    FUNCTION       "FindReleaseLowerBoundColumn" ( NUMERIC release, NUMERIC upperbound )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function finds the index corresponding to the first column in PowellData.PowellMonthlyReleaseTable with an annual total value less than the release volume value provided as a parameter. If the provided release volume is exactly equal to a column total, the lower bound index and upper bound index are equal.<br><br>RETURNS: Column index value<br><br>ARGUMENTS:<br>1. NUMERIC release - annual release volume for Powell<br>2. NUMERIC upperbound - index of the upper bound column in the table<br><br>CONSTRAINTS: Min - 0; Max - Number of columns in table - 1<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( $ "PowellData.PowellMonthlyReleaseTable" ["AnnualTotal", upperbound] - release < 0.10000000 "1000 acre-ft" )
 THEN
  upperbound
 ELSE
  upperbound - 1.00000000
 ENDIF;

    END;

    FUNCTION       "GetPowellReleasesCorrectedForBypass" ( LIST InitialDateRelease )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list in the form of &lcub;Date, Release&rcub; and estimates a pool elevation for each month with those releases. The function creates a series of three item lists in the form &lcub;Date, Release, Pool elevation&rcub; where if the estimated pool elevation is too low a bypass release is calculated. The pool elevation that goes into the three item list is the calculated pool elevation from the lesser of the outflow that was passed in or the determined bypass outflow. This is passed into the rule Set Powell Outflow and the outflow for Powell is set with these values.<br><br>RETURNS: List of lists of the form &lcub;Date, Release, Pool elevation, Remaining Volume&rcub;<br><br>ARGUMENTS:<br>1. LIST initialDateRelease - list of lists of the form &lcub;Date, Release&rcub;<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "AUTHOR, DATE: TP, 20130701<br>MC, 20170501: Updated internal variable names and removed some internal variables for readability";
    BEGIN

      WITH LIST sortedInitDateRelease = "Sort"( InitialDateRelease ) DO
  WITH DATETIME InitialDate = "OffsetDate"( GET @INDEX 0.00000000 FROM GET @INDEX 0.00000000 FROM sortedInitDateRelease, - 1.00000000, "1 Months" ) DO
   WITH LIST listWithInitDate = FOR ( LIST index IN sortedInitDateRelease ) WITH LIST result = { { InitialDate , "null" , $ "Powell.Pool Elevation" [InitialDate] , GET @INDEX 2.00000000 FROM GET @INDEX 0.00000000 FROM InitialDateRelease } } DO
    WITH NUMERIC PreviousResultPE = GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
     WITH DATETIME PreviousDate = GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
      WITH DATETIME CurrentDate = "OffsetDate"( PreviousDate, 1.00000000, "1 Months" ) DO
       WITH NUMERIC CurrentEstRelease = GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM sortedInitDateRelease DO
        WITH NUMERIC MaxBypassRelease = IF ( PreviousResultPE <= 3500.00000000 "ft" )
        THEN
         "TableInterpolation"( $ "PowellMinObjRelData.Bypass Tube Capacity", 0.00000000, 1.00000000, PreviousResultPE, CurrentDate )
        ELSE
         CurrentEstRelease
        ENDIF DO
         WITH NUMERIC NextOutflow = "Min"( CurrentEstRelease, MaxBypassRelease ) DO
          WITH NUMERIC tempPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [CurrentDate], CurrentDate ) - "FlowToVolume"( NextOutflow, CurrentDate ) - NaNToZero ( $ "Powell.Change in Bank Storage" [CurrentDate] ) ) DO
           WITH NUMERIC NewPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [CurrentDate], CurrentDate ) - "PowellEvapEstimation"( CurrentDate, PreviousResultPE, tempPE ) - "FlowToVolume"( NextOutflow, CurrentDate ) - NaNToZero ( $ "Powell.Change in Bank Storage" [CurrentDate] ) ) DO
            WITH NUMERIC addCarryoverIfAny = IF ( ( ( LENGTH result ) == LENGTH InitialDateRelease ) AND ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) < 0.05000000 "acre-ft" )
            THEN
             "Min"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result, GET @INDEX 2.00000000 FROM index ) + GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH InitialDateRelease ) - 1.00000000 FROM InitialDateRelease
            ELSE
             "Min"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result, GET @INDEX 2.00000000 FROM index )
            ENDIF COMMENTED_BY "Want to use the original InitialDateRelease because the sorted version does not <br>have any carryover that needs to be released next year. <br>" DO
             APPEND { CurrentDate , NextOutflow , NewPE , addCarryoverIfAny * "DebuggerStop"(  ) } ONTO result
            ENDWITH
           ENDWITH
          ENDWITH COMMENTED_BY "Calculate the PE for CurrentDate based on the updated outflow"
         ENDWITH COMMENTED_BY "Calculate the outflow as the minimum of the estimate passed in or the calculated maximum bypass"
        ENDWITH COMMENTED_BY "Calculate the maximum bypass possible based on the previous result PE value"
       ENDWITH COMMENTED_BY "Retrieve the release passed into the function for the current date"
      ENDWITH COMMENTED_BY "Set current date"
     ENDWITH COMMENTED_BY "Retrieve previous result date"
    ENDWITH COMMENTED_BY "Retrieve previous result PE"
   ENDFOR DO
    ( REMOVE ITEM @INDEX 0.00000000 FROM listWithInitDate ) COMMENTED_BY "Remove the unneeded first element of the list of lists"
   ENDWITH COMMENTED_BY "Initialize the list with the timestep and pool elevation prior to the first date in the argument list"
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "CalculatePowellMonthlyRelease" ( LIST datesToEOWY, NUMERIC UpperColumn, NUMERIC LowerColumn, NUMERIC RemainingAnnualVolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume does a linear interpolation on that table to find releases that sum up exactly to the annual volume set for Powell.  If the passed in set of dates is the first water year in the run, ie starts with the run's start timestep, then this function will make an adjustment to the releases that were calculated by doing the linear interpolation to account for what was released int he months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List of lists of the form &lcub;date, release, remaining volume over the lower bound to be released&rcub;<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates to the end of the water year<br>2. NUMERIC UpperColumn - index specifying the upper bound column in the table PowellData.PowellMontlhlyReleaseTable<br>3. NUMERIC LowerColumn - index specifying the lower bound column<br>4. NUMERIC RemainingAnnualVolume - the remaining annual volume to be released; <br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR/DATE: SC, 20110325<br>MC, 20170501: The original version of the model did not have RemainingAnnualVolume as an input, but calculated the remaining volume based on the target annual volume and the volume released prior to the model run; this version provides more flexibility to calculate releases for time periods different than those that begin with the current timestep<br>MC, 20170608: See note about necessity of check on volume in light of that type of check in calling function, GetPowellMonthlyReleases";
    BEGIN

      WITH LIST UpperBoundList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
  WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
   APPEND $ "PowellData.PowellMonthlyReleaseTable" [monthsSinceEOWY + 1.00000000, UpperColumn] ONTO result
  ENDWITH
 ENDFOR DO
  WITH LIST LowerBoundList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
   WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
    APPEND $ "PowellData.PowellMonthlyReleaseTable" [monthsSinceEOWY + 1.00000000, LowerColumn] ONTO result
   ENDWITH
  ENDFOR DO
   WITH NUMERIC RemainingVolumeAboveLowerBounds = RemainingAnnualVolume - "Sum"( LowerBoundList ) DO
    WITH LIST differenceList = FOR ( NUMERIC index IN UpperBoundList ) WITH LIST result = {  } DO
     WITH NUMERIC diff = ( GET @INDEX LENGTH result FROM UpperBoundList ) - GET @INDEX LENGTH result FROM LowerBoundList DO
      APPEND diff ONTO result
     ENDWITH
    ENDFOR DO
     WITH LIST tempList = WHILE ( ( LENGTH result ) < LENGTH differenceList ) WITH LIST result = {  } DO
      APPEND { { GET @INDEX LENGTH result FROM datesToEOWY , GET @INDEX LENGTH result FROM differenceList , GET @INDEX LENGTH result FROM LowerBoundList } , GET @INDEX LENGTH result FROM differenceList } ONTO result
     ENDWHILE DO
      WITH LIST sortedList = "SortPairsDescending"( tempList ) DO
       WITH LIST AlteredReleaseFromTable = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = { { 0.00000000 , 0.00000000 , RemainingVolumeAboveLowerBounds } } DO
        WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
         WITH NUMERIC addedRelease = "Min"( GET @INDEX 1.00000000 FROM GET @INDEX index FROM sortedList, GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) DO
          WITH NUMERIC NewVolRemainAbvLB = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - addedRelease DO
           APPEND { GET @INDEX 0.00000000 FROM GET @INDEX index FROM sortedList , "VolumeToFlow"( "Min"( ( ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM sortedList ) + addedRelease ), RemainingAnnualVolume ) COMMENTED_BY "Do not release more than the total remaining annual volume (MC, 20160907)", GET @INDEX 0.00000000 FROM GET @INDEX index FROM sortedList ) , NewVolRemainAbvLB * "DebuggerStop"(  ) } ONTO result
          ENDWITH COMMENTED_BY "Update remaining total volume over LB to be released"
         ENDWITH COMMENTED_BY "Minimum of monthly capacity available over LB and remaining total volume over LB to be released"
        ENDWITH
       ENDFOR COMMENTED_BY "Initial list element is &lcub;0, 0, RemainingVolumeAboveLowerBounds&rcub;, subsequent elements are of the form: <br>&lcub;Month i, Flow rate for month i, Remaining vol over LB after month i release&rcub;" DO
        WITH NUMERIC RemainingVol = GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH AlteredReleaseFromTable ) - 1.00000000 FROM AlteredReleaseFromTable DO
         IF ( RemainingVol <= 1.00000000 "acre-feet" )
         THEN
          WITH LIST AdjMonthlyReleases = REMOVE ITEM @INDEX 0.00000000 FROM AlteredReleaseFromTable DO
           AdjMonthlyReleases
          ENDWITH
         ELSE
          WITH LIST AlteredReleases = REMOVE ITEM @INDEX 0.00000000 FROM AlteredReleaseFromTable DO
           WITH LIST NextLowerBoundList = UpperBoundList DO
            WITH NUMERIC NextUpperColumn = UpperColumn + 1.00000000 DO
             WITH LIST NextUpperBoundList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
              WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
               APPEND $ "PowellData.PowellMonthlyReleaseTable" [monthsSinceEOWY + 1.00000000, NextUpperColumn] ONTO result
              ENDWITH
             ENDFOR DO
              WITH LIST NextDifferenceList = FOR ( NUMERIC index IN NextUpperBoundList ) WITH LIST result = {  } DO
               WITH NUMERIC diff = ( GET @INDEX LENGTH result FROM NextUpperBoundList ) - GET @INDEX LENGTH result FROM NextLowerBoundList DO
                APPEND diff ONTO result
               ENDWITH
              ENDFOR DO
               WITH LIST tempAlteredList = WHILE ( ( LENGTH result ) < LENGTH AlteredReleases ) WITH LIST result = {  } DO
                APPEND { GET @INDEX LENGTH result FROM AlteredReleases , GET @INDEX 0.00000000 FROM GET @INDEX LENGTH result FROM AlteredReleases } ONTO result
               ENDWHILE DO
                WITH LIST ResortedAlteredList = "SortPairsAscending"( tempAlteredList ) DO
                 WITH LIST NextTempList = WHILE ( ( LENGTH result ) < LENGTH NextDifferenceList ) WITH LIST result = {  } DO
                  APPEND { { GET @INDEX LENGTH result FROM datesToEOWY , GET @INDEX LENGTH result FROM NextDifferenceList , GET @INDEX 1.00000000 FROM GET @INDEX LENGTH result FROM ResortedAlteredList } , GET @INDEX LENGTH result FROM NextDifferenceList } ONTO result
                 ENDWHILE DO
                  WITH LIST NextSortedList = "SortPairsDescending"( NextTempList ) DO
                   WITH LIST NextAlteredReleaseFromTable = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = { { 0.00000000 , 0.00000000 , RemainingVol } } DO
                    WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                     WITH NUMERIC NextAddedRelease = "Min"( GET @INDEX 1.00000000 FROM GET @INDEX index FROM NextSortedList, GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) DO
                      WITH NUMERIC NextDiffInVol = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - NextAddedRelease DO
                       APPEND { GET @INDEX 0.00000000 FROM GET @INDEX index FROM NextSortedList , "VolumeToFlow"( ( NextAddedRelease + "FlowToVolume"( GET @INDEX 2.00000000 FROM GET @INDEX index FROM NextSortedList, GET @INDEX 0.00000000 FROM GET @INDEX index FROM NextSortedList ) ), GET @INDEX 0.00000000 FROM GET @INDEX index FROM NextSortedList ) , NextDiffInVol * "DebuggerStop"(  ) } ONTO result
                      ENDWITH
                     ENDWITH
                    ENDWITH
                   ENDFOR DO
                    WITH LIST AdjMonthlyReleases = REMOVE ITEM @INDEX 0.00000000 FROM NextAlteredReleaseFromTable DO
                     AdjMonthlyReleases
                    ENDWITH
                   ENDWITH
                  ENDWITH
                 ENDWITH
                ENDWITH COMMENTED_BY "Need to re-sort the AlteredList by date in order to have indices consistent with <br>other lists used"
               ENDWITH COMMENTED_BY "Create a temporary altered list for resorting by month"
              ENDWITH COMMENTED_BY "Recalculate the differences between the upper and lower bounds"
             ENDWITH COMMENTED_BY "Create the new upper bound list for the months remaining in WY"
            ENDWITH COMMENTED_BY "Increase the upper bound index by one"
           ENDWITH COMMENTED_BY "Make previous upper bound list the new lower bound list"
          ENDWITH COMMENTED_BY "Not all remaining volume was released; can happen when not enough capacity in remainder of WY"
         ENDIF COMMENTED_BY "If total volume is within tolerance, use the calculated releases"
        ENDWITH COMMENTED_BY "Check to see if there is any remaining unreleased volume<br>MC, 20170608: Not sure if this is really necessary; seems like the check on volume in <br>  GetPowellMonthlyReleases should address the problem?"
       ENDWITH
      ENDWITH COMMENTED_BY "Create list of the form &lcub;Month i, UB(i)-LB(i), LB(i)&rcub;, sorted by UB(i)-LB(i)"
     ENDWITH COMMENTED_BY "Create list of the form: &lcub; &lcub;Remaining month i, UB(i)-LB(i), LB(month i)&rcub;, UB(i)-LB(i) &rcub;<br>The second occurrence of UB(i)-LB(i) is used to sort the first list"
    ENDWITH COMMENTED_BY "Calculate the difference between the UB and LB release for each remaining month"
   ENDWITH COMMENTED_BY "Calculate the remaining annual volume greater than the cumulative lower bound volume"
  ENDWITH COMMENTED_BY "Retrieve the release values for the lower bound column"
 ENDWITH COMMENTED_BY "Retrieve the release values for the upper bound column";

    END;

      BREAKPOINT BEFORE_EXEC TRUE;
    FUNCTION       "CalculatePowellUEBToEqualizePowellMonRel" ( LIST datesToEOWY, NUMERIC UpperColumn, NUMERIC LowerColumn, NUMERIC RemainingAnnualVolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Takes a list of dates that go from the current timestep to the end of the water year. It returns a list of two items each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  If the Equalization outflow has been calculated by Branch 1.3 of the Upper Elevation Balancing Tier, then the outflows from the current date until April 1 have to follow a path of a 9.0 MAF release through the start Month and then will be either the maximum power plant release (based on an estimation using engineering functions of RW) or the remaining amount of volume to meet the equalization volume determined by previous rules.  The post march releases will be estimated in this function and any carryover volume from not being able to release the water due to power plant capacity will need to be determined. <br><br>RETURNS: List of lists in the form &lcub;date, release, remaining volume over capacity to be released&rcub;<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates to the end of the water year<br>2. NUMERIC UpperColumn - index specifying the upper bound column in the table PowellData.PowellMontlhlyReleaseTable<br>3. NUMERIC LowerColumn - index specifying the lower bound column<br>4. NUMERIC RemainingAnnualVolume - the remaining annual volume to be released; <br><br>CONSTRAINTS: None<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR/DATE: TP, 20171013<br><br>TP, 20180226: startMonth is the month in which to increase releases to try to balance reservoirs. If the month is set to 4, it simulates the April Adjustment that this function is trying to accomplish. Carryover can be created in this scenario. By entering a 3 (March) the simulation is doing a March Adjustment instead, which may be necessary to not violate Power Plant Capacity and not create carryover.  If this operation is ever desired by the Powell Operator, this could be moved to a scalar slot in the model where it can be edited by the operator for a model simulation and not have to come into this function to make that change.<br>";
    BEGIN

      WITH NUMERIC ColumnNoFor9MAF = "FindReleaseUpperBoundColumn"( 9000000.00000000 "acre-ft" ) DO
  WITH NUMERIC startMonth = 4.00000000 DO
   WITH LIST RelThruMar = FOR ( DATETIME date IN datesToEOWY ) WITH LIST resultb = {  } DO
    WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
     IF ( "GetMonth"( date ) < startMonth OR "GetMonth"( date ) > 9.00000000 )
     THEN
      APPEND $ "PowellData.PowellMonthlyReleaseTable" [monthsSinceEOWY + 1.00000000, ColumnNoFor9MAF] ONTO resultb
     ELSE
      resultb
     ENDIF
    ENDWITH
   ENDFOR COMMENTED_BY "Determine what the Release are necessary for the Oct through March pattern for a 9 MAF <br>release.  <br>" DO
    WITH NUMERIC TobeReleasedThruMar = "Sum"( RelThruMar ) COMMENTED_BY "Sum the October to March Release volume for 9.0 MAF release <br>" DO
     WITH NUMERIC remainingVolumeRelAprThruSep = ( RemainingAnnualVolume - TobeReleasedThruMar ) COMMENTED_BY "Determine the outflow that needs to be released between the Start Month and September to <br>meet the TARV <br>" DO
      WITH NUMERIC lowerColToReleaseRemaining = FOR ( NUMERIC col IN "GetNumbers"( LowerColumn, 25.00000000, 1.00000000 ) ) WITH NUMERIC newCol = LowerColumn DO
       WITH NUMERIC sumAprToSep = "SumTableColumn"( $ "PowellData.PowellMonthlyReleaseTable", col, 7.00000000, 12.00000000 ) DO
        IF ( remainingVolumeRelAprThruSep > sumAprToSep )
        THEN
         newCol + 1.00000000
        ELSE
         newCol
        ENDIF
       ENDWITH
      ENDFOR COMMENTED_BY "Determine the column in the LTEMP Powell Release Table that contains the Start month to <br>September volume necessary to mee the TARV  <br>" DO
       WITH LIST LowerBoundListAprThruSep = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
        WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
         IF ( "GetMonth"( date ) < 10.00000000 AND "GetMonth"( date ) > startMonth - 1.00000000 )
         THEN
          APPEND $ "PowellData.PowellMonthlyReleaseTable" [monthsSinceEOWY + 1.00000000, lowerColToReleaseRemaining] ONTO result
         ELSE
          result
         ENDIF
        ENDWITH
       ENDFOR COMMENTED_BY "Determine the releases for the column determined in the previous step <br>" DO
        WITH LIST UpperBoundListAprThruSep = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = {  } DO
         WITH NUMERIC monthsSinceEOWY = "MonthsSinceEOWY"( date ) DO
          IF ( "GetMonth"( date ) < 10.00000000 AND "GetMonth"( date ) > startMonth - 1.00000000 )
          THEN
           APPEND $ "PowellData.PowellMonthlyReleaseTable" [monthsSinceEOWY + 1.00000000, lowerColToReleaseRemaining + 1.00000000] ONTO result
          ELSE
           result
          ENDIF
         ENDWITH
        ENDFOR COMMENTED_BY "Determine the releases for the upper column of the determined lower column <br>" DO
         WITH NUMERIC LowersSum = "Sum"( LowerBoundListAprThruSep ) COMMENTED_BY "Sum the volumes for the Upper and lower columns <br>" DO
          WITH NUMERIC UpperSum = "Sum"( UpperBoundListAprThruSep ) DO
           WITH LIST baseList = IF ( remainingVolumeRelAprThruSep > UpperSum )
           THEN
            UpperBoundListAprThruSep
           ELSE
            LowerBoundListAprThruSep
           ENDIF COMMENTED_BY "Determine which pattern to use, lower column pattern or upper column pattern <br>" DO
            WITH NUMERIC scalVal = ( remainingVolumeRelAprThruSep / "Sum"( baseList ) ) COMMENTED_BY "Determine a scale value that will increase or decrease a pattern to meet the remaining TARV <br>Volume <br>" DO
             WITH NUMERIC sumPowerPlantCapAprToSep = FOR ( DATETIME dateb IN datesToEOWY ) STAT_SUM
              IF ( "GetMonth"( dateb ) < startMonth OR "GetMonth"( dateb ) > 9.00000000 )
              THEN
               0.00000000 "acre-ft"
              ELSE
               "FlowToVolume"( $ "Powell.Peak Flow" [dateb], dateb )
              ENDIF
             ENDFOR COMMENTED_BY "Determine the volume of Power Plant Capacity between the start month and September <br>" DO
              WITH LIST AdjustedBaseList = FOR ( NUMERIC Rel IN baseList ) WITH LIST result = {  } DO
               APPEND Rel * scalVal ONTO result
              ENDFOR COMMENTED_BY "Scale the base list to the TARV Volume <br>" DO
               WITH LIST TempList = FOR ( DATETIME date IN datesToEOWY ) WITH LIST resultb = {  } DO
                WITH NUMERIC index = ( LENGTH resultb ) DO
                 IF ( "GetMonth"( date ) < startMonth OR "GetMonth"( date ) > 9.00000000 )
                 THEN
                  APPEND { date , GET @INDEX index FROM RelThruMar } ONTO resultb
                 ELSE
                  APPEND { date , GET @INDEX index - ( ( LENGTH datesToEOWY ) - ( 10.00000000 - startMonth ) ) FROM AdjustedBaseList } ONTO resultb
                 ENDIF
                ENDWITH
               ENDFOR COMMENTED_BY "Build a Water Year Release Pattern with 9.0 MAF pattern from Oct to the start month, and the <br>adjusted pattern from the start month to September to meet the TARV.  <br>" DO
                WITH NUMERIC prevPoolElev = $ "Powell.Pool Elevation" ["OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 Months" )] COMMENTED_BY "Get the Previous Pool Elevation for the following List construction <br>" DO
                 WITH LIST ListWithMaxPowerRel = FOR ( LIST index IN TempList ) WITH LIST result = { { "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 Months" ) , "null" , prevPoolElev , RemainingAnnualVolume } COMMENTED_BY "Build the first list in the list of lists with information that will be used in the first iteration of the list <br>" } DO
                  WITH NUMERIC PreviousResultPE = GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
                   WITH DATETIME PreviousDate = GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
                    WITH DATETIME CurrentDate = "OffsetDate"( PreviousDate, 1.00000000, "1 Months" ) DO
                     WITH NUMERIC CurrentEstRelease = IF ( ( LENGTH result ) == ( LENGTH TempList ) )
                     THEN
                      "Max"( "VolumeToFlow"( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM TempList, CurrentDate ), "VolumeToFlow"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result, CurrentDate ) ) COMMENTED_BY "If in the last month, try to release all remaining volume <br>"
                     ELSE
                      "VolumeToFlow"( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM TempList, CurrentDate )
                     ENDIF DO
                      WITH NUMERIC PowerPlantHeadRow = "Min"( "Floor"( ( PreviousResultPE - $ "Powell.Minimum Power Elevation" [0.00000000, "Min Power Elev"] ), 1.00000000 "ft" ), 212.00000000 "feet" ) DO
                       WITH NUMERIC MaxGeneratorRelease = $ "Powell.Peak Flow" [CurrentDate] DO
                        WITH NUMERIC NextOutflow = IF ( "GetMonth"( CurrentDate ) > 9.00000000 OR "GetMonth"( CurrentDate ) < startMonth OR sumPowerPlantCapAprToSep > remainingVolumeRelAprThruSep )
                        THEN
                         "Min"( CurrentEstRelease, MaxGeneratorRelease )
                        ELSE
                         "Min"( "VolumeToFlow"( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result, CurrentDate ) COMMENTED_BY "Remaining Volume<br>", MaxGeneratorRelease )
                        ENDIF DO
                         WITH NUMERIC tempPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [CurrentDate], CurrentDate ) - "FlowToVolume"( NextOutflow, CurrentDate ) - NaNToZero ( $ "Powell.Change in Bank Storage" [CurrentDate] ) ) DO
                          WITH NUMERIC NewPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [CurrentDate], CurrentDate ) - "PowellEvapEstimation"( CurrentDate, PreviousResultPE, tempPE ) - "FlowToVolume"( NextOutflow, CurrentDate ) - NaNToZero ( $ "Powell.Change in Bank Storage" [CurrentDate] ) ) COMMENTED_BY "Determine the Pool Elevation estimation with Evaporation  <br>" DO
                           WITH NUMERIC newRemVol = ( ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) - "FlowToVolume"( NextOutflow, CurrentDate ) ) COMMENTED_BY "Determine the remaining Volume that was not released from the TARV. At the end of the Water <br>Year, any value calculated here, will be considered Carryover.   <br>" DO
                            APPEND { CurrentDate , NextOutflow , NewPE , newRemVol } ONTO result
                           ENDWITH
                          ENDWITH
                         ENDWITH COMMENTED_BY "Calculate the PE for CurrentDate based on the updated outflow without Evap, for use in the <br>Evap function for Powell <br>"
                        ENDWITH COMMENTED_BY "Calculate the outflow as the minimum of the estimate passed in or the calculated maximum bypass"
                       ENDWITH COMMENTED_BY "Calculate the maximum bypass possible based on the previous result PE value"
                      ENDWITH COMMENTED_BY "Calculate the head value for the current PE <br>"
                     ENDWITH COMMENTED_BY "Retrieve the release passed into the function for the current date"
                    ENDWITH COMMENTED_BY "Set current date"
                   ENDWITH COMMENTED_BY "Retrieve previous result date"
                  ENDWITH COMMENTED_BY "Retrieve previous result PE"
                 ENDFOR COMMENTED_BY "Determine the outflows for the Water Year that meets the 9.0 MAF release pattern from October <br>to the start month, and the remaining releases limited to the release of the TARV or the Power <br>Plant Capacity. The result of the function will be a list of lists with the form &lcub;&lcub;Date, Outflow, Pool <br>Elevation, remaining TARV&rcub;,&lcub;Date, Outflow, Pool Eleavation, remaining TARV&rcub;,...&rcub; <br>" DO
                  WITH NUMERIC carryoverVol = ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH ListWithMaxPowerRel ) - 1.00000000 FROM ListWithMaxPowerRel ) COMMENTED_BY "If there is any carryover volume remaining, this could be due to months in the last months of the <br>Water Year where the TARV pattern in the &quot;Base List&quot; could not be met due to Power Plant <br>Capacity Restrictions. If the early months in the &quot;Base List&quot; after the Start Month, TARV <br>patterned release is not as high as the Power Plant Capacity for that month, the carryover <br>created in the later part of the Water Year, could be released in the earlier part, after the start <br>month.  <br>" DO
                   WITH LIST TryToReleaseAllCarryover = FOR ( LIST DRPEVol IN REMOVE ITEM @INDEX 0.00000000 FROM ListWithMaxPowerRel ) WITH LIST result = { { 1.00000000 , 1.00000000 , 1.00000000 , carryoverVol } } DO
                    WITH NUMERIC maxFlow = $ "Powell.Peak Flow" [GET @INDEX 0.00000000 FROM DRPEVol] COMMENTED_BY "Power Plant Capacity <br>" DO
                     WITH NUMERIC DiffCurFlowandMaxFlow = IF ( "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) > 9.00000000 OR "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) < startMonth )
                     THEN
                      0.00000000 "acre-ft/month"
                     ELSE
                      "Max"( maxFlow - GET @INDEX 1.00000000 FROM DRPEVol, 0.00000000 "acre-ft/month" )
                     ENDIF COMMENTED_BY "Determine the amount of possible space available for a given month <br>" DO
                      WITH NUMERIC CarryoverLeftToRelease = ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) COMMENTED_BY "amount of carryover that is needed to be released <br>" DO
                       WITH NUMERIC ChangeInRelease = ( ( GET @INDEX 1.00000000 FROM DRPEVol ) + "Min"( "VolumeToFlow"( CarryoverLeftToRelease, GET @INDEX 0.00000000 FROM DRPEVol ), DiffCurFlowandMaxFlow ) ) COMMENTED_BY "Determine new change in outflow <br>" DO
                        WITH NUMERIC CarryoverLeft = ( CarryoverLeftToRelease - "Min"( CarryoverLeftToRelease, "FlowToVolume"( DiffCurFlowandMaxFlow, GET @INDEX 0.00000000 FROM DRPEVol ) ) ) COMMENTED_BY "Determine if carryover is left to be released in the next months if possible.  <br>" DO
                         APPEND { GET @INDEX 0.00000000 FROM DRPEVol , ChangeInRelease , GET @INDEX 2.00000000 FROM DRPEVol , CarryoverLeft * "DebuggerStop"(  ) } ONTO result
                        ENDWITH
                       ENDWITH
                      ENDWITH
                     ENDWITH
                    ENDWITH
                   ENDFOR COMMENTED_BY "This List tries to insert the Carryover generated from the preivous list, into months where there <br>might be room below the Power Plant Capacity.  This loop could be removed if this operation is <br>not desired and the carryover is better for modeling purposes.  This list generations creates a list <br>of lists in the form &lcub;&lcub;Date, Outflow, Pool Elevation, CarryoverLeft&rcub;,...&rcub; <br>" DO
                    WITH LIST DateFlowVol = FOR ( LIST DFV IN TryToReleaseAllCarryover ) WITH LIST result = {  } DO
                     APPEND { GET @INDEX 0.00000000 FROM DFV , GET @INDEX 1.00000000 FROM DFV , GET @INDEX 3.00000000 FROM DFV } ONTO result
                    ENDFOR COMMENTED_BY "If the previous list is found to be undesirred, then insert &quot; ListWithMaxPowerRel&quot; into where <br>&quot;TryToReleaseAllCarryover&quot; exists.  Then remove the Pool Elevation element from that list. and <br>Return a list of lists in the form &lcub;&lcub;Date, Outflow, Carryover Remaining&rcub;,...&rcub; <br>" DO
                     WITH LIST AdjMonthlyReleases = ( REMOVE ITEM @INDEX 0.00000000 FROM DateFlowVol ) COMMENTED_BY "Remove the first element from the list in the form &lcub;1, 1, 1, Carryover Volume&rcub; <br>" DO
                      AdjMonthlyReleases
                     ENDWITH
                    ENDWITH
                   ENDWITH
                  ENDWITH
                 ENDWITH
                ENDWITH
               ENDWITH
              ENDWITH
             ENDWITH
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH COMMENTED_BY "startMonth is the month in which to increase releases to try to balance reservoirs.  <br>"
 ENDWITH;

    END;

    FUNCTION       "MonthsSinceEOWY" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the number of months since the end of the previous water year<br><br>RETURNS: The number of months since the end of the previous water year<br><br>ARGUMENTS:<br>1. DATETIME date - a date within the run period<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "PowellData.MonthsToFromEOWY" ["GetMonthAsString"( date ), "Since"];

    END;

    FUNCTION       "MonthsUntilEOWY" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the number of months until the end of the water year<br><br>RETURNS: The number of months until the end of the water year<br><br>ARGUMENTS:<br>1. DATETIME date - a date within the run period<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "PowellData.MonthsToFromEOWY" ["GetMonthAsString"( date ), "Until"];

    END;

    FUNCTION       "PowellEvapEstimation" ( DATETIME date, NUMERIC curPE, NUMERIC prevPE )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function follows the method Periodic Net Evaporation (Look up details in RiverWare Help). The function calculates the evaporation that is a function of the reservoir and removes the amount that would have evaporated if the resroivr had not been built. The evaporation is calculated as the Gross Evap from the reservoir less the river, streamside, terrace, and remaining evap that would have occured if the reservoir was not there. TP 2/20/2018<br><br>RETURNS: NUMERIC, Estimate of evaporation volume [L^3]<br><br>ARGUMENTS: <br>1.DATETIME date, The current date of interest<br>2. NUMERIC curPE, The pool elevation estimated without Evaporation for the date<br>3. NUMERIC prevPE, The pool elevation estiatmed in the previous version of the loop that uses this function.<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: TP, 20180220";
    BEGIN

      WITH NUMERIC AvgSurfaceArea = ( ( "ElevationToArea"( % "Powell", prevPE ) + "ElevationToArea"( % "Powell", curPE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average Surface area using an estimated Powell Pool Elevation without <br>Evaporation removed.  <br>" DO
  WITH NUMERIC GrosEvap = ( AvgSurfaceArea * $ "Powell.Gross Evaporation Coefficient" [date, 0.00000000] ) COMMENTED_BY "This is the Gross Evaporation for Powell <br>" DO
   WITH NUMERIC AvgRiverArea = ( ( "TableLookup"( $ "Powell.Elevation River Area", 0.00000000, 1.00000000, prevPE, date, TRUE ) + "TableLookup"( $ "Powell.Elevation River Area", 0.00000000, 1.00000000, curPE, date, TRUE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average River Area  <br>" DO
    WITH NUMERIC RiverEvap = ( AvgRiverArea * $ "Powell.River Evaporation Coefficient" [date, 0.00000000] ) COMMENTED_BY "Determine the amount of Evaporation from the River Area <br>" DO
     WITH NUMERIC AvgStreamsideArea = ( ( "TableLookup"( $ "Powell.Elevation Streamside Area", 0.00000000, 1.00000000, prevPE, date, TRUE ) + "TableLookup"( $ "Powell.Elevation Streamside Area", 0.00000000, 1.00000000, curPE, date, TRUE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average Streamside Area with no Reservor <br>" DO
      WITH NUMERIC StreamsideEvap = ( AvgStreamsideArea * $ "Powell.Streamside Coefficient" [date, 0.00000000] * $ "Powell.Average Air Temperature" [date, 0.00000000] ) COMMENTED_BY "Determine the amount of Evaporation from the Streamside Area, need to use the Average Air <br>Temperature to determine this value. <br>" DO
       WITH NUMERIC AvgTerraceArea = ( ( "TableLookup"( $ "Powell.Elevation Terrace Area", 0.00000000, 1.00000000, prevPE, date, TRUE ) + "TableLookup"( $ "Powell.Elevation Terrace Area", 0.00000000, 1.00000000, curPE, date, TRUE ) ) / 2.00000000 ) COMMENTED_BY "Determine the Average Terrace Area of the River with no reservoir <br>" DO
        WITH NUMERIC TerraceEvap = ( AvgTerraceArea * $ "Powell.Terrace Coefficient" [date, 0.00000000] * $ "Powell.Average Air Temperature" [date, 0.00000000] ) COMMENTED_BY "Determine the amount of Evaporation from the Terrace Area, need to use the Average Air <br>Temperature to determine this value. <br>" DO
         WITH NUMERIC RemainingArea = "Max"( AvgSurfaceArea - AvgRiverArea - AvgStreamsideArea - AvgTerraceArea, 0.00000000 "acre" ) COMMENTED_BY "Determine the Remaining area that would simulate the area outside of the river, streamside, or <br>terrace that is covered by the reservoir.  <br>" DO
          WITH NUMERIC RemainingEvap = ( RemainingArea * $ "Powell.Average Precipitation" [date, 0.00000000] ) COMMENTED_BY "Multiply that remaining area by the precipitation rate, it is assumed that any precipitation in the <br>remaining area is evaporated, so it is included in this estimation. See &quot;Periodic Net Evaporation&quot; in <br>section 17.1.18.7 in Objects of the RiverWare Help Documentation.  <br>" DO
           WITH NUMERIC SalvageEvap = ( RiverEvap + StreamsideEvap + TerraceEvap + RemainingEvap ) COMMENTED_BY "Determine the Salvage Evap (The amount of Evap that would occur if the reservoir were not <br>there) <br>" DO
            WITH NUMERIC Evap = "Max"( "FlowToVolume"( GrosEvap - SalvageEvap, date ), 0.00000000 "acre-ft" ) COMMENTED_BY "The Net Evap (Gross - Salvage) is the value that is returned from this function <br>" DO
             Evap
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "PowellReleaseTier" ( NUMERIC Jan1Elev, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a numeric code designating the release tier for Powell based on the provided date and January 1 pool elevation<br><br>RETURNS: Numeric code associated with a release tier<br><br>ARGUMENTS:<br>1. NUMERIC Jan1Elev - pool elevation for January 1<br>2. DATETIME date - date used to specify the water year for calculating the equalization level pool elevation<br><br>CONSTRAINTS: Value is between 0 & 3<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( Jan1Elev >= "EqLevel"( date ) )
 THEN
  0.00000000 COMMENTED_BY "Equalization"
 ELSE
  IF ( Jan1Elev >= $ "PowellData.TierBreaks" ["UpperMid", 0.00000000] )
  THEN
   1.00000000 COMMENTED_BY "Upper Elevation Balancing"
  ELSE
   IF ( Jan1Elev >= $ "PowellData.TierBreaks" ["MidLower", 0.00000000] )
   THEN
    2.00000000 COMMENTED_BY "Mid-Elevation Release"
   ELSE
    3.00000000 COMMENTED_BY "Lower Elevation Balancing"
   ENDIF
  ENDIF
 ENDIF;

    END;

    FUNCTION       "DebuggerStop" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is a placeholder function that provdes a location for setting a breakpoint in the debugger and allows investigation of LIST of LISTs elements as they are created, instead of after the entire list is created<br><br>RETURNS: Value specified in body of function [NONE]<br><br>ARGUMENTS: NONE<br><br>CONSTRAINTS: NONE";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: Unknown";
    BEGIN

      1.00000000;

    END;

    FUNCTION       "TierIs" ( STRING tier, DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns TRUE or FALSE signifying whether or not Powell is operating under the specified release tier in the water year containing the provided date<br><br>RETURNS: Boolean TRUE or FALSE<br><br>ARGUMENTS:<br>1. STRING tier - the name of the tier<br>2. DATETIME date - date used to determine the water year<br>3. BOOLEAN startYear - specifies whether or not the water year is the first water year (TRUE) in the model run or not (FALSE)<br><br>CONSTRAINTS: Returns FALSE if the release tier for the appropriate year is NaN<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( startYear AND date <= @"24:00:00 September 30" )
 THEN
  IF ( NOT IsNaN $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Current Year"] )
  THEN
   $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Current Year"] == $ "PowellData.TierNames" [tier, 0.00000000]
  ELSE
   FALSE
  ENDIF
 ELSE
  IF ( NOT IsNaN $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Next Year"] )
  THEN
   $ "PowellData.ReleaseTier" [@"24:00:00 December 31, Next Year"] == $ "PowellData.TierNames" [tier, 0.00000000]
  ELSE
   FALSE
  ENDIF
 ENDIF;

    END;

    FUNCTION       "UpperElevationBalancingBranchCalculation" ( DATETIME eowyDate, BOOLEAN startYear )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates a code to specify which branch of the Upper Elevation Balancing Tier is used to calculate the release volume<br><br>RETURNS: Value representing the appropriate Upper Elevation Balancing tier branch<br><br>ARGUMENTS:<br>1. DATETIME eowyDate - the end of water year date for which the branch should be calculated<br>2. BOOLEAN startYear - specifies whether the water year in question is the first water year (TRUE) or an out year (FALSE)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 20120601<br><br>See the &quot;Interim Guidelines Flow Chart&quot; for reference.  This slot shows the branch within the Upper Elevation Balancing Tier that was taken for each year's calculation of Powell annual release volume.  It can take the following values for the following conditions:<br>1.1 - Upper Elev Bal Tier, B1 branch (8.23 MAF release)<br>1.2 - Upper Elev Bal Tier, B2 branch (release between 7 MAF and 9MAF)<br>1.3 - Upper Elev Bal Tier, B3 branch (Equalization Tier Calc)<br>1.4 - Upper Elev Bal Tier, B4 branch (release between 8.23 MAF and 9MAF)<br>999 - Any other Tier<br><br>MC, 20160908: Changed MeadProjectionDate to be dependent on input parameter eowyDate, instead of on @&quot;t&quot;; added Boolean input parameter 'startYear'  for determining which Mead PE to use; added MeadProjectedElevation variable";
    BEGIN

      WITH DATETIME MeadProjectionDate = "Dec31ofYear"( eowyDate - 1.00000000 "year" ) DO
  WITH NUMERIC MeadProjectedElevation = IF ( startYear )
  THEN
   $ "PowellToMeadData.AugEOYMeadPEProjection" [MeadProjectionDate]
  ELSE
   $ "Mead.Pool Elevation" [MeadProjectionDate]
  ENDIF DO
   IF ( $ "Powell.Pool Elevation" [eowyDate] > "EqLevel"( eowyDate ) )
   THEN
    1.30000000
   ELSE
    IF ( MeadProjectedElevation >= 1075.00000000 "ft" )
    THEN
     IF ( $ "Mead.Pool Elevation" [eowyDate] <= 1075.00000000 "ft" AND $ "Powell.Pool Elevation" [eowyDate] > 3575.00000000 "ft" )
     THEN
      1.40000000
     ELSE
      1.10000000
     ENDIF COMMENTED_BY "If Mead's EOWY elevation is less than 1075' and Powell's EOWY elevation is greater than 3575' then release enough to balance <br>the storages up to 9.0 MAF and no less than 8.23 MAF annual release volume (Branch 4).  Otherwise just release 8.23 MAF (Branch 1)"
    ELSE
     IF ( "EnsureReleaseLimits"( "EqualizationRelease"( eowyDate ), $ "PowellData.UpperTierB2MinAnnualRelease" [], $ "PowellData.UpperTierB2MaxAnnualRelease" [] ) > 8230.00000000 "1000 acre-ft" )
     THEN
      1.29000000
     ELSE
      1.27000000
     ENDIF COMMENTED_BY "Branch 2"
    ENDIF
   ENDIF COMMENTED_BY "If greater than the Equalization level, Branch 3"
  ENDWITH COMMENTED_BY "Retrieve the pool elevation for the projection date"
 ENDWITH COMMENTED_BY "Set the date on which to check the Mead pool elevation";

    END;

    FUNCTION       "VolumeDeviationFromEOWYTarget" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the volume deviation of the end-of-water-year storage at Powell and Mead from their appropriate target levels according to the Equalization Tier logic.  The condition that is operative for setting the annual volume in a given year is stored in the PowellData.ControllingEqualizationCondition slot.  See the slot for further description of what the values actually mean.  This deviation volume is then added to the annual release volume to more precisely hit the end of water year (EOWY) target.<br><br>RETURNS: Difference between Powell storage volume and the desired end of water year storage volume [L^3]<br><br>ARGUMENTS:<br>1. DATETIME EOWYDate - end of water year date used to specify the appropriate water year<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.10000000 )
 THEN
  $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) )
 ELSE
  IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.20000000 OR NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.30000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWYDate )] ) == 1.27000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWYDate )] ) == 1.29000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWYDate )] ) == 1.40000000 )
  THEN
   ( $ "Powell.Storage" [EOWYDate] - $ "Mead.Storage" [EOWYDate] ) / 2.00000000
  ELSE
   IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.40000000 )
   THEN
    "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - $ "Mead.Storage" [EOWYDate]
   ELSE
    IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWYDate )] ) == 0.50000000 )
    THEN
     $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" ) - $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "OffsetDate"( EOWYDate, 12.00000000, "1 months" ) )]
    ELSE
     0.00000000 "acre-ft"
    ENDIF COMMENTED_BY "Fourth possible condition is that Powell elevation needs to be at 20ft below the equalization level by the end-of-water-year"
   ENDIF COMMENTED_BY "Third possible condition is that Mead needs to be at elevation 1105 ft by the end-of-water-year"
  ENDIF COMMENTED_BY "Second possible condition is that the end-of-water-year storages need to be equal between Powell and Mead."
 ENDIF COMMENTED_BY "First condition is that Powell needs to be to its equalization level by end-of-water-year";

    END;

    FUNCTION       "WaterYearDatesByGroup" ( NUMERIC inputGroupNumber )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a list of the dates in the same WY group (all dates in a water year have the same group number) &quot;inputGroupNumber&quot;. Note that for the initial water year, only the remaining months in the water year (beginning with that of the Start Timestep) are included in the output.<br><br>RETURNS: List of dates remaining in the water year specified by the input argument<br><br>ARGUMENTS:<br>1. NUMERIC inputGroupNumber - numeric value specifying the water year for which the dates are desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST prelimList = FOR ( DATETIME date IN @"Start Timestep + 1" TO @"Finish Timestep" ) WITH LIST result = { { @"Start Timestep" , 1.00000000 } } DO
  WITH NUMERIC groupNumber = GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
   IF ( "GetMonthAsString"( date ) == "October" )
   THEN
    APPEND { date , groupNumber + 1.00000000 } ONTO result
   ELSE
    APPEND { date , groupNumber } ONTO result
   ENDIF
  ENDWITH
 ENDFOR DO
  IF ( ( inputGroupNumber == 7.00000000 AND @"Start Timestep" == @"October 31" ) COMMENTED_BY "If the start month is October then there is no third water year in the run window.  Thus we need this function to be <br>non-empty and return a date that will definitely be outside of the run window. - sc 11/03/11" )
  THEN
   { @"24:00:00 December 31, 1900" }
  ELSE
   FOR ( LIST dateGroupNumber IN prelimList ) WITH LIST result = {  } DO
    IF ( ( GET @INDEX 1.00000000 FROM dateGroupNumber ) == inputGroupNumber )
    THEN
     APPEND GET @INDEX 0.00000000 FROM dateGroupNumber ONTO result
    ELSE
     result
    ENDIF
   ENDFOR COMMENTED_BY "Loop through prelimList and keep the &lcub;Date, Group Number&rcub; pairs for which Group Number matches inputGroupNumber"
  ENDIF
 ENDWITH COMMENTED_BY "prelimList contains all dates within the model run period and their associated water year numbers";

    END;

    FUNCTION       "GetPowellMonthlyReleases_pre20171024" ( LIST datesToEOWY )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume calculates each month's release.  If the set of dates passed to the function is the first water year in the run (i.e., begins with the run's start timestep), then, if necessary, this function will make an adjustment to the calculated releases to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List with members of the form &lcub;date, release&rcub; where date is a member of the list of dates passed to the function<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates within the model run period<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 20110325<br><br>MC, 20160907: In calculation of AdjustedMonthlyReleases, moved subRelList<1> (and multiplied by 1 &quot;month&quot;) into call to VolumeToFlow to get desired volume; previous version was not giving correct desired volume (at least in some cases when UserInput_MinimumAnnualRelease sets the TARV) due to conversion associated with monthly flow and time scale (i.e., RW was making an unwanted conversion based on the number of days in a month); Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1><br>MC, 20170501: Renamed variables for better understanding";
    BEGIN

      WITH NUMERIC AnnualVolume = "CurrentAnnualVolume"( GET @INDEX 0.00000000 FROM datesToEOWY ) DO
  WITH BOOLEAN EqualizationbyAprAdjust = IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] ) == 1.30000000 )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF DO
   WITH NUMERIC VolumeReleasedPreRun = IF ( "GetMonthAsString"( GET @INDEX 0.00000000 FROM datesToEOWY ) == "October" )
   THEN
    0.00000000 "acre-feet"
   ELSE
    "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), @"Start Timestep - 1" ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] )
   ENDIF DO
    WITH NUMERIC RemainingWYReleaseVolume = AnnualVolume - VolumeReleasedPreRun DO
     WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( AnnualVolume ) DO
      WITH NUMERIC LowerColumnBound = "FindReleaseLowerBoundColumn"( AnnualVolume, UpperColumnBound ) DO
       WITH LIST RemainingMonthlyReleases = IF ( EqualizationbyAprAdjust )
       THEN
        "CalculatePowellUEBToEqualizePowellMonRel"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYReleaseVolume )
       ELSE
        "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYReleaseVolume )
       ENDIF DO
        IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" )
        THEN
         WITH NUMERIC MonthlyReleaseSum = FOR ( LIST monthlyReleaseVol IN RemainingMonthlyReleases ) STAT_SUM
          "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
         ENDFOR DO
          WITH NUMERIC Tolerance = 5.00000000 "acre-feet" DO
           WITH NUMERIC VolumeDifference = RemainingWYReleaseVolume - MonthlyReleaseSum DO
            IF ( "Abs"( VolumeDifference ) < Tolerance )
            THEN
             RemainingMonthlyReleases
            ELSE
             WITH NUMERIC MonthlyVolumeAdjustment = VolumeDifference / LENGTH RemainingMonthlyReleases DO
              WITH LIST AdjustedMonthlyReleases = FOR ( LIST subRelList IN RemainingMonthlyReleases ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
               WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - MonthlyVolumeAdjustment DO
                 ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( MonthlyVolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
                ENDWITH
               ENDWITH
              ENDFOR DO
               REMOVE ITEM @INDEX 0.00000000 FROM AdjustedMonthlyReleases
              ENDWITH
             ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170607: Why not adjust porportionately to monthly releases?<br>"
            ENDIF
           ENDWITH
          ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
         ENDWITH COMMENTED_BY "Calculate total remaining releases from RemainingMonthlyReleases"
        ELSE
         RemainingMonthlyReleases
        ENDIF
       ENDWITH COMMENTED_BY "Calculate list of the form &lcub;Month, Adjusted monthly release rate, Remaining volume above lower bound column&rcub;"
      ENDWITH COMMENTED_BY "Detemine index of first column in monthly release table with total annual volume <= annualVolume<br>(Same as UpperColumnBound if annualVolume is equal to a column total)"
     ENDWITH COMMENTED_BY "Calculate index of first column in monthly release table with total annual volume >= annualVolume"
    ENDWITH
   ENDWITH COMMENTED_BY "Determine volume released prior to model run start"
  ENDWITH
 ENDWITH COMMENTED_BY "Retrieve TargetAnnualReleaseVolume for water year containing datesToEOWY<0>";

    END;

    FUNCTION       "GetPowellMonthlyReleases_v2" ( LIST datesToEOWY, NUMERIC TargetAnnualReleaseVolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume calculates each month's release.  If the set of dates passed to the function is the first water year in the run (i.e., begins with the run's start timestep), then, if necessary, this function will make an adjustment to the calculated releases to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List with members of the form &lcub;date, release&rcub; where date is a member of the list of dates passed to the function<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates within the model run period<br>2. NUMERIC TotalVolumeToRelease - the total volume of water to be released during a water year<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 20110325<br><br>MC, 20160728: This version of the function takes a second argument, TotalVolumeToRelease, instead of using an annual volume calculated by the user-defined function CurrentAnnualVolume; it was originally created for use in handling carryover years";
    BEGIN

      WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( TargetAnnualReleaseVolume ) DO
  WITH NUMERIC LowerColumnBound = "FindReleaseLowerBoundColumn"( TargetAnnualReleaseVolume, UpperColumnBound ) DO
   WITH NUMERIC VolumeReleasedPreRun = IF ( "GetMonthAsString"( ( GET @INDEX 0.00000000 FROM datesToEOWY ) ) == "October" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, 1.00000000, "-1 months" ) )
   ENDIF DO
    WITH NUMERIC CarryoverReleasedPreRun = "Min"( VolumeReleasedPreRun, $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] ) DO
     WITH NUMERIC TARVReleasedPreRun = VolumeReleasedPreRun - CarryoverReleasedPreRun DO
      WITH NUMERIC TARVRemaining = TargetAnnualReleaseVolume - TARVReleasedPreRun DO
       WITH LIST RemainingMonthlyReleases = "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, TARVRemaining ) DO
        IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" )
        THEN
         WITH NUMERIC SumRemainingReleases = FOR ( LIST monthlyReleaseVol IN RemainingMonthlyReleases ) STAT_SUM
          "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
         ENDFOR DO
          WITH NUMERIC VolumeDifference = TARVRemaining - SumRemainingReleases DO
           WITH NUMERIC Tolerance = 5.00000000 "acre-feet" DO
            IF ( "Abs"( VolumeDifference ) < Tolerance )
            THEN
             RemainingMonthlyReleases
            ELSE
             WITH NUMERIC MonthlyVolumeAdjustment = VolumeDifference / LENGTH RemainingMonthlyReleases DO
              WITH LIST AdjustedMonthlyReleases = FOR ( LIST subRelList IN RemainingMonthlyReleases ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
               WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - MonthlyVolumeAdjustment DO
                 ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( MonthlyVolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
                ENDWITH
               ENDWITH
              ENDFOR DO
               REMOVE ITEM @INDEX 0.00000000 FROM AdjustedMonthlyReleases
              ENDWITH
             ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170607: Why not distribute the difference proportionately to releases?"
            ENDIF
           ENDWITH
          ENDWITH
         ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
        ELSE
         RemainingMonthlyReleases
        ENDIF
       ENDWITH COMMENTED_BY "Calculate list of the form &lcub;Month, Monthly release rate, Remaining volume above lower bound column&rcub;"
      ENDWITH COMMENTED_BY "Calculate annual volume that remains to be released"
     ENDWITH COMMENTED_BY "Calculate annual volume previously released "
    ENDWITH COMMENTED_BY "Calculate carryover volume previously released"
   ENDWITH COMMENTED_BY "Calculate total volume previously released"
  ENDWITH
 ENDWITH COMMENTED_BY "Find upper and lower bound columns for annual release";

    END;

    FUNCTION       "GetPowellMonthlyReleases" ( LIST datesToEOWY )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume calculates each month's release.  If the set of dates passed to the function is the first water year in the run (i.e., begins with the run's start timestep), then, if necessary, this function will make an adjustment to the calculated releases to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly.<br><br>RETURNS: List with members of the form &lcub;date, release, remaining volume&rcub; where date is a member of the list of dates passed to the function<br><br>ARGUMENTS:<br>1. LIST datesToEOWY - list of dates within the model run period<br>2. NUMERIC TotalVolumeToRelease - the total volume of water to be released during a water year<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: SC, 20110325<br><br>MC, 20160728: This version of the function takes a second argument, TotalVolumeToRelease, instead of using an annual volume calculated by the user-defined function CurrentAnnualVolume; it was originally created for use in handling carryover years<br><br>MC, 20171024: Tried to combine all functions that develop release schedules into a single one here. Old version renamed GetPowellMonthlyReleases_pre20171024; this version finds bounding release schedule columns based on remaining volume, which Paul D. previously indicated should be okay";
    BEGIN

      WITH DATETIME WaterYear = "Dec31ofYear"( "RelativeEOWYDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) ) DO
  WITH BOOLEAN EqualizationbyAprAdjust = IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" [WaterYear] ) == 1.30000000 )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF DO
   WITH NUMERIC VolumeReleasedPreRun = IF ( "GetMonthAsString"( ( GET @INDEX 0.00000000 FROM datesToEOWY ) ) == "October" )
   THEN
    0.00000000 "acre-ft"
   ELSE
    "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, 1.00000000, "-1 months" ) )
   ENDIF DO
    WITH NUMERIC TargetAnnualVolume = $ "PowellData.TargetAnnualReleaseVolume" [WaterYear] DO
     WITH NUMERIC AnnualCarryoverVolume = IF ( ( ( ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" [WaterYear] ) == 0.20000000 ) OR ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" [WaterYear] ) == 0.30000000 ) ) AND ( NaNToZero ( $ "PowellData.UpperElevBalBranch" [WaterYear] ) == 999.00000000 ) ) COMMENTED_BY "Don't add carryover if EQ volume controlled by equal storage in Powell & Mead <br>" )
     THEN
      0.00000000 "acre-feet"
     ELSE
      NaNToZero ( $ "PowellToMeadData.CarryoverVolume" [WaterYear] )
     ENDIF DO
      WITH LIST TARVVolReleases = WITH NUMERIC RemainingWYRelease = IF ( VolumeReleasedPreRun >= AnnualCarryoverVolume )
      THEN
       TargetAnnualVolume + AnnualCarryoverVolume - VolumeReleasedPreRun
      ELSE
       TargetAnnualVolume
      ENDIF DO
       WITH NUMERIC UpperColumnBound = "FindRemainingReleaseUpperBoundColumn"( RemainingWYRelease, datesToEOWY ) COMMENTED_BY "If the dates end with a water year end, use remaining release to determine column bound<br>If run ends in Dec, using remaining release function leads to all annual volume being released in <br>Oct, Nov, Dec  <br>" DO
        WITH NUMERIC LowerColumnBound = "FindRemainingReleaseLowerBoundColumn"( RemainingWYRelease, datesToEOWY, UpperColumnBound ) DO
         WITH LIST RemainingMonthlyReleases = IF ( EqualizationbyAprAdjust AND TargetAnnualVolume < 50000000.00000000 "acre-feet" COMMENTED_BY "This needs to be on a slot <br>" )
         THEN
          "CalculatePowellUEBToEqualizePowellMonRel"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYRelease )
         ELSE
          "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYRelease )
         ENDIF COMMENTED_BY "List of lists of form: &lcub;Date, Release, Remaining Volume&rcub; <br>" DO
          IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" )
          THEN
           WITH NUMERIC SumRemainingReleases = FOR ( LIST monthlyReleaseVol IN RemainingMonthlyReleases ) STAT_SUM
            "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
           ENDFOR DO
            WITH NUMERIC VolumeDifference = RemainingWYRelease - SumRemainingReleases DO
             WITH NUMERIC Tolerance = 5.00000000 "acre-feet" DO
              IF ( "Abs"( VolumeDifference ) < Tolerance )
              THEN
               RemainingMonthlyReleases
              ELSE
               WITH NUMERIC MonthlyVolumeAdjustment = VolumeDifference / LENGTH RemainingMonthlyReleases DO
                WITH LIST AdjustedMonthlyReleases = FOR ( LIST subRelList IN RemainingMonthlyReleases ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
                 WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
                  WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - MonthlyVolumeAdjustment DO
                   ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( MonthlyVolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
                  ENDWITH
                 ENDWITH
                ENDFOR DO
                 REMOVE ITEM @INDEX 0.00000000 FROM AdjustedMonthlyReleases
                ENDWITH
               ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170607: Why not distribute the difference proportionately to releases?"
              ENDIF
             ENDWITH
            ENDWITH
           ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
          ELSE
           RemainingMonthlyReleases
          ENDIF
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH DO
       IF ( ( VolumeReleasedPreRun >= AnnualCarryoverVolume ) OR IF ( IsNaN $ "PowellData.ReleaseVolumeSetFlag" [WaterYear] )
       THEN
        ( LENGTH datesToEOWY ) < 11.00000000 AND IsNaN $ "Powell.Outflow" [GET @INDEX 0.00000000 FROM datesToEOWY]
       ELSE
        ( $ "PowellData.ReleaseVolumeSetFlag" [WaterYear] == 0.00000000 )
       ENDIF COMMENTED_BY "Carryover will not be added until annual release volume is finalized <br>" )
       THEN
        TARVVolReleases COMMENTED_BY "Schedule remaining volume normally <br>"
       ELSE
        "CalculateCarryoverReleases"( datesToEOWY, AnnualCarryoverVolume, TARVVolReleases ) COMMENTED_BY "Add the Carryover that was created in the previous year to the schedule that is passed into the <br>function, &quot;TARVVolReleases&quot; <br>"
       ENDIF
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "CalculateCarryoverReleases" ( LIST datesToEOWY, NUMERIC InitialCarryoverVolume, LIST TARVVolReleases )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the maximum powerplant capacity release for the case when there is remaining carryover volume between Powell and Mead from one water year to the next. It assumes the monthly releases for the remainder of the year based on the annual release volume have already been calculated<br><br>RETURNS: List of the form &lcub;Date, Release, Carryover Remaining&rcub;. The third (CarryoverRemaining) element in the list are needed internally by the function to track which water is being released through the loop.<br><br>ARGUMENTS: <br>1. LIST datesToEOWY, a list of the months remaining in the current water year<br>2. NUMERIC InitialCarryoverVolume, the carryover volume remaining that was not released prior to the start date of the current model run<br>3. LIST TARVVolReleases, a list of outflows that should sum to the current setting of the TARV.  <br><br>CONSTRAINTS:<br><br> <br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20160711<br>MC, 20160711: The GetMaxReleaseGivenInflow predefined function for future months is dependent on the operating head from pool elevation, which will not be strictly accurate because each month's value is calculated from the previously set typical outflow<br>MC, 20170503: Rewrote function using initial element of list, which allowed condensing code by removing separate sections for first element of list and subsequent elements<br>TP, 2017 11/16/2017: The function needs to know the current setting of the TARV in order to release on top of what needs to be released for the WY.  The function now estimates an upated Pool Elevation and Power Plant Capacity within the function.";
    BEGIN

      WITH DATETIME InitialDate = "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 months" ) DO
  WITH LIST sortedTARVRel = "Sort"( TARVVolReleases ) DO
   WITH NUMERIC TargetAnnualReleaseVolume = $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] DO
    WITH LIST ListWithInit = FOR ( DATETIME date IN datesToEOWY ) WITH LIST result = { { InitialDate , "null" , InitialCarryoverVolume , $ "Powell.Pool Elevation" ["OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, - 1.00000000, "1 Months" )] } } COMMENTED_BY "Build the beginning structure of the list that contains the month prior to when the releases will be <br>start, in an out year, this date will be September of the previous Water Year. Then a &quot;null&quot; value <br>where the outflow that will be calculated will be entered in subsequent sub lists, the initial <br>carryover volume that is to be released (ideally, this will be reduced throughout the construction <br>of the loop), and the initial pool elevation that will help simulate Powell.  <br>" DO
     WITH NUMERIC index = ( FIND date WITHIN datesToEOWY ) + 1.00000000 DO
      WITH NUMERIC TARVOut = ( GET @INDEX 1.00000000 FROM GET @INDEX index - 1.00000000 FROM sortedTARVRel ) COMMENTED_BY "Get the current release, for the current iteration <br>" DO
       WITH NUMERIC PreviousCarryoverRemaining = ( GET @INDEX 2.00000000 FROM GET @INDEX index - 1.00000000 FROM result ) COMMENTED_BY "Get the current carryover volume that still needs to be released <br>" DO
        WITH NUMERIC PreviousResultPE = ( GET @INDEX 3.00000000 FROM GET @INDEX index - 1.00000000 FROM result ) COMMENTED_BY "Get the Previous Pool Elevation, as the loop grows, the simulated Pool Elevation from the <br>previous iteration will be used here. <br>" DO
         WITH NUMERIC Qmax = $ "Powell.Peak Flow" [date] COMMENTED_BY "Use the current Peak Flow value, this value will change as new outflows are set, but as iterations <br>occur with the structure of this logic, this method works. If it is found that the Peak Release is <br>not correct, a different determination of potential Power Plant Capacity should be entered here.  <br>" DO
          WITH NUMERIC Release = "Min"( Qmax, "VolumeToFlow"( PreviousCarryoverRemaining, date ) + TARVOut ) COMMENTED_BY "Determine the new release for the month <br>" DO
           WITH NUMERIC CarryoverRemaining = IF ( ( LENGTH result ) == LENGTH TARVVolReleases )
           THEN
            "Max"( PreviousCarryoverRemaining - "FlowToVolume"( Release - TARVOut, date ), 0.00000000 "acre-ft" ) + GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH TARVVolReleases ) - 1.00000000 FROM TARVVolReleases
           ELSE
            "Max"( PreviousCarryoverRemaining - "FlowToVolume"( Release - TARVOut, date ), 0.00000000 "acre-ft" )
           ENDIF DO
            WITH NUMERIC TempPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [date], date ) - "FlowToVolume"( Release, date ) - NaNToZero ( $ "Powell.Change in Bank Storage" [date] ) ) DO
             WITH NUMERIC NewPE = "StorageToElevation"( % "Powell", "ElevationToStorage"( % "Powell", PreviousResultPE ) + "FlowToVolume"( $ "Powell.Inflow" [date], date ) - "PowellEvapEstimation"( date, PreviousResultPE, TempPE ) - "FlowToVolume"( Release, date ) - NaNToZero ( $ "Powell.Change in Bank Storage" [date] ) ) COMMENTED_BY "Determine the new Pool Elevation with the estimated Powell Evaporation <br>" DO
              APPEND { date , Release , CarryoverRemaining , NewPE * "DebuggerStop"(  ) } ONTO result
             ENDWITH
            ENDWITH COMMENTED_BY "Estimate the new Pool Eleavtion without Evaporation, which is necessary to determine the <br>Evaporation estimate in the next function.  <br>"
           ENDWITH COMMENTED_BY "Determine if Carryover was all released or if some is still needed to be released <br>"
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "Get the current index in the list that is being created <br>"
    ENDFOR DO
     WITH NUMERIC carryoverVol = ( GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH ListWithInit ) - 1.00000000 FROM ListWithInit ) DO
      WITH LIST getAllCarryoverOut = FOR ( LIST DRPEVol IN REMOVE ITEM @INDEX 0.00000000 FROM ListWithInit ) WITH LIST result = { { 1.00000000 , 1.00000000 , 1.00000000 , carryoverVol } } DO
       WITH NUMERIC maxFlow = $ "Powell.Peak Flow" [GET @INDEX 0.00000000 FROM DRPEVol] DO
        WITH NUMERIC DiffCurFlowandMaxFlow = IF ( "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) > 9.00000000 OR "GetMonth"( GET @INDEX 0.00000000 FROM DRPEVol ) < 4.00000000 )
        THEN
         0.00000000 "acre-ft/month"
        ELSE
         "Max"( maxFlow - GET @INDEX 1.00000000 FROM DRPEVol, 0.00000000 "acre-ft/month" )
        ENDIF DO
         WITH NUMERIC CarryoverLeftToRelease = ( GET @INDEX 3.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result ) DO
          WITH NUMERIC ChangeInRelease = ( GET @INDEX 1.00000000 FROM DRPEVol ) + "Min"( "VolumeToFlow"( CarryoverLeftToRelease, GET @INDEX 0.00000000 FROM DRPEVol ), DiffCurFlowandMaxFlow ) DO
           WITH NUMERIC CarryoverLeft = CarryoverLeftToRelease - "Min"( CarryoverLeftToRelease, "FlowToVolume"( DiffCurFlowandMaxFlow, GET @INDEX 0.00000000 FROM DRPEVol ) ) DO
            APPEND { GET @INDEX 0.00000000 FROM DRPEVol , ChangeInRelease , GET @INDEX 3.00000000 FROM DRPEVol , CarryoverLeft * "DebuggerStop"(  ) } ONTO result
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDFOR DO
       WITH LIST DateFlowVol = FOR ( LIST DFV IN getAllCarryoverOut ) WITH LIST result = {  } DO
        APPEND { GET @INDEX 0.00000000 FROM DFV , GET @INDEX 1.00000000 FROM DFV , GET @INDEX 3.00000000 FROM DFV } ONTO result
       ENDFOR DO
        ( REMOVE ITEM @INDEX 0.00000000 FROM DateFlowVol )
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "Remove unneeded first element in list of lists"
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "EqualizationReleaseWithCarryover" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: Created this function to account for the effects of carryover volume in the equalization calculation, which are not needed in the original EqualizationRelease function. If there is carryover volume for the water year, in order to calculate the correct annual volume to release, the calculation needs to 'virtually' move the carryover water from Powell to Mead<br><br>RETURNS: Powell release volume<br><br>ARGUMENTS:<br>1. DATETIME EOWYdate - the end of water year date used to specify the water year of interest<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20160801<br>";
    BEGIN

      ( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] + ( $ "Powell.Storage" [EOWYDate] - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["OffsetDate"( "Dec31ofYear"( EOWYDate ), 12.00000000, "1 months" )] ) - ( $ "Mead.Storage" [EOWYDate] + NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["OffsetDate"( "Dec31ofYear"( EOWYDate ), 12.00000000, "1 months" )] ) ) ) / ( 2.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) ) COMMENTED_BY "Add half of the storage difference that would be present if the carryover volume had been moved from Powell to Mead to the annual release volume";

    END;

    FUNCTION       "GetWaterYearNumber" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the water year number (relative water year within the model run) of the water year containing the argument &quot;date&quot;<br><br>RETURNS: Numeric index of the water year<br><br>ARGUMENTS<br>1. DATETIME date<br><br>CONSTRAINTS:<br><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170209";
    BEGIN

      "GetYear"( date ) - "GetYear"( @"Start Timestep" ) + IF ( "GetMonth"( @"Start Timestep" ) > 9.00000000 AND "GetMonth"( date ) <= 9.00000000 )
 THEN
  0.00000000
 ELSE
  IF ( "GetMonth"( @"Start Timestep" ) <= 9.00000000 AND "GetMonth"( date ) > 9.00000000 )
  THEN
   2.00000000
  ELSE
   1.00000000
  ENDIF COMMENTED_BY "Start<Oct & date>=Oct, add 2"
 ENDIF COMMENTED_BY "If Start>= Oct & date<Oct, then difference in water years is the same as between <br>calendar years";

    END;

    FUNCTION       "FindRemainingReleaseUpperBoundColumn" ( NUMERIC RemainingRelease, LIST datesToEOWY )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the column index for the column in PowellData.PowellMonthlyReleaseTable with the smallest capacity for the remainder of the water year that is greater than the remaining required water year release (Least Upper Bound).<br><br>RETURNS: Numeric index for column [No units]<br><br>ARGUMENTS: <br>1. NUMERIC RemainingRelease - volume of water remaining to be released in the water year of interest<br>2. LIST datesToEOWY - list of dates remaining in the water year of interest<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: MC, 20170627 (previously developed for Sarah Baker's research model)<br><br>MC, 20180116: Added second condition to IF statement regarding last element in datesToEOWY being equal to September. In the January run, the Finish Timestep is Dec resulting in the final outyear selecting a Powell release schedule that allowed the total annual volume to be released during Oct-Dec. Adding the condition allows that case to select the release schedule based on the annual volume, which results in an appropriate release schedule for Oct-Dec";
    BEGIN

      IF ( ( LENGTH datesToEOWY ) < 3.00000000 OR "GetMonth"( GET @INDEX ( LENGTH datesToEOWY ) - 1.00000000 FROM datesToEOWY ) != 9.00000000 )
 THEN
  WHILE ( RemainingRelease - $ "PowellData.PowellMonthlyReleaseTable" ["AnnualTotal", result] > 0.01000000 "1000 acre-ft" ) WITH NUMERIC result = 0.00000000 DO
   result + 1.00000000
  ENDWHILE
 ELSE
  WHILE ( RemainingRelease - FOR ( DATETIME date IN ( GET @INDEX 0.00000000 FROM datesToEOWY ) TO GET @INDEX ( LENGTH datesToEOWY ) - 1.00000000 FROM datesToEOWY ) STAT_SUM
   $ "PowellData.PowellMonthlyReleaseTable" ["GetMonthAsString"( date ), result]
  ENDFOR > 1.00000000 "acre-feet" AND result < "NumColumns"( $ "PowellData.PowellMonthlyReleaseTable" ) ) WITH NUMERIC result = 1.00000000 DO
   result + 1.00000000
  ENDWHILE
 ENDIF COMMENTED_BY "If difference between remaining volume and remaining UB capacity > 1 acre-foot, increment UB column index";

    END;

    FUNCTION       "FindRemainingReleaseLowerBoundColumn" ( NUMERIC RemainingRelease, LIST datesToEOWY, NUMERIC upperbound )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the column index for the column in PowellData.PowellMonthlyReleaseTable with the greatest capacity for the remainder of the water year that is less than the remaining required water year release (Greatest Lower Bound).<br><br>RETURNS: Numeric index for column [No units]<br><br>ARGUMENTS: <br>1. NUMERIC RemainingRelease - volume of water remaining to be released in the water year of interest<br>2. LIST datesToEOWY - list of dates remaining in the water year of interest<br>3. NUMERIC upperbound - the index of the previously-determined upper bound column<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: MC, 20170627 (previously developed for Sarah Baker's research model)";
    BEGIN

      WITH NUMERIC UBSum = FOR ( DATETIME date IN ( GET @INDEX 0.00000000 FROM datesToEOWY ) TO GET @INDEX ( LENGTH datesToEOWY ) - 1.00000000 FROM datesToEOWY ) STAT_SUM
  $ "PowellData.PowellMonthlyReleaseTable" ["GetMonthAsString"( date ), upperbound]
 ENDFOR DO
  IF ( ( UBSum - RemainingRelease < 1.00000000 "acre-feet" ) OR ( upperbound == 1.00000000 "acre-feet" ) COMMENTED_BY "Upper bound is first populated column <br>" )
  THEN
   upperbound
  ELSE
   upperbound - 1.00000000
  ENDIF
 ENDWITH COMMENTED_BY "If the remaining release volume is within 1 acre-foot of the previously determined upper bound sum, use it as <br>the lower bound also; otherwise, decrease the lower bound index";

    END;

    FUNCTION       "ReleaseAdjustment" ( NUMERIC VolumeDeviation, DATETIME EOWY )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the adjustment to the Powell release required to meet the condition specified by the ControllingEqualizationCondition, incorporating Mead and Powell bank storage estimates where necessary.<br><br>RETURNS: Adjustment to the Powell release necessary to correct the VolumeDeviation [L^3]<br><br>ARGUMENTS:<br>1. VolumeDeviation - the volume by which Powell and/or Mead deviate from their respective storages that would satisfy the controlling condition<br>2. EOWY - the end of water year date for the water year under consideration<br><br>CONSTRAINTS: NONE";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: MC, 201801";
    BEGIN

      IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.10000000 )
 THEN
  VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] )
 ELSE
  IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.20000000 OR NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.30000000 )
  THEN
   VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] )
  ELSE
   IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.40000000 )
   THEN
    VolumeDeviation / ( 1.00000000 - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] )
   ELSE
    IF ( NaNToZero ( $ "PowellData.ControllingEqualizationCondition" ["Dec31ofYear"( EOWY )] ) == 0.50000000 )
    THEN
     VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] )
    ELSE
     IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWY )] ) == 1.27000000 OR NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWY )] ) == 1.29000000 )
     THEN
      IF ( VolumeDeviation < 0.00000000 "acre-feet" )
      THEN
       "Max"( $ "PowellData.UpperTierB2MinAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )], VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) )
      ELSE
       "Min"( VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ), $ "PowellData.UpperTierB2MaxAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )] )
      ENDIF
     ELSE
      IF ( NaNToZero ( $ "PowellData.UpperElevBalBranch" ["Dec31ofYear"( EOWY )] ) == 1.40000000 )
      THEN
       "Min"( "Max"( $ "PowellData.UpperTierB4MinAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )], VolumeDeviation / ( 1.00000000 - $ "Powell.Bank Storage Coefficient" [0.00000000, 1.00000000] - $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) ), $ "PowellData.UpperTierB4MaxAnnualRelease" [] - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWY )] )
      ELSE
       0.00000000 "acre-ft"
      ENDIF
     ENDIF COMMENTED_BY "If refining a UEB volume, have to restrict adjustment to keep total annual release within allowable bounds   <br>"
    ENDIF COMMENTED_BY "Fourth possible condition is that Powell elevation needs to be at 20ft below the equalization level by the end-of-water-year"
   ENDIF COMMENTED_BY "Third possible condition is that Mead needs to be at elevation 1105 ft by the end-of-water-year"
  ENDIF COMMENTED_BY "Second possible condition is that the end-of-water-year storages need to be equal between Powell and Mead."
 ENDIF;

    END;

  END;

  UTILITY_GROUP "Powell Steady Flow Experiment Functions";
  DESCRIPTION   "";
  ACTIVE        FALSE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetSeptemberSteadyFlowRelease" ( NUMERIC AnnualReleaseVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "PowellData.SteadyFlowExperimentRelease" ["SteadyFlowTableRow"( AnnualReleaseVolume ), 1.00000000];

    END;

    FUNCTION       "GetOctoberSteadyFlowRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns the october release volume of the current water year under steady flow experiment conditions. ";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "MonthIs"( { "October" , "November" , "December" } ) )
 THEN
  $ "Powell.Outflow" [@"24:00:00 September Max DayOfMonth, Current Year"]
 ELSE
  $ "Powell.Outflow" [@"24:00:00 September Max DayOfMonth, Previous Year"]
 ENDIF;

    END;

    FUNCTION       "GetInitialPowellMonthlyVolumes" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      APPEND "FlowToVolume"( "GetSeptemberSteadyFlowRelease"( $ "PowellData.TargetAnnualReleaseVolume" [] ), @"24:00:00 September Max DayOfMonth, Current Year" ) ONTO INSERT "FlowToVolume"( "GetOctoberSteadyFlowRelease"(  ), @"24:00:00 October Max DayOfMonth, Current Year" ) INTO FOR ( NUMERIC i IN "GetNumbers"( 2.00000000, 11.00000000, 1.00000000 ) ) WITH LIST result = {  } DO
  APPEND "Interpolate"( "CurrentAnnualVolume"( @"t" ), $ "PowellData.PowellMonthlyReleaseTable" [0.00000000, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) )], $ "PowellData.PowellMonthlyReleaseTable" [0.00000000, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) ) + 1.00000000], $ "PowellData.PowellMonthlyReleaseTable" [i, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) )], $ "PowellData.PowellMonthlyReleaseTable" [i, "FindReleaseUpperBoundColumn"( "CurrentAnnualVolume"( @"t" ) ) + 1.00000000] ) ONTO result
 ENDFOR;

    END;

    FUNCTION       "SteadyFlowTableRow" ( NUMERIC AnnualReleaseVolume )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WHILE ( AnnualReleaseVolume >= $ "PowellData.SteadyFlowExperimentRelease" [i, 0.00000000] ) WITH NUMERIC i = 0.00000000 DO
  i + 1.00000000
 ENDWHILE;

    END;

    FUNCTION       "SteadyFlowReduce_1_July" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  IF ( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] >= 0.00000000 "acre-ft" )
  THEN
   "Min"( "GetElement"( monthlyRelease, 2.00000000 ) - 800.00000000 "1000 acre-ft", "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] ) COMMENTED_BY "Return either the amount of reduction in july down to 800 kaf <br>or the total reduction (if it all occurs in July)"
  ELSE
   "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" []
  ENDIF COMMENTED_BY "If the monthly releases exceed the annual release volume, then decrease july first"
 ENDWITH;

    END;

    FUNCTION       "SteadyFlowReduce_2_August" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 1.00000000 ) COMMENTED_BY "1 in reverse order is august" - 800.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in August down to 800 kaf <br>or the total reduction (if it all occurs in August)"
 ENDWITH;

    END;

    FUNCTION       "SteadyFlowReduce_3_June1" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 3.00000000 ) - 800.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 800 kaf <br>or the total reduction (if it all occurs in June), In both cases negatives <br>can occur, so zero these out "
 ENDWITH;

    END;

    FUNCTION       "SteadyFlowReduce_4_June2" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 3.00000000 ) COMMENTED_BY "3 in reverse order is june" - 600.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 600 kaf <br>or the total reduction (if it all occurs in June)"
 ENDWITH;

    END;

    FUNCTION       "SteadyFlowReduce_5_April" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 5.00000000 ) COMMENTED_BY "5 in reverse order is april" - 500.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ) - "SteadyFlowReduce_4_June2"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in April down to 500 kaf<br>or the total reduction (if it all occurs in June)"
 ENDWITH;

    END;

    FUNCTION       "SteadyFlowReduce_6_May" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH LIST monthlyRelease = "Reverse"( "GetInitialPowellMonthlyVolumes"(  ) ) DO
  "Min"( "Max"( "GetElement"( monthlyRelease, 4.00000000 ) COMMENTED_BY "4 in reverse order is may" - 500.00000000 "1000 acre-ft", 0.00000000 "acre-ft" ), "Max"( "Sum"( monthlyRelease ) - $ "PowellData.TargetAnnualReleaseVolume" [] - "SteadyFlowReduce_1_July"(  ) - "SteadyFlowReduce_2_August"(  ) - "SteadyFlowReduce_3_June1"(  ) - "SteadyFlowReduce_4_June2"(  ) - "SteadyFlowReduce_5_April"(  ), 0.00000000 "acre-ft" ) ) COMMENTED_BY "Return either the amount of reduction in June down to 600 kaf <br>or the total reduction (if it all occurs in June)"
 ENDWITH;

    END;

    FUNCTION       "DepletionToDiversionRatio" ( STRING depletionSlot, STRING diversionSlot, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( depletionSlot [date] == 0.00000000 "cms" )
 THEN
  0.00000000
 ELSE
  diversionSlot [date] / depletionSlot [date]
 ENDIF;

    END;

    FUNCTION       "SubbasinShortage" ( STRING subbasin, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( OBJECT obj IN "ListSubbasin"( subbasin ) SET_INTERSECTION ( "ListSubbasin"( "AggDiversionSite" ) COMMENTED_BY "Can eliminate after bug 4914 is fixed.  Have to do this now because we are <br>expecting only aggregate diversion sites not individual water users" ) ) WITH NUMERIC totalShortage = 0.00000000 "acre-ft" DO
  FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC userShortage = 0.00000000 "acre-ft" DO
   userShortage + ( "FlowToVolume"( % "SanJuanNewMexicoDiversionSchedules" & ( ( STRINGIFY obj ) CONCAT "_" CONCAT "Depletion" ) [date], date ) - "FlowToVolume"( obj & "Total Depletion Requested" [date], date ) ) COMMENTED_BY "Subtract off depletion requested because this slot <br>has already been reduced by the WSA rule"
  ENDFOR + totalShortage
 ENDFOR;

    END;

  END;

  UTILITY_GROUP "NavajoFunctions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "DebugDailyNavajoFunction" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is used to debug the parent function, this should not have an impact on the result of the parent function and can be edited using the boolean function that allows this function to execute. <br><br>RETURN TYPE: Flow rate of 0.00 cfs<br><br>ARGUMENTS:<none><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/4/2015<br>";
    BEGIN

      0.00000000 "cfs";

    END;

    FUNCTION       "DetermineNavajoEoWYReleaseLevel" ( DATETIME date )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: <br>This Function returns the value of the release level for the Navajo Release<br>0 = No Release<br>1 = Release of 114,000 AF<br>2 = Relase greater of 166,000 or SpillAF<br>3 = Release of > 344,000 AF to get the reservoir back to full<br><br>The policy is based on the decision Tree used by the Navajo Dam Operator and is within the Flow Recomendations For the San Juan River published by the San Juan River Basin Recovery Implementation Program *1999 <br><br>RETURNS: List of the form &lcub;Water required for EOWY target pool elevation, Release level, Nose level, Nose volume, Excess release&rcub;<br><br>ARGUMENTS<br>1. DATETIME date - date used to determine calendar year of release level<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170502: Unclear to me whether Navajo operates on water year or calendar year at this point; a date is passed into the function as an argument, but the current timestep @&quot;t&quot; is also used in the function";
    BEGIN

      WITH NUMERIC waterRqdForEOWYTPE = "Max"( IF ( @"t" == @"Start Timestep" )
 THEN
  IF ( "GetMonth"( @"t" ) <= 2.00000000 OR "GetMonth"( @"t" ) >= 10.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   "WaterToAchieveEOYTPE"( "GetWaterYearEndDate"( @"t" ) )
  ENDIF
 ELSE
  "WaterToAchieveEOYTPE"( "GetWaterYearEndDate"( @"t" ) ) COMMENTED_BY "If the timestep is not the start timestep, it has to be March"
 ENDIF, 0.00000000 "acre-ft" ) + IF ( $ "NavajoData.Add6050SPRToAvailWater" ["Dec31ofYear"( @"t" )] == 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "ElevationToStorage"( % "Navajo", 6063.00000000 ) - "ElevationToStorage"( % "Navajo", 6050.00000000 )
 ENDIF COMMENTED_BY "In the event that an additional Spring Peak Release of water available to 6,050 ft. on Navajo is <br>requested, the flag NavajoData.Add6050SPRToAvailWater = 1, then the volume of water <br>between 6,063 and 6,050 is added to the Spring Peak Release. The approximate volume of that <br>water is 160.87 KAF. TP 8/4/2014" DO
  WITH NUMERIC releaseLevel = IF ( "IsInput"( $ "NavajoData.ReleaseLevel", "Dec31ofYear"( date ) ) )
  THEN
   $ "NavajoData.ReleaseLevel" ["Dec31ofYear"( date )]
  ELSE
   FOR ( NUMERIC iter IN "GetNumbers"( 1.00000000, 4.00000000, 1.00000000 ) ) WITH NUMERIC result = 0.00000000 DO
    IF ( waterRqdForEOWYTPE >= $ "NavajoData.SpringPeakReleaseLevels" ["Volume", iter - 1.00000000] )
    THEN
     iter
    ELSE
     result
    ENDIF
   ENDFOR
  ENDIF DO
   WITH NUMERIC noseLevel = IF ( releaseLevel == 4.00000000 )
   THEN
    FOR ( NUMERIC iter IN "GetNumbers"( 0.00000000, 10.00000000, 1.00000000 ) ) WITH NUMERIC result = 0.00000000 DO
     IF ( waterRqdForEOWYTPE - $ "NavajoData.SpringPeakReleaseLevels" ["Volume", 3.00000000] >= $ "NavajoData.SpringNoseLevels" ["Volume", iter] )
     THEN
      iter
     ELSE
      result
     ENDIF
    ENDFOR
   ELSE
    0.00000000
   ENDIF DO
    WITH NUMERIC noseVolume = IF ( releaseLevel == 4.00000000 )
    THEN
     waterRqdForEOWYTPE - $ "NavajoData.SpringPeakReleaseLevels" ["Volume", 3.00000000]
    ELSE
     0.00000000 "acre-ft"
    ENDIF DO
     WITH NUMERIC excessOfRelease = IF ( releaseLevel == 4.00000000 )
     THEN
      noseVolume - $ "NavajoData.SpringNoseLevels" ["Volume", noseLevel]
     ELSE
      IF ( NOT releaseLevel == 0.00000000 )
      THEN
       "Max"( waterRqdForEOWYTPE - $ "NavajoData.SpringPeakReleaseLevels" ["Volume", releaseLevel - 1.00000000], 0.00000000 "acre-ft" )
      ELSE
       "Max"( "WaterToAchieveEOYTPE"( "GetWaterYearEndDate"( @"t" ) ), 0.00000000 "acre-ft" )
      ENDIF
     ENDIF DO
      { waterRqdForEOWYTPE , releaseLevel , noseLevel , noseVolume , excessOfRelease }
     ENDWITH
    ENDWITH COMMENTED_BY "Calculate nose volume"
   ENDWITH COMMENTED_BY "Calculate the nose level"
  ENDWITH COMMENTED_BY "Calculate the release level"
 ENDWITH COMMENTED_BY "Water required to reach EOWY target pool elevation";

    END;

    FUNCTION       "DetermineNavajoMonthlyFlowVolumeNew" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Sums flows for each month using the NavajoData.NavajoOuflowWithScale Slot.  These values will be returned as volume per month in Acre-ft and will become the Navajo.Outflow monthly values. <br><br>RETURNS: Monthly outflow as a sum of daily flows [L^3]<br><br>ARGUMENTS<br>1. DATETIME date - timestep date (end of month) specifying the month for which to calculate the outflow<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 8/7/2012";
    BEGIN

      "SumFlowsToVolume"( $ "NavajoData.MarchThruJulyDaily", "OffsetDate"( date, ( "GetDaysInMonth"( date ) / 1.00000000 "day" - 1.00000000 ) * - 1.00000000, "1 days" ), date );

    END;

    FUNCTION       "DailyOutflowsForNavajo" ( DATETIME date, NUMERIC releaseLevel, NUMERIC noseLevel, NUMERIC excessOfRelease )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is called by the rule &quot;March through July Daily Release&quot; to calculate the daily release value from Navajo based on the date, release and nose levels for the year, and excess water available<br><br>RETURNS: Daily release rate<br><br>ARGUMENTS<br>1. DATETIME date - date on which to calculate the release rate<br>2. NUMERIC releaseLevel - annual release level for the reservoir<br>3. NUMERIC noseLevel - annual nose level for the reservoir<br>4. NUMERIC excessOfRelease - excess water available over base flow<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC peakReleaseValue = $ "NavajoData.SpringPeakReleaseByLevel" [date, releaseLevel] DO
  WITH NUMERIC noseReleaseValue = $ "NavajoData.SpringPeakNoseByLevel" [date, noseLevel] DO
   WITH NUMERIC peakAndNoseValue = peakReleaseValue + noseReleaseValue DO
    WITH LIST baseFlowDate = { 0.00000000 "day" , 6.00000000 "day" , 9.00000000 "day" , 13.00000000 "day" , 25.00000000 "day" } DO
     WITH NUMERIC baseFlowDays = "GetDayOfYear"( @"24:00:00 October 1, Current Year" ) - ( 155.00000000 "day" + GET @INDEX releaseLevel FROM baseFlowDate ) DO
      WITH NUMERIC baseFlowChange = excessOfRelease / baseFlowDays DO
       WITH NUMERIC flowValue = IF ( peakAndNoseValue > 0.00000000 "cfs" )
       THEN
        peakAndNoseValue
       ELSE
        IF ( "GetDayOfYear"( date ) < 155.00000000 "day" OR date > @"24:00:00 September 30, Current Year" )
        THEN
         $ "NavajoData.BaseRelease" []
        ELSE
         "Max"( $ "NavajoData.BaseRelease" [] + baseFlowChange, $ "NavajoData.BaseRelease" [] ) COMMENTED_BY "Release at least base flow, but more if available"
        ENDIF COMMENTED_BY "Release base flow prior to June 5 (June 4 in leap year) and after September 30"
       ENDIF DO
        flowValue + IF ( date > @"24:00:00 June 28, Current Year" )
        THEN
         "DebugDailyNavajoFunction"(  )
        ELSE
         0.00000000 "cfs"
        ENDIF
       ENDWITH
      ENDWITH COMMENTED_BY "Calculate amount by which to change base flow"
     ENDWITH COMMENTED_BY "Calculate the number of days at base flow based on the release level"
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "DetermineLowFlowsatNavajo" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: If the spring peak operations cause Navajo to go below 5,990 ft. determine the shortage sharing reduction in outflow and NIIP Diversion to keep Navajo from going below 5,990 ft.  5,990 ft is elevation for which NIIP can no longer divert water from Navajo Reservoir.<br><br>RETURN TYPE: List of lists of the form &lcub;Date, Navajo outflow, Navajo diversion&rcub;<br><br>ARGUMENTS: <none><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH DATETIME EndDate = "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12", @"Finish Timestep" ) DO
  FOR ( DATETIME date IN "GetDates"( @"t", EndDate, "1 months" ) ) WITH LIST result = {  } DO
   WITH LIST DateAndDiffStor = FOR ( DATETIME dateb IN "GetDates"( @"t", EndDate, "1 months" ) ) WITH LIST DateAndDiffStor = {  } DO
    APPEND { dateb , "Max"( "ElevationToStorage"( % "Navajo", $ "NavajoData.MinDesiredPoolElevation" [] ) - $ "Navajo.Storage" [dateb], 0.00000000 "acre-ft" ) } ONTO DateAndDiffStor
   ENDFOR DO
    WITH LIST DiffList = MAPLIST ( LIST DiffListCheck IN DateAndDiffStor ) DO
     GET @INDEX 1.00000000 FROM DiffListCheck
    ENDMAPLIST DO
     WITH NUMERIC MaxDiff = "MaxItem"( DiffList ) DO
      WITH NUMERIC MaxIndex = FIND MaxDiff WITHIN DiffList DO
       WITH NUMERIC MaxDiffWithEvap = MaxDiff + "SumSlot"( $ "Navajo.Evaporation", @"t", EndDate ) DO
        WITH LIST MaxDateLists = GET @INDEX MaxIndex FROM DateAndDiffStor DO
         WITH DATETIME MaxDate = "DateMin"( GET @INDEX 0.00000000 FROM MaxDateLists, @"Finish Timestep" ) DO
          WITH NUMERIC SummedOutflowValuesFromNavajo = "SumFlowsToVolume"( $ "Navajo.Outflow", @"t", MaxDate ) DO
           WITH NUMERIC SummedNIIPDiversions = "SumFlowsToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Depletion Requested", @"t", MaxDate ) DO
            WITH NUMERIC ReductionFactor = "Max"( ( SummedOutflowValuesFromNavajo + SummedNIIPDiversions - MaxDiffWithEvap ) / ( SummedOutflowValuesFromNavajo + SummedNIIPDiversions ), 0.00000000 ) DO
             IF ( date > MaxDate )
             THEN
              ( APPEND { date , $ "Navajo.Outflow" [date] , $ "Navajo.Diversion" [date] } ONTO result ) COMMENTED_BY "No reduction necessary"
             ELSE
              ( APPEND { date , "Max"( $ "Navajo.Outflow" [date] * ReductionFactor, "Min"( $ "NavajoData.MinimumOutflow" [], $ "Navajo.Inflow" [] ) ) , "Max"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [date] * ReductionFactor, 0.00000000 "cfs" ) } ONTO result ) COMMENTED_BY "Reduced outflows and diversions"
             ENDIF COMMENTED_BY "Append appropriate result to list"
            ENDWITH COMMENTED_BY "Calculate factor by which to reduce outflows and diversions"
           ENDWITH COMMENTED_BY "Calculate cumulative NIIP diversions"
          ENDWITH COMMENTED_BY "Calculate cumulative outflows"
         ENDWITH COMMENTED_BY "Find the earlier of MaxDate or the end of the model run"
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "Remove the dates from the prior list of lists and just keep the shortage values"
   ENDWITH COMMENTED_BY "Create list of lists with the form &lcub;Date, Storage shortage on the date&rcub;"
  ENDFOR
 ENDWITH COMMENTED_BY "Loop through dates between current timestep and the earlier of the finish timestep or the end of February of the next year";

    END;

    FUNCTION       "EstimateEvaporationNavajo" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This Function estimates the evaporation from March to July for the available water calculation.  The evaporation is calculated based on the total inflow to the reservoir and  a release of only the base flow.  An error was occuring where the area volume table was limiting the solving of the reservoir because taking an inflow and releasing only the base flow can result in higher storage levels than the table implies.  So the Min function with the equation and the 1,976,849 acre-ft is used right now because 1,977,850.0000999999 acre-ft is the maximum storage in the area volume table.  This limits the evaporation to be calculated based on the largest area in the table.  If the area volume curve is extended, then this min function can be removed. <br><br>RETURN TYPE: Estimate of the evaporation volume<br><br>ARGUMENTS<br>1. DATETIME startDate - beginning of the estimation period<br>2. DATETIME endDate - end of the estimation period<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/14/2012";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC evapCalc = 0.00000000 "acre-ft" DO
  evapCalc + "FlowToVolume"( "StorageToArea"( % "Navajo", "Min"( $ "Navajo.Storage" [@"t - 1"] + "SumFlowsToVolume"( $ "Navajo.Inflow", startDate, date ) - "SumNavajoBaseRelease"( startDate, date ) - FOR ( DATETIME niipDate IN startDate TO date ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
   "FlowToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [niipDate], niipDate ) + result
  ENDFOR, 1976849.00000000 "acre-ft" ) ) * $ "Navajo.Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000], date ) COMMENTED_BY "Estimated evaporation for &quot;date&quot;"
 ENDFOR COMMENTED_BY "Calculate estimate by adding the evaporation estimate for each date to a running total";

    END;

    FUNCTION       "IsLowFlowAdjustmentNecessary" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a TRUE value if for any month between the current timestep and the earlier of the next February or the model Finish Timestep, the pool elevation drops below the MinDesiredPoolElevation value; otherwise, the function returns FALSE<br><br>RETURNS: TRUE (low flow adjustment necessary) or FALSE (no adjustment necessary)<br><br>ARGUMENTS:<none><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN "GetDates"( @"t", "DateMin"( @"24:00:00 February Max DayOfMonth, Current Year + 12", @"Finish Timestep" ), "1 months" ) ) WITH BOOLEAN result = FALSE DO
  IF ( $ "Navajo.Pool Elevation" [date] < $ "NavajoData.MinDesiredPoolElevation" [] )
  THEN
   TRUE
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "MaxDayOfMonth_pre201707" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the date for the end of the month containing the input argument &quot;date&quot;, including consideration for leap years.<br><br>RETURNS: Datetime representing the end of the month date [Datetime]<br><br>ARGUMENTS<br>1. DATETIME date<br><br>CONSTRAINTS: <NONE><br><br>.";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Rewrite this function as MaxDayOfMonth = OffsetDate(date, [GetDaysInMonth(date)-GetDayOfMonth(date)]/1 ?day?, ?1 days?), and use it to replace calls to GetEndDayOfMonth also? Similar for MinDayOfMonth & GetStartDayOfMonth";
    BEGIN

      WITH NUMERIC MoNum = "GetMonth"( date ) DO
  IF ( MoNum == 1.00000000 )
  THEN
   "OffsetDate"( date, "Units NONE"( 31.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
  ELSE
   IF ( MoNum == 2.00000000 )
   THEN
    IF ( "LeapYear"( date ) )
    THEN
     "OffsetDate"( date, "Units NONE"( 60.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
    ELSE
     "OffsetDate"( date, "Units NONE"( 59.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
    ENDIF
   ELSE
    IF ( MoNum == 3.00000000 )
    THEN
     IF ( "LeapYear"( date ) )
     THEN
      "OffsetDate"( date, "Units NONE"( 91.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
     ELSE
      "OffsetDate"( date, "Units NONE"( 90.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
     ENDIF
    ELSE
     IF ( MoNum == 4.00000000 )
     THEN
      IF ( "LeapYear"( date ) )
      THEN
       "OffsetDate"( date, "Units NONE"( 121.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
      ELSE
       "OffsetDate"( date, "Units NONE"( 120.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
      ENDIF
     ELSE
      IF ( MoNum == 5.00000000 )
      THEN
       IF ( "LeapYear"( date ) )
       THEN
        "OffsetDate"( date, "Units NONE"( 152.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
       ELSE
        "OffsetDate"( date, "Units NONE"( 151.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
       ENDIF
      ELSE
       IF ( MoNum == 6.00000000 )
       THEN
        IF ( "LeapYear"( date ) )
        THEN
         "OffsetDate"( date, "Units NONE"( 182.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
        ELSE
         "OffsetDate"( date, "Units NONE"( 181.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
        ENDIF
       ELSE
        IF ( MoNum == 7.00000000 )
        THEN
         IF ( "LeapYear"( date ) )
         THEN
          "OffsetDate"( date, "Units NONE"( 213.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
         ELSE
          "OffsetDate"( date, "Units NONE"( 212.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
         ENDIF
        ELSE
         IF ( MoNum == 8.00000000 )
         THEN
          IF ( "LeapYear"( date ) )
          THEN
           "OffsetDate"( date, "Units NONE"( 244.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
          ELSE
           "OffsetDate"( date, "Units NONE"( 243.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
          ENDIF
         ELSE
          IF ( MoNum == 9.00000000 )
          THEN
           IF ( "LeapYear"( date ) )
           THEN
            "OffsetDate"( date, "Units NONE"( 274.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
           ELSE
            "OffsetDate"( date, "Units NONE"( 273.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
           ENDIF
          ELSE
           IF ( MoNum == 10.00000000 )
           THEN
            IF ( "LeapYear"( date ) )
            THEN
             "OffsetDate"( date, "Units NONE"( 305.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
            ELSE
             "OffsetDate"( date, "Units NONE"( 304.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
            ENDIF
           ELSE
            IF ( MoNum == 11.00000000 )
            THEN
             IF ( "LeapYear"( date ) )
             THEN
              "OffsetDate"( date, "Units NONE"( 335.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ELSE
              "OffsetDate"( date, "Units NONE"( 334.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ENDIF
            ELSE
             IF ( "LeapYear"( date ) )
             THEN
              "OffsetDate"( date, "Units NONE"( 366.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ELSE
              "OffsetDate"( date, "Units NONE"( 365.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
             ENDIF
            ENDIF
           ENDIF
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END;

    FUNCTION       "MaxDayOfMonth" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the date for the end of the month containing the input argument &quot;date&quot;, including consideration for leap years.<br><br>RETURNS: Datetime representing the end of the month date [Datetime]<br><br>ARGUMENTS<br>1. DATETIME date<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Rewrite this function as MaxDayOfMonth = OffsetDate(date, [GetDaysInMonth(date)-GetDayOfMonth(date)]/1 ?day?, ?1 days?), and use it to replace calls to GetEndDayOfMonth also? Similar for MinDayOfMonth & GetStartDayOfMonth.";
    BEGIN

      "OffsetDate"( date, ( "GetDaysInMonth"( date ) - "GetDayOfMonth"( date ) ) / 1.00000000 "day", "1 days" );

    END;

    FUNCTION       "MinDayOfMonth" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date for the beginning of the month containing the input argument &quot;date&quot;. The function assumes that &quot;date&quot; represents the last day of a month.<br><br>RETURNS: Beginning date of month [Datetime]<br><br>ARGUMENTS<br>1. DATETIME date - end date of the month for which the beginning date is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Rewrite this function as MinDayOfMonth = OffsetDate(date, GetDayOfMonth(date)]/1 ?day? - 1, ?-1 days?), and use it to replace calls to GetStartDayOfMonth also? Similar for MaxDayOfMonth & GetEndDayOfMonth.";
    BEGIN

      WITH NUMERIC MoNum = "GetMonth"( date ) DO
  IF ( MoNum == 1.00000000 )
  THEN
   "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
  ELSE
   IF ( MoNum == 2.00000000 )
   THEN
    IF ( "LeapYear"( date ) )
    THEN
     "OffsetDate"( date, "Units NONE"( - 28.00000000 "day" ), "1 days" )
    ELSE
     "OffsetDate"( date, "Units NONE"( - 27.00000000 "day" ), "1 days" )
    ENDIF
   ELSE
    IF ( MoNum == 3.00000000 )
    THEN
     "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
    ELSE
     IF ( MoNum == 4.00000000 )
     THEN
      "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
     ELSE
      IF ( MoNum == 5.00000000 )
      THEN
       "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
      ELSE
       IF ( MoNum == 6.00000000 )
       THEN
        "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
       ELSE
        IF ( MoNum == 7.00000000 )
        THEN
         "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
        ELSE
         IF ( MoNum == 8.00000000 )
         THEN
          "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
         ELSE
          IF ( MoNum == 9.00000000 )
          THEN
           "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
          ELSE
           IF ( MoNum == 10.00000000 )
           THEN
            "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
           ELSE
            IF ( MoNum == 11.00000000 )
            THEN
             "OffsetDate"( date, "Units NONE"( - 29.00000000 "day" ), "1 days" )
            ELSE
             "OffsetDate"( date, "Units NONE"( - 30.00000000 "day" ), "1 days" )
            ENDIF
           ENDIF
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END;

    FUNCTION       "NavajoAboveMaxPEOperations" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: If the Navajo pool elevation is above the maximum then release water to reduce the pool elevation. Return the new outflow for Navajo, the ouflow change as a volume and the volume that needed to be released in order to get to the Dam Protection pool elevation.<br><br>RETURNS: List of form &lcub;Modified Outflow, Outflow volume change, Volume released&rcub;<br><br>ARGUMENTS:<none><br><br>CONSTRAINTS: Maximum release of 5,000 cfs based on Max Release table<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/4/2015";
    BEGIN

      WITH NUMERIC navajoMonthlyOutflow = "Min"( $ "Navajo.Outflow" [] + "VolumeToFlow"( "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] ), @"t" ), 5000.00000000 "cfs" ) DO
  WITH NUMERIC navajoMonthlyVolumeChange = "FlowToVolume"( navajoMonthlyOutflow - $ "Navajo.Outflow" [], @"t" ) DO
   WITH NUMERIC volReleasedForDamProtection = "ElevationToStorage"( % "Navajo", $ "Navajo.Pool Elevation" [] ) - "ElevationToStorage"( % "Navajo", $ "NavajoData.PostDamProtectionPE" [] ) DO
    { navajoMonthlyOutflow , navajoMonthlyVolumeChange , volReleasedForDamProtection }
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Find outflow <=5,000 cfs that will reduce pool elevation to dam protection level; <br>5,000 cfs is the approximate maximum release (at interpolated pool elevation of 6,103 ft)";

    END;

    FUNCTION       "SumNavajoBaseRelease" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the sum of outflows from &quot;startDate&quot; to &quot;endDate&quot;<br><br>RETURNS: Volume released between startDate and endDate<br><br>ARGUMENTS:<br>1. DATETIME startDate - date on which to begin sum<br>2. DATETIME endDate - date on which to end sum<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN startDate TO endDate ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
  result + "FlowToVolume"( $ "Navajo.Outflow" [], date )
 ENDFOR;

    END;

    FUNCTION       "WaterToAchieveEOYTPE" ( DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses a water balance to calculate the water available (over base releases) between the current time and the date in the argument &quot;endDate&quot;, in order to achieve the end-of-water-year pool elevation target for the year containing &quot;endDate&quot;.<br><br>RETURNS: Water volume available for release<br><br>ARGUMENTS<br>1. DATETIME endDate - date that specifies the end of the period for which to calculate available water<br><br>CONSTRAINTS<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC AvailableWater = $ "Navajo.Storage" [@"t - 1"] COMMENTED_BY "Beginning storage" + "SumFlowsToVolume"( $ "Navajo.Inflow", @"t", endDate ) COMMENTED_BY "Inflow volume" - "SumNavajoBaseRelease"( @"t", endDate ) COMMENTED_BY "Base flow release volume" - "ElevationToStorage"( % "Navajo", $ "NavajoData.EOWYTargetPE" ["Dec31ofYear"( endDate )] ) COMMENTED_BY "Storage at target PE" - FOR ( DATETIME niipDate IN @"t" TO endDate ) WITH NUMERIC niipVol = 0.00000000 "acre-ft" DO
  "FlowToVolume"( $ "NavajoIndianIrrigationProjectNIIP.Diversion Requested" [niipDate], niipDate ) + niipVol
 ENDFOR COMMENTED_BY "NIIP diversion volume requested" - "EstimateEvaporationNavajo"( @"t", endDate ) COMMENTED_BY "Evaporation volume" DO
  AvailableWater
 ENDWITH;

    END;

  END;

  UTILITY_GROUP "Flaming Gorge Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "DaysToDownramp" ( NUMERIC PPC, NUMERIC Baseflow, NUMERIC Rate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the number of days required to downramp from powerplant capacity to baseflow. Baseflow is set by the current hydrologic classification. The unit business is because Riverware cannot currently do calculations with the FlowPerTime unit. <br><br>RETURNS: Number of days [NONE]<br><br>ARGUMENTS<br>1. NUMERIC PPC - beginning flow rate (assuming powerplant capacity)<br>2. NUMERIC Baseflow - ending flow rate (baseflow rate based on current hydrologic classification)<br>3. NUMERIC Rate - daily flow rate reduction value<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown";
    BEGIN

      ( ( PPC - Baseflow ) / ( Rate / 1.00000000 "day" ) ) COMMENTED_BY "Assuming we are downramping from power plant capacity, divide required reduction in flow rate by the daily reduction in rate";

    END;

    FUNCTION       "DaysToRampUp" ( NUMERIC PPC, NUMERIC Baseflow, NUMERIC Rate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: The number of days to ramp up are determined by either the powerplant capacity minus the baseflow divided by the ramp up rate, or 0, whichever is greater<br><br>RETURNS: Number of days [NONE]<br><br>ARGUMENTS<br>1. NUMERIC PPC - beginning flow rate (assuming powerplant capacity)<br>2. NUMERIC Baseflow -ending flow rate  (baseflow rate based on current hydrologic classification)<br>3. NUMERIC Rate - daily flow rate reduction value<br><br>CONSTRAINTS<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: CE 6/12/13";
    BEGIN

      "Max"( ( PPC - Baseflow ) / ( Rate / 1.00000000 "day" ), 0.00000000 "day" );

    END;

    FUNCTION       "ForecastComputeOutflowAtRuleCurveStorage" ( OBJECT reservoir, DATETIME month, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function performs a simple water balance for the reservoir and month specified as inputs. The water balance is based on the previous storage passed to the function, the rule curve storage for the month passed as input, the reservoir inflows, and an evaporation estimate.<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS<br>1. OBJECT reservoir - reservoir for which outflow forecast is needed<br>2. DATETIME month - timestep for which outflow forecast is needed<br>3. NUMERIC previousStorage - reservoir storage volume at beginning of month<br><br>CONSTRAINTS: Minimum and Maximum release rates for the specified reservoir<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    MIN_CONSTRAINT "GetMinRelease"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      ( previousStorage - "RuleCurveStorage"( reservoir, month ) ) / 1.00000000 "month" + reservoir & "Inflow" [month] - "VolumeToFlow"( "EstimateEvaporation"( reservoir, previousStorage, previousStorage, month, month ), month );

    END;

    FUNCTION       "ForecastComputeStorageAtGivenOutflow" ( OBJECT reservoir, NUMERIC outflow, DATETIME month, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Based on a simple water balance and the given input arguments, this function returns either the Inactive Capacity of the reservoir or a projection of the storage taking into account the outflow and estimated evaporation<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which outflow forecast is needed<br>2. NUMERIC outflow - outflow rate to use in forecast<br>3. DATETIME month - timestep for which outflow forecast is needed<br>4. NUMERIC previousStorage - reservoir storage volume at beginning of month<br><br>CONSTRAINTS: Inactive storage capacity; Live storage capacity (from slot UBRuleCurveData.ReservoirData)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT "GetInactiveCapacity"( reservoir );
    MAX_CONSTRAINT "GetLiveCapacity"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170503: Previous version of function was written so that it returned either the InactiveCapacity or the LiveCapacity (fixed value), but could not return a value between those; rewrote the function to return the computed water balance value constrained by the Inactive or Live capacity";
    BEGIN

      WITH NUMERIC ForecastStorage = previousStorage + "FlowToVolume"( reservoir & "Inflow" [month], month ) - ( "FlowToVolume"( outflow, month ) + "EstimateEvaporation"( reservoir, previousStorage, previousStorage, month, month ) ) DO
  "Max"( "Min"( ForecastStorage, "GetLiveCapacity"( reservoir ) ), "GetInactiveCapacity"( reservoir ) )
 ENDWITH;

    END;

    FUNCTION       "ForecastFontenelleRelease" ( DATETIME startMonth, DATETIME endMonth )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function forecasts the releases and associated storage volumes for Fontenelle for the period startMonth to endMonth.<br><br>RETURNS: List of lists of the form &lcub;&lcub;Storage volumes&rcub;, &lcub;Outflow rates&rcub;&rcub;<br><br>ARGUMENTS:<br>1. DATETIME startMonth - first month in the period of calculation<br>2. DATETIME endMonth - last month in the period of calculation<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC totalMonths = IF ( "GetMonth"( endMonth ) - "GetMonth"( startMonth ) < 0.00000000 )
 THEN
  12.00000000 - "Abs"( "GetMonth"( endMonth ) - "GetMonth"( startMonth ) )
 ELSE
  "GetMonth"( endMonth ) - "GetMonth"( startMonth )
 ENDIF DO
  FOR ( NUMERIC month IN "GetNumbers"( 0.00000000, totalMonths, 1.00000000 ) ) WITH LIST result = { { $ "Fontenelle.Storage" ["OffsetDate"( startMonth, - 1.00000000, "1 MONTHS" )] } COMMENTED_BY "Previous storage" , {  } COMMENTED_BY "New outflow " } DO
   WITH DATETIME currentDate = "OffsetDate"( startMonth, month, "1 MONTHS" ) DO
    WITH NUMERIC newStorage = "ForecastComputeStorageAtGivenOutflow"( % "Fontenelle", "ForecastComputeOutflowAtRuleCurveStorage"( % "Fontenelle", currentDate, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ), currentDate, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ) DO
     { APPEND newStorage COMMENTED_BY "New, compute StorageAtGivenOutflow which takes time and previous storage as a parameter" ONTO GET @INDEX 0.00000000 FROM result , APPEND ( ( ( GET @INDEX month FROM GET @INDEX 0.00000000 FROM result ) - newStorage ) / 1.00000000 "month" + % "Fontenelle" & "Inflow" [currentDate] - "VolumeToFlow"( "EstimateEvaporation"( % "Fontenelle", GET @INDEX month FROM GET @INDEX 0.00000000 FROM result, GET @INDEX month FROM GET @INDEX 0.00000000 FROM result, currentDate, currentDate ), currentDate ) ) COMMENTED_BY "MC, 20170503: Does this give the same flow rate as ForecastComputeOutflowAtRuleCurveStorage in the computation of newStorage?" ONTO GET @INDEX 1.00000000 FROM result }
    ENDWITH
   ENDWITH
  ENDFOR
 ENDWITH;

    END;

    FUNCTION       "GetDaysAtBypass" ( NUMERIC HClass )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Determines the number of days at bypass capacity. For mod dry, average and mod wet years, if the number of days that the Yampa is greater than 14000 cfs is greater than the threshold then the standard days at bypass capacity are used. If the days greater than 14000 cfs is less than the threshold then the days at bypass is zero.  For dry years the days at bypass is always zero and for wet years always bypass. -CE 6/12/13<br><br>RETURNS: Number of days [NONE]<br><br>ARGUMENTS:<br>1. NUMERIC HClass - hydrologic class indicator<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( HClass < 4.00000000 AND HClass > 0.00000000 )
 THEN
  IF ( "YampaDaysAbove14000"(  ) > $ "FlamingGorgeData.YampaDaysAbove14000ForBypass" [HClass, 0.00000000] )
  THEN
   $ "FlamingGorgeData.DaysAtBypassCapacity" [HClass, 0.00000000]
  ELSE
   0.00000000 "day"
  ENDIF COMMENTED_BY "If the Yampa is very wet then bypass to meet peaks otherwise no bypass"
 ELSE
  IF ( HClass == 0.00000000 )
  THEN
   0.00000000 "day" COMMENTED_BY "In Dry years never bypass"
  ELSE
   $ "FlamingGorgeData.DaysAtBypassCapacity" [HClass, 0.00000000] COMMENTED_BY "In wet years always bypass"
  ENDIF
 ENDIF COMMENTED_BY "Are we in Mod Dry, Ave, or Mod Wet?";

    END;

    FUNCTION       "GetFGBaseFlowMagnitude" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft/month";
    DESCRIPTION    "DESCRIPTION: Returns the steady base flow magnitude necessary to meet the May 1 ULDE.  The magnitude is first projected as if there are no base flow limits. If the necessary base flow is outside of the limits, then the returned flow is within the limits set by the current hydrologic classification. <br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT "SolveOutflow"( % "FlamingGorge", $ "FlamingGorge.Inflow" [], "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.MaxPE" [] ), $ "FlamingGorge.Storage" [@"t - 1"], @"t" );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "GetFGBaseFlowMagnitudeUnconstrained"(  ) < $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 0.00000000] )
 THEN
  $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 0.00000000] COMMENTED_BY "Use Lower Limit of Base Flow Range"
 ELSE
  IF ( "GetFGBaseFlowMagnitudeUnconstrained"(  ) > $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 1.00000000] )
  THEN
   $ "FlamingGorgeData.BaseFlowMagnitudeLimits" [$ "KNN_MTOM.BaseFlowHClass" [], 1.00000000] COMMENTED_BY "Use Upper Limit of Base Flow Range"
  ELSE
   "GetFGBaseFlowMagnitudeUnconstrained"(  ) COMMENTED_BY "Somewhere in between, use calculated value"
  ENDIF
 ENDIF;

    END;

    FUNCTION       "GetFGBaseFlowMagnitudeUnconstrained" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    ".acre-ft/month";
    DESCRIPTION    "DESCRIPTION: Uses a simple water balance with predicted inflows to calculate a steady outflow rate from the current timestep to the next April to meet the May 1 ULDE regardless of base flow restrictions. <br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170315: Calculation the same for May-Dec & Jan-Feb so combine?";
    BEGIN

      IF ( "MonthIs"( { "March" , "April" } ) )
 THEN
  "Max"( "VolumeToFlow"( ( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "FlamingGorge", "GetMay1TargetElevation"(  ) ) + "PredictedFGInflow"( @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) / "NumberOfMonthsUntilMay"(  ), @"t" ), $ "FlamingGorgeData.MinFlow" [] )
 ELSE
  IF ( "MonthIs"( { "May" , "June" , "July" , "August" , "September" , "October" , "November" , "December" } ) )
  THEN
   "Max"( "VolumeToFlow"( ( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.May1TargetElevation" [0.00000000, 2.00000000] ) COMMENTED_BY "May 1 ULDE (Always 6027 FT until March and where it may be adjusted based upon the Percent Exceedence. -From Heather H.  -HG 5/24/2013" + "PredictedFGInflow"( @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Next Year" ) ) / "NumberOfMonthsUntilMay"(  ), @"t" ), $ "FlamingGorgeData.MinFlow" [] )
  ELSE
   "Max"( "VolumeToFlow"( ( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorgeData.May1TargetElevation" [0.00000000, 2.00000000] ) COMMENTED_BY "March 1 soft baseflow target is always a pool elevation of 6027 FT. During March this target may be adjusted based upon the Percent Exceedence to get the actual May 1 ULDE. -From Heather Hermansen  -HG 5/24/2013" + "PredictedFGInflow"( @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) / "NumberOfMonthsUntilMay"(  ), @"t" ), $ "FlamingGorgeData.MinFlow" [] ) COMMENTED_BY "January and February."
  ENDIF
 ENDIF COMMENTED_BY " In actual operations, at March a new forecast would come out for the next April through July volume so we adjust the May 1 ULDE then. For all other months besides March and April<br> the May 1 ULDE is assumed to be the maximum May 1 pool elevation of 6027 FT. -HG 10/9/12";

    END;

    FUNCTION       "GetMay1TargetElevation" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns the May 1 target pool elevation based on the percent exceedance value of the Apr-Jul inflow forecast<br><br>RETURNS: Target May 1 pool elevation for Flaming Gorge [L]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      $ "FlamingGorgeData.May1TargetElevation" [IF ( ( WHILE ( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] * 100.00000000 < $ "FlamingGorgeData.May1TargetElevation" [result, 1.00000000] AND result <= 2.00000000 ) WITH NUMERIC result = 0.00000000 DO
  result + 1.00000000
 ENDWHILE == 0.00000000 ) COMMENTED_BY "Cycle through indices and if exceedance percentage is greater than all in table, return index of 0; target elevation will be 6,027 ft" )
 THEN
  0.00000000
 ELSE
  WHILE ( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [] * 100.00000000 < $ "FlamingGorgeData.May1TargetElevation" [result, 1.00000000] AND result <= 2.00000000 ) WITH NUMERIC result = 0.00000000 DO
   result + 1.00000000
  ENDWHILE COMMENTED_BY "Cycle through indices and return index for which exceedance percentage is between lower and upper limit" - 1.00000000
 ENDIF COMMENTED_BY "Find index in May1TargetElevation corresponding to appropriate exceedance level of forecast", 2.00000000];

    END;

    FUNCTION       "GetNumberOfDaysAtPPC" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function bounds the days at power plant capacity to within the limts for the current hydrologic classification<br><br>RETURNS: Number of days to release at power plant capacity [T]<br><br>ARGUMENTS<br>1. NUMERIC Class<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: CE 6/12/13";
    BEGIN

      WITH NUMERIC DaysAtPPC = "GetNumberOfDaysAtPPCUnconstrained"( Class ) DO
  IF ( DaysAtPPC < $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000] )
  THEN
   $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000]
  ELSE
   IF ( DaysAtPPC > $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000] )
   THEN
    $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000]
   ELSE
    DaysAtPPC
   ENDIF
  ENDIF
 ENDWITH COMMENTED_BY "Ensure that the days at power plant capacity fall within the limits of the current hydrologic classification";

    END;

    FUNCTION       "GetNumberOfDaysAtPPCUnconstrained" ( NUMERIC Class )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Interpolates the number of days to have the powerplant at capacity for the current hydrologic classification based on the current exceedance percentile for the Yampa April through July volume<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS<br>1. NUMERIC Class - Annual hydrologic class<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      "Interpolate"( $ "KNN_MTOM.AprJulPercentExceedanceSpringFlow" [], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 0.00000000], $ "FlamingGorgeData.HydrologicClassPercentileLimits" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 1.00000000], $ "FlamingGorgeData.DaysAtPowerPlantCapacity" [Class, 0.00000000] );

    END;

    FUNCTION       "NumberOfMonthsUntilMay" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the number of months remaining to make releases to meet the May 1 Upper Limit Drawdown Elevation (ULDE) on Flaming Gorge reservoir. This is called by the Flaming Gorge baseflow operations. -HG 9/12/12<br><br>RETURNS: Number of months until next May [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: HG, 9/12/12";
    BEGIN

      IF ( "GetMonth"( @"t" ) >= 5.00000000 )
 THEN
  ( 12.00000000 - "GetMonth"( @"t - 1" ) + 4.00000000 ) COMMENTED_BY "For May through December.<br>Calculate the remaining months of current year (current month - Dec.)<br>Add the first four months of next year (Jan.- Apr.).<br>"
 ELSE
  ( 5.00000000 - "GetMonth"( @"t" ) ) COMMENTED_BY "For January through April.<br>Calculate the remaining months to make releases before May 1, <br>includes the current month."
 ENDIF;

    END;

    FUNCTION       "PredictedFGInflow" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total inflow volume between the dates specified as arguments<br><br>RETURNS: Inflow volume to Flaming Gorge [L^3]<br><br>ARGUMENTS<br>1. DATETIME startDate - beginning date of period for sum<br>2. DATETIME endDate - ending date of period for sum<br><br>CONSTRAINTS<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      IF ( endDate > @"Finish Timestep" )
 THEN
  "SumFlowsToVolume"( $ "FlamingGorge.Inflow", startDate, @"Finish Timestep" ) + "SumFlowsToVolume"( $ "FlamingGorgeData.ProjectedInflow", @"Finish Timestep + 1", endDate )
 ELSE
  "SumFlowsToVolume"( $ "FlamingGorge.Inflow", startDate, endDate )
 ENDIF;

    END;

    FUNCTION       "RoundToNearestDay" ( NUMERIC numDays )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the rounded value of the specified argument &quot;numDays&quot;. If the fractional part of numDays is < 0.5 the value is rounded down; otherwise, the value is rounded up.<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS:<br>1. NUMERIC numDays<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "Fraction"( numDays, 1.00000000 "day" ) >= 0.50000000 "day" )
 THEN
  "Ceiling"( numDays, 1.00000000 "day" )
 ELSE
  "Floor"( numDays, 1.00000000 "day" )
 ENDIF;

    END;

    FUNCTION       "TargetHWGivenInflowforOneMonth" ( NUMERIC elevation )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the release for the current month to attain the specified pool elevation value, &quot;elevation&quot;, based on a water balance using inflow and evaporation<br><br>RETURNS: Monthly outflow rate [L^3/T]<br><br>ARGUMENTS<br>1. NUMERIC elevation - desired pool elevation to reach<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      ( ( "ElevationToStorage"( % "FlamingGorge", $ "FlamingGorge.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "FlamingGorge", elevation ) + "FlowToVolume"( $ "FlamingGorge.Inflow" [], @"t" ) ) - "EstimateEvaporation"( % "FlamingGorge", $ "FlamingGorge.Storage" [@"t - 1"], $ "FlamingGorge.Storage" [@"t - 1"], @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 Current Month Max DayOfMonth, Current Year" ) ) / 1.00000000 "month";

    END;

    FUNCTION       "YampaDaysAbove14000" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Determines the number of days that the Yampa River will be above 14000 cfs. If the Yampa April to July volume is greater than the bypass threshold then the number of days above 14000 cfs is determined with a linear regression equation based on data for the historical period 1923-2006. For volumes less than the bypass threshold the number of days above 14000 cfs is zero. -CE 6/12/13<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS:<NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170315 - The description on this function is the same as the one for the function YampaDaysAbove14000Old, which uses regression; however, this version does not use regression";
    BEGIN

      "CountDaysAboveThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ), 14000.00000000 "cfs" );

    END;

  END;

  UTILITY_GROUP "Daily Flaming Gorge Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "MakeDailyFlamingGorgeReleaseDateandFlowList" ( DATETIME startdate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the daily Flaming Gorge outflows for the portion of the April - July period that is beyond the input argument date<br><br>RETURNS: List of lists of the form &lcub;&lcub;Date, Outflow rate&rcub;&rcub;<br><br>ARGUMENTS: <br>1. DATETIME startdate - beginning date for which daily flows need to be calculated<br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST DateList = "GetDates"( @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" COMMENTED_BY "Only calculates daily schedule to the end of the current month for computation efficiency.", "1 days" ) DO
  WITH LIST FlowList = WITH DATETIME YampaPeakDate = IF ( TRUE )
  THEN
   "FindYampaPeakDateForYear"(  )
  ELSE
   @"24:00:00 May 27, Current Year"
  ENDIF COMMENTED_BY "Finds the Yampa peak flow date for this year, if FALSE use May 27 which matches it with the dates that the expression slot was using..." DO
   WITH NUMERIC DaysAtPPC = "Max"( "RoundToNearestDay"( "GetNumberOfDaysAtPPC"( $ "KNN_MTOM.SpringHClass" [@"t"] ) ), 1.00000000 "day" ) COMMENTED_BY "Calculate number of days that Flaming Gorge will release Power Plant Capacity (PPC), with a minimum of 1 day at PPC to meet flow <br>recommendation, I am unsure about the minimum days in really dry years, but am using 1 for now..." DO
    WITH NUMERIC RampUpDaysToPPC = "RoundToNearestDay"( "Max"( IF ( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) <= $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" )
    THEN
     0.00000000 "day"
    ELSE
     ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" )
    ENDIF, 0.00000000 "day" ) ) COMMENTED_BY "Calculate the number of days that the flow will have to ramp to reach the PPC, or sets it to 0 if it can reach it in one jump." DO
     WITH NUMERIC RampUpToPPCRate = ( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( ( RampUpDaysToPPC / 1.00000000 "day" ) + 1.00000000 ) ) COMMENTED_BY "Calculate the up ramping rate depending on the number of days so that it evenly ramps up to PPC over those days. Will not exceed the up ramp rate limit (2000 cfs)." DO
      WITH NUMERIC RampUpDaysToBypass = "RoundToNearestDay"( "Max"( IF ( ( $ "KNN_MTOM.BypassCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) <= $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" )
      THEN
       0.00000000 "day"
      ELSE
       ( $ "KNN_MTOM.BypassCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" )
      ENDIF, 0.00000000 "day" ) ) DO
       WITH NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - 2700.00000000 "cfs" ) / ( $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs" ) * 1.00000000 "day" ) DO
        WITH NUMERIC DaysAtBypass = "RoundToNearestDay"( "GetDaysAtBypass"( $ "KNN_MTOM.SpringHClass" [] ) ) DO
         WITH DATETIME FGSpringReleaseStartDate = "DateMax"( "DateMin"( IF ( DaysAtBypass != 0.00000000 "day" )
         THEN
          "FindYampa10kcfsBypassDateForYear"( YampaPeakDate ) + $ "KNN_MTOM.FGPeakDelay" []
         ELSE
          "FindYampa14kcfsPPCDateForYear"( DaysAtPPC, YampaPeakDate ) + $ "KNN_MTOM.FGPeakDelay" []
         ENDIF, @"24:00:00 August 2, Current Year" - ( DaysAtPPC + RampUpDaysToPPC + DaysToDownRamp + DaysAtBypass / 2.00000000 ) COMMENTED_BY "Estimate total spring flow days...<br>" ), @"24:00:00 April 2, Current Year" ) COMMENTED_BY "Start ramping up 3 days before Yampa Peak, but Apr 2 as a minimum to avoid breaking, and start early enough to end by July 31" DO
          FOR ( DATETIME date IN DateList ) WITH LIST flows = {  } DO
           WITH NUMERIC i = ( date - @"24:00:00 April 1, Current Year" ) / 1.00000000 "day" DO
            APPEND IF ( date < startdate )
            THEN
             $ "FlamingGorge.Outflow" ["MaxDayOfMonth"( date )]
            ELSE
             IF ( ( date < FGSpringReleaseStartDate ) COMMENTED_BY "Before Spring Releases start continue at base flows for the ULDE in March and April that will meet ULDE on May 1" )
             THEN
              IF ( FGSpringReleaseStartDate == @"April" )
              THEN
               $ "FlamingGorge.Outflow" [@"24:00:00 March Max DayOfMonth, Current Year"]
              ELSE
               $ "FlamingGorge.Outflow" [@"24:00:00 April Max DayOfMonth, Current Year"]
              ENDIF
             ELSE
              IF ( ( date < FGSpringReleaseStartDate + RampUpDaysToPPC ) COMMENTED_BY "Ramping period up to Flaming Gorge PPC Release (or max release if below PPC)" )
              THEN
               "Min"( ( GET @INDEX i - 1.00000000 FROM flows ) + RampUpToPPCRate, "Max"( $ "FlamingGorgeData.PowerPlantCapacity" [], "Max"( "TargetHWGivenInflowforOneMonth"( $ "FlamingGorgeData.MaxPE" [] ), "GetFGBaseFlowMagnitude"(  ) ) ) COMMENTED_BY "Release PPC or volume necessary to stay below max PE." )
              ELSE
               IF ( "CountDaysAboveThreshold"( flows, $ "KNN_MTOM.BypassCapacity" [] ) < DaysAtBypass )
               THEN
                "Min"( ( GET @INDEX i - 1.00000000 FROM flows ) + $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs", "Max"( $ "KNN_MTOM.BypassCapacity" [], "Max"( "TargetHWGivenInflowforOneMonth"( $ "FlamingGorgeData.MaxPE" [] ), "GetFGBaseFlowMagnitude"(  ) ) ) COMMENTED_BY "Release bypass capacity or volume necessary to stay below max PE." ) COMMENTED_BY "Ramps up and continues at Bypass Cap until it has been at Bypass Cap for enough days"
               ELSE
                IF ( "CountDaysAboveThreshold"( flows, $ "FlamingGorgeData.PowerPlantCapacity" [] ) < DaysAtPPC )
                THEN
                 "Max"( ( GET @INDEX i - 1.00000000 FROM flows ) - $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs", "Max"( $ "FlamingGorgeData.PowerPlantCapacity" [], "TargetHWGivenInflowforOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) ) COMMENTED_BY "Downramps to base flows unless inflows will increase FG above max PE.<br>Releases volume necessary to stay below max PE." ) COMMENTED_BY "Ramps down from bypass (if it was there) then continues at PPC until it has been above PPC for enough days"
                ELSE
                 "Max"( ( GET @INDEX i - 1.00000000 FROM flows ) - $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs", "Max"( "GetFGBaseFlowMagnitude"(  ), "TargetHWGivenInflowforOneMonth"( $ "FlamingGorgeData.MaxPE" [] ) ) COMMENTED_BY "Releases base flows or volume necessary to stay below max PE." ) COMMENTED_BY "Ramps down from PPC and then continues at the new base flow which is newly calculated each month"
                ENDIF
               ENDIF
              ENDIF
             ENDIF
            ENDIF COMMENTED_BY "For dates earlier than passed in date, use previously set outflow value" ONTO flows
           ENDWITH
          ENDFOR
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH DO
   FOR ( DATETIME date IN DateList ) WITH LIST DateFlowList = {  } DO
    APPEND { date , GET @INDEX ( date - @"24:00:00 April 1, Current Year" ) / 1.00000000 "day" FROM FlowList } ONTO DateFlowList
   ENDFOR COMMENTED_BY "This links together the date and flow in a list of 2 item lists..... e.g., &lcub;...,(5/1/12, 1200 cfs), (5/2/12, 1300 cfs), etc...&rcub;"
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "DaysAboveThreshold" ( LIST dailyFlows, NUMERIC flowThreshold )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function counts the number of flow values in the argument list &quot;dailyFlows&quot; that exceed the value of the argument &quot;flowThreshold&quot;<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS:<br>1. LIST dailyFlows - list of daily flow rates<br>2. NUMERIC flowThreshold - threshold flow rate<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC flow IN dailyFlows ) WITH NUMERIC result = 0.00000000 "day" DO
  IF ( flow > flowThreshold )
  THEN
   1.00000000 "day"
  ELSE
   0.00000000 "day"
  ENDIF + result
 ENDFOR;

    END;

    FUNCTION       "FindYampaPeakDateForYear" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function finds the date of the Yampa peak flow within the period April through July of the current year<br><br>RETURNS: Date of the Yampa April-July peak flow [DATETIME]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170503: Function simplified by removing 3 unused local variable WITH statements";
    BEGIN

      WITH NUMERIC yampaPeak = "MaxItem"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) ) DO
  GET @INDEX FIND yampaPeak WITHIN "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) FROM "GetDates"( @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year", "1 days" )
 ENDWITH;

    END;

    FUNCTION       "FindYampa10kcfsBypassDateForYear" ( DATETIME YampaPeakDate )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the date to bypass if the Yampa River flows are at 10,000 cfs for the length of time necessary to meet flow targets.<br><br>RETURNS: Date to begin ramp up to bypass [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME YampaPeakDate - date of the Yampa peak flow (from function FindYampaPeakDateForYear)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170503: Numeric input argument BypassDays removed because it was not used";
    BEGIN

      WITH LIST flowList = "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) DO
  WITH NUMERIC DaysAbv10k = "CountDaysAboveThreshold"( flowList, 10000.00000000 "cfs" ) DO
   WITH NUMERIC DaysToRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.BypassCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" ) ) / 1.00000000 "day" + 2.00000000 DO
    WITH NUMERIC DaysToPeak = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
     IF ( $ "KNN_MTOM.SpringHClass" [] < 4.00000000 AND $ "KNN_MTOM.SpringHClass" [] > 0.00000000 )
     THEN
      IF ( ( DaysAbv10k >= $ "KNN_MTOM.YampaDaysAbove10000ForBypass" [$ "KNN_MTOM.SpringHClass" [], 0.00000000] OR ( $ "KNN_MTOM.SpringHClass" [] == 2.00000000 AND DaysAbv10k > 3.00000000 "day" ) ) COMMENTED_BY "Will bypass if Yampa River flows are above 10,000 cfs for days necessary to meet flow targets in all hydrologic classifications or<br>in average years if Yampa River above 10,000 cfs for 3 days in order to meet 18,600 cfs target 50% of the time." )
      THEN
       WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
        IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( DaysToPeak - length - 1.00000000 == - 1.00000000 )
        THEN
         0.00000000
        ELSE
         DaysToPeak - length - 1.00000000
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
        THEN
         DaysToPeak - length
        ELSE
         result
        ENDIF
       ENDFOR COMMENTED_BY "If the Yampa River is above 10,000 cfs for enough days to meet flow targets then this calculation determines the peak date of the Yampa River <br>and returns the first date that the Yampa River reaches 10,000 cfs before the peak date." DO
        GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
        THEN
         0.00000000
        ELSE
         DateIndex - DaysToRamp
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
       ENDWITH
      ELSE
       WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
        IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( DaysToPeak - length - 1.00000000 == - 1.00000000 )
        THEN
         0.00000000
        ELSE
         DaysToPeak - length - 1.00000000
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
        THEN
         DaysToPeak - length
        ELSE
         result
        ENDIF
       ENDFOR DO
        GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
        THEN
         0.00000000
        ELSE
         DateIndex - DaysToRamp
        ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
       ENDWITH
      ENDIF
     ELSE
      "DateMax"( WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
       IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 10000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX IF ( DaysToPeak - length - 1.00000000 == - 1.00000000 )
       THEN
        0.00000000
       ELSE
        DaysToPeak - length - 1.00000000
       ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 10000.00000000 "cfs" ) < 1.00000000 "day" )
       THEN
        DaysToPeak - length
       ELSE
        result
       ENDIF
      ENDFOR DO
       GET @INDEX IF ( DateIndex - DaysToRamp < 0.00000000 )
       THEN
        0.00000000
       ELSE
        DateIndex - DaysToRamp
       ENDIF FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
      ENDWITH, @"24:00:00 April 2, Current Year" ) COMMENTED_BY "Returns the maximum of April 2 or the first day that the Yampa River is above 10,000 cfs so the April-July function works."
     ENDIF
    ENDWITH
   ENDWITH
  ENDWITH COMMENTED_BY "Counts Yampa River flow days above 10,000 cfs to determine if flow targets can be met."
 ENDWITH COMMENTED_BY "Determines the date to bypass if the Yampa River flows are at 10,000 cfs for the length of time necessary to meet flow targets. ";

    END;

    FUNCTION       "FindYampa14kcfsPPCDateForYear" ( NUMERIC PPCDays, DATETIME YampaPeakDate )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the date to increase the Flaming Gorge release to the powerplant capacity (PPC) if the Yampa River flows are at 14,000 cfs for the length of time necessary to meet flow targets.<br><br>RETURNS: Date to increase release rate [DATETIME]<br><br>ARGUMENTS:<br>1. NUMERIC PPCDays - the number of days that Flaming Gorge will release at powerplant capacity<br>2. DATETIME YampaPeakDate - date of the Yampa peak flow (from function FindYampaPeakDateForYear)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST flowList = "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", @"24:00:00 April 1, Current Year", @"24:00:00 July 31, Current Year" ) DO
  WITH NUMERIC DaysAbv14k = "DaysAboveThreshold"( flowList, 14000.00000000 "cfs" ) COMMENTED_BY "Counts Yampa River flows above 14,000 cfs to determine if flow targets can be met." DO
   WITH NUMERIC DaysToRamp = "RoundToNearestDay"( ( $ "FlamingGorgeData.PowerPlantCapacity" [] - $ "FlamingGorge.Outflow" [@"24:00:00 Previous Month Max DayOfMonth, Current Year"] ) / ( $ "KNN_MTOM.RampUpRateNoUnits" [] * 1.00000000 "cfs" / 1.00000000 "day" ) ) / 1.00000000 "day" + 1.00000000 DO
    WITH NUMERIC DaysToPeak = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
     IF ( $ "KNN_MTOM.SpringHClass" [] < 4.00000000 AND $ "KNN_MTOM.SpringHClass" [] > 0.00000000 )
     THEN
      IF ( DaysAbv14k >= $ "KNN_MTOM.YampaDaysAbove14000ForPPC" [$ "KNN_MTOM.SpringHClass" [], 0.00000000] )
      THEN
       WITH NUMERIC DateIndex = FOR ( NUMERIC length IN "GetNumbers"( 0.00000000, DaysToPeak, 1.00000000 ) ) WITH NUMERIC result = LENGTH "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ) DO
        IF ( ( GET @INDEX DaysToPeak - length FROM flowList ) >= 14000.00000000 "cfs" AND "CountDaysBelowThreshold"( "GetSlotVals"( $ "KNN_MTOM.YampaDailyDeerlodgeDepleted", GET @INDEX DaysToPeak - length - 1.00000000 FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" ), YampaPeakDate ), 14000.00000000 "cfs" ) < 1.00000000 "day" )
        THEN
         DaysToPeak - length
        ELSE
         result
        ENDIF
       ENDFOR DO
        GET @INDEX DateIndex - DaysToRamp FROM "GetDates"( @"24:00:00 April 1, Current Year", YampaPeakDate, "1 days" )
       ENDWITH COMMENTED_BY "Finds the date closest to the Yampa River peak flow date that flows are 14,000 cfs in order to begin ramp up to PPC."
      ELSE
       ( YampaPeakDate - PPCDays / 2.00000000 ) COMMENTED_BY "FG has a spring peak every year and flow targets below 18,600 cfs.  This returns the date closest to the Yampa River peak <br>with half of the PPC days determined for flow targets being met in all hydrologic classifications. "
      ENDIF
     ELSE
      ( YampaPeakDate - PPCDays * 0.75000000 ) COMMENTED_BY "FG has a spring peak every year and flow targets below 18,600 cfs.  This returns the date closest to the Yampa River peak with the PPC days determined<br>for flow targets being met in all hydrologic classifications. This returns 75% of the PPC days so that ramping to PPC occurs closer to the Yampa River peak in dry years.  <br>The wet year hydrologic classification is usually targeted using the bypass functions."
     ENDIF
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Determines the date to increase to PPC if the Yampa River flows are at 14,000 cfs for the length of time necessary to meet flow targets.";

    END;

    FUNCTION       "CountDaysAboveThreshold" ( LIST Flows, NUMERIC MinFlow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a count of the number of values in the list &quot;Flows&quot; that are greater than the value of &quot;MinFlow&quot;<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS<br>1. LIST Flows - list of flow rates<br>2. NUMERIC MinFlow - threshold flow rate<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC flow IN Flows ) WITH NUMERIC result = 0.00000000 "day" DO
  IF ( flow >= MinFlow )
  THEN
   result + 1.00000000 "day"
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "CountDaysBelowThreshold" ( LIST Flows, NUMERIC MinFlow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns a count of the number of values in the input argument list &quot;Flows&quot; that are less than the value of the input argument &quot;MinFlow&quot;<br><br>RETURNS: Number of days [T]<br><br>ARGUMENTS<br>1. LIST Flows - list of flow rates<br>2. NUMERIC MinFlow - threshold flow rate<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC flow IN Flows ) WITH NUMERIC result = 0.00000000 "day" DO
  IF ( MinFlow >= flow )
  THEN
   result + 1.00000000 "day"
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "AugustDownRamp" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: When bypass releases extend through the entire April-July period to July 31st, this function downramps to base flows in August.<br><br>RETURNS: List of lists of the form &lcub;&lcub;Date, Flow rate&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC RampRate = $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs" DO
  WITH NUMERIC DaysToDownRamp = "RoundToNearestDay"( ( $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] - $ "FlamingGorge.Outflow" [] ) / RampRate * 1.00000000 "day" ) COMMENTED_BY "Number of days needed to downramp from July 31st bypass release to August base flow." DO
   WITH LIST DateList = "GetDates"( @"24:00:00 August 1, Current Year", @"24:00:00 August 31, Current Year", "1 days" ) COMMENTED_BY "Make list of August dates" DO
    WITH LIST FlowList = FOR ( DATETIME date IN DateList ) WITH LIST Augflows = {  } DO
     WITH NUMERIC index = ( date - @"24:00:00 August 1, Current Year" ) / 1.00000000 "day" DO
      APPEND IF ( date == @"24:00:00 August 1, Current Year" )
      THEN
       ( $ "KNN_MTOM.FlamingGorgeDaily" [@"24:00:00 July Max DayOfMonth, Current Year"] - RampRate )
      ELSE
       IF ( date <= @"24:00:00 August 1, Current Year" + DaysToDownRamp )
       THEN
        "Max"( ( GET @INDEX index - 1.00000000 FROM Augflows ) - $ "KNN_MTOM.BaseFlowDownrampRateNoUnits" [$ "KNN_MTOM.BaseFlowHClass" [@"t"], 0.00000000] * 1.00000000 "cfs", "GetFGBaseFlowMagnitude"(  ) ) COMMENTED_BY "Downramping."
       ELSE
        "Max"( ( GET @INDEX index - 1.00000000 FROM Augflows ), "GetFGBaseFlowMagnitude"(  ) ) COMMENTED_BY "No downramping needed, the list generates August base flows or flows<br>necessary to maintain max PE."
       ENDIF
      ENDIF ONTO Augflows
     ENDWITH
    ENDFOR COMMENTED_BY "Create a list for August flows whether downramping from bypass flows or not." DO
     FOR ( DATETIME date IN DateList ) WITH LIST DateFlowList = {  } DO
      APPEND { date , GET @INDEX ( date - @"24:00:00 August 1, Current Year" ) / 1.00000000 "day" FROM FlowList } ONTO DateFlowList
     ENDFOR COMMENTED_BY "Create final list of the form &lcub;Date, Flow rate&rcub;"
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "SpringFlowA-JVolumeUpdate" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the April through July unregulated inflow volume for Flaming Gorge<br><br>RETURNS: Unregulated inflow volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "MonthIs"( { "January" , "February" , "March" } ) )
 THEN
  ( ( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) / "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) * "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Before April, the April-July volume forecast is calculated as the average volume for that period multiplied by the ratio of the current year's forecast volume <br>from the current month through April to the average for the same period."
 ELSE
  "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) COMMENTED_BY "Otherwise, use the April through July forecast and/or actual flows"
 ENDIF;

    END;

    FUNCTION       "BaseFlowA-JVolumeUpdate" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates an estimated or actual unregulated inflow volume for the period April through July at Flaming Gorge<br><br>RETURNS: Unregulated inflow volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20160913: I don't see how March or May targets are reflected in this function, are they considered elsewhere? That inline comment precedes this documentation.<br>MC, 20170503: August used the same calculation as April-July so I removed its separate IF conditional and just let it calculate under the final ELSE; changed the position of the denominators in the calculations to better reflect how the factor is being calculated as a ratio of average unregulated flows for different periods (not sure it's any clearer, though)";
    BEGIN

      IF ( "MonthIs"( { "January" , "February" , "March" } ) )
 THEN
  ( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) * ( "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) / "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 Current Month Max DayOfMonth, Current Year", @"24:00:00 April Max DayOfMonth, Current Year" ) ) ) COMMENTED_BY "January through April flows change depending on actual inflow, the forecasted unreg inflow and meeting March or May 1 elevation target.<br>Forecast volume is calculated as the sum of the current year's monthly forecast flows from the current month through April multiplied by the <br>ratio of the average April-July flow to the average flow for the current period."
 ELSE
  IF ( "MonthIs"( { "September" , "October" , "November" , "December" } ) )
  THEN
   "Max"( "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"t - 1", @"t - 1" ) * ( "SumSlot"( $ "KNN_MTOM.FGAverageUnregInflow", @"24:00:00 April Max DayOfMonth, Next Year", @"24:00:00 July Max DayOfMonth, Next Year" ) / $ "KNN_MTOM.FGAverageUnregInflow" [@"t - 1"] ), 0.00000000 "acre-ft" )
  ELSE
   "SumFlowsToVolume"( $ "FlamingGorgeInflow.Unregulated", @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year" ) COMMENTED_BY "April, May, June, July, August"
  ENDIF COMMENTED_BY "The months of September through December look at actual flows coming into the system and react if necessary to meet the March 1 elevation target."
 ENDIF;

    END;

  END;

  UTILITY_GROUP "KNNFunctions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "ChooseIndexYearRatio" ( NUMERIC aprRatio, NUMERIC mayRatio, NUMERIC junRatio, NUMERIC julRatio )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function selects an index year from the K nearest neighbors in the historical record. The distance calculation between years is based on the monthly volume ratios to the seasonal volume<br><br>RETURNS: Historical year as a number, not a date [NONE]<br><br>ARGUMENTS:<br>1. NUMERIC aprRatio - the April proportion of the seasonal (April-July) volume<br>2. NUMERIC mayRatio - the May proportion of the seasonal volume<br>3. NUMERIC junRatio - the June proportion of the seasonal volume<br>4. NUMERIC julRatio - the July proportion of the seasonal volume<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      GET @INDEX WHILE ( NOT $ "KNN_MTOM.randomNum" [@"24:00:00 December Max DayOfMonth, Current Year"] <= $ "KNN_MTOM.CumulativeSumW" [i, 0.00000000] ) WITH NUMERIC i = 0.00000000 DO
  i + 1.00000000
 ENDWHILE COMMENTED_BY "Select the index year based on the current year's random number" FROM "FindKNNFromRatios"( aprRatio, mayRatio, junRatio, julRatio );

    END;

    FUNCTION       "FindKNNFromRatios" ( NUMERIC aprRatio, NUMERIC mayRatio, NUMERIC junRatio, NUMERIC julRatio )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function creates a list of the K historical years that are nearest to the year with the monthly ratios specified by the input arguments<br><br>RETURNS: List of lists of the form &lcub;&lcub;Year, Distance&rcub;&rcub;<br><br>ARGUMENTS:<br>1. NUMERIC aprRatio - the April proportion of the seasonal (April-July) volume<br>2. NUMERIC mayRatio - the May proportion of the seasonal volume<br>3. NUMERIC junRatio - the June proportion of the seasonal volume<br>4. NUMERIC julRatio - the July proportion of the seasonal volume<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST sortedYears = "SortPairsAscending"( FOR ( LIST yrVol IN "GetYearsAndRatios"(  ) ) WITH LIST result = {  } DO
  ( APPEND { GET @INDEX 0.00000000 FROM yrVol , "Exp"( ( aprRatio - GET @INDEX 1.00000000 FROM yrVol ) ^ 2.00000000 + ( mayRatio - GET @INDEX 2.00000000 FROM yrVol ) ^ 2.00000000 + ( junRatio - GET @INDEX 3.00000000 FROM yrVol ) ^ 2.00000000 + ( julRatio - GET @INDEX 4.00000000 FROM yrVol ) ^ 2.00000000, 0.50000000 ) } ONTO result ) COMMENTED_BY "Create the list element &lcub;Year, Distance measure&rcub;"
 ENDFOR ) COMMENTED_BY "Create a list with elements &lcub;Year, Distance measure&rcub; for each historic year that is sorted from the smallest to largest distance" DO
  FOR ( NUMERIC val IN "GetNumbers"( 0.00000000, $ "KNN_MTOM.K" [] - 1.00000000, 1.00000000 ) ) WITH LIST result = {  } DO
   APPEND GET @INDEX val FROM sortedYears ONTO result
  ENDFOR COMMENTED_BY "Create a new list with only the K nearest historical years"
 ENDWITH;

    END;

    FUNCTION       "GetCurrentMonthlyNaturalInflow" ( DATETIME month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the monthly flow volume for the month specified in the input argument of the current year (when this function is called from the rule Set Yampa Daily Natural - Second Stage Disagg, the input argument is actually a date, not a month)<br><br>RETURNS: Flow volume for month [L^3]<br><br>ARGUMENTS:<br>1. DATETIME month<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH DATETIME currentMonth = "GetDate"( "GetMonthAsString"( month ) CONCAT ",current year" ) DO
  "FlowToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge" [currentMonth], currentMonth )
 ENDWITH;

    END;

    FUNCTION       "GetCurrentYearDailyList" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function generates a list of the dates within the KNN StartMonth to EndMonth period (currently April-July) for the current year<br><br>RETURNS: List of dates<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170714: Implemented Heather P.'s changes that use predefined functions to streamline the code and remove older CONCAT statements for constructing dates";
    BEGIN

      "GetDates"( "CompletePartialDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ), "CompletePartialDate"( @"Min DayOfMonth", @"t" ) ), "CompletePartialDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ), "CompletePartialDate"( @"Max DayOfMonth", @"t" ) ), "1 days" );

    END;

    FUNCTION       "GetIndexYearDailyList" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function generates a list of the dates within the KNN StartMonth to EndMonth period (currently April-July) for the KNN index year<br><br>RETURNS: List of dates (days) <br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170714: Implemented Heather P.'s changes that use predefined functions to streamline the code and remove some older CONCAT statements for constructing dates";
    BEGIN

      "GetDates"( "CompletePartialDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ), "CompletePartialDate"( "NumberToYear"( $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"] ), @"24:00:00 December 31" COMMENTED_BY "The month doesn't matter here, it just needs a month to be valid <br>" ) ), "CompletePartialDate"( "NumberToYear"( $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"] ), "GetDate"( "24:00:00" CONCAT ( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT " Max DayOfMonth" ) ) ), "1 days" );

    END;

    FUNCTION       "GetMonthlyProportionVector" ( DATETIME month )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates each day's volume proportion of the monthly volume (for the month passed as an input argument) for the historical index year<br><br>RETURNS: List of proportion values [NONE]<br><br>ARGUMENTS:<br>1. DATETIME month - month for which the proportions are needed<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH LIST days = "GetDates"( "GetDate"( "GetMonthAsString"( month ) CONCAT "1, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY $ "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"], "." ) ), "GetDate"( ( "GetMonthAsString"( month ) CONCAT " " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetDaysInMonth"( month ), "." ) ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "KNN_MTOM.IndexYear" [@"24:00:00 December Max DayOfMonth, Current Year"], "." ) ), "1 DAYS" ) COMMENTED_BY "Generate list of days in month for historical index year" DO
  WITH NUMERIC monthlyVolume = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeDaily", GET @INDEX 0.00000000 FROM days, GET @INDEX ( LENGTH days ) - 1.00000000 FROM days ) DO
   FOR ( DATETIME day IN days ) WITH LIST propVec = {  } DO
    ( APPEND ( $ "KNN_MTOM.DeerlodgeDaily" [day] * 24.00000000 "hour" ) / monthlyVolume ONTO propVec ) COMMENTED_BY "Calculate each day's volume proportion and append to result list"
   ENDFOR
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "GetProportionVector" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates each day's volume proportion of the total spring volume for the historical index year<br><br>RETURNS: List of proportion values [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH NUMERIC sprVol = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeDaily", GET @INDEX 0.00000000 FROM "GetIndexYearDailyList"(  ), GET @INDEX ( LENGTH "GetIndexYearDailyList"(  ) ) - 1.00000000 FROM "GetIndexYearDailyList"(  ) ) COMMENTED_BY "Calculate the spring period volume for the historical index year" DO
  FOR ( DATETIME day IN "GetIndexYearDailyList"(  ) ) WITH LIST propVec = {  } DO
   APPEND "FlowToVolume"( $ "KNN_MTOM.DeerlodgeDaily" [day], day ) / sprVol ONTO propVec
  ENDFOR COMMENTED_BY "Calculate each day's proportion of the spring volume"
 ENDWITH;

    END;

    FUNCTION       "GetRandSeed" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns a seed for use by the Random or RandomNormal function. The seed is incremented by the trace number, as stored in the first timestep of the Hydrology Increment slot. The trace number could be available as a RPL function, but would not be enough to fulfill our requirements.<br><br>In the current setup, all MRM runs will have the same set of random numbers at the same trace, but all traces will have different sets, as controlled by the Hydrology Increment slot, which is rotated with the MRM runs.<br>This also allows single trace runs to have identical random numbers generated as well, which is not possible with a RPL function.<br><br>Probably should rename the Hydrology Increment slot to Trace Number.<br><br>With Random Seed = 1, is equivalent to just using the Trace Number as the seed for each trace.<br><br>RETURNS: Number used as seed for Random or RandomNormal function [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170504: The above description predates the use of this uniform documentation format.";
    BEGIN

      ( $ "KNN_MTOM.Random Seed" [] + ( $ "KNN_MTOM.hydrologyIncrement" [@"Start Timestep"] - 1.00000000 ) );

    END;

    FUNCTION       "GetSecondStageProportionVector" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates each day's volume as a proportion of its respective month's volume, based on the same proportions from the historical index year, for the April-July period of the current year<br><br>RETURNS: List of numeric proportions [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME month IN "GetDates"( @"24:00:00 April Max DayOfMonth, Current Year", @"24:00:00 July Max DayOfMonth, Current Year", "1 MONTHS" ) ) WITH LIST propVec = {  } DO
  WITH LIST monthlyProp = "GetMonthlyProportionVector"( month ) COMMENTED_BY "Calculate the month's daily proportion vector" DO
   FOR ( NUMERIC dayProp IN monthlyProp ) WITH LIST result = propVec DO
    APPEND dayProp ONTO result
   ENDFOR COMMENTED_BY "Loop through the month's vector and append elements to final result list"
  ENDWITH
 ENDFOR COMMENTED_BY "Loop through each month in the April-July period";

    END;

    FUNCTION       "GetSpringVolume" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculate the total volume of Yampa_at_Deerlodge for the KNN StartMonth to EndMonth (currently April-July) period<br><br>RETURNS: Flow volume for Yampa_at_Deerlodge [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumFlowsToVolume"( $ "YampaRiverInflow.Yampa_at_Deerlodge", "GetDate"( "NumberToDate"( $ "KNN_MTOM.StartMonth" [] ) CONCAT ",current year" ), "GetDate"( "NumberToDate"( $ "KNN_MTOM.EndMonth" [] ) CONCAT ",current year" ) );

    END;

    FUNCTION       "GetYearsAndRatios" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: For each year in the historical record, this function calclulates each month's proportion of the total April-July Yampa flow volume<br><br>RETURNS: List of lists of the form &lcub;&lcub;Year, Apr proportion, May proportion, June proportion, July proportion&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( NUMERIC year IN "GetNumbers"( "GetYear"( "NumberToDate"( $ "KNN_MTOM.HistoricalStartYear" [] ) ), "GetYear"( "NumberToDate"( $ "KNN_MTOM.HistoricalEndYear" [] ) ), 1.00000000 ) ) WITH LIST result = {  } DO
  WITH NUMERIC seasonalVol = "SumFlowsToVolume"( $ "KNN_MTOM.DeerlodgeMonthly", "GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ), "GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) DO
   APPEND { year , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "April, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "May, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "May, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "June, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "June, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol , "FlowToVolume"( $ "KNN_MTOM.DeerlodgeMonthly" ["GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) )], "GetDate"( "July, " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY year, "." ) ) ) / seasonalVol } ONTO result
  ENDWITH COMMENTED_BY "Calculate the year's April-July volume"
 ENDFOR COMMENTED_BY "Loop over list of historical years";

    END;

  END;

  UTILITY_GROUP "Fontenelle Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "FontenelleMonthlyOutflow" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION:This function returns a monthly outflow for Fontenelle reservoir based on the monthly logic that has always been in the MTOM model.  There are various constraints for some months where the logic is specified for that month and for those months that are not specified, the outflow is set to the outflow of the month before.  All of the monthly flows are constrained to the Min and Max constraints that are conditioned into the function and can be viewed when the &quot;Post-Exec. Checks&quot; box is checked.  <br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Minimum monthly release; release to reach maximum pool elevation; safe channel capacity; release to reach minimum pool elevation";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT "MaxItem"( { $ "FontenelleData.PeriodicMinFlow" [] , "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) } ) COMMENTED_BY "Must release at least the monthly minimum rate and enough to ensure pool elevation does not exceed maximum";
    MAX_CONSTRAINT IF ( ( "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) < 0.00000000 "acre-ft/month" ) COMMENTED_BY "Reservoir can accept all inflow without exceeding maximum capacity" )
 THEN
  "Min"( $ "FontenelleData.SafeChannelCapacity" [], "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MinElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) ) COMMENTED_BY "Maximum is either the SafeChannelCapacity or outflow to reach the minimum elevation"
 ELSE
  "Max"( $ "FontenelleData.SafeChannelCapacity" [], "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.MaxElevation" [] ), $ "Fontenelle.Storage" [@"t - 1"], @"t" ) ) COMMENTED_BY "Maximum is either the SafeChannelCapacity or outflow to reach the maximum elevation"
 ENDIF;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 5/11/2015<br><br>TP, 5/11/2015: This rule replaces a series of 11 other rules that made similar checks.<br><br>MC, 20160816: Corrected the date of the beginning pool elevations in the ElevationToStorage functions for April, September, and December from @&quot;t&quot; to @&quot;t-1&quot;, and changed the time periods in the denominators of those months' calculations from a number of months to a difference of dates, which more accurately calculates the periods in question since &quot;month&quot; in RW is 31 days. Other possible modifications discussed with Lee T. before she left are: 1) changing the recalculation of winter flows from December to October to better reflect actual operations; 2) changing the minimum elevation to 6,465 feet because 6,468 feet is not a hard boundary (leaving the target at 6,468 ft but changing the min elevation to 6,465 ft allows some flexibility in the model that reflects actual operations); 3) adding an estimate of evaporation to the above months' flow calculations (doesn't make much difference); 4) making the minimum flow values periodic and variable throughout the year<br><br>MC, 20170508: All of the changes discussed in the above comment were in place by the April 2017 MTOM run";
    BEGIN

      WITH NUMERIC June1Target = 6480.00000000 "feet" DO
  IF ( "MonthIs"( { "July" } ) )
  THEN
   "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] ) COMMENTED_BY "Set the July Outflow to be such that the August 1 Pool Elevation target is met"
  ELSE
   IF ( "MonthIs"( { "June" } ) )
   THEN
    IF ( $ "Fontenelle.Pool Elevation" [] > $ "FontenelleData.July1Target" [] )
    THEN
     "FontenelleTargetFlow"( $ "FontenelleData.August1Target" [] )
    ELSE
     "FontenelleTargetFlow"( $ "FontenelleData.July1Target" [] )
    ENDIF COMMENTED_BY "Release flows such that the July target is met unless the current pool elevation<br>is currently above the July pool elevation target, then release for the August 1<br>target"
   ELSE
    IF ( "MonthIs"( { "April" } ) )
    THEN
     "Min"( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.July1Target" [] ) + ( "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 2" ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.July1Target" [] ), @"t - 1", @"t + 2" ) ) ) / ( @"24:00:00 June Max DayOfMonth, Current Year" - @"24:00:00 March Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Steady release over April, May and June to meet July1 Target", "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ) COMMENTED_BY "Power Plant Capacity" )
    ELSE
     IF ( "MonthIs"( { "August" } ) )
     THEN
      "Min"( "GetMaxReleaseGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ), $ "Fontenelle.Outflow" [@"t - 1"] )
     ELSE
      IF ( "MonthIs"( { "October" } ) )
      THEN
       ( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 5" ) ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ), @"t - 1", @"t + 5" ) ) / ( @"24:00:00 March Max DayOfMonth, Next Year" - @"24:00:00 September Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Compute the steady flow over December to March necsessary to meet Apr 1 target. Change in storage plus forecasted volume divided by 4 months. The next 3 months will look back at this value."
      ELSE
       IF ( "MonthIs"( { "September" } ) )
       THEN
        ( ( ( "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ) - "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ) + "SumFlowsToVolume"( $ "Fontenelle.Inflow", @"t", @"t + 6" ) ) - "EstimateEvaporation"( % "Fontenelle", $ "Fontenelle.Storage" [@"t - 1"], "ElevationToStorage"( % "Fontenelle", $ "FontenelleData.April1Target" [] ), @"t - 1", @"t + 6" ) ) / ( @"24:00:00 March Max DayOfMonth, Next Year" - @"24:00:00 August Max DayOfMonth, Current Year" ) ) COMMENTED_BY "Compute the steady flow over September to March necsessary to meet Apr 1 target. Change in storage plus forecasted volume divided by 3 months.  The next two months will look back at this value."
       ELSE
        IF ( "MonthIs"( { "May" } ) )
        THEN
         "Max"( $ "Fontenelle.Outflow" [@"t - 1"], "SolveOutflow"( % "Fontenelle", % "Fontenelle" & "Inflow" [@"t"], "ElevationToStorage"( % "Fontenelle", June1Target ), "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ), @"t" ) )
        ELSE
         $ "Fontenelle.Outflow" [@"t - 1"]
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END;

    FUNCTION       "FontenelleTargetFlow" ( NUMERIC Elevation )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Determines the target outflow for Frontenelle. The outflow is either the maximum possible outflow given the inflow, or the release needed to meet the target elevation, whichever is less assuming the flow meets the power plant capacity. - ce 6/6/13<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS:<br>1. NUMERIC Elevation - the target pool elevation to reach with the outflow<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT $ "FontenelleData.MinFlow" [];
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170609: Could the maximum possible release be moved to the Post-Excecution Checks?";
    BEGIN

      "Min"( "GetMaxOutflowGivenInflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], @"t" ) COMMENTED_BY "Maximum possible release from the res", "SolveOutflow"( % "Fontenelle", $ "Fontenelle.Inflow" [], "ElevationToStorage"( % "Fontenelle", Elevation ), "ElevationToStorage"( % "Fontenelle", $ "Fontenelle.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "Release to meet target elevation" );

    END;

  END;

  UTILITY_GROUP "ICSAccountingFunctions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "DeliveryAndCreationCAICS" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the volumes of ICS delivered and EC ICS created for California, taking into account Lower Basin Demand Variability <br><br>RETURNS: List of lists of the form &lcub;&lcub;ICS delivered, EC ICS created&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20180125: Removed SystemTaxAdjustment from Annual Max in MinItem for creationOfCACEICS local variable based on USBR changes to ruleset";
    BEGIN

      WITH NUMERIC creationOfCACEICS = IF ( ( ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR NaNToZero ( $ "Surplus.Quantified Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR NaNToZero ( $ "Surplus.Flood Control Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) OR NOT "IsMRM"(  ) ) COMMENTED_BY "If the year is a Shortage Year, a Quantified Surplus Year, a Flood Control Year, <br>or if the run is a deterministic Min, Max or Most run, do not Create any ICS TP <br>12/18/2017 <br>" )
 THEN
  0.00000000 "acre-ft"
 ELSE
  "MinItem"( { $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Put Step 1"] COMMENTED_BY "Annual Max <br>" , "Max"( ( $ "ICS Credits.MeadBankParameters" ["California", "Max Capacity"] - $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December 31, Previous Year"] ), 0.00000000 "acre-ft" ) COMMENTED_BY "Account Space <br>" , $ "ICS Credits.MeadBankParameters" ["California", "Max Put"] COMMENTED_BY "Maximum Creation of MWD ICS <br>" , "Max"( "SumFlowsToVolume"( $ "MWDDiversion:MWD.Diversion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) - $ "MWDDiversionData.MWDMinimumAnnualDelivery" [], 0.00000000 "acre-ft" ) COMMENTED_BY "Difference between Diversion Requests and Minimum Required MWD Delivery <br>" } )
 ENDIF DO
  WITH NUMERIC totalDeliveryOfCAICS = "MinItem"( { IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 OR NOT "IsMRM"(  ) )
  THEN
   0.00000000 "acre-ft" COMMENTED_BY "Shortage Years <br>"
  ELSE
   IF ( ( NaNToZero ( $ "Surplus.Domestic Surplus Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 ) COMMENTED_BY "If the year has domestic surplus, reduce the ICS Delivery by the amount of <br>Domestic surplus entitlement for MWD. TP 12/18/2017 <br>" )
   THEN
    "Max"( ( $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] - $ "Surplus Volume Entitlements.MWD Domestic" ["Dec31ofYear"( @"t" )] ), 0.00000000 "acre-ft" )
   ELSE
    $ "ICS Credits.MWDICS_AnnualRequestedPutTake" [NaNToZero ( $ "ICS Credits.SacWYType" [@"24:00:00 December 31, Current Year"] ) - 1.00000000, "Take Step 1"] COMMENTED_BY "Not Surplus or Shortage <br>"
   ENDIF
  ENDIF , ( $ "MWDDiversionData.MWDMaximumAnnualDelivery" [] - "SumFlowsToVolume"( $ "MWDDiversion:MWD.Depletion Requested", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) ) COMMENTED_BY "MWD at full ditch (Conveyance Capacity)<br>" , "Min"( $ "ICS Credits.MeadBankParameters" ["California", "Max Take"], $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December 31, Previous Year"] COMMENTED_BY "Make sure the amount of Delivery taken is within the system or below the <br>Maximum Take that MWD can have. TP 12/18/2017 <br>" + creationOfCACEICS ) COMMENTED_BY "Available ICS Water <br>" } ) DO
   { totalDeliveryOfCAICS , creationOfCACEICS }
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "FloodControlECICSBalance" ( NUMERIC fcvolume )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes the passed in flood control volume and uses the resulting EC ICS volumes for each state to determine the balance for each state. Then determines a reduction ratio which is the flood control volume divided by the total EC ICS volume.  If this value is greater than 1, the flood control volume is greater than the total EC ICS volume and the resulting EC Volumes need to be set to 0 AF. If the ratio is less than one, then the EC ICS volumes need to be reduced by the ratio proportional to the volume for each state.  The function returns the volumes for each state in AF. - TP 11/4/2014<br><br>RETURNS: List of lists of the form &lcub;&lcub;CA EC balance, NV EC balance, AZ EC balance, CA Total ICS, NV Total ICS, AZ Total ICS&rcub;&rcub;<br><br>ARGUMENTS:<br>1. NUMERIC fcvolume - Flood control release rate<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 11/4/2014";
    BEGIN

      WITH NUMERIC caECICS = $ "ICS Credits.ExtraordinaryConservationICS_CA" ["Dec31ofYear"( @"t" )] DO
  WITH NUMERIC nvECICS = $ "ICS Credits.ExtraordinaryConservationICS_NV" ["Dec31ofYear"( @"t" )] DO
   WITH NUMERIC azECICS = $ "ICS Credits.ExtraordinaryConservationICS_AZ" ["Dec31ofYear"( @"t" )] DO
    WITH NUMERIC totalECICS = caECICS + nvECICS + azECICS DO
     WITH NUMERIC caOtherICS = $ "ICS Credits.TotalICS_CA" ["Dec31ofYear"( @"t" )] - caECICS DO
      WITH NUMERIC nvOtherICS = $ "ICS Credits.TotalICS_NV" ["Dec31ofYear"( @"t" )] - nvECICS DO
       WITH NUMERIC azOtherICS = $ "ICS Credits.TotalICS_AZ" ["Dec31ofYear"( @"t" )] - azECICS DO
        IF ( fcvolume < totalECICS )
        THEN
         WITH NUMERIC volRatio = fcvolume / totalECICS DO
          WITH LIST stateECBalLista = { volRatio * caECICS , volRatio * nvECICS , volRatio * azECICS } DO
           WITH LIST totalECBalList = { caOtherICS + GET @INDEX 0.00000000 FROM stateECBalLista , nvOtherICS + GET @INDEX 1.00000000 FROM stateECBalLista , azOtherICS + GET @INDEX 2.00000000 FROM stateECBalLista } DO
            { 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , GET @INDEX 0.00000000 FROM stateECBalLista , GET @INDEX 1.00000000 FROM stateECBalLista , GET @INDEX 2.00000000 FROM stateECBalLista , GET @INDEX 0.00000000 FROM totalECBalList , GET @INDEX 1.00000000 FROM totalECBalList , GET @INDEX 2.00000000 FROM totalECBalList }
           ENDWITH
          ENDWITH
         ENDWITH
        ELSE
         { 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , 0.00000000 "acre-ft" , caOtherICS , nvOtherICS , azOtherICS } COMMENTED_BY "if the FC volume is greater than the EC ICS total delivery volume and EC ICS volume, then reduce the state values for delivery and volume to 0 AF and the total ICS volume for each state <br>will be equal to the other ICS Volumes in the system. "
        ENDIF COMMENTED_BY "If the Flood Control is greater than the delivery volume, but less than the total EC ICS volume plus the EC ICS Delivery, reduce the state EC ICS volume by the amount<br>of the Flood Control volume less the EC ICS total delivery volume. Reduce the current EC ICS volumes for each state by the ratio derived and reduce the Total ICS Volume <br>for each state by the difference each state volume of EC ICS "
       ENDWITH
      ENDWITH
     ENDWITH COMMENTED_BY "Get the Total ICS Volume for each stat minuse the EC water"
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Get the EC ICS Volumes for each state and compute <br>the total volume. ";

    END;

    FUNCTION       "ICSAccountingForAZ" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation of the ICS categories Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat) and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total Arizona ICS Volume. <br>The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>For the delivery of AZ ICS: <br>If the projected January Lake Mead elevation is 1,100 ft or higher, then set the ICS delivery to the Total ICS Created / 10. <br> In the case that the Lower Basin is in Surplus, CAP would take delivery of 1/10 ICS Created in addition to any Surplus entitlement. <br> In cases where the projected January Lake Mead elevation is under 1,100 ft, set the delivery volume to 0 af, regardless of Normal or Shortage condition. <br><br>RETURNS: List of lists of the form &lcub;&lcub;Delivery charged to EC, Delivery charged to SE, Delivery charged to Binational, AZ EC ICS, AZ SE ICS, Binational AZ ICS, Total AZ ICS, Total AZ ICS delivery, Total AZ ICS creation&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 9/10/2014";
    BEGIN

      WITH NUMERIC creationOfEC = IF ( ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 3.00000000 ) COMMENTED_BY "This Check references the surplus value that represents Quantified Surplus in <br>the Determine Mead and Lower Basin Condition Rule. Quantified Surplus is set <br>as a value of 3 in the IsSurplusYear annual series slot. TP 7/28/2015" )
 THEN
  0.00000000 "acre-ft"
 ELSE
  $ "ICS Credits.AnnualCreationEC_AZ" ["Dec31ofYear"( @"t" )]
 ENDIF DO
  WITH NUMERIC creationOfSE = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 3.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   $ "ICS Credits.AnnualCreationSysEff_AZ" ["Dec31ofYear"( @"t" )]
  ENDIF DO
   WITH NUMERIC creationOfBiNat = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 3.00000000 )
   THEN
    0.00000000 "acre-ft"
   ELSE
    $ "ICS Credits.AnnualCreationBiNat_AZ" ["Dec31ofYear"( @"t" )]
   ENDIF DO
    WITH NUMERIC deliveryChargedToEC = IF ( ( ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= 1100.00000000 "ft" ) AND "GetYear"( @"t" ) >= 2021.00000000 ) COMMENTED_BY "If the Projected January Lake Mead Elevation is to be greater than 1,100 ft or the Lower Basin is <br>in Surplus, then set the ICS delivery to Total ICS Created/10 (For now this value is 18,000 AF and <br>can be changed in the future if needed. If Lake Mead is below 1,100 ft, then do not allow any <br>delivery of ICS. Also, Arizona will only take delivery of EC ICS after the beginning of 2021. Per <br>conversation with Shana Tighi 8/4/2015 " )
    THEN
     "Min"( 18000.00000000 "acre-ft", $ "ICS Credits.ExtraordinaryConservationICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] )
    ELSE
     0.00000000 "acre-ft"
    ENDIF DO
     WITH NUMERIC deliveryChargedToSE = IF ( ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= 1100.00000000 "ft" ) COMMENTED_BY "If the Projected January Lake Mead Elevation is to be greater than 1,100 ft or the <br>Lower Basin is in Surplus, then set the ICS delivery to Total ICS Created/10. If Lake <br>Mead is below 1,100 ft, then do not allow any delivery of ICS. The logic only needs to <br>know if Lake Mead is above 1,110 ft and the delivery will be added to any allocation <br>already set by the Surplus logic. " )
     THEN
      10305.00000000 "acre-ft"
     ELSE
      0.00000000 "acre-ft"
     ENDIF DO
      WITH NUMERIC deliveryChargedToBiNat = 0.00000000 "acre-ft" DO
       WITH NUMERIC ECICSAZ = IF ( ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 ) )
       THEN
        $ "ICS Credits.ExtraordinaryConservationICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] - deliveryChargedToEC + creationOfEC * 0.95000000
       ELSE
        ( $ "ICS Credits.ExtraordinaryConservationICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] - deliveryChargedToEC ) * 0.97000000 + creationOfEC * 0.95000000
       ENDIF COMMENTED_BY "Resulting ExtraordinaryConservation ICS " DO
        WITH NUMERIC SEICSAZ = ( $ "ICS Credits.SystemEfficiencyICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfSE - deliveryChargedToSE ) COMMENTED_BY "Resulting System Efficiency ICS " DO
         WITH NUMERIC BiNatICSAZ = ( $ "ICS Credits.BiNationalICS_AZ" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfBiNat - deliveryChargedToBiNat ) COMMENTED_BY "Resulting Bi National ICS " DO
          WITH NUMERIC totalICSAZ = ( ECICSAZ + SEICSAZ + BiNatICSAZ ) COMMENTED_BY "Total ICS" DO
           WITH NUMERIC totalICSAZDelivery = deliveryChargedToEC + deliveryChargedToSE + deliveryChargedToBiNat DO
            WITH NUMERIC totalICSAZCreation = creationOfEC DO
             { deliveryChargedToEC , deliveryChargedToSE , deliveryChargedToBiNat , ECICSAZ , SEICSAZ , BiNatICSAZ , totalICSAZ , totalICSAZDelivery , totalICSAZCreation }
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "ICSAccountingForCA" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation of the ICS categories Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat) and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total California ICS Volume. The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>RETURNS: List of lists of the form &lcub;&lcub;EC delivery, SE delivery, BiNat delivery, EC ICS created, CA EC ICS, CA SE ICS, CA BiNat ICS, Total CA ICS, MWD diversion reduction&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 9/10/2014";
    BEGIN

      WITH NUMERIC totalDeliveryOfCAICS = IF ( NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  GET @INDEX 0.00000000 FROM "DeliveryAndCreationCAICS"(  )
 ENDIF COMMENTED_BY "In shortage years no delivery of ICS is possible" DO
  WITH NUMERIC creationOfCACEICS = IF ( NaNToZero ( $ "Surplus.Quantified Surplus Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 OR NaNToZero ( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) > 0.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   GET @INDEX 1.00000000 FROM "DeliveryAndCreationCAICS"(  )
  ENDIF COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water" DO
   WITH NUMERIC creationSE = $ "ICS Credits.AnnualCreationSysEff_CA" ["Dec31ofYear"( @"t" )] COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water. Investments in long term <br>projects and these would be known and they would be scheduled by a date where they can start getting <br>credits after the completion of those projects, can be created under any condition.  ST 9/11/2015" DO
    WITH NUMERIC creationBiNat = $ "ICS Credits.AnnualCreationBiNat_CA" ["Dec31ofYear"( @"t" )] COMMENTED_BY "If the LB Condition is Quantified Surplus or shortage, do not create any ICS water" DO
     WITH NUMERIC deliveryChargedToEC = "Min"( totalDeliveryOfCAICS, $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfCACEICS ) DO
      WITH NUMERIC deliveryChargedToSE = "Min"( totalDeliveryOfCAICS - deliveryChargedToEC, $ "ICS Credits.SystemEfficiencyICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationSysEff_CA" ["Dec31ofYear"( @"t" )] ) DO
       WITH NUMERIC deliveryChargedToBiNat = "Min"( totalDeliveryOfCAICS - deliveryChargedToEC - deliveryChargedToSE, $ "ICS Credits.BiNationalICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.AnnualCreationBiNat_CA" ["Dec31ofYear"( @"t" )] ) DO
        WITH NUMERIC mwdDiversionReduction = "Max"( totalDeliveryOfCAICS - deliveryChargedToEC - deliveryChargedToSE - deliveryChargedToBiNat, 0.00000000 "acre-ft" ) DO
         WITH NUMERIC ECICSCA = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
         THEN
          $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationOfCACEICS * "SystemTaxAdjustment"(  ) - deliveryChargedToEC
         ELSE
          ( $ "ICS Credits.ExtraordinaryConservationICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] - deliveryChargedToEC ) * 0.97000000 + creationOfCACEICS * "SystemTaxAdjustment"(  )
         ENDIF COMMENTED_BY "Resulting ExtraOrdinaryConservation ICS " DO
          WITH NUMERIC SEICSCA = ( $ "ICS Credits.SystemEfficiencyICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationSE - deliveryChargedToSE ) COMMENTED_BY "Resulting System Efficiency ICS " DO
           WITH NUMERIC BiNatICSCA = ( $ "ICS Credits.BiNationalICS_CA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationBiNat - deliveryChargedToBiNat ) COMMENTED_BY "Resulting Bi National ICS " DO
            WITH NUMERIC totalICSCA = ( ECICSCA + SEICSCA + BiNatICSCA ) COMMENTED_BY "Total ICS" DO
             { deliveryChargedToEC , deliveryChargedToSE , deliveryChargedToBiNat , creationOfCACEICS , ECICSCA , SEICSCA , BiNatICSCA , totalICSCA , mwdDiversionReduction , totalDeliveryOfCAICS }
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "ICSAccountingForNV" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the input slots for the creation of the ICS categories Tributary, Imported, Extraordinary Conservation (EC), System Efficiency (SE), and Bi-National (BiNat), Tributary DSS (Developed Shortage Supply), Imported DSS and determines the delivery of each category of ICS and the resulting amount of ICS Storage for each category as well as the Total Nevada ICS Volume. The function returns a list of each of these values for the Rule to assign to the appropriate slots.  TP 9/10/2014<br><br>For the delivery of NV ICS: <br>The delivery values of NV ICS are all input and if logic is needed to determine the delivery of NV ICS, then the logic would go into this function. <br><br>RETURNS: List of lists of the form &lcub;&lcub;Creation Trib ICS, Creation Trib DSS, SE ICS, EC ICS, NV Trib DSS ICS, NV Imp DSS ICS, NV BiNat ICS, NV Total ICS, Delivery of NV Trib DSS, Delivery of NV Imp DSS, Creation NV Imp ICS, Creation NV Imp DSS, NV Imp ICS, NV Trib ICS, Delivery of Trib ICS, Delivery of Imp ICS&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 9/10/2014";
    BEGIN

      WITH NUMERIC creationTribICS_NV = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  $ "ICS Credits.AnnualCreationTrib_NV" ["Dec31ofYear"( @"t" )]
 ENDIF DO
  WITH NUMERIC creationIMPICS_NV = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   $ "ICS Credits.AnnualCreationImp_NV" ["Dec31ofYear"( @"t" )]
  ENDIF DO
   WITH NUMERIC creationTribDSS_NV = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
   THEN
    $ "ICS Credits.AnnualCreationTrib_NV" ["Dec31ofYear"( @"t" )]
   ELSE
    0.00000000 "acre-ft"
   ENDIF DO
    WITH NUMERIC creationImpDSS_NV = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
    THEN
     $ "ICS Credits.AnnualCreationImp_NV" ["Dec31ofYear"( @"t" )]
    ELSE
     0.00000000 "acre-ft"
    ENDIF DO
     WITH NUMERIC deliveryTribDSS_NV = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
     THEN
      WITH NUMERIC shortageVolume = $ "Shortage.State Shortage Volumes" [( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) - 1.00000000, "Nevada"] DO
       IF ( $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )] <= $ "AnnualWaterUse.NV_BasicApportionment" [] - shortageVolume )
       THEN
        0.00000000 "acre-feet"
       ELSE
        "Min"( $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )] - ( $ "AnnualWaterUse.NV_BasicApportionment" [] - shortageVolume ), creationTribDSS_NV * 0.95000000 )
       ENDIF COMMENTED_BY "Deliver TribDSS, up to available created, to make up shortage"
      ENDWITH COMMENTED_BY "LowerBasinDemandVariability.LowerBasinCondition = 1 indicates Shortage, but the value of the <br>Shortage flag indicates the level and is needed to calculate shortage volume"
     ELSE
      0.00000000 "acre-feet"
     ENDIF DO
      WITH NUMERIC deliveryImpDSS_NV = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 1.00000000 )
      THEN
       WITH NUMERIC shortageVolume = $ "Shortage.State Shortage Volumes" [( $ "Shortage.Shortage Flag" ["Dec31ofYear"( @"t" )] ) - 1.00000000, "Nevada"] DO
        IF ( $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )] <= $ "AnnualWaterUse.NV_BasicApportionment" [] - shortageVolume + deliveryTribDSS_NV )
        THEN
         0.00000000 "acre-feet"
        ELSE
         "Min"( $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )] - ( $ "AnnualWaterUse.NV_BasicApportionment" [] - shortageVolume + deliveryTribDSS_NV ), creationTribDSS_NV * 0.95000000 )
        ENDIF COMMENTED_BY "Deliver ImpDSS, up to available created, to make up shortage after TribDSS used"
       ENDWITH
      ELSE
       0.00000000 "acre-feet"
      ENDIF DO
       WITH NUMERIC deliveryofTribICS = IF ( ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 3.00000000 ) COMMENTED_BY "Quantified Surplus" )
       THEN
        creationTribICS_NV * 0.95000000 COMMENTED_BY "Evaporation Charge"
       ELSE
        0.00000000 "acre-ft"
       ENDIF DO
        WITH NUMERIC deliveryofImpICS = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 3.00000000 )
        THEN
         creationIMPICS_NV * 0.95000000 COMMENTED_BY "Evaporation Charge"
        ELSE
         0.00000000 "acre-ft"
        ENDIF DO
         WITH NUMERIC creationEC = IF ( ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 3.00000000 ) COMMENTED_BY "This Check references the surplus value that represents Quantified Surplus in <br>the Determine Mead and Lower Basin Condition Rule. Quantified Surplus is set <br>as a value of 3 in the IsSurplusYear annual series slot. TP 7/28/2015" )
         THEN
          0.00000000 "acre-ft"
         ELSE
          $ "ICS Credits.AnnualCreationEC_NV" ["Dec31ofYear"( @"t" )]
         ENDIF DO
          WITH NUMERIC creationSE = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 3.00000000 )
          THEN
           0.00000000 "acre-ft"
          ELSE
           $ "ICS Credits.AnnualCreationSysEff_NV" ["Dec31ofYear"( @"t" )]
          ENDIF DO
           WITH NUMERIC creationBiNat = IF ( NaNToZero ( $ "LowerBasinDemandVariability.LowerBasinCondition" ["Dec31ofYear"( @"t" )] ) == 3.00000000 )
           THEN
            0.00000000 "acre-ft"
           ELSE
            $ "ICS Credits.AnnualCreationBiNat_NV" ["Dec31ofYear"( @"t" )]
           ENDIF DO
            WITH NUMERIC tribICSNV = creationTribICS_NV * 0.95000000 - $ "ICS Credits.AnnualDeliveryTrib_NV" ["Dec31ofYear"( @"t" )] DO
             WITH NUMERIC impICSNV = creationIMPICS_NV * 0.95000000 - $ "ICS Credits.AnnualDeliveryImp_NV" ["Dec31ofYear"( @"t" )] DO
              WITH NUMERIC tribDSSICSNV = creationTribDSS_NV * 0.95000000 - deliveryTribDSS_NV DO
               WITH NUMERIC impDSSICSNV = creationImpDSS_NV * 0.95000000 - deliveryImpDSS_NV DO
                WITH NUMERIC ECICSNV = IF ( $ "Mead.Pool Elevation" [@"t - 1"] <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
                THEN
                 $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.TributaryICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.ImportedICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.AnnualDeliveryEC_NV" ["Dec31ofYear"( @"t" )]
                ELSE
                 ( $ "ICS Credits.ExtraordinaryConservationICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.TributaryICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + $ "ICS Credits.ImportedICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] - $ "ICS Credits.AnnualDeliveryEC_NV" ["Dec31ofYear"( @"t" )] ) * 0.97000000 + creationEC * 0.95000000
                ENDIF COMMENTED_BY "Resulting ExtraordinaryConservation ICS. In the case that the previous year was a Quantified Surplus year, the <br>Tributary and Imported ICS would have been delivered and that is accounted for in the equation below. " DO
                 WITH NUMERIC SEICSNV = ( $ "ICS Credits.SystemEfficiencyICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationSE - $ "ICS Credits.AnnualDeliverySysEff_NV" ["Dec31ofYear"( @"t" )] ) COMMENTED_BY "Resulting System Efficiency ICS " DO
                  WITH NUMERIC BiNatICSNV = ( $ "ICS Credits.BiNationalICS_NV" [@"24:00:00 December Max DayOfMonth, Previous Year"] + creationBiNat - $ "ICS Credits.AnnualDeliveryBiNat_NV" ["Dec31ofYear"( @"t" )] ) COMMENTED_BY "Resulting Bi National ICS " DO
                   WITH NUMERIC totalICSNV = ( tribICSNV + impICSNV + ECICSNV + SEICSNV + BiNatICSNV ) COMMENTED_BY "Total ICS" DO
                    { creationTribICS_NV , creationTribDSS_NV , SEICSNV , ECICSNV , tribDSSICSNV , impDSSICSNV , BiNatICSNV , totalICSNV , deliveryTribDSS_NV , deliveryImpDSS_NV , creationIMPICS_NV , creationImpDSS_NV , impICSNV , tribICSNV , deliveryofTribICS , deliveryofImpICS }
                   ENDWITH
                  ENDWITH
                 ENDWITH
                ENDWITH
               ENDWITH
              ENDWITH
             ENDWITH
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "SumAnnualCAPDivRequest" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total annual CAP diversion requested for the current calendar year<br><br>RETURNS: Total annual diversion volume requested [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  "FlowToVolume"( $ "CAPDiversion.Total Diversion Requested" [date], date )
 ENDFOR;

    END;

    FUNCTION       "SumAnnualSNWADivRequest" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Sums the annual diversion request for SNWP Pumping from Lake Mead TP 7/27/2015<br><br>RETURNS: Diversion requested volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 7/27/2015";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  "FlowToVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested" [date], date )
 ENDFOR;

    END;

    FUNCTION       "SumAnnualMWDDivRequest" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total volume of the MWDDiversion:MWD.Diversion Requested slot for the current model year<br><br>RETURNS: Diversion volume requested for current year<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  ( "FlowToVolume"( $ "MWDDiversion:MWD.Diversion Requested" [date], date ) - $ "California_CU_Schedules.MWDReturns" [date] )
 ENDFOR;

    END;

    FUNCTION       "SystemTaxAdjustment" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Used to calculate the &quot;tax&quot; charged to ICS water<br><br>RETURNS: Coefficient to multiply ICS volume by to assess tax [NONE]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: MC, 20171204<br><br>MC, 20171204: Copied from Aug2017 CRSS model during modifications to switch CA ICS creation and delivery from Powell inflow basis to Sacramento Water Year basis";
    BEGIN

      1.00000000 - $ "ICS Credits.SystemTaxPercent" [];

    END;

  END;

  UTILITY_GROUP "Midterm Model General Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "CurrentYear" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the date that represents the current year for annual slots<br><br>RETURNS: Dec 31, Current Year [DATETIME]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      @"24:00:00 December Max DayOfMonth, Current Year";

    END;

    FUNCTION       "DateToCheckEOWYElevation" ( DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the appropriate end of water year date on which to check the pool elevation<br><br>RETURNS: 24:00:00 September 30 of appropriate year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies which water year to check<br>2. BOOLEAN startYear - logical argument that specifies whether &quot;date&quot; is in the Start Year [TRUE] or an out year [FALSE]<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( date >= @"October 31" OR ( date == @"August 31" AND NOT startYear ) OR ( date == @"September 30" AND NOT startYear ) )
 THEN
  @"24:00:00 September 30, Next Year"
 ELSE
  @"24:00:00 September 30, Current Year"
 ENDIF;

    END;

    FUNCTION       "DateToCheckJan1Elevation" ( DATETIME date, BOOLEAN startYear )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date of Dec 31 for the appropriate calendar year to represent a Jan 1 pool elevation (i.e., the Dec 31 pool elevation represents the Jan 1 pool elevation). The function assumes if &quot;date&quot; is October or later, or is August and not in the first year of the model run, that Jan 1 of the calendar year following the one containing &quot;date&quot; is desired; otherwise, Jan 1 of the current calendar year is desired. <br><br>RETURNS: Dec 31 of the year containing &quot;date&quot; [DATETIME]<br><br>ARGUMENTS: <br>1. DATETIME date - date for which the Jan 1 elevation should be checked<br>2. BOOLEAN startYear - Boolean variable designating if the year is the first year of the model run (TRUE) or not (FALSE)<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: I think the assumptions made in the function may be unnecessary and complicating. It might be easier to make adjustments in the &quot;date&quot; argument rather than sending in the additional Boolean argument; that is, if in August and want Jan 1 of next year, just pass @&quot;t+2&quot; instead of requiring the separate Boolean argument";
    BEGIN

      IF ( date >= @"October 31" OR ( date == @"August 31" AND NOT startYear ) )
 THEN
  "Dec31ofYear"( date )
 ELSE
  "Dec31ofYear"( date - 1.00000000 "year" )
 ENDIF;

    END;

    FUNCTION       "EnsureReleaseLimits" ( NUMERIC release, NUMERIC lowerLimit, NUMERIC upperLimit )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function ensures the release volume specified as an argument lies between the minimum and maximum values specifed as arguments<br><br>RETURNS: Release volume [L^3]<br><br>ARGUMENTS:<br>1. NUMERIC release - release volume to check<br>2. NUMERIC lowerLimit - minimum release volume<br>3. NUMERIC upperLimit - maximum release volume<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MIN_CONSTRAINT lowerLimit;
    MAX_CONSTRAINT upperLimit;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      release;

    END;

    FUNCTION       "EqLevel" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "DESCRIPTION: This function returns the value for the year containing &quot;date&quot; from the slot PowellData.EqualizationElevationTable (i.e., the Equalization pool elevation specified for the year)<br><br>RETURNS: Pool elevation [L]<br><br>ARGUMENTS: <br>1. DATETIME date - date that specifies the water year to check<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      WITH STRING waterYear = IF ( date >= @"October 31" )
 THEN
  "GetYearAsString"( "OffsetDate"( date, 1.00000000, "1 years" ) )
 ELSE
  "GetYearAsString"( date )
 ENDIF DO
  $ "PowellData.EqualizationElevationTable" [waterYear, 0.00000000]
 ENDWITH;

    END;

    FUNCTION       "EstimateEvaporation" ( OBJECT reservoir, NUMERIC startStorage, NUMERIC endStorage, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns an estimate of the evaporation volume occurring on the specified reservoir between the specified dates and storages<br><br>RETURNS: Evaporation volume [L^3]<br><br>ARGUMENTS<br>1. OBJECT reservoir - reservoir for which evaporation volume is desired<br>2. NUMERIC startStorage - beginning storage volume<br>3. NUMERIC endStorage - ending storage volume<br>4. DATETIME startDate - date of beginning storage volume<br>5. DATETIME endDate - date of ending storage volume<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "FlowToVolume"( ( "StorageToArea"( reservoir, startStorage ) + "StorageToArea"( reservoir, endStorage ) ) / 2.00000000 * "SumEvapCoeffCRSS"( reservoir, "GetMonth"( startDate ) - 1.00000000, "GetMonth"( endDate ) - 1.00000000 ), endDate );

    END;

    FUNCTION       "GetElement" ( LIST list, NUMERIC i )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the value (numeric) of the list item at index i<br><br>RETURNS: Numeric value [Variable]<br><br>ARGUMENTS:<br>1. LIST list - list of items<br>2. NUMERIC i - index value into list<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      GET @INDEX i FROM list;

    END;

    FUNCTION       "HasAnyRuleFired" ( LIST rules )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines if any rule in the input list &quot;rules&quot; has fired successfully<br><br>RETURNS: TRUE if any rule in the list has fired successfully; otherwise FALSE [BOOLEAN]<br><br>ARGUMENTS:<br>1. LIST rules - a list of rule names<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( STRING rule IN rules ) WITH BOOLEAN fired = FALSE DO
  IF ( "HasRuleFiredSuccessfully"( rule ) AND NOT fired )
  THEN
   TRUE
  ELSE
   fired
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "Interpolate" ( NUMERIC x, NUMERIC x0, NUMERIC x1, NUMERIC y0, NUMERIC y1 )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function does a linear interpolation of values in a table<br><br>RETURNS: Interpolated value of y [Units of y]<br><br>ARGUMENTS<br>1. NUMERIC x - value of X variable whose corresponding value in Y column of table is desired<br>2. NUMERIC x0 - highest value in X column that is less than x<br>3. NUMERIC x1 - lowest value in X column that is greater than x<br>4. NUMERIC y0 - value in Y vector corresponding to x0 value in X column<br>5. NUMERIC y1 - value in Y vector corresponding to x1 value in X column<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: CE 6/12/13";
    BEGIN

      y0 + ( x - x0 ) / ( x1 - x0 ) * ( y1 - y0 );

    END;

    FUNCTION       "IsYearDemandVariabilityAndRunCycle4" ( DATETIME date )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This rule returns a Boolean value of TRUE if lower basin demand variability is active and the run is in Run Cycle 4 and a value of FALSE otherwise<br><br>RETURNS: Boolean [BOOLEAN]<br><br>ARGUMENTS:<br>1. DATETIME date - date which specifies the year in question<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20180125: Added LBDV.BlwParkerTriggerSet and ICS Credits.SacWYType conditions to function based on USBR changes to function";
    BEGIN

      IF ( "GetRunCycleIndex"(  ) == 4.00000000 AND ( ( NaNToZero ( $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == 1.00000000 OR NaNToZero ( $ "LowerBasinDemandVariability.AbvHooverTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == - 1.00000000 ) OR ( ( NaNToZero ( $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == 1.00000000 OR NaNToZero ( $ "LowerBasinDemandVariability.BlwParkerTriggerSet" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] ) == - 1.00000000 ) OR $ "ICS Credits.SacWYType" ["Dec31ofYear"( "GetWaterYearEndDate"( date ) )] != 3.00000000 ) ) )
 THEN
  TRUE
 ELSE
  FALSE
 ENDIF;

    END;

    FUNCTION       "MeadPumpingDemandVariabilityFactor" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function checks the lower basin demand threshhold for the Local Inflows above Hoover and applies the changes to Mead pumping where necessary.  If the local inflows above Hoover Dam are greater than the 90% historic local inflow volume then the pumping is reduced by 5%.  In the case that the local inflows are less than the 10% exceedence historic local inflow volume then the pumping is increased by 5%. The function returns a factor which is applied to the monthly pumping requests and set by the rule that calls this function (Reset Monthly Forecast SNWP LC Demand Variability).  TP 3/12/2013<br><br>RETURNS: Number representing the current pumping rate relative to a normal year [NONE]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies the year for which the pumping factor is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 3/12/2013";
    BEGIN

      IF ( "IsMRM"(  ) AND NOT "IsSurplusOrShortage"(  ) )
 THEN
  IF ( ( $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowAboveHoover90"] ) COMMENTED_BY "For high inflow year, pumping reduced" )
  THEN
   0.95000000
  ELSE
   IF ( ( $ "LowerBasinDemandVariability.LocalInflowAboveHooverTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowAboveHoover10"] ) COMMENTED_BY "For low inflow year, pumping increased" )
   THEN
    1.05000000
   ELSE
    1.00000000
   ENDIF
  ENDIF
 ELSE
  1.00000000
 ENDIF;

    END;

    FUNCTION       "AgUsersBelowParkerDemandVariabilityFactor" ( DATETIME date, STRING AgUser )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function checks the lower basin demand threshhold for the Local Inflows below Parker and applies the changes to Mead pumping where necessary.  The function takes a date and checks the conditions for the year of that date then returns a factor for increased or decreased pumping from Mead.<br><br>RETURNS: Demand variability factor [NONE]<br><br>ARGUMENTS:<br>1. DATETIME date - date that determines the year to check<br>2. STRING AgUser - user for who the factor is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP, 3/12/13";
    BEGIN

      IF ( "IsMRM"(  ) )
 THEN
  IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker90"] )
  THEN
   0.90000000
  ELSE
   IF ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker10"] )
   THEN
    IF ( AgUser == "IID" OR AgUser == "CVWD" OR AgUser == "YMIDD" OR AgUser == "WMIDD" )
    THEN
     1.00000000
    ELSE
     1.05000000
    ENDIF
   ELSE
    1.00000000
   ENDIF
  ENDIF
 ELSE
  1.00000000
 ENDIF;

    END;

    FUNCTION       "CAPDemandVariabilityFactor" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function checks the lower basin demand threshhold for the Local Inflows above Hoover and applies the changes to Mead pumping where necessary.  The function takes a date and checks the conditions for the year of that date then returns a factor for increased or decreased pumping from Mead. If local inflows to the system below Parker Dam are greater than the 90% exceedence of historic local inflows a factor of 90% is returned.  If the local inflows are below the 10% exceedence of the historic local inflows, then the diversion requested can be increased in the amount the is equal to the difference in the State Apportionment for the year and the volume of Senior Prority user diversion requests.  This value is added to any ICS delivery if Lake Mead is above 1,100 Ft.  The sum of the remaining state apportionment and the ICS Delivery is what CAP is allowed to divert.  A ratio of the new diversion amount to the old diversion amount is returned and applied to the diversion request slot in the rule calling this function (Reset Monthly Forecast CAP LC Demand Variability). TP 7/27/2015<br><br>RETURNS: Factor to apply to diversion requests [NONE]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies the year considered<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 3/12/2013";
    BEGIN

      IF ( "IsMRM"(  ) AND NOT "IsSurplusOrShortage"(  ) )
 THEN
  IF ( ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] > $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker90"] ) COMMENTED_BY "High local inflows" )
  THEN
   0.90000000
  ELSE
   IF ( ( $ "LowerBasinDemandVariability.LocalInflowBelowParkerTrigger" ["Dec31ofYear"( date )] < $ "LowerBasinDemandVariability.LBDemandVariabilityTriggerThreshholds" [0.00000000, "SideInflowBelowParker10"] ) COMMENTED_BY "Low local inflows" )
   THEN
    WITH NUMERIC volOfAZAgScheduled = FOR ( DATETIME dateSum IN "GetDates"( "OffsetDate"( "Dec31ofYear"( date ), - 11.00000000, "1 Months" ), "Dec31ofYear"( date ), "1 Months" ) ) STAT_SUM
     FOR ( OBJECT azNonCapWaterUser IN "ListSubbasin"( "ArizonaNonCAPWaterUsers" ) ) STAT_SUM
      "FlowToVolume"( azNonCapWaterUser & "Diversion Requested" [dateSum], dateSum )
     ENDFOR
    ENDFOR DO
     WITH NUMERIC diffVolAgDivAZ = $ "AnnualWaterUse.Arizona_Apportionment" ["Dec31ofYear"( date )] - volOfAZAgScheduled DO
      WITH NUMERIC volOfScheduledCAPDiv = "SumAnnualCAPDivRequest"(  ) DO
       WITH NUMERIC ratioFullAllocToAgDiv = ( diffVolAgDivAZ / volOfScheduledCAPDiv ) COMMENTED_BY "Add the difference in the volume available for CAP to divert to the ICS<br> diversion that is available if Lake Mead is above 1,100 Ft." DO
        ratioFullAllocToAgDiv
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "This needs to be changed to take into account All ofthe Ag Diversions for Arizona below Parker Dam so that the total <br>diversion does not exceede 2.8 MAF for the given year. All of the ag diversions are not included here. TP 3/12/2013<br>Added a new Sub Basin called ArizonaNonCAPWaterUsers and now this issue is resolved TP 1/28/2015"
   ELSE
    1.00000000
   ENDIF
  ENDIF
 ELSE
  1.00000000
 ENDIF;

    END;

    FUNCTION       "IsMRM" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This Function will determine if the model is in a deterministic mode or an MRM mode.  Right now, the deterministic run is as high as 32 months and the MRM is as short as 60 months. so anything over 3 years difference between the year of the finish timestep and the year of the start timestep will be an MRM run. The function returns True if the model is in an MRM run and False if the model is not. If the MRM is only run for the deterministic period, this function does not apply. Other methods of determining an MRM run should be implemented here if they are known. TP 3/13/2013<br><br>RETURNS: FALSE if slot LowerBasinDemandVariability.DetermCheck has value of NaN or 1.0; TRUE otherwise [BOOLEAN]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 3/13/2013<br>MC, 20170515: The function is called from several rules in the current ruleset, but the slot used in this function doesn't appear to be set anywhere in the rules. It is currently set as input through Sep 2022 in the model but I can't determine how it was set as it shows up on the MRM DMI but is not in the EnsembleForecasts spreadsheet. I looked at the SEP15 model and spreadsheets and it does not appear in the spreadsheet there either, but is in the model?<br>MC, 20180309: The slot is set from values in the DONOTCHANGE worksheet of the EnsembleForecasts spreadsheet";
    BEGIN

      IF ( IsNaN $ "LowerBasinDemandVariability.DetermCheck" [@"Start Timestep"] OR $ "LowerBasinDemandVariability.DetermCheck" [@"Start Timestep"] == 1.00000000 )
 THEN
  FALSE
 ELSE
  TRUE
 ENDIF;

    END;

    FUNCTION       "IsSurplusOrShortage" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This Function checks the two limits of Shortage or Surplus and returns a boolean statement saying if the water year is in surplus or shortage. This is being used in the LC Demand Variability Logic. TP 4/18/2013<br><br>RETURNS: TRUE if Mead is in Shortage or Surplus; FALSE otherwise [BOOLEAN]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: TP 4/18/2013";
    BEGIN

      IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] <= $ "Shortage.Mead Shortage Elevations" [0.00000000, 0.00000000] )
 THEN
  TRUE
 ELSE
  IF ( $ "Mead.Pool Elevation" [@"24:00:00 December 31, Previous Year"] >= $ "Surplus.Domestic Surplus Trigger Elevation" [] )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF
 ENDIF;

    END;

    FUNCTION       "MonthIs" ( LIST months )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns True if the current timestep is in the list months and False if it is not. - CE 6/11/13<br><br>RETURNS: Boolean [BOOLEAN]<br><br>ARGUMENTS: <br>1. LIST months - list of months as strings to check for current month<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "GetMonthAsString"( @"t" ) IN months;

    END;

    FUNCTION       "RelativeEOWYDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns the datetime at the end of the water year relative the the current timestep. e.g. if the month is June, the function would return @&quot;t+3&quot;<br><br>RETURNS: Date of the end of the water year containing the input argument &quot;date&quot; [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the end of water year is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20161201: Replace use of this function by WaterYearEndDate, which does not rely on the MonthsUntilEOWY user-defined function?";
    BEGIN

      "OffsetDate"( date, "MonthsUntilEOWY"( date ), "1 months" );

    END;

    FUNCTION       "RuleCurveStorage" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the storage volume target from the UBRuleCurveData.BaseRuleCurves slot for the reservoir and date passed as input<br><br>RETURNS: Storage volume target [L^3]<br><br>ARGUMENTS<br>1. OBJECT res - reservoir for which storage volume is desired<br>2. DATETIME date - timestep for which storage volume is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.BaseRuleCurves" [STRINGIFY res, "GetMonthAsString"( date )];

    END;

    FUNCTION       "StartMonthIsSeptember" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns TRUE if the timestep is the Start Timestep and the month is September, and returns FALSE otherwise<br><br>RETURNS: Boolean [BOOLEAN]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170511: Function name is somewhat misleading? I thought it meant the Start Timestep occurred in September, regardless of whether the current timestep was the Start Timestep";
    BEGIN

      @"t" == @"Start Timestep" AND "MonthIs"( { "September" } );

    END;

    FUNCTION       "SumEvapCoeffCRSS" ( OBJECT res, NUMERIC startRow, NUMERIC endRow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function sums the values in the Evaporation Coefficients slot of the reservoir specified as an argument for the row specified as arguments<br><br>RETURNS: total evaporation rate for the period determined by the rows specified [L/T]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir for which the total evaporation rate is desired<br>2. NUMERIC startRow - index representing the beginning month of the period desired in the Evaporation Coefficients slot<br>3. NUMERIC endRow - index representing the ending month of the period desired in the Evaporation Coefficients slot<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumTableColumn"( res & "Evaporation Coefficients", 0.00000000, startRow, endRow );

    END;

    FUNCTION       "GetWaterYearEndDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date of the end of the water year containing the date passed as an argument; if the month of the date is September or earlier, use Sep 30 of the same calendar year; otherwise, use Sep 30 of the following calendar year<br><br>RETURNS: 24:00:00 September 30 for the appropriate water year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - datetime for which the end of water year date is desired<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "GetMonth"( date ) <= 9.00000000 )
 THEN
  "CompletePartialDate"( @"24:00:00 September 30", date )
 ELSE
  "CompletePartialDate"( @"24:00:00 September 30", "NumberToYear"( "GetYear"( date ) + 1.00000000 ) )
 ENDIF;

    END;

    FUNCTION       "GetWaterYearBeginDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the date of the beginning of the water year containing the date passed as an argument. Note that the datetime returned represents October 31, not October 1, since the model uses a monthly timestep and timesteps are represented by their end, not beginning.<br><br>RETURNS: 24:00:00 October 31 for the appropriate water year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME tInput - datetime for which the beginning of water year date is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "GetMonth"( date ) <= 9.00000000 )
 THEN
  "CompletePartialDate"( @"24:00:00 October 31", "NumberToYear"( "GetYear"( date ) - 1.00000000 ) )
 ELSE
  "CompletePartialDate"( @"24:00:00 October 31", date )
 ENDIF;

    END;

    FUNCTION       "CheckAndAdjustToCapacity" ( SLOT divSlot, NUMERIC divCap )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function redistributes flows in divSlot that exceed the capacity value divCap<br><br>RETURNS: List of flow rates [L^3/T]<br><br>ARGUMENTS:<br>1. SLOT divSlot - slot with units of flow rate [L^3/T] to check for values meeting capacity provided<br>2. NUMERIC divCap - maximum value to allow for values in divSlot<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: John Roca, Unknown<br>MC, 20170609: This function was written in response to a situation that occurred whereby MWD would take extra available water near the end of a year, but doing so too late in the year resulted in diversions that exceeded the canal capacity";
    BEGIN

      WITH LIST divPairs = FOR ( DATETIME ithDate IN "GetDates"( @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) WITH LIST result = {  } DO
  APPEND { ithDate , "FlowToVolume"( divSlot [ithDate], ithDate ) } ONTO result
 ENDFOR DO
  WITH NUMERIC overCapVol = FOR ( LIST ithVal IN divPairs ) WITH NUMERIC result = 0.00000000 "acre-feet" DO
   result + "Max"( 0.00000000 "acre-feet", ( GET @INDEX 1.00000000 FROM ithVal ) - "FlowToVolume"( divCap, GET @INDEX 0.00000000 FROM ithVal ) )
  ENDFOR DO
   WITH LIST spaceAvailable = FOR ( LIST ithVal IN divPairs ) WITH LIST result = {  } DO
    APPEND "FlowToVolume"( divCap, GET @INDEX 0.00000000 FROM ithVal ) - GET @INDEX 1.00000000 FROM ithVal ONTO result
   ENDFOR DO
    FOR ( LIST ithPair IN "Reverse"( divPairs ) ) WITH LIST output = {  } DO
     INSERT WITH NUMERIC cumulativeSpaceAvailable = FOR ( DATETIME jthT IN "GetDates"( ( GET @INDEX 0.00000000 FROM ithPair ), @"24:00:00 December Max DayOfMonth, Current Year", "1 months" ) ) WITH NUMERIC result = 0.00000000 "acre-feet" DO
      result + "Max"( GET @INDEX "GetMonth"( jthT ) - 1.00000000 FROM spaceAvailable, 0.00000000 "acre-feet" )
     ENDFOR COMMENTED_BY "Get the cumulative space available for the given month" DO
      "VolumeToFlow"( ( ( GET @INDEX 1.00000000 FROM ithPair ) + "MinItem"( { overCapVol , GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable , IF ( cumulativeSpaceAvailable < overCapVol )
      THEN
       GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable
      ELSE
       IF ( cumulativeSpaceAvailable - overCapVol >= GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable )
       THEN
        0.00000000 "acre-ft"
       ELSE
        ( GET @INDEX "GetMonth"( GET @INDEX 0.00000000 FROM ithPair ) - 1.00000000 FROM spaceAvailable ) - ( cumulativeSpaceAvailable - overCapVol )
       ENDIF
      ENDIF COMMENTED_BY "This logic detemines the incremental change required without going over the annual volume" } ) ) COMMENTED_BY "Add or subtract the required adjustment value to meet the required annual volume or to prevent <br>going over the monthly capacity", GET @INDEX 0.00000000 FROM ithPair )
     ENDWITH INTO output
    ENDFOR COMMENTED_BY "Iterate through the dates from December backwards to January while <br>distributing the over-capacity total volume to months that have space"
   ENDWITH COMMENTED_BY "Figure out the monthly values by which diversions are over or under the capacity"
  ENDWITH COMMENTED_BY "Figure out the total volume that needs to be redistibuted given the monthly diversion values that <br>go over the capacity"
 ENDWITH COMMENTED_BY "Get a list of date and value pairs for the calendar year";

    END;

    FUNCTION       "IsUEBEqualizingBranchAndRunCycle4" ( DATETIME eoyDate )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns TRUE if the current Run Cycle is 4 and the Powell upper elevation balancing branch is > 1.20 (1.27, 1.29, 1.3, or 1.4), and FALSE otherwise.<br><br>RETURNS: Boolean TRUE or FALSE<br><br>ARGUMENTS:<br>1. DATETIME eoyDate - the end of year date specifying the water year for which the UEB Branch is checked<br><br>CONSTRAINTS: NONE";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "AUTHOR, DATE: TP, 201801";
    BEGIN

      ( "GetRunCycleIndex"(  ) == 4.00000000 AND $ "PowellData.UpperElevBalBranch" [eoyDate] > 1.20000000 );

    END;

  END;

  UTILITY_GROUP "Headwater Reservoir Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetEOMTargetElevation" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object and a date, and then returns the end of month target elevation for that reservoir on that date.  This function requires that the reservoirs data object be named &quot;[reservoir]Data&quot; and that the guide slot that holds the target elevations be named &quot;[reservoir]Guide&quot;.  - sc 12/16/10<br><br>RETURNS: Pool elevation [L]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir for which target elevation is desired<br>2. DATETIME date - date for which target is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/16/2010";
    BEGIN

      WITH OBJECT resDataObj = "GetObject"( ( STRINGIFY res ) CONCAT "Data" ) DO
  WITH STRING guideSlotName = ( STRINGIFY res ) CONCAT "Guide" DO
   resDataObj & guideSlotName [date, "Target Elevation"]
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "GetReservoirMinConstraint" ( OBJECT reservoir, DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir and a date and returns the minimum constraint to the outflow allowed from that reservoir on that date. - sc 12/16/10<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which minimum outflow is desired (Taylor Park or Vallecito)<br>2. DATETIME date - date for which minimum is desired<br>3. NUMERIC prevElev - pool elevation at the end of the previous timestep<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/16/2010<br>TV, 8/1/2012: Added additional argument necessary for Taylor Park";
    BEGIN

      IF ( reservoir == % "TaylorPark" )
 THEN
  "Min"( $ "TaylorParkData.MinFlow" [date] COMMENTED_BY "Minimum flow requirements", "SolveOutflow"( % "TaylorPark", $ "TaylorPark.Inflow" [date], "ElevationToStorage"( % "TaylorPark", $ "TaylorParkData.MinElevation" [] ), "ElevationToStorage"( % "TaylorPark", prevElev ), date ) COMMENTED_BY "Maximum possible release from reservoir to dead pool. -tv 8.1.12" )
 ELSE
  IF ( reservoir == % "Vallecito" )
  THEN
   $ "VallecitoData.MinFlow" []
  ELSE
   STOP_RUN "No such Reservoir"
  ENDIF
 ENDIF;

    END;

    FUNCTION       "MonthlyEvapVolume" ( OBJECT reservoir, DATETIME date, NUMERIC previousPoolElevation, NUMERIC previousStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object, a datetime, a pool elevation and storage at the end of the timestep previous to the passed-in date.  It returns the volume of water evaporated from the passed-in reservoir during the passed-in date timestep. - sc 12/19/10<br><br>RETURNS: Evaporation volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which evaporation estimate is desired<br>2. DATETIME date - date the specifies the timestep for which evaporation is desired<br>3. NUMERIC previousPoolElevation - pool elevation at the end of the timestep prior to &quot;date&quot;<br>4. NUMERIC previousStorage - storage volume at the end of the timestep prior to &quot;date&quot;<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/19/2010";
    BEGIN

      WITH NUMERIC evapHeight = reservoir & "Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000] * "GetDaysInMonth"( date ) DO
  WITH NUMERIC elevationAfterEvap = previousPoolElevation - evapHeight DO
   WITH NUMERIC storageAfterEvap = "TableInterpolation"( reservoir & "Elevation Volume Table", 0.00000000, 1.00000000, elevationAfterEvap, date ) DO
    previousStorage - storageAfterEvap
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "GetReservoirMaxConstraint" ( OBJECT reservoir, DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir and a date and returns the maximum constraint to the outflow allowed from that reservoir on that date. - sc 12/16/10<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which maximum outflow is desired (Taylor Park or Vallecito)<br>2. DATETIME date - date for which maximum is desired<br>3. NUMERIC prevElev - pool elevation at the end of the previous timestep<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/16/2010";
    BEGIN

      IF ( reservoir == % "TaylorPark" OR reservoir == % "Vallecito" )
 THEN
  "TableInterpolation"( reservoir & "Max Release", 0.00000000, 1.00000000, prevElev, @"t" )
 ELSE
  STOP_RUN "No such Reservoir"
 ENDIF;

    END;

    FUNCTION       "SolveConstrainedOutflow" ( OBJECT reservoir, NUMERIC elevationTarget, NUMERIC previousPoolElev, NUMERIC minConstraint, NUMERIC maxConstraint, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object, an end-of-timestep elevation target, a previous timestep elevation, a minimum release constraint, a maximum release constraint, and a datetime.  It returns a release value for the passed in reservoir on the passed in date that hits the elevation target, or gets as close as possible within the passed in constraints.  Note the min and max constraints are imposed in the Post-Execution checks and do not appear in the body of the function. - sc 12/14/10<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which outflow is desired<br>2. NUMERIC elevationTarget - target pool elevation<br>3. NUMERIC previousPoolElev - pool elevation at end of previous timestep<br>4. NUMERIC minConstraint - minimum flow rate possible<br>5. NUMERIC maxConstraint - maximum flow rate possible<br>6. DATETIME date - date for which pool elevation should meet target<br><br>CONSTRAINTS: minConstraint & maxConstraint (passed arguments)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    MAX_CONSTRAINT maxConstraint;
    MIN_CONSTRAINT minConstraint;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/14/2010<br>MC, 20170531: Remove WITH statement?";
    BEGIN

      "SolveOutflow"( reservoir, reservoir & "Inflow" [date], "ElevationToStorage"( reservoir, elevationTarget ), "ElevationToStorage"( reservoir, previousPoolElev ), date );

    END;

    FUNCTION       "SimulateHeadwaterRes" ( OBJECT reservoir )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a reservoir object and returns a list of three-item lists, each sub-list of the form &lcub;date, outflow, end-of-month pool elevation&rcub;. There is one sublist for each timestep in the run.<br>The function operates the passed-in reservoir basically according to a guide curve specified on the reservoirs data object.  A minimum constraint and maximum constraint to the outflow are calculated for each timestep that provides a floor and ceiling to the outflow that can be initiated to hit the elevation target prescribed by the guide curve.  A water balance calculation is performed at each timestep to determine the pool elevation at the end of the timestep. Then it steps forward one timestep does another water balance calculation, and continues doing this until it reaches the last timestep of the run.  The water balance equation used here is:<br><br>[Previous End of Month Storage] + [Reservoir Inflow] - [Reservoir Outflow] - [Reservoir Evaporation] = [End of Month Storage].  - sc 12/20/10<br><br>RETURNS: List of lists of the form &lcub;&lcub;date, outflow, End of month pool elevation&rcub;&rcub;<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir for which outflows are desired<br><br>CONSTRAINTS: minConstraint and maxConstraint outflows calculated by user-defined functions<br><br><br><br>TV, 20120801: Added additional argument (previous pool elevation) required by changes to the function GetReservoirMinConstraint";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/20/2010";
    BEGIN

      FOR ( DATETIME date IN @"Start Timestep" TO @"Finish Timestep" ) WITH LIST result = {  } DO
  WITH NUMERIC previousPoolElevation = IF ( date == @"Start Timestep" )
  THEN
   reservoir & "Pool Elevation" [@"t - 1"]
  ELSE
   GET @INDEX 2.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result
  ENDIF DO
   WITH NUMERIC resOutflow = WITH NUMERIC elevationTarget = "GetEOMTargetElevation"( reservoir, date ) DO
    WITH NUMERIC minConstraint = "GetReservoirMinConstraint"( reservoir, date, previousPoolElevation ) DO
     WITH NUMERIC maxConstraint = "GetReservoirMaxConstraint"( reservoir, date, previousPoolElevation ) DO
      "SolveConstrainedOutflow"( reservoir, elevationTarget, previousPoolElevation, minConstraint, maxConstraint, date )
     ENDWITH
    ENDWITH
   ENDWITH COMMENTED_BY "Calculate outflow from previous pool elevation to target subject to constraints" DO
    WITH NUMERIC PreviousStorage = "TableInterpolation"( reservoir & "Elevation Volume Table", 0.00000000, 1.00000000, previousPoolElevation, date ) DO
     WITH NUMERIC releaseVolume = resOutflow * "GetDaysInMonth"( date ) DO
      WITH NUMERIC inflowVolume = reservoir & "Inflow" [date] * "GetDaysInMonth"( date ) DO
       WITH NUMERIC evapVolume = "MonthlyEvapVolume"( reservoir, date, previousPoolElevation, PreviousStorage ) DO
        WITH NUMERIC newStorage = PreviousStorage + inflowVolume - releaseVolume - evapVolume DO
         WITH NUMERIC EOMPoolElevation = "TableInterpolation"( reservoir & "Elevation Volume Table", 1.00000000, 0.00000000, newStorage, date ) DO
          APPEND { date , resOutflow , EOMPoolElevation } ONTO result
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDFOR;

    END;

  END;

  UTILITY_GROUP "Aspinall/Gunnison Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "BlueMesaOutflowCalc" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function determines the outflow to be released from Blue Mesa by considering the following constraints: 1.) Release the greater of the flows necessary to meet the Whitewater Target Flow, the Black Canyon Target Flow, and the target pool elevation for Blue Mesa; 2.) Prevent an overflow at Crystal; 3.) If above minimum power pool elevation (7,393 ft), then maintain the pool above that value; 4.) Release no more than the maximum possible outflow; 5.) Maintain the pool elevation above the top of the dead pool (7,358 ft); 6.) Prevent the pool elevation from exceeding the maximum pool elevation.<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Release not less than 0 cfs";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Some of the limiting constraints could be moved to Post-Execution Checks (i.e., max possible outflow, release to max PE, release to dead pool); update local variable names; replace hard-coded values with slot values as possible";
    BEGIN

      WITH NUMERIC MonthlyWhitewaterTarget = IF ( ( "GetMonth"( @"t" ) == 5.00000000 OR "GetMonth"( @"t" ) == 6.00000000 ) AND ( $ "BlueMesa.Storage" [@"t - 1"] + "FlowToVolume"( $ "BlueMesa.Inflow" [@"t"], @"t" ) > "ElevationToStorage"( % "BlueMesa", 7487.90000000 "feet" ) OR $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] < 3.00000000 ) )
 THEN
  FOR ( DATETIME date IN "GetDates"( "GetStartDayOfMonth"(  ), "GetEndDayOfMonth"(  ), "1 days" ) ) STAT_AVE
   $ "BlueMesaData.TargetDailyWhitewaterFlows" [date]
  ENDFOR
 ELSE
  $ "BlueMesaData.BaseCanyonTargetFlows" [@"t"]
 ENDIF COMMENTED_BY "Computes the average flow for the month at the Whitewater Gage, which is calculated and then <br>referenced on the BlueMesaData.MayThruJulyDaily slot. TP 9/22/2015" DO
  WITH NUMERIC MonthlyCanyonFlows = IF ( $ "BlueMesaData.MeetCanyonDecreeFlows" [] == 1.00000000 )
  THEN
   FOR ( DATETIME date IN "GetDates"( "GetStartDayOfMonth"(  ), "GetEndDayOfMonth"(  ), "1 days" ) ) STAT_AVE
    $ "BlueMesaData.TargetDailyBlackCanyonFlows" [date]
   ENDFOR
  ELSE
   0.00000000 "acre-ft/month"
  ENDIF DO
   WITH NUMERIC MeetDownstreamFlowTargets = "SolveBlueMesaReleaseForDownstreamTargets"( MonthlyWhitewaterTarget, @"t", MonthlyCanyonFlows ) COMMENTED_BY "Maximum release to meet the Whitewater Gage and the Black Canyon Target Flows" DO
    WITH NUMERIC ReleaseToMeetBMMaxPE = "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MaximumPoolElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "Outflow to bring the reservoir to the maximum reservoir pool" DO
     WITH NUMERIC ReleaseToMeetBMTargetPE = "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), 0.00000000 "cfs" COMMENTED_BY "IF the reservoir is below MaxPoolElevation = 7,519.4 feet, the SolveOutflow function will calculate a negative outflow, this <br>prevents that from being included in solving the Blue Mesa Outflow TP 9/22/2015" ) COMMENTED_BY "Outflow to meet the target pool elevation" DO
      WITH NUMERIC MaxReleaseToAvoidMinPE = WITH NUMERIC tunnelDiv = $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [@"t"] DO
       WITH NUMERIC WaterAvailToCanyon = "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPowerElevation" [] COMMENTED_BY "Input Minimum Pool Elevation on the Blue Mesa Data Object" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), % "BlueMesa" & "Inflow" [@"t"] ) DO
        WITH NUMERIC GainsAbvCrystal = $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [@"t"] + $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [@"t"] DO
         WITH NUMERIC GainsBMToGJ = GainsAbvCrystal + $ "GunnisonBelowCrystal:GunnisonNrGJ_Whitewater.Local Inflow" [@"t"] DO
          WITH NUMERIC flowLevel = $ "BlueMesaData.GunnisonHClass" [@"24:00:00 December 31, Current Year"] DO
           WITH NUMERIC WaterRigtsAtWW = $ "BlueMesaData.BaseCanyonTargetFlows" [@"t", flowLevel] DO
            "Max"( tunnelDiv + "MinItem"( { WaterAvailToCanyon , "MaxItem"( { WaterRigtsAtWW - GainsBMToGJ , $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"] - GainsAbvCrystal , 0.00000000 "cfs" } ) , IF ( $ "BlueMesa.Pool Elevation" [@"t - 1"] <= $ "BlueMesaData.MinimumPowerElevation" [] )
            THEN
             "Max"( 300.00000000 "cfs" - GainsAbvCrystal, 0.00000000 "cfs" )
            ELSE
             "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPowerElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) - tunnelDiv, 0.00000000 "cfs" )
            ENDIF } ), "Max"( "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MinimumPowerElevation" [] ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ), 0.00000000 "cfs" ) )
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH COMMENTED_BY "This determines the outflow from the reservoir as the reservoir approaches and goes below the spillway.  <br>If the Blue Mesa is above min power pool (7,393 ft) in the previous time step, then release the amount <br>necessary to meet the downstream demands, including the Gunnison Tunnel and the Whitewater and Black <br>Canyon Target Flows but not more than what would lower Blue Mesa to Min Power Pool. If the Blue Mesa Pool <br>Elevation is below Min Power Pool then only release enough to meet the Gunnison Tunnel flow and base target <br>flows at Whitewater and the Canyon. " DO
       WITH NUMERIC MaxReleaseToPreventCrystalOverflow = "SolveBlueMesaReleaseForCrystalReleaseTarget"( $ "BlueMesaData.CrystalMaxOutflow" [@"t"], @"t" ) COMMENTED_BY "If Possible do not release over the maximum monthly target flow for Crystal. <br>Aug - Apr: 2,100 cfs; June - July: 4,150 cfs; no limit in May. " DO
        WITH NUMERIC BMPoolElevWithNoRelease = "TableInterpolation"( $ "BlueMesa.Elevation Volume Table", 1.00000000, 0.00000000, $ "BlueMesa.Storage" [@"t - 1"] + "FlowToVolume"( $ "BlueMesa.Inflow" [@"t"], @"t" ), @"t" ) DO
         WITH NUMERIC NoReleaseStorage = "ElevationToStorage"( % "BlueMesa", BMPoolElevWithNoRelease ) COMMENTED_BY "Calculate storage without release <br>" DO
          WITH NUMERIC SpillwayStorage = "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.SpillwayElevation" [] ) COMMENTED_BY "Calculate storage at the spillway invert <br>" DO
           WITH NUMERIC VolumeAboveSpillway = NoReleaseStorage - SpillwayStorage DO
            WITH NUMERIC ReleaseableVolumeRate = VolumeAboveSpillway / 1.00000000 "month" + $ "BlueMesa.Maximum Controlled Release" [0.00000000, 0.00000000] COMMENTED_BY "Here, this value represents only the max outlet works instead of also including <br>the Regulated Spill, which is how the RiverWare documentation considers it. <br>" DO
             WITH NUMERIC maxPossibleOutflow = "TableInterpolation"( $ "BlueMesaData.BlueMesa_MaxOutflowTable", 0.00000000, 1.00000000, BMPoolElevWithNoRelease, @"t" ) COMMENTED_BY "Mathematically derived max possible outflow based on the Max Release table <br>on the Blue Mesa data object. " DO
              WITH NUMERIC maxOutflowToBottom = "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.MaxDeadPoolElevation" [] + 0.10000000 "feet" ) COMMENTED_BY "The minimum elevation is a tenth of a foot high to prevent the reservoir from failing from the <br>mass balance for the reservoir. TP 9/28/2015", "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "Max release to the top of the dead pool (7,358 ft.)" DO
               WITH NUMERIC TargetReleaseFromBM = "Max"( "MinItem"( { "MaxItem"( { MeetDownstreamFlowTargets , ReleaseToMeetBMTargetPE } ) , MaxReleaseToPreventCrystalOverflow , MaxReleaseToAvoidMinPE , ReleaseableVolumeRate COMMENTED_BY "MC, 20170808: for testing, replaced maxPossibleOutflow <br>with ReleaseableVolumeRate  <br>" , maxOutflowToBottom } ), ReleaseToMeetBMMaxPE COMMENTED_BY "Release necessary to prevent Flood Control" ) DO
                "Max"( TargetReleaseFromBM, 0.00000000 "cfs" )
               ENDWITH
              ENDWITH
             ENDWITH
            ENDWITH
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH COMMENTED_BY "Calculate flows needed in Black Canyon"
 ENDWITH COMMENTED_BY "Calculate flows needed at Whitewater gage";

    END;

    FUNCTION       "SolveBlueMesaReleaseForDownstreamTargets" ( NUMERIC TargetWhitewaterFlow, DATETIME date, NUMERIC TargetCanyonFlow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function calculates the Blue Mesa release necessary to achieve both the flow target through Black Canyon and the flow target at the Whitewater gage. The flow targets and a date for the release are passed to the function as arguments, and the release to meet each target is calculated using a simple water balance for the river reach appropriate for the target. The maximum of the two releases required to meet the targets is then chosen to ensure both are met.<br><br>RETURNS: Blue Mesa release [L^3/T]<br><br>ARGUMENTS:<br>1. NUMERIC TargetWhitewaterFlow - flow rate required at the Whitewater gage<br>2. DATETIME date - date for which the release is desired<br>3. NUMERIC TargetCanyonFlow - flow rate required through Black Canyon<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br><br>MC, 20170705: Added adjustment to local inflows for dates in May because local inflow value includes changes in Paonia and Ridgway storages that are not available to meet downstream targets (i.e., the local inflows are unregulated but regulated flows are what actually contribute to target flows). The value added is the average difference between regulated and unregulated flows for 1980-2017 based on data received from Rick C. <br>MC, 20161123: This function receives target Whitewater and Black Canyon flows, as well as a date. It returns the Blue Mesa Reservoir release value necessary to achieve both of the passed-in flow targets by calculating a water balance between the reservoir and each target location, and setting the release to the maximum needed to attain the targets.  (used in updated BlueMesaOpsOutline_November2016.docx)";
    BEGIN

      "Max"( ( TargetWhitewaterFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] - ( $ "GainsCrystalToGJ.GainsCrystalToGJ" [date] - IF ( "GetMonth"( date ) == 5.00000000 )
 THEN
  $ "BlueMesaData.CrystalToGJ_MayAdjustment" []
 ELSE
  0.00000000 "acre-feet/month"
 ENDIF COMMENTED_BY "In May, adjust local inflows for reservoir storages" ) ) COMMENTED_BY "Blue Mesa Release to meet the Whitewater Target and the <br>Gunnison Tunnel Diversion while leveraging the gains between <br>Blue Mesa and Grand Junction TP/MC 9/22/2015", ( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] ) COMMENTED_BY "Blue Mesa Release to meet the minimum Black Canyon Flows <br>and the Gunnison Tunnel Diversion while leveraging the gains <br>between BM and the Tunnel. TP/MC 9/22/2105" );

    END;

    FUNCTION       "SolveBlueMesaReleaseForCrystalReleaseTarget" ( NUMERIC TargetCrystalRelease, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function takes a numeric release target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in release target for Crystal Reservoir  The function does this by doing a water balance in the reach of the river between Blue Mesa and Crystal Res and solving for the release from Crystal Res. - sc 12/28/10<br><br>RETURNS: Release rate [L^3/T]<br><br>ARGUMENTS:<br>1. NUMERIC TargetCrystalRelease - release rate desired from Crystal<br>2. DATETIME date - date on which the release is desired<br><br>CONSTRAINTS: Value on BlueMesaData.BlueMesaMinRelease slot (Minimum)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: sc 12/28/10";
    BEGIN

      "Max"( TargetCrystalRelease - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date], $ "BlueMesaData.BlueMesaMinRelease" [] );

    END;

    FUNCTION       "TaylorParkMinReleaseConstraint" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and returns the minimum release permitted on that date from Taylor Park Reservoir.  Currently it is just the &quot;MinFlow&quot; slot on the &quot;TaylorParkData&quot; object.  It is expected that this function will get more detailed as the development of the model continues and may have unique calculations for each month of the year. - sc 12/16/10<br><br>RETURNS: Minimum flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the minimum flow is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: Replace calls to this function with references to the slot?";
    BEGIN

      $ "TaylorParkData.MinFlow" [date];

    END;

    FUNCTION       "CalcCanyonPeakFlowTarget" ( NUMERIC currentForecast )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function returns the one-day peak flow target for the Black Canyon portion of the Gunnison River that will meet the Federal Reserve Water Right. Data for the linear calculation is stored in BlueMesaData.PeakFlowCalcData. Peak flow levels are from Appendix G, Sect 31 of Decree, Case No. 01CW05.<br><br>ARGUMENTS: Current Unregulated Inflow Forecast<br><br>RETURNS: One-day peak flow target for the Black Canyon portion of the Gunnison River.<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/22/2010<br><br>CF, 20170505: The function was modified to take currentForecast as an argument. Data for the linear calculation has been stored in BlueMesaData.PeakFlowCalcData rather than the function's body. - CF 5/5/17<br><br>SC, 20101222: The calculation is taken from Paul Davidson's &quot;Black Canyon Logic&quot; spreadsheet which references the relevant section of the Decree. The peak flow is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir. There are six regions, each having its own linear calculation for the peak flow. First the function determines which region, or level, the forecast fits into, and then calculates using the linear equation associated with that region, the appropriate peak flow target for May of the current year. - sc 12/22/10";
    BEGIN

      WITH STRING forecastLevel = FOR ( STRING level IN { "Level 6" , "Level 5" , "Level 4" , "Level 3" , "Level 2" , "Level 1" } ) WITH STRING result = "Level 6" DO
  IF ( $ "BlueMesaData.CanyonFlowCalcData" [level, "Upper Limit"] > currentForecast )
  THEN
   level
  ELSE
   result
  ENDIF
 ENDFOR DO
  ( $ "BlueMesaData.CanyonFlowCalcData" [forecastLevel, "Parameter A"] * ( currentForecast / 1000.00000000 "acre-feet" ) + $ "BlueMesaData.CanyonFlowCalcData" [forecastLevel, "Parameter B"] ) * 1.00000000 "cfs"
 ENDWITH;

    END;

    FUNCTION       "CalcGunnisonWWPeakFlowTarget" ( NUMERIC HClass, NUMERIC currentForecast )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: The one-day peak flow target at the Whitewater gage is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir BlueMesaInflow.Unregulated. The target is determine based a linear equation divided into six regions corresponding to the different hydrologic year types. The coefficients are stored in BlueMesaData.PeakFlowCalcData and come from the 2012 ROD Figure 1 and Table 1.<br><br>RETURNS: One-day peak flow target for the Whitewater gage.<br><br>ARGUMENTS: <br>1. NUMERIC HClass - current hydrologic year classification based on the current Apr-Jul forecast for Blue Mesa unregulated inflow<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: SC, 12/22/2010<br><br>CF, 20170505: The function was modified to take currentForecast and HClass as arguments. - CF 5/5/17<br><br>MC, 20161103: I think this calculation is actually for the Whitewater Gage, not the Black Canyon. The parameters in BlueMesaData.PeakFlowCalcData are consistent with those from the ROD referenced in the document BlueMesaOpsOutline_2015.docx<br><br>This function returns the one-day peak flow target for the Black Canyon portion of the Gunnison River.  The calculation is taken from Paul Davidson's &quot;Black Canyon Logic&quot; spreadsheet which references the releavant section of the Decree.  The peak flow is a function of the official April-July forecast for unregulated inflow to Blue Mesa Reservoir.  There are six regions, each having its own linear calculation for the peak flow.  First the function determines which region, or level, the forecast fits into, and then calculates using the linear equation associated with that region, the appropriate peak flow target for May of the current year. - sc 12/22/10";
    BEGIN

      $ "BlueMesaData.PeakFlowCalcData" [HClass, "Parameter A"] * ( currentForecast / 1000.00000000 "acre-feet" ) + $ "BlueMesaData.PeakFlowCalcData" [HClass, "Parameter B"];

    END;

    FUNCTION       "CalcGunnisonHClass" ( NUMERIC currentForecast )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: Calculates the Hydrologic Year classification which is a value between 0 (Dry) and 5 (Wet) that is based on Figure 1 and Table 1 of the 2012 ROD for the Aspinall Unit.  Values are stored in BlueMesaData.PeakFlowCalcData. <br><br>RETURNS: Numeric peak flow level 0-5/hydrologic year type [No Units]<br><br>ARGUMENTS:<br>1. NUMERIC currentForecast - current Blue Mesa forecasted unregulated inflow<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: CF, 20170505<br><br>CF, 20170505: The function was modified to take currentForecast as an argument. The name of this function was updated. - CF 5/5/17";
    BEGIN

      FOR ( NUMERIC HClass IN { 0.00000000 , 1.00000000 , 2.00000000 , 3.00000000 , 4.00000000 , 5.00000000 } ) WITH NUMERIC result = 0.00000000 DO
  IF ( currentForecast > $ "BlueMesaData.PeakFlowCalcData" [HClass, "Lower Limit"] )
  THEN
   HClass
  ELSE
   result
  ENDIF
 ENDFOR;

    END;

  END;

  UTILITY_GROUP "Vallecito Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "VallecitoMinReleaseConstraint" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and returns the minimum release permitted on that date from Vallecito Reservoir.  Currently it is just the &quot;MinFlow&quot; slot on the VallecitoData object.  It is expected that this function will get more detail as the development of the model continues and may have unique calculations for each month of the year. - sc 12/16/10<br><br>RETURNS: Minimum release rate [L^3/T]<br><br>ARGUMENTS:<br>1. DATETIME date - date which is currently irrelevant to function<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: Remove function as unnecessary?";
    BEGIN

      $ "VallecitoData.MinFlow" [];

    END;

    FUNCTION       "VallecitoMaxReleaseConstraint" ( DATETIME date, NUMERIC prevElev )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function takes a datetime and a previous elevation value and returns the maximum allowable release from Vallecito Reservoir on that date.  Currently it is calculated as the appropriate value on the &quot;Max Release&quot; table of the reservoir.  It is expected that this function will get more detailed as the model is developed and will likely have unique calculations for each month of the year.  - sc 12/17/10<br><br>RETURNS: Maximum release rate [L^3/T]<br><br>ARGUMENTS: <br>1. DATETIME date - date specifying timestep for which max release is desired<br>2. NUMERIC  prevElev - pool elevation at end of previous timestep<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "TableInterpolation"( $ "Vallecito.Max Release", 0.00000000, 1.00000000, prevElev, @"t" );

    END;

  END;

  UTILITY_GROUP "Flood Control Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AvailableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the available storage in a reservoir as the difference between the live capacity of the reservoir and the storage value at the end of the previous timestep<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the available space is desired<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: The upstream UC reservoirs use this same calculation in the rule Set Forecast Data, but do not call the function";
    BEGIN

      "GetLiveCapacity"( reservoir ) - reservoir & "Storage" [@"t - 1"];

    END;

    FUNCTION       "ComputeMinimumSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the space available in &quot;reservoir&quot; given the minimum required space<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the space is desired (see Development Notes)<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170518: As of now, the only reservoir with data in the MeadFloodControlData.MinSpace slot (which is referenced by the GetMinimumSpace function) is Mead, so the only successful call to this function will be with reservoir as &quot;Mead&quot;";
    BEGIN

      "GetLiveCapacity"( reservoir ) - "GetMininumSpace"( reservoir );

    END;

    FUNCTION       "ComputeTargetStorageRelease" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "DESCRIPTION: This function calculates the outflow required to reach the target elevation specified by the SpaceBuilding function with an upper bound of the maximum space building release (28,000 cfs).<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: 0 acre-feet/month (minimum), MeadFloodControlData.MaxRelease (maximum)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170518: The function ComputeOutflowAtGivenStorageForSpaceBuilding uses the SolveOutflow function, which includes both Release and Spill; however, the first condition restricts the outflow to the maximum release value; also, the ComputeOutflowAtGivenStorageForSpaceBuilding function does not constrain releases to a MinRelease and MaxRelease like ComputeOutflowAtGivenStorage does<br>MC, 20170518: Instead of using the IF conditional, could add Post-Exec Checks that limit outflow to [0 acre-feet/month, MaxRelease]; or, should the 0 acre-feet actually be a MinRelease value (UBRuleCurveData.ReservoirData slot has a min release value of 3,000 cfs for Mead)";
    BEGIN

      IF ( ( "ComputeOutflowAtGivenStorageForSpaceBuilding"( % "Mead", "SpaceBuilding"(  ) ) > $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000] ) COMMENTED_BY "Outflow to reach target > Max flood control release, use Max flood control release" )
 THEN
  $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000]
 ELSE
  "Max"( "ComputeOutflowAtGivenStorageForSpaceBuilding"( % "Mead", "SpaceBuilding"(  ) ), 0.00000000 "acre-feet/month" ) COMMENTED_BY "Use non-negative release to reach target"
 ENDIF;

    END;

    FUNCTION       "ComputeTargetStorage" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates a target storage volume for Mead based on either the volume calculated by the SpaceBuilding function, or the volume achievable by the MaxRelease outflow<br><br>RETURNS: Storage Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( "ComputeOutflowAtGivenStorage"( % "Mead", "SpaceBuilding"(  ) ) > $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000] )
 THEN
  "ComputeStorageWithGivenOutflow"( % "Mead", $ "MeadFloodControlData.MaxSpaceBuildingRelease" [0.00000000, 0.00000000] )
 ELSE
  "SpaceBuilding"(  )
 ENDIF COMMENTED_BY "If the outflow to reach the SpaceBuilding storage target exceeds the MaxRelease outflow, <br>calculate the storage achieved at the MaxRelease; otherwise use the SpaceBuilding storage";

    END;

    FUNCTION       "CurrentAvailableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the storage space available at the current timestep for the specified reservoir<br><br>RETURNS: Available volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the available space is desired<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "GetLiveCapacity"( reservoir ) - reservoir & "Storage" [];

    END;

    FUNCTION       "FloodControlEvap" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the evaporation incurred during flood control operations using a storage value halfway between the storage at the previous timestep and the live capacity of the reservoir<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir for which the evaporation is calculated<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "StorageToArea"( reservoir, "GetLiveCapacity"( reservoir ) - "AvailableSpace"( reservoir ) / 2.00000000 ) * "SumEvapCoeff"( reservoir );

    END;

    FUNCTION       "DeltaBankStorage" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the total change in bank storage of Mead and Powell that occurs by using the space available in each<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] * ( "AvailableSpace"( % "Mead" ) - $ "MeadFloodControlData.MinSpace" [0.00000000, 0.00000000] ) + $ "Powell.Bank Storage Coefficient" [0.00000000, 0.00000000] * "AvailableSpace"( % "Powell" );

    END;

    FUNCTION       "ForecastMeadInflow" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function computes the inflow forecast through July for Mead for use in the flood control release determination.<br><br>RETURNS: Forecast inflow volume to Mead [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumSlotVolume"( $ "PowellInflow.Unregulated", "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) ) + "SumAllGainsBelowVolume"( % "Powell", @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) + $ "MeadFloodControlData.Forcmax" ["Forcmax", "GetMonthAsString"( @"t" )] - $ "FloodControlOutput.UBEffective" [];

    END;

    FUNCTION       "SouthernNevConsumed" ( LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the total diversion volume requested by SNWP over the date range passed as an argument<br><br>RETURNS: Diversion volume requested [L^3]<br><br>ARGUMENTS:<br>1. LIST dates - a list of dates over which the diversion is summed<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: This function is unnecessary since its functionality can be replaced by using the predefined function SumFlowsToVolume";
    BEGIN

      "SumSlotVolume"( $ "PumpingFromLakeMead:SNWP.Diversion Requested", dates );

    END;

    FUNCTION       "ForecastRunoffSeason " (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the release level required to pass excess inflow from Mead. This level corresponds to the flood control release steps in Table 1 in Exhibit A of the Flood Control Manual and is used in determining Mead flood control releases January 1 - July 31.<br><br>RETURNS: List of lists of the form &lcub;&lcub;Flow, Release level index&rcub;&rcub;<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Non-negative minimum release flow<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170906: Changed ?<=? to ?<? in the Boolean ?(results<1>) < 5.00000? in the WHILE conditional statement";
    BEGIN

      WHILE ( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) ), @"t" ) COMMENTED_BY "Remaining excess volume at current release level as flow rate" > $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] COMMENTED_BY "Currently considered release level" AND ( GET @INDEX 1.00000000 FROM results ) < 5.00000000 ) WITH LIST results = { "Max"( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( 0.00000000 ), @"t" ) COMMENTED_BY "Volume at lowest release level", 0.00000000 "acre-feet/month" ) , 0.00000000 } DO
  IF ( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 ), @"t" ) COMMENTED_BY "Remaining excess volume at next higher release level as flow rate" <= $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] COMMENTED_BY "Currently considered release level" )
  THEN
   INSERT $ "MeadFloodControlData.Levels" [0.00000000, ( GET @INDEX 1.00000000 FROM results )] INTO INSERT ( ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 ) * "DebuggerStop"(  ) INTO results
  ELSE
   INSERT "Max"( "VolumeToFlow"( "ComputeMinMeadFloodRelease"( ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 ), @"t" ), 0.00000000 "acre-feet/month" ) INTO INSERT ( GET @INDEX 1.00000000 FROM results ) + 1.00000000 INTO results
  ENDIF
 ENDWHILE;

    END;

    FUNCTION       "ComputeMinMeadFloodRelease" ( NUMERIC index )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the difference between the Mead inflow volume in excess of the available space in Mead and Powell and the volume released between the next timestep and the end of July of the current year at the release level specified by the input argument &quot;index&quot;<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. NUMERIC index - index that specifies a release level for Mead<br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "FloodControlOutput.Withoutrel" [] - "FloodControlLevelVolume"( "GetMonthlyDatelist"( @"t + 1", @"24:00:00 July Max DayOfMonth, Current Year" ), index );

    END;

    FUNCTION       "FloodControlLevelVolume" ( LIST dateList, NUMERIC index )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates the volume released from Mead at the release level specified by the input argument &quot;index&quot;<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. LIST dateList - list of dates over which the release volume should be calculated<br>2. NUMERIC index - index specifying a release level<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( DATETIME date IN dateList ) WITH NUMERIC result = 0.00000000 "acre-feet" DO
  result + "FlowToVolume"( $ "MeadFloodControlData.Levels" [0.00000000, index], date )
 ENDFOR;

    END;

    FUNCTION       "ComputeDeltaTargetStorage" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function computes the difference between the previous timestep's storage and the target storage at the current timestep for the Lower Basin reservoir specified as an input argument<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - LB reservoir for which storage difference is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "GetTargetStorage"( reservoir, @"t" ) - reservoir & "Storage" [@"t - 1"];

    END;

    FUNCTION       "UBCreditableSpace" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function sums the space available in upper basin reservoirs for flood control, up to the maximum creditable space, for Powell, Flaming Gorge (including Fontenelle), Navajo, and Blue Mesa. The maximum creditable space for each reservoir is specified in the Hoover Flood Control Manual for the space building months of August through December.<br><br>RETURNS: Available UB storage [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS:<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( OBJECT reservoir IN "ListSubbasin"( "UBFloodControlReservoirs" ) ) WITH NUMERIC sum = 0.00000000 "acre-feet" DO
  IF ( ( STRINGIFY reservoir ) == "FlamingGorge" )
  THEN
   sum + "Min"( "CurrentAvailableSpace"( % "FlamingGorge" ) + "CurrentAvailableSpace"( % "Fontenelle" ), "GetMaxCreditableSpace"( % "FlamingGorge" ) )
  ELSE
   sum + "Min"( "CurrentAvailableSpace"( reservoir ), "GetMaxCreditableSpace"( reservoir ) )
  ENDIF
 ENDFOR;

    END;

    FUNCTION       "SpaceBuilding" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function is used to determine if space building releases from Hoover are necessary. It compares the minimum required available flood control storage space at a given month (using the SystemSpace function and the MeadFloodControlData.Space table) to the available space in Mead plus the creditable space in upper basin reservoirs. If there is not sufficient flood control space available, it computes the target storage required to create the minimum flood control space in Mead, and returns that storage target.<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( ( "CurrentAvailableSpace"( % "Mead" ) + "UBCreditableSpace"(  ) > "SystemSpace"(  ) ) COMMENTED_BY "Current Mead space + UB space > Required space for current month" )
 THEN
  "ComputeMinimumSpace"( % "Mead" ) COMMENTED_BY "Calculate max space available in Mead"
 ELSE
  ( "GetLiveCapacity"( % "Mead" ) - "SystemSpace"(  ) + "UBCreditableSpace"(  ) ) COMMENTED_BY "Calculate max space available in Mead + UB"
 ENDIF;

    END;

    FUNCTION       "SumEvapCoeff" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the sum of all the evaporation coefficients for the specified reservoir until July. During the sum, the coefficient values are adjusted to deal with the unit conversion issue between the current month and the months for which the values were entered, and converted into 31 day months. <br><br>RETURNS: Evaporation depth [L]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - the reservoir whose coefficients are to be summed<br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: Powell uses the Periodic Net evaporation method, and does not have a slot named &quot;Evaporation Coefficients&quot;.  For that reason, I'm doubtful this function has been called since that method has been in use, as it seems likely the function would fail.";
    BEGIN

      FOR ( DATETIME date IN "GetMonthlyDatelist"( @"t", @"24:00:00 July Max DayOfMonth, Current Year" ) ) WITH NUMERIC result = 0.00000000 "ft" DO
  result + reservoir & "Evaporation Coefficients" ["GetMonth"( date ) - 1.00000000, 0.00000000] * 1.00000000 "month"
 ENDFOR;

    END;

  END;

  UTILITY_GROUP "24 Month General Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AcreFeetPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170504: Disabled this function because there are no calls to it in the current rule set";
    BEGIN

      value;

    END;

    FUNCTION       "SlotToString" ( OBJECT obj )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function retrieves a list of slots from a data object by using the GetSeriesSlots predefined function and then converts the list of slots into a list of strings of the slot names.<br><br>RETURNS: List of strings<br><br>ARGUMENTS:<br>1. OBJECT obj - object for which the slot names are desired<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      MAPLIST ( SLOT slotname IN "GetSeriesSlots"( obj ) ) DO
  "GetSlotName"( slotname )
 ENDMAPLIST;

    END;

    FUNCTION       "AcreFeetPerMonthPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[acre-feet/month]";
    DESCRIPTION    "<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170504: This function is only used in DebuggingRule, which I turned off, so I turned this function off also";
    BEGIN

      value;

    END;

    FUNCTION       "CFSPrint" ( NUMERIC value )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "[cfs]";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170504: No calls to this function so I turned it off";
    BEGIN

      value;

    END;

    FUNCTION       "CheckResPhysicalConstraint" ( OBJECT res, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the total water available as a flow rate by converting the previous storage volume into a flow rate, adding the inflows for the date specified, and subtracting a fixed flow rate (50,000 acre-ft/month)<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir to check<br>2. DATETIME date - date on which to check the reservoir<br><br>CONSTRAINTS: <NONE>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: Is there a basis for the fixed 50,000 acre-ft/month, and if so, what is it? Move this value to a slot?";
    BEGIN

      WITH DATETIME dateBefore = "OffsetDate"( date, - 1.00000000, "1 months" ) DO
  "VolumeToFlow"( res & "Storage" [dateBefore], date ) + res & "Inflow" [date] - 50000.00000000 "acre-ft/month"
 ENDWITH;

    END;

    FUNCTION       "GetMonthlyDatelist" ( DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: makes a monthly datelist from the startDate month to the endDate month.<br><br>RETURNS: List of form &lcub;Month&rcub; [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME startDate - beginning period for which to generate list<br>2. DATETIME endDate - ending of period for which to generate list<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170504: Calls to this function use current or next timestep and end of July in current year as startDate and endDate, so implicit assumption those arguments are end of month dates? I think all of the calls to the function use t or t+1 as startDate and July 31, Current Year as endDate, so okay now but not robust.";
    BEGIN

      IF ( startDate >= endDate )
 THEN
  { endDate }
 ELSE
  WHILE ( ( GET @INDEX 0.00000000 FROM dateList ) > startDate ) WITH LIST dateList = { endDate } DO
   INSERT ( GET @INDEX 0.00000000 FROM dateList ) - "GetDaysInMonth"( ( GET @INDEX 0.00000000 FROM dateList ) - 1.00000000 "day" ) INTO dateList
  ENDWHILE
 ENDIF;

    END;

    FUNCTION       "SumGainsBelow" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "MC, 20170530: This function has no calls to it in the current ruleset, so I turned it off. Note this version differs from SumGainsBelowVolume and SumAllGainsBelowVolume because it only sums slots with Input values.";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "INPUT", FALSE, @"t", @"t" );

    END;

    FUNCTION       "SumGainsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumObjectsAggregatedOverTime to calculate the sum of the local inflows downstream of the reservoir specified as an input argument between the dates specified as input arguments<br><br>RETURNS: Volume of local inflows (the TRUE option in the call to SumObjectsAggregatedOverTime converts FLOW to VOLUME)<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir object for which local inflow total is desired<br>2. DATETIME startDate - beginning date for sum<br>3. DATETIME endDate - end date for sum<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: This function is the same as SumAllGainsBelowVolume, so I changed all references to this function to call that function, and turned this function off.";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "ALL", TRUE, startDate, endDate );

    END;

    FUNCTION       "SumAllGainsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumObjectsAggregatedOverTime to calculate the sum of the local inflows downstream of the reservoir specified as an input argument between the dates specified as input arguments<br><br>RETURNS: Volume of local inflows (the TRUE option in the call to SumObjectsAggregatedOverTime converts FLOW to VOLUME) [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir object for which local inflow total is desired<br>2. DATETIME startDate - beginning date for sum<br>3. DATETIME endDate - end date for sum<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: This function is the same as the user-defined function SumGainsBelowVolume. I changed all calls to that function to call thist function and turned that one off.";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Local Inflow", "SUM", "ALL", TRUE, startDate, endDate );

    END;

    FUNCTION       "SumDiversionsBelow" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "MC, 20170530: This function is the same as SumDiversionsBelowVolume except that this version does not convert the aggregated flow rates to Volume; there are no calls to this function in the current ruleset, so I turned it off.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "INPUT", FALSE, @"t", @"t" );

    END;

    FUNCTION       "SumDiversionsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "MC, 20170530: This function is the same as SumAllDiversionsBelowVolume except this version aggregates only slots with Input values. There are no calls to this function in the current ruleset, so I turned it off.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "INPUT", TRUE, startDate, endDate );

    END;

    FUNCTION       "SumAllDiversionsBelowVolume" ( OBJECT reservoir, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumObjectsAggregatedOverTime to calculate the sum of the diversion requests downstream of the reservoir specified as an input argument between the dates specified as input arguments<br><br>RETURNS: Volume of diversion requests (the TRUE option in the call to SumObjectsAggregatedOverTime converts FLOW to VOLUME) [L^3]<br><br>ARGUMENTS:<br>1. OBJECT reservoir - reservoir object for which diversion total is desired<br>2. DATETIME startDate - beginning date for sum<br>3. DATETIME endDate - end date for sum<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SumObjectsAggregatedOverTime"( "Below" CONCAT STRINGIFY reservoir, "Total Diversion Requested", "SUM", "ALL", TRUE, startDate, endDate );

    END;

    FUNCTION       "SumSlotVolume" ( SLOT slot, LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: Given a slot (FLOW units) and a list of dates as arguments, returns the volume sum of the slot over the dates<br><br>RETURNS: Volume sum of slots flow values for dates specified [L^3]<br><br>ARGUMENTS:<br>1. SLOT slot - the slot whose values are to be summed<br>2. LIST dates - the dates to be included in the sum<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170517: Replace calls to this function with the predefined function SumFlowsToVolume?";
    BEGIN

      FOR ( DATETIME date IN dates ) WITH NUMERIC sum = 0.00000000 "acre-feet" DO
  sum + "FlowToVolume"( slot [date], date )
 ENDFOR;

    END;

    FUNCTION       "Compute Head as a Function of Turbine Release" ( NUMERIC turbineRelease )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the Mohave power head for the current timestep as the difference between the tailwater elevation, as calculated from the tailwater table using the turbineRelease argument, and the average pool elevation over the current timestep, calculated as the sum of the current pool elevation and the previous pool elevation divided by 2<br><br>RETURNS: Turbine head [L]<br><br>ARGUMENTS:<br>1. NUMERIC turbineRelease - dam release through the turbines<br><br>CONSTRAINTS:<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      ( $ "Mohave.Pool Elevation" [] + $ "Mohave.Pool Elevation" [@"t - 1"] ) / 2.00000000 - "TableInterpolation"( $ "Mohave.Tailwater Table", 0.00000000, 1.00000000, turbineRelease, @"t" );

    END;

    FUNCTION       "Annual Volume" ( SLOT slot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function uses the predefined function SumFlowsToVolume to calculate the sum of a given slot over the current calendar year<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<br>1. SLOT slot - the slot for which the annual volume is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: Remove this function and simply call SumFlowsToVolume instead?";
    BEGIN

      "SumFlowsToVolume"( slot, @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" );

    END;

    FUNCTION       "AnnualVolumeSlot" ( SLOT slot )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculate the sum of a given slot over the current calendar year<br><br>RETURNS: Sum of slot values [Slot units]<br><br>ARGUMENTS:<br>1. SLOT slot - the slot to sum<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      "SumSlot"( slot, @"24:00:00 January Max DayOfMonth, Current Year", @"24:00:00 December Max DayOfMonth, Current Year" );

    END;

    FUNCTION       "SumSlotList" ( OBJECT obj )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "This functions starts out with a data object. It gets a list of slots in the object by using the GetSeriesSlots predefined function. It then sums the values of all the slots in the object over the current timestep.<br><br>MC, 20170530: There are no calls to this function in the current ruleset, so I turned it off.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( SLOT slotname IN "GetSeriesSlots"( obj ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
  result + slotname []
 ENDFOR;

    END;

    FUNCTION       "SumSlotListDates" ( OBJECT obj, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This functions sums the values of all the slots on the object passed as an argument for the timestep passed as an argument<br><br>RETURNS: Sum of slot values [L^3]<br><br>ARGUMENTS:<br>1. OBJECT obj - object whose slots are to be summed<br>2. DATETIME date - date on which to calculate the slot sum<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      FOR ( SLOT slotname IN "GetSeriesSlots"( obj ) ) WITH NUMERIC result = 0.00000000 "acre-ft" DO
  result + slotname [date]
 ENDFOR;

    END;

    FUNCTION       "GetLastDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the last day of the year of the model run's last timestep, regardless of the date passed to the function.<br><br>RETURNS: Last day of the year for last year in run [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date that is irrelevant since the function returns the same value regardless of this date<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170530: This function returns the same value no matter what date is passed; replace it with the Dec31ofYear(@&quot;Finish Timestep&quot;) wherever it occurs";
    BEGIN

      IF ( "GetMonth"( date ) > 1.00000000 )
 THEN
  "Dec31ofYear"( @"Finish Timestep" )
 ELSE
  "Dec31ofYear"( @"Finish Timestep" )
 ENDIF;

    END;

    FUNCTION       "GetFirstDate" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is used in rules that set monthly values in outyears. If the start timestep is December, we want the rule to skip the 1st 2 timesteps and set values Feb - Dec (11 total), otherwise set values Jan-Dec (12 total). <br><br>RETURNS: Last date in January or February of the current year [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date used to determine whether the returned date represents January or February<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( date == @"Start Timestep + 1" )
 THEN
  @"24:00:00 February Max DayOfMonth, Current Year"
 ELSE
  @"24:00:00 January Max DayOfMonth, Current Year"
 ENDIF;

    END;

    FUNCTION       "GetDaysBasedOnFirstDate" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function is used in rules that set monthly values in outyears. If the start timestep is December, we want the rule to skip the 1st two timesteps and set values Feb - Dec (11 total), otherwise set values Jan-Dec (12 total). <br><br>RETURNS: the number of months to divide an annual volume into [NONE]<br><br>ARGUMENTS: <br>1. DATETIME date - date used to determine the number of months<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown <br>MC, 20170530: 1.) Replaced @&quot;t&quot; by date because both rules calling this function pass @&quot;t&quot; as date; 2.) Changed the original misleading name GetDaysBasedOnFirstDate to current name because the function is actually calculating a number of months, not days (reverted back for consistency with CRSS?)";
    BEGIN

      IF ( date == @"Start Timestep" )
 THEN
  12.00000000 - "GetMonth"( @"t" )
 ELSE
  12.00000000
 ENDIF;

    END;

    FUNCTION       "Dec31ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Determines the day of the year for December 31 making corrections for leap years if necessary. -CE 6/11/13<br><br>RETURNS: December 31 of the year of the date specified [DATETIME]<br><br>ARGUMENTS:<br>1. DATETIME date - date that specifies the year for which Dec 31 is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170531: (Possible rewrite) CompletePartialDate(@&quot;December 31&quot;, date)";
    BEGIN

      IF ( "LeapYear"( date ) )
 THEN
  "OffsetDate"( date, "Units NONE"( 366.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ELSE
  "OffsetDate"( date, "Units NONE"( 365.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ENDIF;

    END;

    FUNCTION       "PartialToFull" ( DATETIME MonthDay )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Returns a fully-specified datetime in the current year of the partially-specified datetime in the input parameter MonthDay<br><br>RETURNS: A full datetime expression [DATETIME]<br><br>ARGUMENTS: <br>1. DATETIME MonthDay - a partially-specified datetime representing a month and day<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown <br>MC, 20160915: Replace calls with calls to predefined function CompletePartialDate (cf. Annual Daily Black Canyon Flow Determination)? ";
    BEGIN

      WHILE ( result < MonthDay ) WITH DATETIME result = @"24:00:00 January 1, Current Year" DO
  result + 1.00000000 "day"
 ENDWHILE;

    END;

    FUNCTION       "Units NONE" ( NUMERIC number )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Removes the &quot;day&quot; units from a value. - CE 6/11/13<br><br>RETURNS: Number without units [NONE]<br><br>ARGUMENTS:<br>1. NUMERIC number - a number with units of &quot;days&quot;<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      number / 1.00000000 "day";

    END;

  END;

  UTILITY_GROUP "Rule Curve Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "ComputeOutflowAtGivenStorage" ( OBJECT reservoir, NUMERIC storage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: Uses the predefined function SolveOutflow to calculate the outflow value that leads to the final storage value provided in the input parameter &quot;storage&quot; bound by Mead min and max releases defined in the UBRuleCurveData object.<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir object for which the outflow value is desired<br>2. NUMERIC storage - the end of timestep storage target<br><br>CONSTRAINTS: Minimum and maximum releases as stored on UBRuleCurveData.ReservoirData<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT "GetMinRelease"( reservoir );
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20160915 - the ComputeOutflowAtGivenStorageForSpaceBuilding user-defined function uses the same calculation but does not contain the Min and Max Release constraints that are in this function";
    BEGIN

      "SolveOutflow"( reservoir, reservoir & "Inflow" [@"t"], storage, reservoir & "Storage" [@"t - 1"], @"t" );

    END;

    FUNCTION       "ComputeOutflowAtGivenStorageForSpaceBuilding" ( OBJECT reservoir, NUMERIC storage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet/month";
    DESCRIPTION    "DESCRIPTION: Uses the predefined function SolveOutflow to calculate the outflow value that leads to the final storage value provided as the input parameter &quot;storage&quot; without outflow constraints<br><br>RETURNS: Outflow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir object for which the outflow value is desired<br>2. NUMERIC storage - the end of timestep storage target<br><br>CONSTRAINTS:";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20160915: the ComputeOutflowAtGivenStorage user-defined function uses the same calculation but contains Post-Exec Checks that constrain the outflow to Min and Max Release values; remove this one?";
    BEGIN

      "SolveOutflow"( reservoir, reservoir & "Inflow" [], storage, reservoir & "Storage" [@"t - 1"], @"t" );

    END;

    FUNCTION       "ComputeStorageWithGivenOutflow" ( OBJECT reservoir, NUMERIC outflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Uses the predefined function SolveStorage to calculate the end of timestep storage using the provided outflow value, subject to minimum and maximum storage values from the GetInactiveCapacity and GetLiveCapacity user-defined functions<br><br>RETURNS: Storage volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir object for which the storage is desired<br>2. NUMERIC outflow - the outflow value used to achieve the end of timestep storage value<br><br>CONSTRAINTS: Inactive (min) and Live (max) capacities of reservoir<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    MIN_CONSTRAINT "GetInactiveCapacity"( reservoir );
    MAX_CONSTRAINT "GetLiveCapacity"( reservoir );
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "SolveStorage"( reservoir, reservoir & "Inflow" [], outflow, reservoir & "Storage" [@"t - 1"], @"t" );

    END;

  END;

  UTILITY_GROUP "Get Data Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetMaxRelease" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function returns the maxRelease value from the UBRuleCurveData data object for the reservoir specified<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the maximum release is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "maxRelease"];

    END;

    FUNCTION       "GetMinRelease" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "DESCRIPTION: This function returns the minRelease value from the UBRuleCurveData data object for the reservoir specified<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the minimum release is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "minRelease"];

    END;

    FUNCTION       "GetMininumSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the Min Space value from the MeadFloodControlData data object for the reservoir specified<br><br>RETURNS: Volume [L^3]<br><br>CONSTRAINTS: <NONE><br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the minimum space is desired (originally only Mead value specified in data object)<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "MeadFloodControlData.MinSpace" [STRINGIFY reservoir, "Min Space"];

    END;

    FUNCTION       "GetMaxCreditableSpace" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the maximum creditable space from the MeadFloodControlData.CredSpace table for the specified upper basin reservoir. This represents the maximum space that can be credited to available flood control space in the system for that reservoir.<br><br>RETURNS: Volume [L^3]<br><br>CONSTRAINTS: <NONE><br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the creditable space is desired<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "MeadFloodControlData.CredSpace" ["Credit. Space", STRINGIFY reservoir];

    END;

    FUNCTION       "GetInactiveCapacity" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the value from the inactiveCapacityStorage column of the slot UBRuleCurveData.ReservoirData for the reservoir specified<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the inactive capacity storage is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "inactiveCapacityStorage"];

    END;

    FUNCTION       "GetLiveCapacity" ( OBJECT reservoir )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the value from the liveCapacityStorage column of the slot UBRuleCurveData.ReservoirData for the reservoir specified<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - the reservoir for which the live capacity storage is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "UBRuleCurveData.ReservoirData" [STRINGIFY reservoir, "liveCapacityStorage"];

    END;

    FUNCTION       "GetTargetStorage" ( OBJECT reservoir, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the value from the slot for Target Storage on the LBRuleCurveData data object for the reservoir and date specified<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. OBJECT reservoir - reservoir for which Target Storage is desired<br>2. DATETIME date - date for which Target Storage is desired<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "LBRuleCurveData." CONCAT ( STRINGIFY reservoir ) CONCAT " Target Storage" [date];

    END;

    FUNCTION       "SystemSpace" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function returns the space required in Mead for the current timestep from the MeadFloodControlData.Space slot<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      $ "MeadFloodControlData.Space" [0.00000000, "GetMonthAsString"( @"t" )];

    END;

    FUNCTION       "GetEndDayOfMonth" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns the last day of the current month<br><br>RETURNS: Datetime<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: See Development Notes on function MaxDayOfMonth";
    BEGIN

      @"24:00:00 Current Month Max DayOfMonth, Current Year";

    END;

    FUNCTION       "GetStartDayOfMonth" (  )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates and returns the first day of the current month<br><br>RETURNS: First day of current month [Datetime]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170522: See Development Notes on function MinDayOfMonth";
    BEGIN

      @"24:00:00 Current Month Min DayOfMonth, Current Year";

    END;

  END;

  UTILITY_GROUP "Shortage Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "GetShortageElevationString" ( NUMERIC indextier )
    RETURN_TYPE    STRING;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function returns, as a string, the lower limit of the Mead pool elevation value for the shortage tier specified in the input argument<br><br>RETURNS: Pool elevation value as a string [NONE] <br><br>ARGUMENTS: <br>1. NUMERIC indextier - numeric indicator of Lower Basin shortage level<br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      IF ( indextier == 0.00000000 )
 THEN
  "1075"
 ELSE
  IF ( indextier == 1.00000000 )
  THEN
   "1050"
  ELSE
   "1025"
  ENDIF
 ENDIF;

    END;

    FUNCTION       "Arizona Shortage Depletion" ( STRING user, NUMERIC indextier, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function calculates the specified AZ user's depletion allowed under a Shortage condition<br><br>RETURNS: Flow rate [L^3/T]<br><br>ARGUMENTS: <br>1. STRING user - specifies the user for which the shortage depletion is desired<br>2. NUMERIC indextier - specifies the index of the shortage tier<br>3. DATETIME date - specifies the date for which the depletion is desired<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR,DATE: Unknown";
    BEGIN

      WITH STRING short_elev = "GetShortageElevationString"( indextier ) DO
  "VolumeToFlow"( % "Arizona_CU_Schedules" & user [date] - "GetObject"( ( "Arizona_Shortage" CONCAT short_elev ) CONCAT "_Schedules" ) & user ["Dec31ofYear"( date )] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"], date )
 ENDWITH;

    END;

    FUNCTION       "CAP Shortage Depletion" ( NUMERIC indextier, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculate the monthly forecast CAP diversion under Shortage condition<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <br>1. NUMERIC indextier - Shortage tier<br>2. DATETIME date - date for which to calculate the monthly volume<br><br>CONSTRAINTS: Minimum of 0.00 acre-feet/month<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "Max"( "VolumeToFlow"( $ "ForecastUse.CAPResetAnnualFC" [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"] - "GetAnnualCAPShortage"( indextier ) * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"], date ), 0.00000000 "acre-ft/month" );

    END;

    FUNCTION       "GetAnnualCAPShortage" ( NUMERIC indextier )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: The annual CAP shortage amount is the Arizona shortage amount minus the sum of the non-CAP shortage amounts<br><br>RETURNS: Shortage volume for CAP [L^3]<br><br>ARGUMENTS: <br>1. NUMERIC indextier - the index for a Lower Basin shortage tier<br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown ";
    BEGIN

      WITH STRING short_elev = "GetShortageElevationString"( indextier ) DO
  $ "Shortage.State Shortage Volumes" [indextier, "Arizona"] - "SumSlotListDates"( "GetObject"( ( "Arizona_Shortage" CONCAT short_elev ) CONCAT "_Schedules" ), @"24:00:00 December 31, Current Year" )
 ENDWITH;

    END;

  END;

  UTILITY_GROUP "Surplus Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "SumPreviousYearICScredits" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: Calculates the Lower Basin states' total cumulative ICS credits for the previous calendar year. Created as part of the Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: <NONE><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR,DATE: HMG, 8/2/2011";
    BEGIN

      $ "ICS Credits.TotalICS_AZ" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.TotalICS_CA" [@"24:00:00 December 31, Previous Year"] + $ "ICS Credits.TotalICS_NV" [@"24:00:00 December 31, Previous Year"];

    END;

    FUNCTION       "Normal_LBDemands - Include Mexico" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates Lower Basin water use under Normal Conditions by summing diversion requests, including for Mexico. Created as part of the Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Maximum value of 7.5 MAF<br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/2011<br>MC, 20170522: &quot;Annual Volume&quot; is just a call to SumFlowsToVolume; replace with those calls?";
    BEGIN

      "Min"( 7500000.00000000 "acre-ft" + "Annual Volume"( $ "MexicanTreatyDelivery.Total Diversion Requested" ), "Annual Volume"( $ "PumpingFromLakeMead.Total Diversion Requested" ) + "Annual Volume"( $ "OthersMeadToMohave.Total Diversion Requested" ) + "Annual Volume"( $ "NvDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "CaDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "AzDvsToPkr.Total Diversion Requested" ) + "Annual Volume"( $ "FtMohaveIndRes.Total Diversion Requested" ) + "Annual Volume"( $ "MWDDiversion.Total Diversion Requested" ) + "Annual Volume"( $ "CAPDiversion.Total Diversion Requested" ) + "Annual Volume"( $ "PaloVerde.Total Diversion Requested" ) + "Annual Volume"( $ "CRIR.Total Diversion Requested" ) + "Annual Volume"( $ "CaPkrToImp.Total Diversion Requested" ) + "Annual Volume"( $ "AzPkrToImp.Total Diversion Requested" ) + "Annual Volume"( $ "AAC.Total Diversion Requested" ) + "Annual Volume"( $ "GilaGravityMainCanal.Total Diversion Requested" ) + "Annual Volume"( $ "GilaAndYumaUsers.Total Diversion Requested" ) + "Annual Volume"( $ "MexicanTreatyDelivery.Total Diversion Requested" ) + "Annual Volume"( $ "OthersBlwImp.Total Diversion Requested" ) );

    END;

    FUNCTION       "CalcQuantifiedSurplusVolume" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the non-negative volume of Quantified Surplus for the current calendar year<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Minimum of 0 acre-feet<br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "<br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>";
    BEGIN

      "Max"( ( $ "Powell.Storage" [@"t - 1"] + $ "Mead.Storage" [@"t - 1"] - $ "Surplus.MaxStorage" [] - ( "SumPreviousYearICScredits"(  ) + $ "Mexico Shortage and Surplus.ICMA Balance" [@"24:00:00 December 31, Previous Year"] ) COMMENTED_BY "Previous year ICS credits" ) * ( 1.00000000 + ( ( $ "Powell.Bank Storage Coefficient" [0.00000000, 0.00000000] + $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) / 2.00000000 ) COMMENTED_BY "Avg Bank Storage Coefficient" ) + $ "Surplus.70RLeesFerryFlow" [] COMMENTED_BY "70th percentile non-exceedance flow" - ( $ "Surplus.UBEvaporation" [] + $ "Surplus.UBDemand" [@"24:00:00 December 31, Current Year"] ) - "SumLBDemands - Include Mexico"(  ), 0.00000000 "acre-ft" );

    END;

    FUNCTION       "QuantifiedSurplusVolume" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates the non-negative volume of Quantified Surplus for the current calendar year<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS: <NONE><br><br>CONSTRAINTS: Minimum of 0 acre-feet<br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    BEGIN

      "Max"( ( $ "Powell.Storage" [@"t - 1"] + $ "Mead.Storage" [@"t - 1"] - $ "Surplus.MaxStorage" [] - ( "SumPreviousYearICScredits"(  ) + $ "Mexico Shortage and Surplus.ICMA Balance" [@"24:00:00 December 31, Previous Year"] ) ) * ( 1.00000000 + ( $ "Powell.Bank Storage Coefficient" [0.00000000, 0.00000000] + $ "Mead.Bank Storage Coefficient" [0.00000000, 0.00000000] ) / 2.00000000 ) + $ "Surplus.70RLeesFerryFlow" [] COMMENTED_BY "70th percentile non-exceedance <br>flow" - ( $ "Surplus.UBEvaporation" [] + $ "Surplus.UBDemand" [@"24:00:00 December 31, Current Year"] ) - "SumLBDemands - Include Mexico"(  ), 0.00000000 "acre-ft" );

    END;

    FUNCTION       "SumLBDemands - Include Mexico" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "DESCRIPTION: Calculates the Lower Basin demands as defined in the Interim Guidelines ROD. Created as part of the Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Volume [L^3]<br><br>ARGUMENTS:<NONE><br><br>CONSTRAINTS: <NONE><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR, DATE: HMG, 8/2/2011";
    BEGIN

      "Normal_LBDemands - Include Mexico"(  ) + ( $ "Surplus.Average Annual Evaporation" [0.00000000, "Mead"] + $ "Surplus.Average Annual Evaporation" [0.00000000, "Mohave"] + $ "Surplus.Average Annual Evaporation" [0.00000000, "Havasu"] ) - ( "SumAllGainsBelowVolume"( % "Powell", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + "SumAllGainsBelowVolume"( % "Mead", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) + "SumAllGainsBelowVolume"( % "Havasu", @"24:00:00 January 31, Current Year", @"24:00:00 December 31, Current Year" ) );

    END;

    FUNCTION       "Set Monthly Surplus Schedule" ( DATETIME date, STRING user )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the monthly surplus volume from the annual volume. This function was created as part of the Domestic and Quantified Surplus logic. -HMG 8/2/11<br><br>RETURNS: Monthly surplus volume [L^3]<br><br>ARGUMENTS<br>1. DATETIME date - date to calculate monthly surplus volume<br>2. STRING user - specifies user for which to calculate surplus volume<br><br>CONSTRAINTS: <NONE><br><br><br>";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "DEVELOPMENT NOTES<br>AUTHOR,DATE: HMG, 8/2/2011<br>MC, 20170512: Use of Monthly shortage percents is correct? If so, surplus monthly percentages are taken with the same distribution as shortage";
    BEGIN

      IF ( user == "CAP" )
 THEN
  % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"]
 ELSE
  IF ( user == "SNWA" )
  THEN
   % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"]
  ELSE
   % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Equal"]
  ENDIF
 ENDIF;

    END;

    FUNCTION       "Set Monthly Surplus Schedule- FC" ( DATETIME date, STRING user )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Calculates the monthly Flood Control Surplus volume from the annual volume. This function varies from the &quot;Set Monthly Surplus Schedule&quot; function in that it can be applied to any starting month instead of being limited to January. This is because a Flood Surplus can be declared at any point within the year. Once a Flood Control Surplus is declared it will continue through to the end of the current calendar year.  <br><br>RETURNS: Monthly volume [L^3]<br><br>ARGUMENTS: <br>1. DATETIME date - date used to calculate the monthly volume<br>2. STRING user - user for whom monthly volume is calculated<br><br>CONSTRAINTS: <NONE><br><br>DEVELOPMENT NOTES<br>AUTHOR,DATE: Unknown";
    ACTIVE         TRUE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( user == "CAP" )
 THEN
  % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "CAP"]
 ELSE
  IF ( user == "SNWA" )
  THEN
   % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Average"]
  ELSE
   % "Surplus Total Annual Schedules" & user [@"24:00:00 December 31, Current Year"] * $ "Shortage.MonthlyPercents" ["GetMonthAsString"( date ), "Equal"]
  ENDIF
 ENDIF;

    END;

  END;

  UTILITY_GROUP "Orphan Functions";
  DESCRIPTION   "";
  ACTIVE        TRUE;
  NOTES          "";
  BEGIN

    FUNCTION       "AlreadyUsedWater" ( OBJECT obj, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "SumFlowsToVolume"( obj & "Total Depletion", @"24:00:00 January Max DayOfMonth, Current Year", @"t - 1" );

    END;

    FUNCTION       "AnnualRequestedWater" ( STRING user, STRING type, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "SumFlowsToVolume"( "GetSlot"( user CONCAT ".Total " CONCAT type CONCAT " Requested" ), "OffsetDate"( date, - ( "GetMonth"( date ) - 1.00000000 ) COMMENTED_BY "The number to subtract from date to go to January of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to January of the year found in 'date'", "OffsetDate"( date, ( 12.00000000 - "GetMonth"( date ) ) COMMENTED_BY "The number to add to date to go to December of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to December of year found in 'date'" ) COMMENTED_BY "Calculated annual requested water (either depletion or diversion which is <br>specified by 'type') and expects the user to be on the San Juan River";

    END;

    FUNCTION       "AnticipatedInflowNavajo" ( DATETIME dateToStart, DATETIME dateToProject )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "DESCRIPTION: This function calculates the inflow to Navajo for the entire run period<br><br>RETURN TYPE: NUMERIC<br><br>ARGUMENTS<br>1. DATETIME dateToStart<br>2. DATETIME dateToProject<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: TP 8/07/2012<br>MC, 20170502: I turned this rule off and replaced its 2 references in the ruleset by its body. I'm scheduling it for deletion as unnecessary.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "SumFlowsToVolume"( $ "Navajo.Inflow", dateToStart, dateToProject );

    END;

    FUNCTION       "April30ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the day of the year for April 30 making corrections for leap years if necessary. -CE 6/11/13";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "LeapYear"( date ) )
 THEN
  "OffsetDate"( date, "Units NONE"( 121.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ELSE
  "OffsetDate"( date, "Units NONE"( 120.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ENDIF;

    END;

    FUNCTION       "BlueMesaEOMElevationTarget" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "ft";
    DESCRIPTION    "DESCRIPTION: This function takes a date and returns the end-of-month elevation target for Blue Mesa Reservoir.  It does this by reading the appropriate row from the BlueMesaData.BlueMesaGuide slot.  The only exception is that if the reservoir did not fill in June, then in July the function will return the June entry in the table. - sc 12/28/10<br><br>RETURNS: Pool elevation [L]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the target elevation is needed<br><br>CONSTRAINTS: <NONE><br><br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: No calls to this function so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "June" , "July" } )
 THEN
  IF ( "MaxItem"( "GetSlotVals"( $ "BlueMesa.Pool Elevation", @"t - 2", @"t - 1" ) ) >= $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] )
  THEN
   $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"]
  ELSE
   $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"]
  ENDIF
 ELSE
  $ "BlueMesaData.BlueMesaGuide" [@"t", "Target Elevation"]
 ENDIF;

    END;

    FUNCTION       "BlueMesaReleaseMAXConstraintByMonth" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "DESCRIPTION: This function calculates the maximum constraint (ceiling) for the Blue Mesa release on the passed-in date.  The max constraint will not necessarily be the release, just provide an upper bound for that months release. - sc 12/28/10<br><br>RETURNS: Blue Mesa release ceiling [L^3/T]<br><br>ARGUMENTS:<br>1. DATETIME date - date for which the release ceiling is needed<br><br>CONSTRAINTS: <br><br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown<br>MC, 20170531: May ceiling is unlimited?; no calls to function so disabled it";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "December" , "January" , "February" , "March" , "April" , "August" , "September" , "October" COMMENTED_BY "Move october and november to 2100 limit, per Paul D. - tv 7.26.12" , "November" } )
 THEN
  "Max"( "SolveBlueMesaReleaseForCrystalReleaseTarget"( 2100.00000000 "cfs", @"t" ), "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" COMMENTED_BY "change to 7516.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date ) )
 ELSE
  IF ( "GetMonthAsString"( date ) IN { "June" , "July" } )
  THEN
   "Max"( "SolveBlueMesaReleaseForCrystalReleaseTarget"( 4150.00000000 "cfs" COMMENTED_BY "Max at 4150 cfs, per Paul D. - tv 7.26.12", @"t" ), "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7519.40000000 "ft" COMMENTED_BY "change to 7519.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date ) COMMENTED_BY "Changed from mass balance to SolveOutflow function - tv 7.26.12" )
  ELSE
   9999999.00000000 "cfs"
  ENDIF
 ENDIF;

    END;

    FUNCTION       "BlueMesaReleaseMINConstraintByMonth" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10<br><br>MC, 20170531: No calls to function so disabled it";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC DownstreamFlowBasedConstraint = "BlueMesaReleaseMINConstraint_DownstreamFlow"( @"t" ) DO
  WITH NUMERIC ReservoirElevationBasedConstraint = "BlueMesaReleaseMINConstraint_ResElevation"( @"t" ) DO
   "Min"( "Max"( DownstreamFlowBasedConstraint, ReservoirElevationBasedConstraint ), "SolveOutflow"( % "BlueMesa", $ "BlueMesa.Inflow" [@"t"], "ElevationToStorage"( % "BlueMesa", 7358.01000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), @"t" ) COMMENTED_BY "The maximum that the reservoir can release to the bottom of outlets at 7358 ft. Added 8/1/12 - tv" )
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "BlueMesaReleaseMINConstraint_ResElevation" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      IF ( "GetMonthAsString"( date ) IN { "January" } )
 THEN
  WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
   WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
    WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
     "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.17000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
    ENDWITH
   ENDWITH
  ENDWITH
 ELSE
  IF ( "GetMonthAsString"( date ) IN { "February" } )
  THEN
   WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
    WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
     WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
      "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.15000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
     ENDWITH
    ENDWITH
   ENDWITH
  ELSE
   IF ( "GetMonthAsString"( date ) IN { "March" } )
   THEN
    WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
     WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
      WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
       "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.15000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
      ENDWITH
     ENDWITH
    ENDWITH
   ELSE
    IF ( "GetMonthAsString"( date ) IN { "April" } )
    THEN
     WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
      WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
       WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 June 30, Current Year", "Target Elevation"] ) - MayReleaseVolume DO
        "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.20000000 COMMENTED_BY "Changed this ratio. -tv 8.1.12", date ), date )
       ENDWITH
      ENDWITH
     ENDWITH
    ELSE
     IF ( "GetMonthAsString"( date ) IN { "June" } )
     THEN
      WITH NUMERIC MayReleaseVolume = $ "BlueMesaData.MayReleaseVolume" [@"24:00:00 December 31, Current Year"] DO
       WITH NUMERIC totalInflowVolumeThruJuly = "SumFlowsToVolume"( $ "BlueMesa.Inflow", date, @"24:00:00 July 31, Current Year" ) DO
        WITH NUMERIC RemainingVolumeAfterFill = "PrevStorage"( % "BlueMesa" ) + totalInflowVolumeThruJuly - "ElevationToStorage"( % "BlueMesa", $ "BlueMesaData.BlueMesaGuide" [@"24:00:00 July 31, Current Year", "Target Elevation"] ) DO
         "SolveBlueMesaReleaseForBlackCanyonTarget"( "VolumeToFlow"( RemainingVolumeAfterFill * 0.33000000, date ), date )
        ENDWITH
       ENDWITH
      ENDWITH
     ELSE
      IF ( "GetMonthAsString"( date ) IN { "July" } )
      THEN
       "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7519.40000000 "ft" COMMENTED_BY "Changed to 7519.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
      ELSE
       IF ( "GetMonthAsString"( date ) IN { "August" } )
       THEN
        "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" COMMENTED_BY "Changed to 7516.4 ft, per Paul D. - tv 7.26.12" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
       ELSE
        IF ( "GetMonthAsString"( date ) IN { "September" } )
        THEN
         "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
        ELSE
         IF ( "GetMonthAsString"( date ) IN { "October" } )
         THEN
          "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
         ELSE
          IF ( "GetMonthAsString"( date ) IN { "November" } )
          THEN
           "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
          ELSE
           "SolveOutflow"( % "BlueMesa", % "BlueMesa" & "Inflow" [date], "ElevationToStorage"( % "BlueMesa", 7516.40000000 "ft" ), "ElevationToStorage"( % "BlueMesa", $ "BlueMesa.Pool Elevation" [@"t - 1"] ), date )
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF;

    END;

    FUNCTION       "BlueMesaReleaseMINConstraint_DownstreamFlow" ( DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This function takes a date.  It returns the minimum constraint (floor) for the Blue Mesa release on the passed-in date.  The min constraint will not necessarily be the release, just provide an upper bound for that month's release. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC flowLevel = $ "BlueMesaData.MayPeakFlowLevel" ["Dec31ofYear"( @"24:00:00 April 1, Current Year" )] DO
  IF ( "GetMonthAsString"( date ) IN { "January" } )
  THEN
   "Min"( "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "TunnelReturnFlow.Inflow" [@"t - 1"] ), @"t" ), $ "BlueMesaData.BaseCanyonTargetFlows" [date, flowLevel] )
  ELSE
   IF ( "GetMonthAsString"( date ) IN { "February" } )
   THEN
    "Min"( "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" ), $ "BlueMesaData.BaseCanyonTargetFlows" [date, flowLevel] )
   ELSE
    IF ( "GetMonthAsString"( date ) IN { "March" } )
    THEN
     "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
    ELSE
     IF ( "GetMonthAsString"( date ) IN { "April" } )
     THEN
      "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
     ELSE
      IF ( "GetMonthAsString"( date ) IN { "June" } )
      THEN
       "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "BlueMesaData.BaseCanyonTargetFlows" [date, flowLevel] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [@"t"] ), @"t" )
      ELSE
       IF ( "GetMonthAsString"( date ) IN { "July" } )
       THEN
        "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "BlueMesaData.BaseCanyonTargetFlows" [date, flowLevel] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [@"t"] ), @"t" )
       ELSE
        IF ( "GetMonthAsString"( date ) IN { "August" } )
        THEN
         "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
        ELSE
         IF ( "GetMonthAsString"( date ) IN { "September" } )
         THEN
          "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
         ELSE
          IF ( "GetMonthAsString"( date ) IN { "October" } )
          THEN
           "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
          ELSE
           IF ( "GetMonthAsString"( date ) IN { "November" } )
           THEN
            "SolveBlueMesaReleaseForBlackCanyonTarget"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], @"t" )
           ELSE
            "SolveBlueMesaReleaseForBlackCanyonTarget"( "Max"( $ "BlueMesaData.MinimumBlackCanyonFlow" [@"t"], $ "BlueMesaData.BaseCanyonTargetFlows" [date, flowLevel] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [@"t"] ), @"t" )
           ENDIF
          ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDWITH;

    END;

    FUNCTION       "CalendarYearDatesByGroup" ( NUMERIC inputGroupNumber )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "MC, 20170502: This function is not called in the current ruleset";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH LIST prelimList = FOR ( DATETIME date IN @"Start Timestep + 1" TO @"Finish Timestep" ) WITH LIST result = { { @"Start Timestep" , 1.00000000 } } DO
  WITH NUMERIC groupNumber = GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH result ) - 1.00000000 FROM result DO
   IF ( "GetMonthAsString"( date ) == "October" )
   THEN
    APPEND { date , groupNumber + 1.00000000 } ONTO result
   ELSE
    APPEND { date , groupNumber } ONTO result
   ENDIF
  ENDWITH
 ENDFOR DO
  IF ( ( inputGroupNumber == 3.00000000 AND @"Start Timestep" == @"October 31" ) COMMENTED_BY "If the start month is October then there is no third water year in the run window.  Thus we need this function to be <br>non-empty and return a date that will definitely be outside of the run window. - sc 11/03/11" )
  THEN
   { @"24:00:00 December 31, 1900" }
  ELSE
   FOR ( LIST dateGroupNumber IN prelimList ) WITH LIST result = {  } DO
    IF ( ( GET @INDEX 1.00000000 FROM dateGroupNumber ) == inputGroupNumber )
    THEN
     APPEND GET @INDEX 0.00000000 FROM dateGroupNumber ONTO result
    ELSE
     result
    ENDIF
   ENDFOR
  ENDIF
 ENDWITH;

    END;

    FUNCTION       "EqualizationTeirCalculationForRelease_Orig" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC PowellVolumeOverEqLevel = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) ), 0.00000000 "acre-ft" ) DO
  WITH NUMERIC equalizationReleaseVolume = "EqualizationRelease"( EOWYDate ) DO
   WITH NUMERIC preliminaryReleaseVolume = "Min"( PowellVolumeOverEqLevel + $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )], equalizationReleaseVolume ) DO
    WITH NUMERIC meadElevationWithPrelimRelease = IF ( $ "Mead.Storage" [EOWYDate] + ( preliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) >= "ElevationToStorage"( % "Mead", 1229.00000000 "feet" ) )
    THEN
     1229.00000000 "feet"
    ELSE
     "StorageToElevation"( % "Mead", $ "Mead.Storage" [EOWYDate] + ( preliminaryReleaseVolume - $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] ) )
    ENDIF DO
     IF ( meadElevationWithPrelimRelease < 1105.00000000 "ft" )
     THEN
      WITH NUMERIC totalVolumeToRaiseMeadTo1105 = "Max"( "ElevationToStorage"( % "Mead", 1105.00000000 "ft" ) - $ "Mead.Storage" [EOWYDate], 0.00000000 "acre-ft" ) DO
       WITH NUMERIC PowellVolumeOverEqLevelLess20ft = "Max"( $ "Powell.Storage" [EOWYDate] - "ElevationToStorage"( % "Powell", "EqLevel"( EOWYDate ) - 20.00000000 "ft" ), 0.00000000 "acre-ft" ) DO
        ( "MinItem"( { equalizationReleaseVolume , totalVolumeToRaiseMeadTo1105 , PowellVolumeOverEqLevelLess20ft } ) + 8230.00000000 "1000 acre-feet" ) COMMENTED_BY "Choose the minimum of the equalization release, the release to take Mead to 1105 and the release to take Powell down to the equalization level less 20'"
       ENDWITH COMMENTED_BY "Volume of Powell storage above the equalization level minus 20 feet"
      ENDWITH COMMENTED_BY "Volume needed to release from Powell to raise Mead elevation to 1105'"
     ELSE
      preliminaryReleaseVolume
     ENDIF COMMENTED_BY "Check if the preliminary release volume takes Mead above 1105'.  If so the preliminary volume is chosen, if not continue."
    ENDWITH COMMENTED_BY "EOWY Elevation of Mead with the preliminaryReleaseVolume release from Powell"
   ENDWITH COMMENTED_BY "Preliminary annual volume release before the Mead elevation check."
  ENDWITH COMMENTED_BY "Total volume that would need to be released to equalize storage"
 ENDWITH COMMENTED_BY "Total Volume in Powell above the Current Equalization Level";

    END;

    FUNCTION       "DetermineMonthlyDistribution" ( STRING slot2check, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( "FlowToVolume"( "GetSlot"( slot2check ) [date], date ) / "SumFlowsToVolume"( "GetSlot"( slot2check ), "OffsetDate"( date, - ( "GetMonth"( date ) - 1.00000000 ) COMMENTED_BY "The number to subtract from date to go to January of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to January of the year in date", "OffsetDate"( date, ( 12.00000000 - "GetMonth"( date ) ) COMMENTED_BY "The number to add to date to go to December of the year in Date", "1 MONTHS" ) COMMENTED_BY "Evaluates to December of the year in date" ) ) COMMENTED_BY "Determines the monthly distribution of any slot.  Returns the poriton of demand/flow of <br>the date passed to the function for the slot passed to the function";

    END;

    FUNCTION       "DummyTestFunction" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      0.00000000;

    END;

    FUNCTION       "ECDF" ( LIST Data, NUMERIC num )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns the proportion of values in LIST &quot;Data&quot; that are less than value in &quot;num&quot; - MC, 20160527";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( NUMERIC val IN Data ) WITH NUMERIC result = 0.00000000 DO
  IF ( val <= num )
  THEN
   result + 1.00000000
  ELSE
   result
  ENDIF
 ENDFOR / LENGTH Data;

    END;

    FUNCTION       "EstimateBankStorageChange" ( OBJECT res, NUMERIC startStorage, NUMERIC endStorage, DATETIME startDate, DATETIME endDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-feet";
    DESCRIPTION    "DESCRIPTION: This function calculates an estimate of the change in the bank storage that occurs due to the change in storage from startStorage to endStorage<br><br>RETURNS: Change in bank storage volume [L^3]<br><br>ARGUMENTS:<br>1. OBJECT res - reservoir for which storage change occurs<br>2. NUMERIC startStorage - beginning storage volume<br>3. NUMERIC endStorage - ending storage volume<br>4. DATETIME startDate - date on which startStorage occurs<br>5. DATETIME endDate - date on which endStorage occurs<br><br>CONSTRAINTS: <NONE><br><br>DEVELOPMENT NOTES<br>AUTHOR, DATE: Unknown";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      ( endStorage - "EstimateEvaporation"( res, startStorage, endStorage, startDate, endDate ) - startStorage ) COMMENTED_BY "Available volume to contibute to bank storage" * res & "Bank Storage Coefficient" [0.00000000, 0.00000000] COMMENTED_BY "proportion of volume available for bank storage <br>that actually becomes bank storage";

    END;

    FUNCTION       "EstimateDeltaStorageEOWY" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "RuleCurveStorage"( res, "RelativeEOWYDate"( @"t" ) ) - "PrevStorage"( res );

    END;

    FUNCTION       "EstimateDeltaStorageOND" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "RuleCurveStorage"( res, @"24:00:00 December Max DayOfMonth, Current Year" ) - "RuleCurveStorage"( res, @"24:00:00 October Max DayOfMonth, Current Year" );

    END;

    FUNCTION       "ForecastComputeDemandsBelow" ( OBJECT reservoir, DATETIME month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function computes the inflow to the subbasin below &quot;reservoir&quot; for the timestep &quot;month&quot; required to satisfy all subbasin diversions while meeting minimum flow requirements (see also documentation for predefined function &quot;NetSubBasinDiversionRequirement&quot;)<br><br>RETURNS: NUMERIC<br><br>ARGUMENTS<br>1. OBJECT reservoir - reservoir that defines downstream subbasin<br>2. DATETIME month - timestep for which calculation is made<br><br>CONSTRAINTS: Maximum release flow rate from specified reservoir<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170503: There are no references to this function in the current ruleset, so I am disabling it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    MAX_CONSTRAINT "GetMaxRelease"( reservoir );
    NOTES          "";
    BEGIN

      IF ( month <= "RunEndDate"(  ) )
 THEN
  "Max"( "NetSubBasinDiversionRequirement"( "ListSubbasin"( "Below" CONCAT STRINGIFY reservoir ), month ), 0.00000000 "acre-feet/month" )
 ELSE
  "Max"( "NetSubBasinDiversionRequirement"( "ListSubbasin"( "Below" CONCAT STRINGIFY reservoir ), "GetDate"( "GetMonthAsString"( month ) CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ) ), 0.00000000 "acre-feet/month" )
 ENDIF;

    END;

    FUNCTION       "FutureFontenelleInflow" ( STRING month )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "MC, 20170503: This function has no calls to it in the current ruleset, so it is turned off.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( "MonthlyAverageFlowInModel"( $ "GreenRAboveFontenelle.Inflow", month ) - "SumObjectsAggregatedOverTime"( "UsersAboveCP9", "Total Depletion Requested", "SUM", "ALL", FALSE, "GetDate"( month CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ), "GetDate"( month CONCAT ", " CONCAT GET @INDEX 0.00000000 FROM "Split"( STRINGIFY "GetYear"( "RunEndDate"(  ) ), "." ) ) ) ) COMMENTED_BY "Calculates the future (after the model end date) inflow into Fontenelle based on <br>average natural flow above Fontenelle for the particular month, and the demands <br>above Fontenelle from the last year of the model run.";

    END;

    FUNCTION       "GetMeadPowellElevDiff" ( STRING reservoir, DATETIME eowyDate, STRING elevOrStorage )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "MC, 20170501: This function is not referenced in the ruleset.<br><br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC PowellAnnualVolume = $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( "RelativeEOWYDate"( IF ( @"t" == @"Start Timestep" )
 THEN
  @"t"
 ELSE
  @"t + 2"
 ENDIF ) )] DO
  IF ( reservoir == "Powell" )
  THEN
   IF ( elevOrStorage == "elev" )
   THEN
    IF ( PowellAnnualVolume == 8230000.00000000 "acre-ft" )
    THEN
     $ "Powell.Pool Elevation" [eowyDate]
    ELSE
     "StorageToElevation"( % "Powell", $ "Powell.Storage" [eowyDate] + ( PowellAnnualVolume - 8230000.00000000 "acre-ft" ) )
    ENDIF
   ELSE
    $ "Powell.Storage" [eowyDate] + ( PowellAnnualVolume - 8230000.00000000 "acre-ft" )
   ENDIF
  ELSE
   IF ( elevOrStorage == "elev" )
   THEN
    IF ( PowellAnnualVolume == 8230000.00000000 "acre-ft" )
    THEN
     $ "Mead.Pool Elevation" [eowyDate]
    ELSE
     "StorageToElevation"( % "Mead", $ "Mead.Storage" [eowyDate] - ( PowellAnnualVolume - 8230000.00000000 "acre-ft" ) )
    ENDIF
   ELSE
    $ "Mead.Storage" [eowyDate] - ( PowellAnnualVolume - 8230000.00000000 "acre-ft" )
   ENDIF
  ENDIF
 ENDWITH;

    END;

    FUNCTION       "GetPowellMonthlyReleases_pre20170427" ( LIST datesToEOWY )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function takes a list of dates that go from the current timestep to the end of the Water Year.  It returns a list of two item lists each of the form &lcub;date, release&rcub; for each date in the passed-in list of dates.  It does this by taking the annual volume calculated for the passed in water years dates and then using the table for monthly releases given an annual volume does a linear interpolation on that table to find releases that sum up exactly to the annual volume set for Powell.  If the passed in set of dates is the first water year in the run (i.e., starts with the run's start timestep), then this function will make an adjustment to the releases that were calculated by doing the linear interpolation to account for what was released in the months that are in the current water year, but occurred before the run start.  The releases must be adjusted because the actual releases from Powell will not match those prescribed in the table and so an adjustment to the actual remaining volume for the current year from the expected remaining volume for the current water year must be made.  The adjustment preserves the proportions of the total annual volume that come from each month in the table, but scales the volume in the remaining months so that the annual volume is met exactly- sc 03/25/11<br><br>ARGUMENTS:<br>1. datesToEOWY<br><br>RETURNS: A list either of the form &lcub;Month, Monthly Release, Remaining Volume over Lower Bounds&rcub; (from CalculatePowellMonthlyRelease) OR &lcub;Month, Monthly Release, <br><br>DEVELOPMENT NOTES:<br>MC, 20160907: In calculation of newAdjustedMonthlyRel, moved subRelList<1> (and multiplied by 1 &quot;month&quot;) into call to VolumeToFlow to get desired volume; previous version was not giving correct desired volume (at least in some cases when UserInput_MinimumAnnualRelease sets the TARV) due to conversion associated with monthly flow and time scale (i.e., RW was making an unwanted conversion based on the number of days in a month); Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC annualVolume = "CurrentAnnualVolume"( GET @INDEX 0.00000000 FROM datesToEOWY ) DO
  WITH NUMERIC totalVolumeReleasedPreRun = IF ( "GetMonthAsString"( GET @INDEX 0.00000000 FROM datesToEOWY ) == "October" )
  THEN
   0.00000000 "acre-feet"
  ELSE
   "SumFlowsToVolume"( $ "Powell.Outflow", "OffsetDate"( GET @INDEX 0.00000000 FROM datesToEOWY, "MonthsSinceEOWY"( GET @INDEX 0.00000000 FROM datesToEOWY ), "-1 months" ), @"Start Timestep - 1" ) - NaNToZero ( $ "PowellToMeadData.CarryoverVolume" ["Dec31ofYear"( "GetWaterYearEndDate"( GET @INDEX 0.00000000 FROM datesToEOWY ) )] )
  ENDIF DO
   WITH NUMERIC RemainingWYReleaseVolume = annualVolume - totalVolumeReleasedPreRun DO
    WITH NUMERIC UpperColumnBound = "FindReleaseUpperBoundColumn"( annualVolume ) DO
     WITH NUMERIC LowerColumnBound = "FindReleaseLowerBoundColumn"( annualVolume, UpperColumnBound ) DO
      WITH LIST AdjustedMonthlyRel = "CalculatePowellMonthlyRelease"( datesToEOWY, UpperColumnBound, LowerColumnBound, RemainingWYReleaseVolume ) DO
       IF ( ( GET @INDEX 0.00000000 FROM datesToEOWY ) == @"Start Timestep" )
       THEN
        WITH NUMERIC sumMonthlyReleases = FOR ( LIST monthlyReleaseVol IN AdjustedMonthlyRel ) STAT_SUM
         "FlowToVolume"( GET @INDEX 1.00000000 FROM monthlyReleaseVol, GET @INDEX 0.00000000 FROM monthlyReleaseVol )
        ENDFOR DO
         WITH NUMERIC Tolerance = 5.00000000 "acre-ft" DO
          WITH NUMERIC VolumeDifference = RemainingWYReleaseVolume - sumMonthlyReleases DO
           IF ( "Abs"( VolumeDifference ) < Tolerance )
           THEN
            AdjustedMonthlyRel
           ELSE
            WITH NUMERIC VolumeAdjustment = VolumeDifference / LENGTH AdjustedMonthlyRel DO
             WITH LIST newAdjustedMonthlyRel = FOR ( LIST subRelList IN AdjustedMonthlyRel ) WITH LIST result = { { 0.00000000 , 0.00000000 , VolumeDifference } } DO
              WITH NUMERIC index = ( LENGTH result ) - 1.00000000 DO
               WITH NUMERIC RemainingVolumeDifference = ( GET @INDEX 2.00000000 FROM GET @INDEX index FROM result ) - VolumeAdjustment DO
                ( APPEND { GET @INDEX 0.00000000 FROM subRelList , "VolumeToFlow"( VolumeAdjustment + "FlowToVolume"( ( GET @INDEX 1.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ), GET @INDEX 0.00000000 FROM subRelList ) , RemainingVolumeDifference } ONTO result ) COMMENTED_BY "MC, 20160907: Previous version: VolumeToFlow(newAmt, subRelList<0>) + subRelList<1>"
               ENDWITH
              ENDWITH
             ENDFOR DO
              REMOVE ITEM @INDEX 0.00000000 FROM newAdjustedMonthlyRel
             ENDWITH
            ENDWITH COMMENTED_BY "Distribute the volume difference equally over the remaining months<br>MC, 20170207: Within the function CalculatePowellMonthlyRelease there is also a check that all required volume was released;<br>	should all volume checking be made more robust & moved to CalculatePowellMonthlyRelease?<br>MC, 20170427: I thnk the check in CalculatePowellMonthlyRelease should be removed and have the adjustment done here, but <br>change the adjustment to be proportional to the monthly release.<br>"
           ENDIF
          ENDWITH
         ENDWITH COMMENTED_BY "Verify that all of the required volume (within a tolerance) was released; if not, adjust the release volume for each month"
        ENDWITH COMMENTED_BY "Calculate total remaining releases from AdjustedMonthlyRel"
       ELSE
        AdjustedMonthlyRel
       ENDIF
      ENDWITH COMMENTED_BY "Calculate list of the form &lcub;Month, Adjusted monthly release rate, Remaining volume above lower bound column&rcub;"
     ENDWITH COMMENTED_BY "Detemine index of first column in monthly release table with total annual volume <= annualVolume<br>(Same as UpperColumnBound if annualVolume is equal to a column total)"
    ENDWITH COMMENTED_BY "Calculate index of first column in monthly release table with total annual volume >= annualVolume"
   ENDWITH
  ENDWITH COMMENTED_BY "Determine volume released prior to model run start"
 ENDWITH COMMENTED_BY "Retrieve TargetAnnualReleaseVolume for water year containing datesToEOWY<0>";

    END;

    FUNCTION       "IsSpringPeakMonth" ( OBJECT res, DATETIME date )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( res == % "Navajo" )
 THEN
  IF ( date >= @"24:00:00 April 31, Current Year" AND date <= @"24:00:00 June 30, Current Year" )
  THEN
   TRUE
  ELSE
   FALSE
  ENDIF
 ELSE
  STOP_RUN "Invalid reservoir passed to IsSpringPeakMonth"
 ENDIF;

    END;

    FUNCTION       "July31ofYear" ( DATETIME date )
    RETURN_TYPE    DATETIME;
    SCALE_UNITS    "";
    DESCRIPTION    "Determines the day of the year for July 31 making corrections for leap years if necessary. -CE 6/11/13";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      IF ( "LeapYear"( date ) )
 THEN
  "OffsetDate"( date, "Units NONE"( 213.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ELSE
  "OffsetDate"( date, "Units NONE"( 212.00000000 "day" - "GetDayOfYear"( date ) ), "1 days" )
 ENDIF;

    END;

    FUNCTION       "LowerTierEqualizationRelease" ( DATETIME EOWYDate )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      ( $ "PowellData.TargetAnnualReleaseVolume" ["Dec31ofYear"( EOWYDate )] + ( $ "Powell.Storage" [EOWYDate] - $ "Mead.Storage" [EOWYDate] ) / 2.00000000 ) COMMENTED_BY "MC, 20160803: This function is the same calculation as the EqualizationRelease function.  I changed the call in the Set Lower Balancing Release Volume and PostLBDV functions to the EqualizationRelease function instead of this one, <br>which should be deleted as redundant orphan.";

    END;

    FUNCTION       "MonthDayRatio" ( NUMERIC days )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      ( 31.00000000 "day" / days );

    END;

    FUNCTION       "MyGetSlot" ( OBJECT obj, STRING slot )
    RETURN_TYPE    SLOT;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "GetSlot"( ( STRINGIFY obj ) CONCAT ( "." CONCAT slot ) );

    END;

    FUNCTION       "MyPercentRank" ( LIST Data, NUMERIC num )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      1.00000000;

    END;

    FUNCTION       "NevadaBankingICS" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC unusedNV = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
 THEN
  0.00000000 "acre-ft"
 ELSE
  300000.00000000 "acre-ft" - $ "AnnualWaterUse.Nevada_Apportionment" ["Dec31ofYear"( @"t" )]
 ENDIF DO
  WITH NUMERIC nvBankedCA = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
  THEN
   0.00000000 "acre-ft"
  ELSE
   unusedNV
  ENDIF DO
   WITH NUMERIC nvBankedAZ = IF ( NaNToZero ( $ "Shortage.Shortage Flag" [@"24:00:00 December 31, Current Year"] ) > 0.00000000 )
   THEN
    0.00000000 "acre-ft"
   ELSE
    0.00000000 "acre-ft"
   ENDIF DO
    WITH NUMERIC CumulativeNVBankedInCA = $ "ICS Credits.CumulativeNVBankedinCA" [@"24:00:00 December Max DayOfMonth, Previous Year"] + nvBankedCA - nvUnbankedCA DO
     WITH NUMERIC AnnualNVRecoverableAZ = "Min"( 40000.00000000 "acre-ft", nvBankedAZ ) DO
      WITH NUMERIC AnnuaNVRecoverableCA = "Min"( 30000.00000000 "acre-ft", CumulativeNVBankedInCA ) DO
       WITH NUMERIC AnnualNVUnbankedFromAZ = "Min"( AnnualNVRecoverableAZ, nvUnbankedAZ ) DO
        WITH NUMERIC AnnualNVUnbankedFromCA = "Min"( AnnualNVRecoverableAZ, nvUnbankedCA ) DO
         ?
        ENDWITH
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "OND" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      @"24:00:00 October Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year";

    END;

    FUNCTION       "PrevStorage" ( OBJECT res )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "acre-ft";
    DESCRIPTION    "Returns the storage of the argument object for the previous timestep. -CE 6/11/13";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      res & "Storage" [@"t - 1"];

    END;

    FUNCTION       "Quantile" ( LIST Data, NUMERIC prob )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      GET @INDEX 1.00000000 FROM Data;

    END;

    FUNCTION       "RampUpDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns a list of two-item lists, each sublist of the form &lcub;date, flow target&rcub;.  The function does this by starting at the peak flow date and the peak flow value and then going backward one day at a time and calculating the new flow target until it gets down to the shoulder flow which is already set on the slot by the previous rule (April Through July Daily Canyon Flows).  The liimitations in the ramp up daily rate are no more than 500cfs and no more than 25% of the previous day's flow. - sc 12/22/10<br><br>MC, 20170531: No calls to this function, so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC peakLevel = $ "BlueMesaData.MayPeakFlowLevel" [@"24:00:00 December 31, Current Year"] DO
  WITH DATETIME peakDate = "PartialToFull"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) ) DO
   WITH NUMERIC peakFlowTarget = "Max"( $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"], $ "BlueMesaData.TargetDailyWhitewaterFlows" [peakDate] ) DO
    WITH NUMERIC daysAtPeak = $ "BlueMesaData.SpringPeakAndDurationCanyonTargets" [peakLevel, "Duration of Half Bank Days"] DO
     WITH DATETIME dateToCheckRamp = peakDate - "Floor"( daysAtPeak / 2.00000000, 1.00000000 "day" ) DO
      WHILE ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) > $ "BlueMesaData.TargetDailyWhitewaterFlows" [GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList] OR ( LENGTH dateFlowList ) == 1.00000000 ) WITH LIST dateFlowList = { { dateToCheckRamp , peakFlowTarget } } DO
       WITH DATETIME previousDaysDate = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 1.00000000 "day" DO
        WITH NUMERIC previousDaysFlow = "Max"( "Min"( ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) * ( 1.00000000 / ( 1.00000000 + 0.25000000 COMMENTED_BY "If Paul says that the ramp up rate needs to be user-controlled, <br>put the slot reference here. - sc 12/22/10" ) ) ), ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 500.00000000 "cfs" ), $ "BlueMesaData.TargetDailyWhitewaterFlows" [previousDaysDate] ) DO
         APPEND { previousDaysDate , previousDaysFlow } ONTO dateFlowList
        ENDWITH
       ENDWITH
      ENDWHILE
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "RampDownDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "This function returns a list of two-item lists, each sublist of the form &lcub;date, flow target&rcub;.  The function does this by starting at the peak flow date and the peak flow value and then going forward one day at a time and calculating the new flow target until it gets down to the shoulder flow which is already set on the slot by the previous rule (April Through July Daily Canyon Flows).  The liimitations in the ramp down daily rate are no more than 400cfs and no more than15% of the previous day's flow. - sc 12/22/10<br><br>MC, 20170531: No calls to this function, so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      WITH NUMERIC peakLevel = $ "BlueMesaData.MayPeakFlowLevel" [@"24:00:00 December 31, Current Year"] DO
  WITH DATETIME peakDate = "PartialToFull"( "NumberToDate"( $ "BlueMesaData.MayPeakFlowDate" [@"24:00:00 December 31, Current Year"] ) ) DO
   WITH NUMERIC peakFlowTarget = "Max"( $ "BlueMesaData.MayPeakFlowTarget" [@"24:00:00 December 31, Current Year"], $ "BlueMesaData.TargetDailyWhitewaterFlows" [peakDate] ) DO
    WITH NUMERIC daysAtPeak = $ "BlueMesaData.SpringPeakAndDurationCanyonTargets" [peakLevel, "Duration At Peak Flow"] DO
     WITH DATETIME dateToCheckRamp = peakDate + ( "Floor"( daysAtPeak / 2.00000000, 1.00000000 "day" ) - IF ( daysAtPeak == 0.00000000 "day" )
     THEN
      0.00000000 "day"
     ELSE
      1.00000000 "day"
     ENDIF ) DO
      WHILE ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) > $ "BlueMesaData.TargetDailyWhitewaterFlows" [GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList] OR ( LENGTH dateFlowList ) == 1.00000000 ) WITH LIST dateFlowList = { { dateToCheckRamp , peakFlowTarget } } DO
       WITH DATETIME nextDaysDate = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) + 1.00000000 "day" DO
        WITH NUMERIC nextDaysFlow = "Max"( "Min"( ( ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) * ( 1.00000000 - 0.15000000 COMMENTED_BY "If Paul says that the ramp down rate needs to be user- controlled, <br>put the slot reference here. - sc 12/22/10" ) ), ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) - 400.00000000 "cfs" ), $ "BlueMesaData.TargetDailyWhitewaterFlows" [nextDaysDate] ) DO
         APPEND { nextDaysDate , nextDaysFlow } ONTO dateFlowList
        ENDWITH
       ENDWITH
      ENDWHILE
     ENDWITH
    ENDWITH
   ENDWITH
  ENDWITH
 ENDWITH;

    END;

    FUNCTION       "SolveBlueMesaReleaseForBlackCanyonTarget" ( NUMERIC TargetCanyonFlow, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a numeric flow target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in flow target in the Black Canyon section of the Gunnison River which is the &quot;Tunnel Return Flow&quot; object on the workspace.  The function does this by doing a water balance in the reach of the river between Blue Mesa and the Black Canyon and solving for the release from Blue Mesa. - sc 12/28/10<br><br>MC, 20170531: This function only called by other disabled Aspinall/Gunnison functions, so disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date], $ "BlueMesaData.BlueMesaMinRelease" [] );

    END;

    FUNCTION       "SolveBlueMesaReleaseForWhitewaterTarget" ( NUMERIC TargetCanyonFlow, DATETIME date )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a numeric flow target and a date.  It returns the value of the release from Blue Mesa Reservoir that is necessary to hit the passed-in flow target in the Black Canyon section of the Gunnison River which is the &quot;Tunnel Return Flow&quot; object on the workspace.  The function does this by doing a water balance in the reach of the river between Blue Mesa and the Black Canyon and solving for the release from Blue Mesa. - sc 12/28/10";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      "Max"( ( TargetCanyonFlow + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] - $ "GainsCrystalToGJ.GainsCrystalToGJ" [date] ) COMMENTED_BY "Would set a Blue Mesa Release enough to meet the Whitewater Target and the Gunnison Tunnel <br><br>Diversion while leveraging the gains between Blue Mesa and Grand Junction TP/MC 9/22/2015", ( $ "BlueMesaData.MinimumBlackCanyonFlow" [date] + $ "TunnelDiversionBelowCrystalForAg.Diversion Requested" [date] - $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date] - $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date] ) COMMENTED_BY "This would set a Blue Mesa Release enough to meet the minimum Black Canyon Flows and the <br><br>Gunnison Tunnel Diversion while leveraging the gains between BM and the Tunnel. TP/MC <br><br>9/22/2105" );

    END;

    FUNCTION       "SolveBlwBlueMesaInterveningFlows" ( LIST dates )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "cfs";
    DESCRIPTION    "This function takes a list of dates and sums the intervening flows from Below Blue Mesa.  Usually May has already been solved for so we do not include it in this calculation. <br>TP 2/13/2014<br><br>MC, 201705031: No calls to this function so disabled it.<br>";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN dates ) STAT_SUM
  "FlowToVolume"( $ "GunnisonAboveMorrowPoint:InterveningAboveMorrowPoint.Local Inflow" [date], date ) + "FlowToVolume"( $ "GunnisonAboveCrystal:InterveningAboveCrystal.Local Inflow" [date], date )
 ENDFOR;

    END;

    FUNCTION       "SolvePoolElevation" ( OBJECT obj, NUMERIC outflow )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: Solves for end of time step storage given an object and its outflow<br><br>RETURN TYPE: NUMERIC<br><br>ARGUMENTS<br>1. OBJECT obj<br>2. NUMERIC outflow<br><br>COMMENTS<br><br>AUTHOR, DATE: Unknown<br><br>UPDATE NOTES<br>1. Standardized description added by MC, 20170323";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "StorageToElevation"( obj, "SolveStorage"( obj, "MyGetSlot"( obj, "Inflow" ) [], outflow, "MyGetSlot"( obj, "Storage" ) [@"t - 1"], @"t" ) );

    END;

    FUNCTION       "SpringDateAndFlowLists" (  )
    RETURN_TYPE    LIST;
    SCALE_UNITS    "";
    DESCRIPTION    "DESCRIPTION: This function calculates a list of the form &lcub;Date, Flow Rate&rcub; for the time period April 30 to August 1, accounting for base flow, ramp up & down days, and days at powerplant capacity<br><br>RETURNS: List of lists of the form &lcub;Date, Flow rate&rcub;<br><br>ARGUMENTS:<NONE><br><br>CONSTRAINTS:<br><br>DEVELOPMENT NOTES:<br>AUTHOR, DATE: Unknown<br>MC, 20170503: No listed calls to this function; turned it off";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      WITH NUMERIC HClass = $ "FlamingGorgeData.HClass" ["Dec31ofYear"( @"t" )] DO
  WITH NUMERIC PPC = $ "FlamingGorgeData.PowerPlantCapacity" [] DO
   WITH NUMERIC PreviousBaseflow = $ "FlamingGorge.Outflow" [@"24:00:00 April Max DayOfMonth, Current Year"] COMMENTED_BY "Set By Rule: &quot;Base Flow Operations&quot;" DO
    WITH NUMERIC Baseflow = "GetFGBaseFlowMagnitude"(  ) DO
     WITH NUMERIC BypassCapacity = $ "FlamingGorgeData.BypassCharacteristics" [0.00000000, "Bypass Capacity"] DO
      WITH NUMERIC RampUpRate = $ "FlamingGorgeData.RampUpRate" [] DO
       WITH NUMERIC RampDownRate = $ "FlamingGorgeData.BaseFlowDownrampRate" [HClass, 0.00000000] DO
        WITH NUMERIC DaysAtPPC = "GetNumberOfDaysAtPPC"( HClass ) DO
         WITH NUMERIC DaysToRampUp = "DaysToRampUp"( PPC, PreviousBaseflow, RampUpRate ) DO
          WITH NUMERIC DaysToRampDown = "DaysToDownramp"( PPC, Baseflow, RampDownRate ) DO
           WITH NUMERIC DaysToBypass = "GetDaysAtBypass"( HClass ) DO
            WITH DATETIME RampUpStartDate = "CompletePartialDate"( "NumberToDate"( $ "FlamingGorgeData.RampUpStartDate" [0.00000000, 0.00000000] ), @"t" ) COMMENTED_BY "User Input Ramp Up Start Date, should correspond with the Yampa Peak. -HG 9/13/12" DO
             WITH DATETIME PPCStartDate = RampUpStartDate + DaysToRampUp DO
              WITH DATETIME PPCEndDate = PPCStartDate + ( DaysAtPPC - 1.00000000 "day" ) DO
               WITH DATETIME RampDownEndDate = PPCEndDate + DaysToRampDown DO
                WHILE ( ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) < @"24:00:00 August 1, Current Year" ) WITH LIST dateFlowList = { { @"24:00:00 April 30, Current Year" , PreviousBaseflow } } DO
                 WITH DATETIME date = ( GET @INDEX 0.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) + 1.00000000 "day" DO
                  WITH NUMERIC PreviousDaysFlow = ( GET @INDEX 1.00000000 FROM GET @INDEX ( LENGTH dateFlowList ) - 1.00000000 FROM dateFlowList ) DO
                   IF ( "GetMonth"( date ) == 6.00000000 AND "GetDayOfMonth"( date ) <= DaysToBypass )
                   THEN
                    APPEND { date , BypassCapacity } ONTO dateFlowList
                   ELSE
                    IF ( date < RampUpStartDate )
                    THEN
                     APPEND { date , PreviousBaseflow } ONTO dateFlowList
                    ELSE
                     IF ( date >= RampUpStartDate AND date < PPCStartDate )
                     THEN
                      ( APPEND { date , "Min"( PreviousDaysFlow + RampUpRate, PPC ) } ONTO dateFlowList ) COMMENTED_BY "Limit the Ramp Up to a Maximum of the Power Plant Capacity"
                     ELSE
                      IF ( date >= PPCStartDate AND date <= PPCEndDate )
                      THEN
                       APPEND { date , PPC } ONTO dateFlowList
                      ELSE
                       IF ( date <= RampDownEndDate )
                       THEN
                        APPEND { date , "Max"( PreviousDaysFlow - RampDownRate, Baseflow ) } ONTO dateFlowList
                       ELSE
                        APPEND { date , Baseflow } ONTO dateFlowList
                       ENDIF
                      ENDIF
                     ENDIF
                    ENDIF
                   ENDIF COMMENTED_BY "Set Daily Outflows"
                  ENDWITH
                 ENDWITH
                ENDWHILE COMMENTED_BY "Set Daily Outflows"
               ENDWITH
              ENDWITH
             ENDWITH
            ENDWITH COMMENTED_BY "Define Dates"
           ENDWITH
          ENDWITH
         ENDWITH
        ENDWITH COMMENTED_BY "Determine Days At Each Rate"
       ENDWITH
      ENDWITH
     ENDWITH
    ENDWITH COMMENTED_BY "This is a problem. <br>We do not know what the baseflow is going to be at the end of the spring release operations. <br>The baseflow is calculated based upon the Previous Pool Elevation and we do not know that when projecting forward. -HG 9/13/12"
   ENDWITH
  ENDWITH
 ENDWITH COMMENTED_BY "Define Flow Rates";

    END;

    FUNCTION       "StartYear" (  )
    RETURN_TYPE    BOOLEAN;
    SCALE_UNITS    "";
    DESCRIPTION    "Returns True if the timestep is the start timestep, and False otherwise. -CE 6/11/13";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      "GetYearAsString"( @"t" ) == "GetYearAsString"( @"Start Timestep" );

    END;

    FUNCTION       "SumAnnualDivRequest" ( OBJECT object, STRING wateruser )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      FOR ( DATETIME date IN @"24:00:00 January Max DayOfMonth, Current Year" TO @"24:00:00 December Max DayOfMonth, Current Year" ) STAT_SUM
  "FlowToVolume"( object & wateruser [date], date )
 ENDFOR;

    END;

    FUNCTION       "TotalCreationOfArizonaICS" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Sums the user input creation values of ICS for Arizona TP 7/27/2015";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "ICS Credits.AnnualCreationBiNat_AZ" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationSysEff_AZ" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationEC_CA" ["Dec31ofYear"( @"t" )];

    END;

    FUNCTION       "TotalCreationOfNevadaICS" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "";
    DESCRIPTION    "Sums the user input creation values of ICS for Nevada TP 7/27/2015";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG FALSE;
    NOTES          "";
    BEGIN

      $ "ICS Credits.AnnualCreationBiNat_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationSysEff_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationEC_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationImp_NV" ["Dec31ofYear"( @"t" )] + $ "ICS Credits.AnnualCreationTrib_NV" ["Dec31ofYear"( @"t" )];

    END;

    FUNCTION       "VallecitoMaxBankReleaseConstraint" (  )
    RETURN_TYPE    NUMERIC;
    SCALE_UNITS    "1000 acre-ft/month";
    DESCRIPTION    "This is the max bank flow for the Pinos River below Vallacito. The value is 2000 cfs and is the recommended max flow from Vallacito by the USBR operations guidelines to prevent damage downstream of Vallacito in Normal Operations.  - TP 10/8/2012<br><br>MC, 20170531: There are no calls to this function, so I disabled it.";
    ACTIVE         FALSE;
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
    NOTES          "";
    BEGIN

      $ "VallecitoData.NoDamageMaxBankFlow" [];

    END;

  END;

  PREDEFINED_GROUP "Numeric / Math";
  DESCRIPTION   "Predefined functions which perform generic numerical computations.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "Max" ( NUMERIC arg1, NUMERIC arg2 )
    SCALE_UNITS    "1000 acre-ft/month";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "Min" ( NUMERIC arg1, NUMERIC arg2 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "MinItem" ( LIST arg1 )
    SCALE_UNITS    "acre-ft";
    PRE_EXEC_DIAG  FALSE;
    POST_EXEC_DIAG TRUE;
;

    PREDEFINED_FUNCTION "Sum" ( LIST arg1 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Date / Time";
  DESCRIPTION   "Predefined functions which access and manipulate date/times.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "OffsetDate" ( DATETIME arg1, NUMERIC arg2, STRING arg3 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Engineering";
  DESCRIPTION   "Predefined functions similar to methods on objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "SolveOutflow" ( OBJECT arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4, DATETIME arg5 )
    SCALE_UNITS    "acre-ft/month";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

  END;

  PREDEFINED_GROUP "Workspace";
  DESCRIPTION   "Predefined functions which access information on slots and objects.";
  ACTIVE        TRUE;
  BEGIN

    PREDEFINED_FUNCTION "TableInterpolation" ( SLOT arg1, NUMERIC arg2, NUMERIC arg3, NUMERIC arg4, DATETIME arg5 )
    SCALE_UNITS    "";
    PRE_EXEC_DIAG  TRUE;
    POST_EXEC_DIAG TRUE;
;

  END;

  REPORT_GROUP "Report Group";
  DESCRIPTION  "";
  NOTES  "";
  BEGIN
  END;

END
